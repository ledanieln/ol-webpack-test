{"map":"{\"version\":3,\"sources\":[\"webpack/bootstrap\",\"C:\\\\Users\\\\Daniel\\\\Documents\\\\Fall2018\\\\SWE\\\\olshpDisplay\\\\node_modules\\\\rbush\\\\index.js\",\"C:\\\\Users\\\\Daniel\\\\Documents\\\\Fall2018\\\\SWE\\\\olshpDisplay\\\\node_modules\\\\ol\\\\webgl.js\",\"C:\\\\Users\\\\Daniel\\\\Documents\\\\Fall2018\\\\SWE\\\\olshpDisplay\\\\node_modules\\\\ol\\\\index.js\",\"C:\\\\Users\\\\Daniel\\\\Documents\\\\Fall2018\\\\SWE\\\\olshpDisplay\\\\node_modules\\\\ol\\\\AssertionError.js\",\"C:\\\\Users\\\\Daniel\\\\Documents\\\\Fall2018\\\\SWE\\\\olshpDisplay\\\\node_modules\\\\ol\\\\asserts.js\",\"C:\\\\Users\\\\Daniel\\\\Documents\\\\Fall2018\\\\SWE\\\\olshpDisplay\\\\node_modules\\\\ol\\\\obj.js\",\"C:\\\\Users\\\\Daniel\\\\Documents\\\\Fall2018\\\\SWE\\\\olshpDisplay\\\\node_modules\\\\ol\\\\events.js\",\"C:\\\\Users\\\\Daniel\\\\Documents\\\\Fall2018\\\\SWE\\\\olshpDisplay\\\\node_modules\\\\ol\\\\events\\\\EventType.js\",\"C:\\\\Users\\\\Daniel\\\\Documents\\\\Fall2018\\\\SWE\\\\olshpDisplay\\\\node_modules\\\\ol\\\\ObjectEventType.js\",\"C:\\\\Users\\\\Daniel\\\\Documents\\\\Fall2018\\\\SWE\\\\olshpDisplay\\\\node_modules\\\\ol\\\\functions.js\",\"C:\\\\Users\\\\Daniel\\\\Documents\\\\Fall2018\\\\SWE\\\\olshpDisplay\\\\node_modules\\\\ol\\\\Disposable.js\",\"C:\\\\Users\\\\Daniel\\\\Documents\\\\Fall2018\\\\SWE\\\\olshpDisplay\\\\node_modules\\\\ol\\\\events\\\\Event.js\",\"C:\\\\Users\\\\Daniel\\\\Documents\\\\Fall2018\\\\SWE\\\\olshpDisplay\\\\node_modules\\\\ol\\\\events\\\\EventTarget.js\",\"C:\\\\Users\\\\Daniel\\\\Documents\\\\Fall2018\\\\SWE\\\\olshpDisplay\\\\node_modules\\\\ol\\\\Observable.js\",\"C:\\\\Users\\\\Daniel\\\\Documents\\\\Fall2018\\\\SWE\\\\olshpDisplay\\\\node_modules\\\\ol\\\\Object.js\",\"C:\\\\Users\\\\Daniel\\\\Documents\\\\Fall2018\\\\SWE\\\\olshpDisplay\\\\node_modules\\\\ol\\\\extent\\\\Corner.js\",\"C:\\\\Users\\\\Daniel\\\\Documents\\\\Fall2018\\\\SWE\\\\olshpDisplay\\\\node_modules\\\\ol\\\\extent\\\\Relationship.js\",\"C:\\\\Users\\\\Daniel\\\\Documents\\\\Fall2018\\\\SWE\\\\olshpDisplay\\\\node_modules\\\\ol\\\\extent.js\",\"C:\\\\Users\\\\Daniel\\\\Documents\\\\Fall2018\\\\SWE\\\\olshpDisplay\\\\node_modules\\\\ol\\\\geom\\\\flat\\\\transform.js\",\"C:\\\\Users\\\\Daniel\\\\Documents\\\\Fall2018\\\\SWE\\\\olshpDisplay\\\\node_modules\\\\ol\\\\math.js\",\"C:\\\\Users\\\\Daniel\\\\Documents\\\\Fall2018\\\\SWE\\\\olshpDisplay\\\\node_modules\\\\ol\\\\geom\\\\GeometryType.js\",\"C:\\\\Users\\\\Daniel\\\\Documents\\\\Fall2018\\\\SWE\\\\olshpDisplay\\\\node_modules\\\\ol\\\\sphere.js\",\"C:\\\\Users\\\\Daniel\\\\Documents\\\\Fall2018\\\\SWE\\\\olshpDisplay\\\\node_modules\\\\ol\\\\proj\\\\Units.js\",\"C:\\\\Users\\\\Daniel\\\\Documents\\\\Fall2018\\\\SWE\\\\olshpDisplay\\\\node_modules\\\\ol\\\\proj\\\\Projection.js\",\"C:\\\\Users\\\\Daniel\\\\Documents\\\\Fall2018\\\\SWE\\\\olshpDisplay\\\\node_modules\\\\ol\\\\proj\\\\epsg3857.js\",\"C:\\\\Users\\\\Daniel\\\\Documents\\\\Fall2018\\\\SWE\\\\olshpDisplay\\\\node_modules\\\\ol\\\\proj\\\\epsg4326.js\",\"C:\\\\Users\\\\Daniel\\\\Documents\\\\Fall2018\\\\SWE\\\\olshpDisplay\\\\node_modules\\\\ol\\\\proj\\\\projections.js\",\"C:\\\\Users\\\\Daniel\\\\Documents\\\\Fall2018\\\\SWE\\\\olshpDisplay\\\\node_modules\\\\ol\\\\proj\\\\transforms.js\",\"C:\\\\Users\\\\Daniel\\\\Documents\\\\Fall2018\\\\SWE\\\\olshpDisplay\\\\node_modules\\\\ol\\\\proj.js\",\"C:\\\\Users\\\\Daniel\\\\Documents\\\\Fall2018\\\\SWE\\\\olshpDisplay\\\\node_modules\\\\ol\\\\transform.js\",\"C:\\\\Users\\\\Daniel\\\\Documents\\\\Fall2018\\\\SWE\\\\olshpDisplay\\\\node_modules\\\\ol\\\\geom\\\\Geometry.js\",\"C:\\\\Users\\\\Daniel\\\\Documents\\\\Fall2018\\\\SWE\\\\olshpDisplay\\\\node_modules\\\\ol\\\\color.js\",\"C:\\\\Users\\\\Daniel\\\\Documents\\\\Fall2018\\\\SWE\\\\olshpDisplay\\\\node_modules\\\\ol\\\\colorlike.js\",\"C:\\\\Users\\\\Daniel\\\\Documents\\\\Fall2018\\\\SWE\\\\olshpDisplay\\\\node_modules\\\\ol\\\\dom.js\",\"C:\\\\Users\\\\Daniel\\\\Documents\\\\Fall2018\\\\SWE\\\\olshpDisplay\\\\node_modules\\\\ol\\\\has.js\",\"C:\\\\Users\\\\Daniel\\\\Documents\\\\Fall2018\\\\SWE\\\\olshpDisplay\\\\node_modules\\\\ol\\\\ImageState.js\",\"C:\\\\Users\\\\Daniel\\\\Documents\\\\Fall2018\\\\SWE\\\\olshpDisplay\\\\node_modules\\\\ol\\\\css.js\",\"C:\\\\Users\\\\Daniel\\\\Documents\\\\Fall2018\\\\SWE\\\\olshpDisplay\\\\node_modules\\\\ol\\\\structs\\\\LRUCache.js\",\"C:\\\\Users\\\\Daniel\\\\Documents\\\\Fall2018\\\\SWE\\\\olshpDisplay\\\\node_modules\\\\ol\\\\render\\\\canvas.js\",\"C:\\\\Users\\\\Daniel\\\\Documents\\\\Fall2018\\\\SWE\\\\olshpDisplay\\\\node_modules\\\\ol\\\\style\\\\Image.js\",\"C:\\\\Users\\\\Daniel\\\\Documents\\\\Fall2018\\\\SWE\\\\olshpDisplay\\\\node_modules\\\\ol\\\\style\\\\RegularShape.js\",\"C:\\\\Users\\\\Daniel\\\\Documents\\\\Fall2018\\\\SWE\\\\olshpDisplay\\\\node_modules\\\\ol\\\\style\\\\Circle.js\",\"C:\\\\Users\\\\Daniel\\\\Documents\\\\Fall2018\\\\SWE\\\\olshpDisplay\\\\node_modules\\\\ol\\\\style\\\\Fill.js\",\"C:\\\\Users\\\\Daniel\\\\Documents\\\\Fall2018\\\\SWE\\\\olshpDisplay\\\\node_modules\\\\ol\\\\style\\\\Stroke.js\",\"C:\\\\Users\\\\Daniel\\\\Documents\\\\Fall2018\\\\SWE\\\\olshpDisplay\\\\node_modules\\\\ol\\\\style\\\\Style.js\",\"C:\\\\Users\\\\Daniel\\\\Documents\\\\Fall2018\\\\SWE\\\\olshpDisplay\\\\node_modules\\\\ol\\\\Feature.js\",\"C:\\\\Users\\\\Daniel\\\\Documents\\\\Fall2018\\\\SWE\\\\olshpDisplay\\\\node_modules\\\\ol\\\\format\\\\Feature.js\",\"C:\\\\Users\\\\Daniel\\\\Documents\\\\Fall2018\\\\SWE\\\\olshpDisplay\\\\node_modules\\\\ol\\\\format\\\\FormatType.js\",\"C:\\\\Users\\\\Daniel\\\\Documents\\\\Fall2018\\\\SWE\\\\olshpDisplay\\\\node_modules\\\\ol\\\\format\\\\JSONFeature.js\",\"C:\\\\Users\\\\Daniel\\\\Documents\\\\Fall2018\\\\SWE\\\\olshpDisplay\\\\node_modules\\\\ol\\\\geom\\\\GeometryCollection.js\",\"C:\\\\Users\\\\Daniel\\\\Documents\\\\Fall2018\\\\SWE\\\\olshpDisplay\\\\node_modules\\\\ol\\\\array.js\",\"C:\\\\Users\\\\Daniel\\\\Documents\\\\Fall2018\\\\SWE\\\\olshpDisplay\\\\node_modules\\\\ol\\\\geom\\\\GeometryLayout.js\",\"C:\\\\Users\\\\Daniel\\\\Documents\\\\Fall2018\\\\SWE\\\\olshpDisplay\\\\node_modules\\\\ol\\\\geom\\\\SimpleGeometry.js\",\"C:\\\\Users\\\\Daniel\\\\Documents\\\\Fall2018\\\\SWE\\\\olshpDisplay\\\\node_modules\\\\ol\\\\geom\\\\flat\\\\closest.js\",\"C:\\\\Users\\\\Daniel\\\\Documents\\\\Fall2018\\\\SWE\\\\olshpDisplay\\\\node_modules\\\\ol\\\\geom\\\\flat\\\\deflate.js\",\"C:\\\\Users\\\\Daniel\\\\Documents\\\\Fall2018\\\\SWE\\\\olshpDisplay\\\\node_modules\\\\ol\\\\geom\\\\flat\\\\inflate.js\",\"C:\\\\Users\\\\Daniel\\\\Documents\\\\Fall2018\\\\SWE\\\\olshpDisplay\\\\node_modules\\\\ol\\\\geom\\\\flat\\\\interpolate.js\",\"C:\\\\Users\\\\Daniel\\\\Documents\\\\Fall2018\\\\SWE\\\\olshpDisplay\\\\node_modules\\\\ol\\\\geom\\\\flat\\\\contains.js\",\"C:\\\\Users\\\\Daniel\\\\Documents\\\\Fall2018\\\\SWE\\\\olshpDisplay\\\\node_modules\\\\ol\\\\geom\\\\flat\\\\segments.js\",\"C:\\\\Users\\\\Daniel\\\\Documents\\\\Fall2018\\\\SWE\\\\olshpDisplay\\\\node_modules\\\\ol\\\\geom\\\\flat\\\\intersectsextent.js\",\"C:\\\\Users\\\\Daniel\\\\Documents\\\\Fall2018\\\\SWE\\\\olshpDisplay\\\\node_modules\\\\ol\\\\geom\\\\flat\\\\length.js\",\"C:\\\\Users\\\\Daniel\\\\Documents\\\\Fall2018\\\\SWE\\\\olshpDisplay\\\\node_modules\\\\ol\\\\geom\\\\flat\\\\simplify.js\",\"C:\\\\Users\\\\Daniel\\\\Documents\\\\Fall2018\\\\SWE\\\\olshpDisplay\\\\node_modules\\\\ol\\\\geom\\\\LineString.js\",\"C:\\\\Users\\\\Daniel\\\\Documents\\\\Fall2018\\\\SWE\\\\olshpDisplay\\\\node_modules\\\\ol\\\\geom\\\\MultiLineString.js\",\"C:\\\\Users\\\\Daniel\\\\Documents\\\\Fall2018\\\\SWE\\\\olshpDisplay\\\\node_modules\\\\ol\\\\geom\\\\Point.js\",\"C:\\\\Users\\\\Daniel\\\\Documents\\\\Fall2018\\\\SWE\\\\olshpDisplay\\\\node_modules\\\\ol\\\\geom\\\\MultiPoint.js\",\"C:\\\\Users\\\\Daniel\\\\Documents\\\\Fall2018\\\\SWE\\\\olshpDisplay\\\\node_modules\\\\ol\\\\geom\\\\flat\\\\area.js\",\"C:\\\\Users\\\\Daniel\\\\Documents\\\\Fall2018\\\\SWE\\\\olshpDisplay\\\\node_modules\\\\ol\\\\geom\\\\LinearRing.js\",\"C:\\\\Users\\\\Daniel\\\\Documents\\\\Fall2018\\\\SWE\\\\olshpDisplay\\\\node_modules\\\\ol\\\\geom\\\\flat\\\\interiorpoint.js\",\"C:\\\\Users\\\\Daniel\\\\Documents\\\\Fall2018\\\\SWE\\\\olshpDisplay\\\\node_modules\\\\ol\\\\geom\\\\flat\\\\reverse.js\",\"C:\\\\Users\\\\Daniel\\\\Documents\\\\Fall2018\\\\SWE\\\\olshpDisplay\\\\node_modules\\\\ol\\\\geom\\\\flat\\\\orient.js\",\"C:\\\\Users\\\\Daniel\\\\Documents\\\\Fall2018\\\\SWE\\\\olshpDisplay\\\\node_modules\\\\ol\\\\geom\\\\Polygon.js\",\"C:\\\\Users\\\\Daniel\\\\Documents\\\\Fall2018\\\\SWE\\\\olshpDisplay\\\\node_modules\\\\ol\\\\geom\\\\MultiPolygon.js\",\"C:\\\\Users\\\\Daniel\\\\Documents\\\\Fall2018\\\\SWE\\\\olshpDisplay\\\\node_modules\\\\ol\\\\geom\\\\flat\\\\center.js\",\"C:\\\\Users\\\\Daniel\\\\Documents\\\\Fall2018\\\\SWE\\\\olshpDisplay\\\\node_modules\\\\ol\\\\format\\\\GeoJSON.js\",\"C:\\\\Users\\\\Daniel\\\\Documents\\\\Fall2018\\\\SWE\\\\olshpDisplay\\\\node_modules\\\\ol\\\\CollectionEventType.js\",\"C:\\\\Users\\\\Daniel\\\\Documents\\\\Fall2018\\\\SWE\\\\olshpDisplay\\\\node_modules\\\\ol\\\\Collection.js\",\"C:\\\\Users\\\\Daniel\\\\Documents\\\\Fall2018\\\\SWE\\\\olshpDisplay\\\\node_modules\\\\ol\\\\MapEvent.js\",\"C:\\\\Users\\\\Daniel\\\\Documents\\\\Fall2018\\\\SWE\\\\olshpDisplay\\\\node_modules\\\\ol\\\\MapBrowserEvent.js\",\"C:\\\\Users\\\\Daniel\\\\Documents\\\\Fall2018\\\\SWE\\\\olshpDisplay\\\\node_modules\\\\ol\\\\MapBrowserEventType.js\",\"C:\\\\Users\\\\Daniel\\\\Documents\\\\Fall2018\\\\SWE\\\\olshpDisplay\\\\node_modules\\\\ol\\\\MapBrowserPointerEvent.js\",\"C:\\\\Users\\\\Daniel\\\\Documents\\\\Fall2018\\\\SWE\\\\olshpDisplay\\\\node_modules\\\\ol\\\\pointer\\\\EventType.js\",\"C:\\\\Users\\\\Daniel\\\\Documents\\\\Fall2018\\\\SWE\\\\olshpDisplay\\\\node_modules\\\\ol\\\\pointer\\\\EventSource.js\",\"C:\\\\Users\\\\Daniel\\\\Documents\\\\Fall2018\\\\SWE\\\\olshpDisplay\\\\node_modules\\\\ol\\\\pointer\\\\MouseSource.js\",\"C:\\\\Users\\\\Daniel\\\\Documents\\\\Fall2018\\\\SWE\\\\olshpDisplay\\\\node_modules\\\\ol\\\\pointer\\\\MsSource.js\",\"C:\\\\Users\\\\Daniel\\\\Documents\\\\Fall2018\\\\SWE\\\\olshpDisplay\\\\node_modules\\\\ol\\\\pointer\\\\NativeSource.js\",\"C:\\\\Users\\\\Daniel\\\\Documents\\\\Fall2018\\\\SWE\\\\olshpDisplay\\\\node_modules\\\\ol\\\\pointer\\\\PointerEvent.js\",\"C:\\\\Users\\\\Daniel\\\\Documents\\\\Fall2018\\\\SWE\\\\olshpDisplay\\\\node_modules\\\\ol\\\\pointer\\\\TouchSource.js\",\"C:\\\\Users\\\\Daniel\\\\Documents\\\\Fall2018\\\\SWE\\\\olshpDisplay\\\\node_modules\\\\ol\\\\pointer\\\\PointerEventHandler.js\",\"C:\\\\Users\\\\Daniel\\\\Documents\\\\Fall2018\\\\SWE\\\\olshpDisplay\\\\node_modules\\\\ol\\\\MapBrowserEventHandler.js\",\"C:\\\\Users\\\\Daniel\\\\Documents\\\\Fall2018\\\\SWE\\\\olshpDisplay\\\\node_modules\\\\ol\\\\MapEventType.js\",\"C:\\\\Users\\\\Daniel\\\\Documents\\\\Fall2018\\\\SWE\\\\olshpDisplay\\\\node_modules\\\\ol\\\\MapProperty.js\",\"C:\\\\Users\\\\Daniel\\\\Documents\\\\Fall2018\\\\SWE\\\\olshpDisplay\\\\node_modules\\\\ol\\\\TileState.js\",\"C:\\\\Users\\\\Daniel\\\\Documents\\\\Fall2018\\\\SWE\\\\olshpDisplay\\\\node_modules\\\\ol\\\\structs\\\\PriorityQueue.js\",\"C:\\\\Users\\\\Daniel\\\\Documents\\\\Fall2018\\\\SWE\\\\olshpDisplay\\\\node_modules\\\\ol\\\\TileQueue.js\",\"C:\\\\Users\\\\Daniel\\\\Documents\\\\Fall2018\\\\SWE\\\\olshpDisplay\\\\node_modules\\\\ol\\\\tilegrid\\\\common.js\",\"C:\\\\Users\\\\Daniel\\\\Documents\\\\Fall2018\\\\SWE\\\\olshpDisplay\\\\node_modules\\\\ol\\\\centerconstraint.js\",\"C:\\\\Users\\\\Daniel\\\\Documents\\\\Fall2018\\\\SWE\\\\olshpDisplay\\\\node_modules\\\\ol\\\\rotationconstraint.js\",\"C:\\\\Users\\\\Daniel\\\\Documents\\\\Fall2018\\\\SWE\\\\olshpDisplay\\\\node_modules\\\\ol\\\\ViewHint.js\",\"C:\\\\Users\\\\Daniel\\\\Documents\\\\Fall2018\\\\SWE\\\\olshpDisplay\\\\node_modules\\\\ol\\\\ViewProperty.js\",\"C:\\\\Users\\\\Daniel\\\\Documents\\\\Fall2018\\\\SWE\\\\olshpDisplay\\\\node_modules\\\\ol\\\\coordinate.js\",\"C:\\\\Users\\\\Daniel\\\\Documents\\\\Fall2018\\\\SWE\\\\olshpDisplay\\\\node_modules\\\\ol\\\\easing.js\",\"C:\\\\Users\\\\Daniel\\\\Documents\\\\Fall2018\\\\SWE\\\\olshpDisplay\\\\node_modules\\\\ol\\\\View.js\",\"C:\\\\Users\\\\Daniel\\\\Documents\\\\Fall2018\\\\SWE\\\\olshpDisplay\\\\node_modules\\\\ol\\\\resolutionconstraint.js\",\"C:\\\\Users\\\\Daniel\\\\Documents\\\\Fall2018\\\\SWE\\\\olshpDisplay\\\\node_modules\\\\ol\\\\layer\\\\Property.js\",\"C:\\\\Users\\\\Daniel\\\\Documents\\\\Fall2018\\\\SWE\\\\olshpDisplay\\\\node_modules\\\\ol\\\\layer\\\\Base.js\",\"C:\\\\Users\\\\Daniel\\\\Documents\\\\Fall2018\\\\SWE\\\\olshpDisplay\\\\node_modules\\\\ol\\\\source\\\\State.js\",\"C:\\\\Users\\\\Daniel\\\\Documents\\\\Fall2018\\\\SWE\\\\olshpDisplay\\\\node_modules\\\\ol\\\\layer\\\\Group.js\",\"C:\\\\Users\\\\Daniel\\\\Documents\\\\Fall2018\\\\SWE\\\\olshpDisplay\\\\node_modules\\\\ol\\\\size.js\",\"C:\\\\Users\\\\Daniel\\\\Documents\\\\Fall2018\\\\SWE\\\\olshpDisplay\\\\node_modules\\\\ol\\\\PluggableMap.js\",\"C:\\\\Users\\\\Daniel\\\\Documents\\\\Fall2018\\\\SWE\\\\olshpDisplay\\\\node_modules\\\\ol\\\\control\\\\Control.js\",\"C:\\\\Users\\\\Daniel\\\\Documents\\\\Fall2018\\\\SWE\\\\olshpDisplay\\\\node_modules\\\\ol\\\\render\\\\EventType.js\",\"C:\\\\Users\\\\Daniel\\\\Documents\\\\Fall2018\\\\SWE\\\\olshpDisplay\\\\node_modules\\\\ol\\\\layer\\\\Layer.js\",\"C:\\\\Users\\\\Daniel\\\\Documents\\\\Fall2018\\\\SWE\\\\olshpDisplay\\\\node_modules\\\\ol\\\\control\\\\Attribution.js\",\"C:\\\\Users\\\\Daniel\\\\Documents\\\\Fall2018\\\\SWE\\\\olshpDisplay\\\\node_modules\\\\ol\\\\control\\\\Rotate.js\",\"C:\\\\Users\\\\Daniel\\\\Documents\\\\Fall2018\\\\SWE\\\\olshpDisplay\\\\node_modules\\\\ol\\\\control\\\\Zoom.js\",\"C:\\\\Users\\\\Daniel\\\\Documents\\\\Fall2018\\\\SWE\\\\olshpDisplay\\\\node_modules\\\\ol\\\\Kinetic.js\",\"C:\\\\Users\\\\Daniel\\\\Documents\\\\Fall2018\\\\SWE\\\\olshpDisplay\\\\node_modules\\\\ol\\\\interaction\\\\Property.js\",\"C:\\\\Users\\\\Daniel\\\\Documents\\\\Fall2018\\\\SWE\\\\olshpDisplay\\\\node_modules\\\\ol\\\\interaction\\\\Interaction.js\",\"C:\\\\Users\\\\Daniel\\\\Documents\\\\Fall2018\\\\SWE\\\\olshpDisplay\\\\node_modules\\\\ol\\\\interaction\\\\DoubleClickZoom.js\",\"C:\\\\Users\\\\Daniel\\\\Documents\\\\Fall2018\\\\SWE\\\\olshpDisplay\\\\node_modules\\\\ol\\\\events\\\\condition.js\",\"C:\\\\Users\\\\Daniel\\\\Documents\\\\Fall2018\\\\SWE\\\\olshpDisplay\\\\node_modules\\\\ol\\\\interaction\\\\Pointer.js\",\"C:\\\\Users\\\\Daniel\\\\Documents\\\\Fall2018\\\\SWE\\\\olshpDisplay\\\\node_modules\\\\ol\\\\interaction\\\\DragPan.js\",\"C:\\\\Users\\\\Daniel\\\\Documents\\\\Fall2018\\\\SWE\\\\olshpDisplay\\\\node_modules\\\\ol\\\\interaction\\\\DragRotate.js\",\"C:\\\\Users\\\\Daniel\\\\Documents\\\\Fall2018\\\\SWE\\\\olshpDisplay\\\\node_modules\\\\ol\\\\render\\\\Box.js\",\"C:\\\\Users\\\\Daniel\\\\Documents\\\\Fall2018\\\\SWE\\\\olshpDisplay\\\\node_modules\\\\ol\\\\interaction\\\\DragBox.js\",\"C:\\\\Users\\\\Daniel\\\\Documents\\\\Fall2018\\\\SWE\\\\olshpDisplay\\\\node_modules\\\\ol\\\\interaction\\\\DragZoom.js\",\"C:\\\\Users\\\\Daniel\\\\Documents\\\\Fall2018\\\\SWE\\\\olshpDisplay\\\\node_modules\\\\ol\\\\events\\\\KeyCode.js\",\"C:\\\\Users\\\\Daniel\\\\Documents\\\\Fall2018\\\\SWE\\\\olshpDisplay\\\\node_modules\\\\ol\\\\interaction\\\\KeyboardPan.js\",\"C:\\\\Users\\\\Daniel\\\\Documents\\\\Fall2018\\\\SWE\\\\olshpDisplay\\\\node_modules\\\\ol\\\\interaction\\\\KeyboardZoom.js\",\"C:\\\\Users\\\\Daniel\\\\Documents\\\\Fall2018\\\\SWE\\\\olshpDisplay\\\\node_modules\\\\ol\\\\interaction\\\\MouseWheelZoom.js\",\"C:\\\\Users\\\\Daniel\\\\Documents\\\\Fall2018\\\\SWE\\\\olshpDisplay\\\\node_modules\\\\ol\\\\interaction\\\\PinchRotate.js\",\"C:\\\\Users\\\\Daniel\\\\Documents\\\\Fall2018\\\\SWE\\\\olshpDisplay\\\\node_modules\\\\ol\\\\interaction\\\\PinchZoom.js\",\"C:\\\\Users\\\\Daniel\\\\Documents\\\\Fall2018\\\\SWE\\\\olshpDisplay\\\\node_modules\\\\ol\\\\interaction\\\\DragAndDrop.js\",\"C:\\\\Users\\\\Daniel\\\\Documents\\\\Fall2018\\\\SWE\\\\olshpDisplay\\\\node_modules\\\\ol\\\\interaction\\\\DragRotateAndZoom.js\",\"C:\\\\Users\\\\Daniel\\\\Documents\\\\Fall2018\\\\SWE\\\\olshpDisplay\\\\node_modules\\\\ol\\\\geom\\\\Circle.js\",\"C:\\\\Users\\\\Daniel\\\\Documents\\\\Fall2018\\\\SWE\\\\olshpDisplay\\\\node_modules\\\\ol\\\\LayerType.js\",\"C:\\\\Users\\\\Daniel\\\\Documents\\\\Fall2018\\\\SWE\\\\olshpDisplay\\\\node_modules\\\\ol\\\\layer\\\\VectorRenderType.js\",\"C:\\\\Users\\\\Daniel\\\\Documents\\\\Fall2018\\\\SWE\\\\olshpDisplay\\\\node_modules\\\\ol\\\\layer\\\\Vector.js\",\"C:\\\\Users\\\\Daniel\\\\Documents\\\\Fall2018\\\\SWE\\\\olshpDisplay\\\\node_modules\\\\ol\\\\featureloader.js\",\"C:\\\\Users\\\\Daniel\\\\Documents\\\\Fall2018\\\\SWE\\\\olshpDisplay\\\\node_modules\\\\ol\\\\loadingstrategy.js\",\"C:\\\\Users\\\\Daniel\\\\Documents\\\\Fall2018\\\\SWE\\\\olshpDisplay\\\\node_modules\\\\ol\\\\source\\\\Source.js\",\"C:\\\\Users\\\\Daniel\\\\Documents\\\\Fall2018\\\\SWE\\\\olshpDisplay\\\\node_modules\\\\ol\\\\source\\\\VectorEventType.js\",\"C:\\\\Users\\\\Daniel\\\\Documents\\\\Fall2018\\\\SWE\\\\olshpDisplay\\\\node_modules\\\\ol\\\\structs\\\\RBush.js\",\"C:\\\\Users\\\\Daniel\\\\Documents\\\\Fall2018\\\\SWE\\\\olshpDisplay\\\\node_modules\\\\ol\\\\source\\\\Vector.js\",\"C:\\\\Users\\\\Daniel\\\\Documents\\\\Fall2018\\\\SWE\\\\olshpDisplay\\\\node_modules\\\\ol\\\\interaction\\\\Draw.js\",\"C:\\\\Users\\\\Daniel\\\\Documents\\\\Fall2018\\\\SWE\\\\olshpDisplay\\\\node_modules\\\\ol\\\\interaction\\\\Extent.js\",\"C:\\\\Users\\\\Daniel\\\\Documents\\\\Fall2018\\\\SWE\\\\olshpDisplay\\\\node_modules\\\\ol\\\\interaction\\\\Modify.js\",\"C:\\\\Users\\\\Daniel\\\\Documents\\\\Fall2018\\\\SWE\\\\olshpDisplay\\\\node_modules\\\\ol\\\\interaction\\\\Select.js\",\"C:\\\\Users\\\\Daniel\\\\Documents\\\\Fall2018\\\\SWE\\\\olshpDisplay\\\\node_modules\\\\ol\\\\interaction\\\\Snap.js\",\"C:\\\\Users\\\\Daniel\\\\Documents\\\\Fall2018\\\\SWE\\\\olshpDisplay\\\\node_modules\\\\ol\\\\interaction\\\\Translate.js\",\"C:\\\\Users\\\\Daniel\\\\Documents\\\\Fall2018\\\\SWE\\\\olshpDisplay\\\\node_modules\\\\ol\\\\reproj\\\\common.js\",\"C:\\\\Users\\\\Daniel\\\\Documents\\\\Fall2018\\\\SWE\\\\olshpDisplay\\\\node_modules\\\\ol\\\\ImageBase.js\",\"C:\\\\Users\\\\Daniel\\\\Documents\\\\Fall2018\\\\SWE\\\\olshpDisplay\\\\node_modules\\\\ol\\\\ImageCanvas.js\",\"C:\\\\Users\\\\Daniel\\\\Documents\\\\Fall2018\\\\SWE\\\\olshpDisplay\\\\node_modules\\\\ol\\\\render\\\\Event.js\",\"C:\\\\Users\\\\Daniel\\\\Documents\\\\Fall2018\\\\SWE\\\\olshpDisplay\\\\node_modules\\\\ol\\\\render\\\\VectorContext.js\",\"C:\\\\Users\\\\Daniel\\\\Documents\\\\Fall2018\\\\SWE\\\\olshpDisplay\\\\node_modules\\\\ol\\\\render\\\\canvas\\\\Immediate.js\",\"C:\\\\Users\\\\Daniel\\\\Documents\\\\Fall2018\\\\SWE\\\\olshpDisplay\\\\node_modules\\\\ol\\\\style\\\\IconImageCache.js\",\"C:\\\\Users\\\\Daniel\\\\Documents\\\\Fall2018\\\\SWE\\\\olshpDisplay\\\\node_modules\\\\ol\\\\renderer\\\\Map.js\",\"C:\\\\Users\\\\Daniel\\\\Documents\\\\Fall2018\\\\SWE\\\\olshpDisplay\\\\node_modules\\\\ol\\\\renderer\\\\canvas\\\\Map.js\",\"C:\\\\Users\\\\Daniel\\\\Documents\\\\Fall2018\\\\SWE\\\\olshpDisplay\\\\node_modules\\\\ol\\\\renderer\\\\Layer.js\",\"C:\\\\Users\\\\Daniel\\\\Documents\\\\Fall2018\\\\SWE\\\\olshpDisplay\\\\node_modules\\\\ol\\\\renderer\\\\canvas\\\\Layer.js\",\"C:\\\\Users\\\\Daniel\\\\Documents\\\\Fall2018\\\\SWE\\\\olshpDisplay\\\\node_modules\\\\ol\\\\renderer\\\\canvas\\\\IntermediateCanvas.js\",\"C:\\\\Users\\\\Daniel\\\\Documents\\\\Fall2018\\\\SWE\\\\olshpDisplay\\\\node_modules\\\\ol\\\\renderer\\\\canvas\\\\ImageLayer.js\",\"C:\\\\Users\\\\Daniel\\\\Documents\\\\Fall2018\\\\SWE\\\\olshpDisplay\\\\node_modules\\\\ol\\\\TileRange.js\",\"C:\\\\Users\\\\Daniel\\\\Documents\\\\Fall2018\\\\SWE\\\\olshpDisplay\\\\node_modules\\\\ol\\\\renderer\\\\canvas\\\\TileLayer.js\",\"C:\\\\Users\\\\Daniel\\\\Documents\\\\Fall2018\\\\SWE\\\\olshpDisplay\\\\node_modules\\\\ol\\\\render\\\\ReplayGroup.js\",\"C:\\\\Users\\\\Daniel\\\\Documents\\\\Fall2018\\\\SWE\\\\olshpDisplay\\\\node_modules\\\\ol\\\\render\\\\ReplayType.js\",\"C:\\\\Users\\\\Daniel\\\\Documents\\\\Fall2018\\\\SWE\\\\olshpDisplay\\\\node_modules\\\\ol\\\\geom\\\\flat\\\\textpath.js\",\"C:\\\\Users\\\\Daniel\\\\Documents\\\\Fall2018\\\\SWE\\\\olshpDisplay\\\\node_modules\\\\ol\\\\render\\\\canvas\\\\Instruction.js\",\"C:\\\\Users\\\\Daniel\\\\Documents\\\\Fall2018\\\\SWE\\\\olshpDisplay\\\\node_modules\\\\ol\\\\render\\\\replay.js\",\"C:\\\\Users\\\\Daniel\\\\Documents\\\\Fall2018\\\\SWE\\\\olshpDisplay\\\\node_modules\\\\ol\\\\render\\\\canvas\\\\Replay.js\",\"C:\\\\Users\\\\Daniel\\\\Documents\\\\Fall2018\\\\SWE\\\\olshpDisplay\\\\node_modules\\\\ol\\\\render\\\\canvas\\\\ImageReplay.js\",\"C:\\\\Users\\\\Daniel\\\\Documents\\\\Fall2018\\\\SWE\\\\olshpDisplay\\\\node_modules\\\\ol\\\\render\\\\canvas\\\\LineStringReplay.js\",\"C:\\\\Users\\\\Daniel\\\\Documents\\\\Fall2018\\\\SWE\\\\olshpDisplay\\\\node_modules\\\\ol\\\\render\\\\canvas\\\\PolygonReplay.js\",\"C:\\\\Users\\\\Daniel\\\\Documents\\\\Fall2018\\\\SWE\\\\olshpDisplay\\\\node_modules\\\\ol\\\\geom\\\\flat\\\\straightchunk.js\",\"C:\\\\Users\\\\Daniel\\\\Documents\\\\Fall2018\\\\SWE\\\\olshpDisplay\\\\node_modules\\\\ol\\\\style\\\\TextPlacement.js\",\"C:\\\\Users\\\\Daniel\\\\Documents\\\\Fall2018\\\\SWE\\\\olshpDisplay\\\\node_modules\\\\ol\\\\render\\\\canvas\\\\TextReplay.js\",\"C:\\\\Users\\\\Daniel\\\\Documents\\\\Fall2018\\\\SWE\\\\olshpDisplay\\\\node_modules\\\\ol\\\\render\\\\canvas\\\\ReplayGroup.js\",\"C:\\\\Users\\\\Daniel\\\\Documents\\\\Fall2018\\\\SWE\\\\olshpDisplay\\\\node_modules\\\\ol\\\\renderer\\\\vector.js\",\"C:\\\\Users\\\\Daniel\\\\Documents\\\\Fall2018\\\\SWE\\\\olshpDisplay\\\\node_modules\\\\ol\\\\renderer\\\\canvas\\\\VectorLayer.js\",\"C:\\\\Users\\\\Daniel\\\\Documents\\\\Fall2018\\\\SWE\\\\olshpDisplay\\\\node_modules\\\\ol\\\\layer\\\\VectorTileRenderType.js\",\"C:\\\\Users\\\\Daniel\\\\Documents\\\\Fall2018\\\\SWE\\\\olshpDisplay\\\\node_modules\\\\ol\\\\renderer\\\\canvas\\\\VectorTileLayer.js\",\"C:\\\\Users\\\\Daniel\\\\Documents\\\\Fall2018\\\\SWE\\\\olshpDisplay\\\\node_modules\\\\ol\\\\Map.js\",\"C:\\\\Users\\\\Daniel\\\\Documents\\\\Fall2018\\\\SWE\\\\olshpDisplay\\\\node_modules\\\\ol\\\\control\\\\util.js\",\"C:\\\\Users\\\\Daniel\\\\Documents\\\\Fall2018\\\\SWE\\\\olshpDisplay\\\\node_modules\\\\ol\\\\interaction.js\",\"C:\\\\Users\\\\Daniel\\\\Documents\\\\Fall2018\\\\SWE\\\\olshpDisplay\\\\node_modules\\\\ol\\\\layer\\\\TileProperty.js\",\"C:\\\\Users\\\\Daniel\\\\Documents\\\\Fall2018\\\\SWE\\\\olshpDisplay\\\\node_modules\\\\ol\\\\layer\\\\Tile.js\",\"C:\\\\Users\\\\Daniel\\\\Documents\\\\Fall2018\\\\SWE\\\\olshpDisplay\\\\node_modules\\\\ol\\\\Tile.js\",\"C:\\\\Users\\\\Daniel\\\\Documents\\\\Fall2018\\\\SWE\\\\olshpDisplay\\\\node_modules\\\\ol\\\\ImageTile.js\",\"C:\\\\Users\\\\Daniel\\\\Documents\\\\Fall2018\\\\SWE\\\\olshpDisplay\\\\node_modules\\\\ol\\\\tilecoord.js\",\"C:\\\\Users\\\\Daniel\\\\Documents\\\\Fall2018\\\\SWE\\\\olshpDisplay\\\\node_modules\\\\ol\\\\TileCache.js\",\"C:\\\\Users\\\\Daniel\\\\Documents\\\\Fall2018\\\\SWE\\\\olshpDisplay\\\\node_modules\\\\ol\\\\reproj.js\",\"C:\\\\Users\\\\Daniel\\\\Documents\\\\Fall2018\\\\SWE\\\\olshpDisplay\\\\node_modules\\\\ol\\\\reproj\\\\Triangulation.js\",\"C:\\\\Users\\\\Daniel\\\\Documents\\\\Fall2018\\\\SWE\\\\olshpDisplay\\\\node_modules\\\\ol\\\\reproj\\\\Tile.js\",\"C:\\\\Users\\\\Daniel\\\\Documents\\\\Fall2018\\\\SWE\\\\olshpDisplay\\\\node_modules\\\\ol\\\\tileurlfunction.js\",\"C:\\\\Users\\\\Daniel\\\\Documents\\\\Fall2018\\\\SWE\\\\olshpDisplay\\\\node_modules\\\\ol\\\\tilegrid\\\\TileGrid.js\",\"C:\\\\Users\\\\Daniel\\\\Documents\\\\Fall2018\\\\SWE\\\\olshpDisplay\\\\node_modules\\\\ol\\\\tilegrid.js\",\"C:\\\\Users\\\\Daniel\\\\Documents\\\\Fall2018\\\\SWE\\\\olshpDisplay\\\\node_modules\\\\ol\\\\source\\\\Tile.js\",\"C:\\\\Users\\\\Daniel\\\\Documents\\\\Fall2018\\\\SWE\\\\olshpDisplay\\\\node_modules\\\\ol\\\\source\\\\TileEventType.js\",\"C:\\\\Users\\\\Daniel\\\\Documents\\\\Fall2018\\\\SWE\\\\olshpDisplay\\\\node_modules\\\\ol\\\\source\\\\UrlTile.js\",\"C:\\\\Users\\\\Daniel\\\\Documents\\\\Fall2018\\\\SWE\\\\olshpDisplay\\\\node_modules\\\\ol\\\\source\\\\TileImage.js\",\"C:\\\\Users\\\\Daniel\\\\Documents\\\\Fall2018\\\\SWE\\\\olshpDisplay\\\\node_modules\\\\ol\\\\source\\\\XYZ.js\",\"C:\\\\Users\\\\Daniel\\\\Documents\\\\Fall2018\\\\SWE\\\\olshpDisplay\\\\node_modules\\\\ol\\\\source\\\\OSM.js\",\"C:\\\\Users\\\\Daniel\\\\Documents\\\\Fall2018\\\\SWE\\\\olshpDisplay\\\\node_modules\\\\ol\\\\style\\\\Atlas.js\",\"C:\\\\Users\\\\Daniel\\\\Documents\\\\Fall2018\\\\SWE\\\\olshpDisplay\\\\node_modules\\\\ol\\\\style\\\\AtlasManager.js\",\"C:\\\\Users\\\\Daniel\\\\Documents\\\\Fall2018\\\\SWE\\\\olshpDisplay\\\\node_modules\\\\ol\\\\style\\\\IconAnchorUnits.js\",\"C:\\\\Users\\\\Daniel\\\\Documents\\\\Fall2018\\\\SWE\\\\olshpDisplay\\\\node_modules\\\\ol\\\\style\\\\IconImage.js\",\"C:\\\\Users\\\\Daniel\\\\Documents\\\\Fall2018\\\\SWE\\\\olshpDisplay\\\\node_modules\\\\ol\\\\style\\\\IconOrigin.js\",\"C:\\\\Users\\\\Daniel\\\\Documents\\\\Fall2018\\\\SWE\\\\olshpDisplay\\\\node_modules\\\\ol\\\\style\\\\Icon.js\",\"C:\\\\Users\\\\Daniel\\\\Documents\\\\Fall2018\\\\SWE\\\\olshpDisplay\\\\node_modules\\\\ol\\\\style\\\\Text.js\",\"C:\\\\Users\\\\Daniel\\\\Documents\\\\Fall2018\\\\SWE\\\\olshpDisplay\\\\node_modules\\\\ol\\\\OverlayPositioning.js\",\"C:\\\\Users\\\\Daniel\\\\Documents\\\\Fall2018\\\\SWE\\\\olshpDisplay\\\\node_modules\\\\ol\\\\Overlay.js\",\"C:\\\\Users\\\\Daniel\\\\Documents\\\\Fall2018\\\\SWE\\\\olshpDisplay\\\\main.js\",\"C:\\\\Users\\\\Daniel\\\\Documents\\\\Fall2018\\\\SWE\\\\olshpDisplay\\\\node_modules\\\\quickselect\\\\quickselect.js\",\"C:\\\\Users\\\\Daniel\\\\Documents\\\\Fall2018\\\\SWE\\\\olshpDisplay\\\\node_modules\\\\style-loader\\\\lib\\\\urls.js\",\"C:\\\\Users\\\\Daniel\\\\Documents\\\\Fall2018\\\\SWE\\\\olshpDisplay\\\\node_modules\\\\style-loader\\\\lib\\\\addStyles.js\",\"C:\\\\Users\\\\Daniel\\\\Documents\\\\Fall2018\\\\SWE\\\\olshpDisplay\\\\node_modules\\\\css-loader\\\\lib\\\\css-base.js\",\"C:\\\\Users\\\\Daniel\\\\Documents\\\\Fall2018\\\\SWE\\\\olshpDisplay\\\\node_modules\\\\css-loader\\\\index.js!C:\\\\Users\\\\Daniel\\\\Documents\\\\Fall2018\\\\SWE\\\\olshpDisplay\\\\node_modules\\\\ol\\\\ol.css\",\"C:\\\\Users\\\\Daniel\\\\Documents\\\\Fall2018\\\\SWE\\\\olshpDisplay\\\\node_modules\\\\style-loader\\\\index.js!C:\\\\Users\\\\Daniel\\\\Documents\\\\Fall2018\\\\SWE\\\\olshpDisplay\\\\node_modules\\\\css-loader\\\\index.js!C:\\\\Users\\\\Daniel\\\\Documents\\\\Fall2018\\\\SWE\\\\olshpDisplay\\\\node_modules\\\\ol\\\\ol.css\"],\"names\":[\"installedModules\",\"__webpack_require__\",\"moduleId\",\"exports\",\"module\",\"i\",\"l\",\"modules\",\"call\",\"m\",\"c\",\"d\",\"name\",\"getter\",\"o\",\"Object\",\"defineProperty\",\"configurable\",\"enumerable\",\"get\",\"r\",\"value\",\"n\",\"__esModule\",\"object\",\"property\",\"prototype\",\"hasOwnProperty\",\"p\",\"s\",\"rbush\",\"default\",\"quickselect\",\"maxEntries\",\"format\",\"this\",\"_maxEntries\",\"Math\",\"max\",\"_minEntries\",\"ceil\",\"_initFormat\",\"clear\",\"findItem\",\"item\",\"items\",\"equalsFn\",\"indexOf\",\"length\",\"calcBBox\",\"node\",\"toBBox\",\"distBBox\",\"children\",\"k\",\"destNode\",\"createNode\",\"minX\",\"Infinity\",\"minY\",\"maxX\",\"maxY\",\"child\",\"extend\",\"leaf\",\"a\",\"b\",\"min\",\"compareNodeMinX\",\"compareNodeMinY\",\"bboxArea\",\"bboxMargin\",\"contains\",\"intersects\",\"height\",\"multiSelect\",\"arr\",\"left\",\"right\",\"compare\",\"mid\",\"stack\",\"pop\",\"push\",\"all\",\"_all\",\"data\",\"search\",\"bbox\",\"result\",\"len\",\"childBBox\",\"nodesToSearch\",\"collides\",\"load\",\"insert\",\"_build\",\"slice\",\"_splitRoot\",\"tmpNode\",\"_insert\",\"remove\",\"parent\",\"index\",\"goingUp\",\"path\",\"indexes\",\"splice\",\"_condense\",\"compareMinX\",\"compareMinY\",\"toJSON\",\"fromJSON\",\"apply\",\"N\",\"M\",\"log\",\"pow\",\"j\",\"right2\",\"right3\",\"N2\",\"N1\",\"sqrt\",\"_chooseSubtree\",\"level\",\"targetNode\",\"area\",\"enlargement\",\"minArea\",\"minEnlargement\",\"isNode\",\"insertPath\",\"_split\",\"_adjustParentBBoxes\",\"_chooseSplitAxis\",\"splitIndex\",\"_chooseSplitIndex\",\"newNode\",\"bbox1\",\"bbox2\",\"overlap\",\"minOverlap\",\"_allDistMargin\",\"sort\",\"leftBBox\",\"rightBBox\",\"margin\",\"siblings\",\"compareArr\",\"Function\",\"join\",\"CONTEXT_IDS\",\"WEBGL_MAX_TEXTURE_SIZE\",\"WEBGL_EXTENSIONS\",\"HAS_WEBGL\",\"window\",\"gl\",\"canvas\",\"opt_attributes\",\"ii\",\"context\",\"getContext\",\"e\",\"document\",\"createElement\",\"failIfMajorPerformanceCaveat\",\"getParameter\",\"MAX_TEXTURE_SIZE\",\"getSupportedExtensions\",\"inherits\",\"childCtor\",\"parentCtor\",\"create\",\"constructor\",\"uidCounter_\",\"getUid\",\"obj\",\"ol_uid\",\"AssertionError\",\"code\",\"split\",\"message\",\"Error\",\"ol_AssertionError\",\"assert\",\"assertion\",\"errorCode\",\"obj_assign\",\"assign\",\"target\",\"var_sources\",\"undefined\",\"TypeError\",\"output\",\"arguments\",\"source\",\"key\",\"getValues\",\"values\",\"isEmpty\",\"findListener\",\"listeners\",\"listener\",\"opt_this\",\"opt_setDeleteIndex\",\"listenerObj\",\"bindTo\",\"deleteIndex\",\"getListeners\",\"type\",\"listenerMap\",\"ol_lm\",\"getListenerMap\",\"removeListeners\",\"removeEventListener\",\"boundListener\",\"keys\",\"listen\",\"opt_once\",\"callOnce\",\"addEventListener\",\"evt\",\"unlistenByKey\",\"bindListener\",\"listenOnce\",\"unlisten\",\"EventType\",\"CHANGE\",\"CLEAR\",\"CONTEXTMENU\",\"CLICK\",\"DBLCLICK\",\"DRAGENTER\",\"DRAGOVER\",\"DROP\",\"ERROR\",\"KEYDOWN\",\"KEYPRESS\",\"LOAD\",\"MOUSEDOWN\",\"MOUSEMOVE\",\"MOUSEOUT\",\"MOUSEUP\",\"MOUSEWHEEL\",\"MSPOINTERDOWN\",\"RESIZE\",\"TOUCHSTART\",\"TOUCHMOVE\",\"TOUCHEND\",\"WHEEL\",\"ObjectEventType\",\"TRUE\",\"FALSE\",\"UNDEFINED\",\"Disposable\",\"disposed_\",\"dispose\",\"disposeInternal\",\"ol_Disposable\",\"Event\",\"propagationStopped\",\"stopPropagation\",\"preventDefault\",\"events_Event\",\"EventTarget\",\"pendingRemovals_\",\"dispatching_\",\"listeners_\",\"dispatchEvent\",\"event\",\"propagate\",\"pendingRemovals\",\"unlistenAll\",\"hasListener\",\"opt_type\",\"events_EventTarget\",\"Observable\",\"revision_\",\"changed\",\"getRevision\",\"on\",\"Array\",\"isArray\",\"once\",\"un\",\"ol_Observable\",\"ObjectEvent\",\"oldValue\",\"BaseObject\",\"opt_values\",\"values_\",\"setProperties\",\"changeEventTypeCache\",\"getChangeEventType\",\"getKeys\",\"getProperties\",\"notify\",\"eventType\",\"set\",\"opt_silent\",\"unset\",\"ol_Object\",\"Corner\",\"BOTTOM_LEFT\",\"BOTTOM_RIGHT\",\"TOP_LEFT\",\"TOP_RIGHT\",\"Relationship\",\"UNKNOWN\",\"INTERSECTING\",\"ABOVE\",\"RIGHT\",\"BELOW\",\"LEFT\",\"boundingExtent\",\"coordinates\",\"extent\",\"createEmpty\",\"extendCoordinate\",\"buffer\",\"opt_extent\",\"clone\",\"closestSquaredDistanceXY\",\"x\",\"y\",\"dx\",\"dy\",\"containsCoordinate\",\"coordinate\",\"containsXY\",\"containsExtent\",\"extent1\",\"extent2\",\"coordinateRelationship\",\"relationship\",\"createOrUpdate\",\"createOrUpdateEmpty\",\"createOrUpdateFromCoordinate\",\"createOrUpdateFromFlatCoordinates\",\"flatCoordinates\",\"offset\",\"end\",\"stride\",\"extendFlatCoordinates\",\"equals\",\"extendCoordinates\",\"extendXY\",\"forEachCorner\",\"callback\",\"val\",\"getBottomLeft\",\"getBottomRight\",\"getTopRight\",\"getTopLeft\",\"getArea\",\"extent_isEmpty\",\"getWidth\",\"getHeight\",\"getCenter\",\"getForViewAndSize\",\"center\",\"resolution\",\"rotation\",\"size\",\"cosRotation\",\"cos\",\"sinRotation\",\"sin\",\"xCos\",\"xSin\",\"yCos\",\"ySin\",\"x0\",\"x1\",\"x2\",\"x3\",\"y0\",\"y1\",\"y2\",\"y3\",\"getIntersection\",\"intersection\",\"extent_intersects\",\"applyTransform\",\"transformFn\",\"xs\",\"ys\",\"_boundingExtentXYs\",\"transform2D\",\"transform\",\"opt_dest\",\"dest\",\"clamp\",\"cosh\",\"exp\",\"squaredSegmentDistance\",\"t\",\"math_squaredDistance\",\"toRadians\",\"angleInDegrees\",\"PI\",\"modulo\",\"lerp\",\"GeometryType\",\"POINT\",\"LINE_STRING\",\"LINEAR_RING\",\"POLYGON\",\"MULTI_POINT\",\"MULTI_LINE_STRING\",\"MULTI_POLYGON\",\"GEOMETRY_COLLECTION\",\"CIRCLE\",\"DEFAULT_RADIUS\",\"getDistance\",\"c1\",\"c2\",\"opt_radius\",\"radius\",\"lat1\",\"lat2\",\"deltaLatBy2\",\"deltaLonBy2\",\"atan2\",\"Units\",\"DEGREES\",\"FEET\",\"METERS\",\"PIXELS\",\"TILE_PIXELS\",\"USFEET\",\"METERS_PER_UNIT\",\"proj_Units\",\"Projection\",\"options\",\"code_\",\"units_\",\"extent_\",\"worldExtent_\",\"worldExtent\",\"axisOrientation_\",\"axisOrientation\",\"global_\",\"global\",\"canWrapX_\",\"getPointResolutionFunc_\",\"getPointResolution\",\"defaultTileGrid_\",\"metersPerUnit_\",\"metersPerUnit\",\"canWrapX\",\"getCode\",\"getExtent\",\"getUnits\",\"getMetersPerUnit\",\"getWorldExtent\",\"getAxisOrientation\",\"isGlobal\",\"setGlobal\",\"getDefaultTileGrid\",\"setDefaultTileGrid\",\"tileGrid\",\"setExtent\",\"setWorldExtent\",\"setGetPointResolution\",\"func\",\"getPointResolutionFunc\",\"proj_Projection\",\"RADIUS\",\"HALF_SIZE\",\"EXTENT\",\"WORLD_EXTENT\",\"EPSG3857Projection\",\"units\",\"point\",\"PROJECTIONS\",\"fromEPSG4326\",\"input\",\"opt_output\",\"opt_dimension\",\"dimension\",\"halfSize\",\"tan\",\"epsg3857_toEPSG4326\",\"atan\",\"epsg4326_EXTENT\",\"epsg4326_METERS_PER_UNIT\",\"EPSG4326Projection\",\"opt_axisOrientation\",\"epsg4326_PROJECTIONS\",\"projections_cache\",\"transforms\",\"transforms_add\",\"destination\",\"sourceCode\",\"destinationCode\",\"cloneTransform\",\"identityTransform\",\"addProjection\",\"projection\",\"projections_add\",\"proj_get\",\"projectionLike\",\"opt_units\",\"pointResolution\",\"toEPSG4326\",\"getTransformFromProjections\",\"vertices\",\"addEquivalentProjections\",\"projections\",\"forEach\",\"addProjections\",\"createProjection\",\"defaultCode\",\"equivalent\",\"projection1\",\"projection2\",\"equalUnits\",\"sourceProjection\",\"destinationProjection\",\"transformFunc\",\"transforms_get\",\"getTransform\",\"proj_transform\",\"projections2\",\"forwardTransform\",\"inverseTransform\",\"tmp_\",\"multiply\",\"transform1\",\"transform2\",\"a1\",\"b1\",\"d1\",\"e1\",\"f1\",\"a2\",\"b2\",\"d2\",\"e2\",\"f2\",\"transform_set\",\"f\",\"setFromArray\",\"ol_transform_scale\",\"transform_translate\",\"compose\",\"dx1\",\"dy1\",\"sx\",\"sy\",\"angle\",\"dx2\",\"dy2\",\"Geometry\",\"extentRevision_\",\"simplifiedGeometryCache\",\"simplifiedGeometryMaxMinSquaredTolerance\",\"simplifiedGeometryRevision\",\"tmpTransform\",\"closestPointXY\",\"closestPoint\",\"minSquaredDistance\",\"getClosestPoint\",\"opt_closestPoint\",\"NaN\",\"intersectsCoordinate\",\"computeExtent\",\"returnOrUpdate\",\"rotate\",\"anchor\",\"scale\",\"opt_sy\",\"opt_anchor\",\"simplify\",\"tolerance\",\"getSimplifiedGeometry\",\"squaredTolerance\",\"getType\",\"intersectsExtent\",\"translate\",\"deltaX\",\"deltaY\",\"inCoordinates\",\"outCoordinates\",\"pixelExtent\",\"projectedExtent\",\"geom_Geometry\",\"HEX_COLOR_RE_\",\"NAMED_COLOR_RE_\",\"asString\",\"color\",\"color_toString\",\"fromString\",\"cache\",\"cacheSize\",\"g\",\"exec\",\"el\",\"style\",\"body\",\"appendChild\",\"rgb\",\"getComputedStyle\",\"removeChild\",\"fromNamed\",\"hasAlpha\",\"parseInt\",\"substr\",\"normalize\",\"map\",\"Number\",\"fromStringInternal_\",\"asColorLike\",\"CanvasPattern\",\"CanvasGradient\",\"isColorLike\",\"createCanvasContext2D\",\"opt_width\",\"opt_height\",\"width\",\"replaceNode\",\"oldNode\",\"parentNode\",\"replaceChild\",\"removeNode\",\"removeChildren\",\"lastChild\",\"ua\",\"navigator\",\"userAgent\",\"toLowerCase\",\"FIREFOX\",\"SAFARI\",\"WEBKIT\",\"MAC\",\"DEVICE_PIXEL_RATIO\",\"devicePixelRatio\",\"CANVAS_LINE_DASH\",\"has\",\"setLineDash\",\"TOUCH\",\"POINTER\",\"MSPOINTER\",\"ImageState\",\"IDLE\",\"LOADING\",\"LOADED\",\"CLASS_HIDDEN\",\"getFontFamilies\",\"font\",\"family\",\"fontFamily\",\"LRUCache\",\"opt_highWaterMark\",\"highWaterMark\",\"count_\",\"entries_\",\"oldest_\",\"newest_\",\"canExpireCache\",\"getCount\",\"containsKey\",\"entry\",\"value_\",\"key_\",\"newer\",\"older\",\"peekLast\",\"peekLastKey\",\"peekFirstKey\",\"replace\",\"setSize\",\"prune\",\"structs_LRUCache\",\"defaultFillStyle\",\"defaultLineDash\",\"defaultStrokeStyle\",\"defaultPadding\",\"labelCache\",\"checkedFonts\",\"measureContext\",\"textHeights\",\"checkFont\",\"retries\",\"checked\",\"referenceFonts\",\"text\",\"interval\",\"referenceWidth\",\"isAvailable\",\"getMeasureContext\",\"available\",\"referenceFont\",\"measureText\",\"check\",\"done\",\"clearInterval\",\"fontSpec\",\"fontFamilies\",\"setInterval\",\"measureTextHeight\",\"span\",\"heights\",\"textContent\",\"padding\",\"position\",\"offsetHeight\",\"measureTextWidth\",\"rotateAtOffset\",\"offsetX\",\"offsetY\",\"resetTransform\",\"drawImage\",\"opacity\",\"image\",\"originX\",\"originY\",\"w\",\"h\",\"alpha\",\"globalAlpha\",\"setTransform\",\"ImageStyle\",\"opacity_\",\"rotateWithView_\",\"rotateWithView\",\"rotation_\",\"scale_\",\"snapToPixel_\",\"snapToPixel\",\"getOpacity\",\"getRotateWithView\",\"getRotation\",\"getScale\",\"getSnapToPixel\",\"getAnchor\",\"getImage\",\"pixelRatio\",\"getHitDetectionImage\",\"getImageState\",\"getImageSize\",\"getHitDetectionImageSize\",\"getOrigin\",\"getSize\",\"setOpacity\",\"setRotateWithView\",\"setRotation\",\"setScale\",\"setSnapToPixel\",\"listenImageChange\",\"thisArg\",\"unlistenImageChange\",\"style_Image\",\"RegularShape\",\"checksums_\",\"canvas_\",\"hitDetectionCanvas_\",\"fill_\",\"fill\",\"origin_\",\"points_\",\"points\",\"radius_\",\"radius1\",\"radius2_\",\"radius2\",\"angle_\",\"stroke_\",\"stroke\",\"anchor_\",\"size_\",\"imageSize_\",\"hitDetectionImageSize_\",\"atlasManager_\",\"atlasManager\",\"render_\",\"getFill\",\"getPoints\",\"getRadius\",\"getRadius2\",\"getAngle\",\"getStroke\",\"imageSize\",\"strokeStyle\",\"lineCap\",\"lineJoin\",\"miterLimit\",\"lineDash\",\"lineDashOffset\",\"strokeWidth\",\"getColor\",\"getLineDash\",\"getLineDashOffset\",\"getLineJoin\",\"getLineCap\",\"getMiterLimit\",\"renderOptions\",\"draw_\",\"createHitDetectionCanvas_\",\"round\",\"hasCustomHitDetectionImage\",\"renderHitDetectionCallback\",\"drawHitDetectionCanvas_\",\"bind\",\"id\",\"getChecksum\",\"info\",\"add\",\"hitImage\",\"angle0\",\"radiusC\",\"beginPath\",\"arc\",\"lineTo\",\"fillStyle\",\"lineWidth\",\"closePath\",\"strokeChecksum\",\"fillChecksum\",\"checksum\",\"toString\",\"style_RegularShape\",\"CircleStyle\",\"opt_options\",\"setRadius\",\"Circle\",\"Fill\",\"color_\",\"checksum_\",\"setColor\",\"style_Fill\",\"Stroke\",\"lineCap_\",\"lineDash_\",\"lineDashOffset_\",\"lineJoin_\",\"miterLimit_\",\"width_\",\"setLineCap\",\"setLineDashOffset\",\"setLineJoin\",\"setMiterLimit\",\"setWidth\",\"style_Stroke\",\"Style\",\"geometry_\",\"geometryFunction_\",\"defaultGeometryFunction\",\"geometry\",\"setGeometry\",\"image_\",\"renderer_\",\"renderer\",\"text_\",\"zIndex_\",\"zIndex\",\"getGeometry\",\"getText\",\"getZIndex\",\"getRenderer\",\"setRenderer\",\"getGeometryFunction\",\"setFill\",\"setImage\",\"setStroke\",\"setText\",\"feature\",\"setZIndex\",\"defaultStyles\",\"createDefaultStyle\",\"createEditingStyle\",\"styles\",\"white\",\"blue\",\"concat\",\"style_Style\",\"Feature\",\"opt_geometryOrProperties\",\"id_\",\"geometryName_\",\"style_\",\"styleFunction_\",\"geometryChangeKey_\",\"handleGeometryChanged_\",\"properties\",\"setGeometryName\",\"getGeometryName\",\"getStyle\",\"setStyle\",\"getId\",\"getStyleFunction\",\"handleGeometryChange_\",\"createStyleFunction\",\"setId\",\"ol_Feature\",\"FeatureFormat\",\"defaultDataProjection\",\"defaultFeatureProjection\",\"getReadOptions\",\"dataProjection\",\"readProjection\",\"featureProjection\",\"adaptOptions\",\"getLastExtent\",\"readFeature\",\"readFeatures\",\"readGeometry\",\"writeFeature\",\"writeFeatures\",\"features\",\"writeGeometry\",\"format_Feature\",\"transformWithOptions\",\"write\",\"transformed\",\"decimals\",\"power\",\"FormatType\",\"ARRAY_BUFFER\",\"JSON\",\"TEXT\",\"XML\",\"JSONFeature\",\"getObject\",\"parse\",\"readFeatureFromObject\",\"readFeaturesFromObject\",\"readGeometryFromObject\",\"readProjectionFromObject\",\"stringify\",\"writeFeatureObject\",\"writeFeaturesObject\",\"writeGeometryObject\",\"format_JSONFeature\",\"GeometryCollection\",\"opt_geometries\",\"geometries_\",\"listenGeometriesChange_\",\"cloneGeometries\",\"geometries\",\"clonedGeometries\",\"unlistenGeometriesChange_\",\"geometryCollection\",\"setGeometries\",\"getGeometries\",\"getGeometriesArray\",\"simplifiedGeometries\",\"simplified\",\"simplifiedGeometry\",\"simplifiedGeometryCollection\",\"setGeometriesArray\",\"geom_GeometryCollection\",\"numberSafeCompareFunction\",\"includes\",\"linearFindNearest\",\"direction\",\"reverseSubArray\",\"begin\",\"tmp\",\"array_extend\",\"extension\",\"array_equals\",\"arr1\",\"arr2\",\"len1\",\"GeometryLayout\",\"XY\",\"XYZ\",\"XYM\",\"XYZM\",\"SimpleGeometry\",\"layout\",\"getStrideForLayout\",\"getCoordinates\",\"getFirstCoordinate\",\"getFlatCoordinates\",\"getLastCoordinate\",\"getLayout\",\"getSimplifiedGeometryInternal\",\"getStride\",\"setFlatCoordinatesInternal\",\"setCoordinates\",\"opt_layout\",\"setLayout\",\"nesting\",\"getLayoutForStride\",\"anchorX\",\"anchorY\",\"transform_scale\",\"geom_SimpleGeometry\",\"assignClosest\",\"offset1\",\"offset2\",\"maxSquaredDelta\",\"squaredDelta\",\"arrayMaxSquaredDelta\",\"ends\",\"assignClosestPoint\",\"maxDelta\",\"isRing\",\"opt_tmpPoint\",\"squaredDistance\",\"tmpPoint\",\"assignClosestArrayPoint\",\"deflateCoordinate\",\"deflateCoordinates\",\"deflateCoordinatesArray\",\"coordinatess\",\"opt_ends\",\"jj\",\"inflateCoordinates\",\"opt_coordinates\",\"inflateCoordinatesArray\",\"opt_coordinatess\",\"inflateMultiCoordinatesArray\",\"endss\",\"opt_coordinatesss\",\"coordinatesss\",\"interpolatePoint\",\"fraction\",\"pointX\",\"pointY\",\"cumulativeLengths\",\"haystack\",\"needle\",\"opt_comparator\",\"cmp\",\"comparator\",\"low\",\"high\",\"found\",\"binarySearch\",\"lineStringCoordinateAtM\",\"extrapolate\",\"lo\",\"hi\",\"m0\",\"linearRingContainsExtent\",\"linearRingContainsXY\",\"wn\",\"linearRingsContainsXY\",\"point1\",\"point2\",\"ret\",\"intersectsLineString\",\"coordinatesExtent\",\"start\",\"startRel\",\"endRel\",\"startX\",\"startY\",\"endX\",\"endY\",\"slope\",\"intersectsSegment\",\"intersectsLinearRingArray\",\"intersectsLinearRing\",\"lineStringLength\",\"douglasPeucker\",\"simplifiedFlatCoordinates\",\"simplifiedOffset\",\"markers\",\"last\",\"first\",\"maxSquaredDistance\",\"douglasPeuckerArray\",\"simplifiedEnds\",\"snap\",\"quantize\",\"quantizeArray\",\"LineString\",\"flatMidpoint_\",\"flatMidpointRevision_\",\"maxDelta_\",\"maxDeltaRevision_\",\"appendCoordinate\",\"lineString\",\"setFlatCoordinates\",\"forEachSegment\",\"getCoordinateAtM\",\"opt_extrapolate\",\"getCoordinateAt\",\"getLength\",\"getFlatMidpoint\",\"simplifiedLineString\",\"geom_LineString\",\"MultiLineString\",\"ends_\",\"appendLineString\",\"multiLineString\",\"opt_interpolate\",\"interpolate\",\"lineStringsCoordinateAtM\",\"getEnds\",\"getLineString\",\"getLineStrings\",\"lineStrings\",\"getFlatMidpoints\",\"midpoints\",\"simplifiedMultiLineString\",\"intersectsLineStringArray\",\"setLineStrings\",\"geom_MultiLineString\",\"Point\",\"geom_Point\",\"MultiPoint\",\"appendPoint\",\"multiPoint\",\"getPoint\",\"geom_MultiPoint\",\"area_linearRing\",\"twiceArea\",\"area_linearRings\",\"LinearRing\",\"linearRing\",\"simplifiedLinearRing\",\"geom_LinearRing\",\"getInteriorPointOfArray\",\"flatCenters\",\"flatCentersOffset\",\"intersections\",\"rr\",\"maxSegmentLength\",\"segmentLength\",\"abs\",\"isNaN\",\"reverse_coordinates\",\"linearRingIsClockwise\",\"edge\",\"linearRingIsOriented\",\"opt_right\",\"isClockwise\",\"orientLinearRings\",\"orientLinearRingsArray\",\"Polygon\",\"flatInteriorPointRevision_\",\"flatInteriorPoint_\",\"orientedRevision_\",\"orientedFlatCoordinates_\",\"appendLinearRing\",\"polygon\",\"getOrientedFlatCoordinates\",\"getFlatInteriorPoint\",\"flatCenter\",\"getInteriorPoint\",\"getLinearRingCount\",\"getLinearRing\",\"getLinearRings\",\"linearRings\",\"simplifiedPolygon\",\"fromExtent\",\"fromCircle\",\"circle\",\"opt_sides\",\"opt_angle\",\"sides\",\"arrayLength\",\"makeRegular\",\"startAngle\",\"MultiPolygon\",\"endss_\",\"flatInteriorPointsRevision_\",\"flatInteriorPoints_\",\"appendPolygon\",\"multiPolygon\",\"newEndss\",\"multiArrayMaxSquaredDelta\",\"assignClosestMultiArrayPoint\",\"linearRingssContainsXY\",\"linearRingss\",\"getEndss\",\"getFlatInteriorPoints\",\"center_linearRingss\",\"interiorPoints\",\"getInteriorPointsOfMultiArray\",\"getInteriorPoints\",\"linearRingsAreOriented\",\"simplifiedEndss\",\"quantizeMultiArray\",\"simplifiedMultiPolygon\",\"getPolygon\",\"prevEnds\",\"geom_Polygon\",\"getPolygons\",\"polygons\",\"intersectsLinearRingMultiArray\",\"opt_endss\",\"deflateMultiCoordinatesArray\",\"lastEnds\",\"setPolygons\",\"geom_MultiPolygon\",\"GeoJSON\",\"geometryName\",\"extractGeometryName_\",\"extractGeometryName\",\"GEOMETRY_READERS\",\"GEOMETRY_WRITERS\",\"rightHanded\",\"geometryReader\",\"geometryWriter\",\"geoJSONFeature\",\"geometry_name\",\"geoJSONFeatures\",\"crs\",\"objects\",\"format_GeoJSON\",\"CollectionEventType\",\"Property\",\"CollectionEvent\",\"opt_element\",\"element\",\"Collection\",\"opt_array\",\"unique_\",\"unique\",\"array_\",\"assertUnique_\",\"updateLength_\",\"array\",\"getArray\",\"insertAt\",\"elem\",\"removeAt\",\"prev\",\"setAt\",\"opt_except\",\"ol_Collection\",\"MapEvent\",\"opt_frameState\",\"frameState\",\"ol_MapEvent\",\"MapBrowserEvent\",\"browserEvent\",\"opt_dragging\",\"originalEvent\",\"pixel\",\"getEventPixel\",\"getCoordinateFromPixel\",\"dragging\",\"ol_MapBrowserEvent\",\"MapBrowserEventType\",\"SINGLECLICK\",\"POINTERDRAG\",\"POINTERMOVE\",\"POINTERDOWN\",\"POINTERUP\",\"POINTEROVER\",\"POINTEROUT\",\"POINTERENTER\",\"POINTERLEAVE\",\"POINTERCANCEL\",\"MapBrowserPointerEvent\",\"pointerEvent\",\"ol_MapBrowserPointerEvent\",\"pointer_EventType\",\"EventSource\",\"dispatcher\",\"mapping\",\"mapping_\",\"getEvents\",\"getHandlerForEvent\",\"pointer_EventSource\",\"MouseSource\",\"mousedown\",\"mousemove\",\"mouseup\",\"mouseover\",\"mouseout\",\"pointerMap\",\"lastTouches\",\"POINTER_ID\",\"POINTER_TYPE\",\"prepareEvent\",\"inEvent\",\"cloneEvent\",\"pd\",\"pointerId\",\"isPrimary\",\"pointerType\",\"isEventSimulatedFromTouch_\",\"lts\",\"clientX\",\"clientY\",\"cancel\",\"down\",\"move\",\"button\",\"up\",\"cleanupMouse\",\"enterOver\",\"leaveOut\",\"pointer_MouseSource\",\"MsSource\",\"MSPointerDown\",\"msPointerDown\",\"MSPointerMove\",\"msPointerMove\",\"MSPointerUp\",\"msPointerUp\",\"MSPointerOut\",\"msPointerOut\",\"MSPointerOver\",\"msPointerOver\",\"MSPointerCancel\",\"msPointerCancel\",\"MSGotPointerCapture\",\"msGotPointerCapture\",\"MSLostPointerCapture\",\"msLostPointerCapture\",\"POINTER_TYPES\",\"prepareEvent_\",\"cleanup\",\"makeEvent\",\"pointer_MsSource\",\"NativeSource\",\"pointerdown\",\"pointerDown\",\"pointermove\",\"pointerMove\",\"pointerup\",\"pointerUp\",\"pointerout\",\"pointerOut\",\"pointerover\",\"pointerOver\",\"pointercancel\",\"pointerCancel\",\"gotpointercapture\",\"gotPointerCapture\",\"lostpointercapture\",\"lostPointerCapture\",\"fireNativeEvent\",\"pointer_NativeSource\",\"PointerEvent\",\"opt_eventDict\",\"eventDict\",\"buttons\",\"getButtons_\",\"pressure\",\"getPressure_\",\"bubbles\",\"cancelable\",\"view\",\"detail\",\"screenX\",\"screenY\",\"ctrlKey\",\"altKey\",\"shiftKey\",\"metaKey\",\"relatedTarget\",\"tiltX\",\"tiltY\",\"hwTimestamp\",\"HAS_BUTTONS\",\"which\",\"ev\",\"MouseEvent\",\"pointer_PointerEvent\",\"TouchSource\",\"mouseSource\",\"touchstart\",\"touchmove\",\"touchend\",\"touchcancel\",\"firstTouchId_\",\"clickCount_\",\"resetId_\",\"dedupTimeout_\",\"isPrimaryTouch_\",\"inTouch\",\"identifier\",\"setPrimaryTouch_\",\"count\",\"cancelResetClickCount_\",\"removePrimaryPointer_\",\"inPointer\",\"resetClickCount_\",\"setTimeout\",\"resetClickCountHandler_\",\"clearTimeout\",\"touchToPointer_\",\"webkitRadiusX\",\"radiusX\",\"webkitRadiusY\",\"radiusY\",\"webkitForce\",\"force\",\"processTouches_\",\"inFunction\",\"touches\",\"changedTouches\",\"pointer\",\"findTouch_\",\"touchList\",\"searchId\",\"vacuumTouches_\",\"out\",\"cancelOut_\",\"dedupSynthMouse_\",\"overDown_\",\"outTarget\",\"over\",\"enter\",\"moveOverOut_\",\"outEvent\",\"upOut_\",\"leave\",\"cleanUpPointer_\",\"lt\",\"array_remove\",\"pointer_TouchSource\",\"PointerEventHandler\",\"element_\",\"eventMap_\",\"eventSourceList_\",\"registerSources\",\"CLONE_PROPS\",\"registerSource\",\"register_\",\"newEvents\",\"handler\",\"eventSource\",\"addEvents_\",\"unregister_\",\"removeEvents_\",\"eventHandler_\",\"events\",\"eventName\",\"eventCopy\",\"fireEvent\",\"contains_\",\"container\",\"contained\",\"inType\",\"wrapMouseEvent\",\"pointer_PointerEventHandler\",\"MapBrowserEventHandler\",\"moveTolerance\",\"map_\",\"clickTimeoutId_\",\"dragging_\",\"dragListenerKeys_\",\"moveTolerance_\",\"down_\",\"getViewport\",\"activePointers_\",\"trackedTouches_\",\"pointerEventHandler_\",\"documentPointerEventHandler_\",\"pointerdownListenerKey_\",\"handlePointerDown_\",\"relayedListenerKey_\",\"relayEvent_\",\"emulateClick_\",\"newEvent\",\"updateActivePointers_\",\"handlePointerUp_\",\"isMouseActionButton_\",\"handlePointerMove_\",\"isMoving_\",\"ol_MapBrowserEventHandler\",\"MapEventType\",\"MapProperty\",\"LAYERGROUP\",\"SIZE\",\"TARGET\",\"VIEW\",\"TileState\",\"PriorityQueue\",\"priorityFunction\",\"keyFunction\",\"priorityFunction_\",\"keyFunction_\",\"elements_\",\"priorities_\",\"queuedElements_\",\"dequeue\",\"elements\",\"priorities\",\"siftUp_\",\"elementKey\",\"enqueue\",\"priority\",\"siftDown_\",\"getLeftChildIndex_\",\"getRightChildIndex_\",\"getParentIndex_\",\"heapify_\",\"isKeyQueued\",\"isQueued\",\"startIndex\",\"lIndex\",\"rIndex\",\"smallerChildIndex\",\"parentIndex\",\"reprioritize\",\"structs_PriorityQueue\",\"TileQueue\",\"tilePriorityFunction\",\"tileChangeCallback\",\"getKey\",\"tileChangeCallback_\",\"tilesLoading_\",\"tilesLoadingKeys_\",\"added\",\"handleTileChange\",\"getTilesLoading\",\"tile\",\"state\",\"getState\",\"tileKey\",\"loadMoreTiles\",\"maxTotalLoading\",\"maxNewLoads\",\"newLoads\",\"abortedTiles\",\"ol_TileQueue\",\"DEFAULT_MAX_ZOOM\",\"DEFAULT_TILE_SIZE\",\"none\",\"disable\",\"delta\",\"rotationconstraint_none\",\"ViewHint\",\"ANIMATING\",\"INTERACTING\",\"ViewProperty\",\"coordinate_add\",\"closestOnSegment\",\"segment\",\"along\",\"coordinate_equals\",\"coordinate1\",\"coordinate2\",\"coordinate_rotate\",\"cosAngle\",\"sinAngle\",\"coordinate_scale\",\"coordinate_squaredDistance\",\"coord1\",\"coord2\",\"coordinate_distance\",\"squaredDistanceToSegment\",\"easeIn\",\"easeOut\",\"inAndOut\",\"linear\",\"DEFAULT_MIN_ZOOM\",\"View\",\"hints_\",\"animations_\",\"updateAnimationKey_\",\"updateAnimations_\",\"projection_\",\"applyOptions_\",\"isNoopAnimation\",\"animation\",\"sourceCenter\",\"targetCenter\",\"sourceResolution\",\"targetResolution\",\"sourceRotation\",\"targetRotation\",\"resolutionConstraintInfo\",\"resolutionConstraint\",\"maxResolution\",\"minResolution\",\"minZoom\",\"maxZoom\",\"zoomFactor\",\"resolutions\",\"z\",\"floor\",\"defaultMaxResolution\",\"defaultMinResolution\",\"opt_maxLevel\",\"oldLevel\",\"newLevel\",\"createSnapToPower\",\"constraint\",\"createResolutionConstraint\",\"maxResolution_\",\"minResolution_\",\"zoomFactor_\",\"resolutions_\",\"minZoom_\",\"centerConstraint\",\"createCenterConstraint\",\"rotationConstraint\",\"enableRotation\",\"constrainRotation\",\"opt_tolerance\",\"createSnapToZero\",\"theta\",\"createSnapToN\",\"createRotationConstraint\",\"constraints_\",\"zoom\",\"constrainResolution\",\"getResolution\",\"options_\",\"getUpdatedOptions_\",\"newOptions\",\"getZoom\",\"animate\",\"var_args\",\"animationCount\",\"isDef\",\"setCenter\",\"setZoom\",\"Date\",\"now\",\"series\",\"complete\",\"duration\",\"easing\",\"setHint\",\"getAnimating\",\"getInteracting\",\"cancelAnimations\",\"cancelAnimationFrame\",\"more\",\"seriesComplete\",\"elapsed\",\"progress\",\"calculateCenterZoom\",\"calculateCenterRotate\",\"filter\",\"Boolean\",\"requestAnimationFrame\",\"currentCenter\",\"currentResolution\",\"getSizeFromViewport_\",\"selector\",\"querySelector\",\"metrics\",\"constrainCenter\",\"opt_delta\",\"opt_direction\",\"getConstraints\",\"getHints\",\"opt_hints\",\"calculateExtent\",\"opt_size\",\"getMaxResolution\",\"getMinResolution\",\"getMaxZoom\",\"getZoomForResolution\",\"setMaxZoom\",\"getMinZoom\",\"setMinZoom\",\"getProjection\",\"getResolutions\",\"getResolutionForExtent\",\"xResolution\",\"yResolution\",\"getResolutionForValueFunction\",\"opt_power\",\"getValueForResolutionFunction\",\"nearest\",\"getResolutionForZoom\",\"fit\",\"geometryOrExtent\",\"coords\",\"minRotX\",\"minRotY\",\"maxRotX\",\"maxRotY\",\"rotX\",\"rotY\",\"constrainedResolution\",\"centerRotX\",\"centerRotY\",\"setResolution\",\"centerOn\",\"centerX\",\"centerY\",\"hint\",\"ol_View\",\"layer_Property\",\"BaseLayer\",\"visible\",\"state_\",\"layer\",\"managed\",\"getLayerState\",\"sourceState\",\"getSourceState\",\"getVisible\",\"getLayersArray\",\"getLayerStatesArray\",\"opt_states\",\"setMaxResolution\",\"setMinResolution\",\"setVisible\",\"zindex\",\"Base\",\"State\",\"Group_Property\",\"LayerGroup\",\"baseOptions\",\"layers\",\"layersListenerKeys_\",\"listenerKeys_\",\"handleLayersChanged_\",\"setLayers\",\"handleLayerChange_\",\"getLayers\",\"handleLayersAdd_\",\"handleLayersRemove_\",\"layersArray\",\"collectionEvent\",\"states\",\"pos\",\"ownLayerState\",\"layerState\",\"Group\",\"toSize\",\"PluggableMap\",\"optionsInternal\",\"keyboardEventTarget\",\"getElementById\",\"layerGroup\",\"controls\",\"interactions\",\"overlays\",\"createOptionsInternal\",\"maxTilesLoading_\",\"maxTilesLoading\",\"loadTilesWhileAnimating_\",\"loadTilesWhileAnimating\",\"loadTilesWhileInteracting_\",\"loadTilesWhileInteracting\",\"pixelRatio_\",\"animationDelayKey_\",\"animationDelay_\",\"renderFrame_\",\"coordinateToPixelTransform_\",\"pixelToCoordinateTransform_\",\"frameIndex_\",\"frameState_\",\"previousExtent_\",\"viewPropertyListenerKey_\",\"viewChangeListenerKey_\",\"layerGroupPropertyListenerKeys_\",\"viewport_\",\"className\",\"overflow\",\"msTouchAction\",\"touchAction\",\"overlayContainer_\",\"overlayContainerStopEvent_\",\"overlayEvents\",\"mapBrowserEventHandler_\",\"handleMapBrowserEvent\",\"keyboardEventTarget_\",\"keyHandlerKeys_\",\"handleBrowserEvent\",\"overlays_\",\"overlayIdIndex_\",\"createRenderer\",\"handleResize_\",\"focus_\",\"postRenderFunctions_\",\"tileQueue_\",\"getTilePriority\",\"handleTileChange_\",\"skippedFeatureUids_\",\"handleLayerGroupChanged_\",\"handleViewChanged_\",\"handleSizeChanged_\",\"handleTargetChanged_\",\"control\",\"setMap\",\"interaction\",\"addOverlayInternal_\",\"addControl\",\"getControls\",\"addInteraction\",\"getInteractions\",\"addLayer\",\"getLayerGroup\",\"addOverlay\",\"overlay\",\"getOverlays\",\"setTarget\",\"forEachFeatureAtPixel\",\"hitTolerance\",\"layerFilter\",\"forEachFeatureAtCoordinate\",\"getFeaturesAtPixel\",\"forEachLayerAtPixel\",\"opt_layerFilter\",\"opt_this2\",\"thisArg2\",\"hasFeatureAtPixel\",\"hasFeatureAtCoordinate\",\"getEventCoordinate\",\"viewportPosition\",\"getBoundingClientRect\",\"eventPosition\",\"top\",\"getTarget\",\"getTargetElement\",\"pixelToCoordinateTransform\",\"getOverlayById\",\"getPixelFromCoordinate\",\"coordinateToPixelTransform\",\"getView\",\"getOverlayContainer\",\"getOverlayContainerStopEvent\",\"tileSourceKey\",\"tileCenter\",\"tileResolution\",\"wantedTiles\",\"focus\",\"mapBrowserEvent\",\"interactionsArray\",\"getActive\",\"handleEvent\",\"handlePostRender\",\"tileQueue\",\"hints\",\"viewHints\",\"postRenderFunctions\",\"render\",\"targetElement\",\"updateSize\",\"removeLayerRenderers\",\"handleViewPropertyChanged_\",\"setAttribute\",\"isRendered\",\"renderSync\",\"removeControl\",\"removeInteraction\",\"removeLayer\",\"removeOverlay\",\"time\",\"viewState\",\"previousFrameState\",\"hasArea\",\"layerStatesArray\",\"layerStates\",\"pixelResolution\",\"skippedFeatureUids\",\"usedTiles\",\"renderFrame\",\"setLayerGroup\",\"setView\",\"skipFeature\",\"featureUid\",\"computedStyle\",\"offsetWidth\",\"parseFloat\",\"unskipFeature\",\"ol_PluggableMap\",\"Control\",\"target_\",\"listenerKeys\",\"getMap\",\"control_Control\",\"render_EventType\",\"Layer\",\"mapPrecomposeKey_\",\"mapRenderKey_\",\"sourceChangeKey_\",\"handleSourcePropertyChange_\",\"setSource\",\"visibleAtResolution\",\"getSource\",\"handleSourceChange_\",\"layer_Layer\",\"Attribution\",\"ulElement_\",\"collapsed_\",\"collapsed\",\"collapsible_\",\"collapsible\",\"tipLabel\",\"collapseLabel\",\"collapseLabel_\",\"label\",\"label_\",\"activeLabel\",\"title\",\"handleClick_\",\"cssClasses\",\"Attribution_render\",\"renderedAttributions_\",\"renderedVisible_\",\"mapEvent\",\"updateElement_\",\"getSourceAttributions_\",\"lookup\",\"visibleAttributions\",\"attributionGetter\",\"getAttributions\",\"attributions\",\"display\",\"innerHTML\",\"handleToggle_\",\"classList\",\"toggle\",\"getCollapsible\",\"setCollapsible\",\"setCollapsed\",\"getCollapsed\",\"control_Attribution\",\"Rotate\",\"callResetNorth_\",\"resetNorth\",\"Rotate_render\",\"duration_\",\"autoHide_\",\"autoHide\",\"msTransform\",\"webkitTransform\",\"resetNorth_\",\"control_Rotate\",\"Zoom\",\"zoomInLabel\",\"zoomOutLabel\",\"zoomInTipLabel\",\"zoomOutTipLabel\",\"inElement\",\"createTextNode\",\"outElement\",\"zoomByDelta_\",\"newResolution\",\"control_Zoom\",\"Kinetic\",\"decay\",\"minVelocity\",\"delay\",\"decay_\",\"minVelocity_\",\"delay_\",\"initialVelocity_\",\"update\",\"lastIndex\",\"firstIndex\",\"ol_Kinetic\",\"interaction_Property\",\"Interaction\",\"setActive\",\"Interaction_rotate\",\"opt_duration\",\"rotateWithoutConstraints\",\"currentRotation\",\"zoomWithoutConstraints\",\"zoomByDelta\",\"active\",\"interaction_Interaction\",\"DoubleClickZoom\",\"delta_\",\"stopEvent\",\"interaction_DoubleClickZoom\",\"altShiftKeysOnly\",\"always\",\"mouseActionButton\",\"never\",\"singleClick\",\"noModifierKeys\",\"shiftKeyOnly\",\"targetNotEditable\",\"tagName\",\"mouseOnly\",\"primaryAction\",\"handleDragEvent\",\"handleUpEvent\",\"handleDownEvent\",\"handleMoveEvent\",\"PointerInteraction\",\"Pointer_handleEvent\",\"handleDownEvent_\",\"handleDragEvent_\",\"handleMoveEvent_\",\"handleUpEvent_\",\"handlingDownUpSequence\",\"trackedPointers_\",\"targetPointers\",\"Pointer_centroid\",\"pointerEvents\",\"updateTrackedPointers_\",\"handledUp\",\"handled\",\"shouldStopEvent\",\"isPointerDraggingEvent\",\"Pointer\",\"DragPan\",\"DragPan_handleDownEvent\",\"DragPan_handleDragEvent\",\"DragPan_handleUpEvent\",\"kinetic_\",\"kinetic\",\"lastCentroid\",\"lastPointersCount_\",\"condition_\",\"condition\",\"noKinetic_\",\"centroid\",\"distance\",\"centerpx\",\"interaction_DragPan\",\"DragRotate\",\"DragRotate_handleDownEvent\",\"DragRotate_handleDragEvent\",\"DragRotate_handleUpEvent\",\"lastAngle_\",\"interaction_DragRotate\",\"RenderBox\",\"startPixel_\",\"endPixel_\",\"startPixel\",\"endPixel\",\"setPixels\",\"createOrUpdateGeometry\",\"Box\",\"DragBoxEventType\",\"BOXSTART\",\"BOXDRAG\",\"BOXEND\",\"DragBoxEvent\",\"DragBox\",\"DragBox_handleDownEvent\",\"DragBox_handleDragEvent\",\"DragBox_handleUpEvent\",\"box_\",\"minArea_\",\"boxEndCondition_\",\"boxEndCondition\",\"defaultBoxEndCondition\",\"onBoxEnd\",\"interaction_DragBox\",\"DragZoom\",\"out_\",\"mapExtent\",\"boxPixelExtent\",\"scaleFromCenter\",\"interaction_DragZoom\",\"KeyCode\",\"UP\",\"DOWN\",\"KeyboardPan\",\"KeyboardPan_handleEvent\",\"defaultCondition_\",\"pixelDelta_\",\"pixelDelta\",\"keyCode\",\"mapUnitsDelta\",\"pan\",\"interaction_KeyboardPan\",\"KeyboardZoom\",\"KeyboardZoom_handleEvent\",\"charCode\",\"charCodeAt\",\"interaction_KeyboardZoom\",\"Mode\",\"TRACKPAD\",\"MouseWheelZoom\",\"MouseWheelZoom_handleEvent\",\"timeout_\",\"timeout\",\"useAnchor_\",\"useAnchor\",\"constrainResolution_\",\"lastAnchor_\",\"startTime_\",\"timeoutId_\",\"mode_\",\"trackpadEventGap_\",\"trackpadTimeoutId_\",\"trackpadDeltaPerZoom_\",\"trackpadZoomBuffer_\",\"wheelEvent\",\"deltaMode\",\"WheelEvent\",\"DOM_DELTA_PIXEL\",\"DOM_DELTA_LINE\",\"wheelDeltaY\",\"decrementInteractingHint_\",\"rebound\",\"timeLeft\",\"handleWheelZoom_\",\"setMouseAnchor\",\"interaction_MouseWheelZoom\",\"PinchRotate\",\"PinchRotate_handleDownEvent\",\"PinchRotate_handleDragEvent\",\"PinchRotate_handleUpEvent\",\"rotating_\",\"rotationDelta_\",\"threshold_\",\"threshold\",\"rotationDelta\",\"touch0\",\"touch1\",\"interaction_PinchRotate\",\"PinchZoom\",\"PinchZoom_handleDownEvent\",\"PinchZoom_handleDragEvent\",\"PinchZoom_handleUpEvent\",\"lastDistance_\",\"lastScaleDelta_\",\"scaleDelta\",\"interaction_PinchZoom\",\"DragAndDropEventType\",\"DragAndDropEvent\",\"file\",\"opt_features\",\"opt_projection\",\"DragAndDrop\",\"formatConstructors_\",\"formatConstructors\",\"dropListenKeys_\",\"source_\",\"handleDrop\",\"files\",\"dataTransfer\",\"reader\",\"FileReader\",\"handleResult_\",\"readAsText\",\"handleStop\",\"dropEffect\",\"formatConstructor\",\"tryReadFeatures_\",\"addFeatures\",\"registerListeners_\",\"dropArea\",\"unregisterListeners_\",\"DragRotateAndZoom\",\"DragRotateAndZoom_handleDownEvent\",\"DragRotateAndZoom_handleDragEvent\",\"DragRotateAndZoom_handleUpEvent\",\"lastMagnitude_\",\"magnitude\",\"angleDelta\",\"Circle_Circle\",\"setCenterAndRadius\",\"getRadiusSquared_\",\"geom_Circle\",\"LayerType\",\"VectorRenderType\",\"Vector_Property\",\"VectorLayer\",\"renderBuffer\",\"updateWhileAnimating\",\"updateWhileInteracting\",\"declutter_\",\"declutter\",\"renderBuffer_\",\"updateWhileAnimating_\",\"updateWhileInteracting_\",\"renderMode_\",\"renderMode\",\"getDeclutter\",\"setDeclutter\",\"getRenderBuffer\",\"getRenderOrder\",\"getUpdateWhileAnimating\",\"getUpdateWhileInteracting\",\"setRenderOrder\",\"renderOrder\",\"styleFunction\",\"toFunction\",\"getRenderMode\",\"Vector\",\"featureloader_xhr\",\"url\",\"success\",\"failure\",\"xhr\",\"XMLHttpRequest\",\"open\",\"responseType\",\"onload\",\"status\",\"responseText\",\"responseXML\",\"DOMParser\",\"parseFromString\",\"onerror\",\"send\",\"loadFeaturesXhr\",\"loadingstrategy_all\",\"Source\",\"attributions_\",\"adaptAttributions_\",\"wrapX_\",\"wrapX\",\"attributionLike\",\"getWrapX\",\"refresh\",\"setAttributions\",\"setState\",\"source_Source\",\"VectorEventType\",\"RBush\",\"opt_maxEntries\",\"rbush_\",\"rbush_default\",\"items_\",\"extents\",\"uid\",\"getAll\",\"getInExtent\",\"forEach_\",\"forEachInExtent\",\"structs_RBush\",\"VectorSourceEvent\",\"opt_feature\",\"VectorSource\",\"loader_\",\"format_\",\"overlaps_\",\"overlaps\",\"url_\",\"loader\",\"strategy_\",\"strategy\",\"useSpatialIndex\",\"collection\",\"featuresRtree_\",\"loadedExtentsRtree_\",\"nullGeometryFeatures_\",\"idIndex_\",\"undefIdIndex_\",\"featureChangeKeys_\",\"featuresCollection_\",\"addFeaturesInternal\",\"bindFeaturesCollection_\",\"addFeature\",\"addFeatureInternal\",\"featureKey\",\"addToIndex_\",\"setupChangeEvents_\",\"handleFeatureChange_\",\"valid\",\"newFeatures\",\"geometryFeatures\",\"modifyingCollection\",\"removeFeature\",\"opt_fast\",\"featureId\",\"removeFeatureInternal\",\"clearEvent\",\"forEachFeature\",\"forEachFeatureAtCoordinateDirect\",\"forEachFeatureInExtent\",\"forEachFeatureIntersectingExtent\",\"getFeaturesCollection\",\"getFeatures\",\"getFeaturesAtCoordinate\",\"getFeaturesInExtent\",\"getClosestFeatureToCoordinate\",\"opt_filter\",\"closestFeature\",\"previousMinSquaredDistance\",\"minDistance\",\"getFeatureById\",\"getFormat\",\"getOverlaps\",\"getUrl\",\"sid\",\"removeFromIdIndex_\",\"hasFeature\",\"loadFeatures\",\"loadedExtentsRtree\",\"extentsToLoad\",\"extentToLoad\",\"removeLoadedExtent\",\"removed\",\"setLoader\",\"source_Vector\",\"Draw_Mode\",\"DrawEventType\",\"DrawEvent\",\"Draw\",\"Draw_handleDownEvent\",\"Draw_handleEvent\",\"Draw_handleUpEvent\",\"shouldHandle_\",\"downPx_\",\"downTimeout_\",\"lastDragTime_\",\"freehand_\",\"features_\",\"snapTolerance_\",\"snapTolerance\",\"type_\",\"mode\",\"getMode\",\"stopClick_\",\"stopClick\",\"minPoints_\",\"minPoints\",\"maxPoints_\",\"maxPoints\",\"finishCondition_\",\"finishCondition\",\"geometryFunction\",\"opt_geometry\",\"squaredLength\",\"Constructor\",\"dragVertexDelay_\",\"dragVertexDelay\",\"finishCoordinate_\",\"sketchFeature_\",\"sketchPoint_\",\"sketchCoords_\",\"sketchLine_\",\"sketchLineCoords_\",\"squaredClickTolerance_\",\"clickTolerance\",\"overlay_\",\"getDefaultStyleFunction\",\"freehandCondition_\",\"freehand\",\"freehandCondition\",\"updateState_\",\"pass\",\"addToDrawing_\",\"startDrawing_\",\"circleMode\",\"finishDrawing\",\"atFinish_\",\"abortDrawing_\",\"downPx\",\"clickPx\",\"modifyDrawing_\",\"createOrUpdateSketchPoint_\",\"at\",\"potentiallyDone\",\"potentiallyFinishCoordinates\",\"finishCoordinate\",\"finishPixel\",\"updateSketchFeatures_\",\"sketchLineGeom\",\"ring\",\"removeLastPoint\",\"sketchFeature\",\"sketchFeatures\",\"overlaySource\",\"ExtentEventType\",\"ExtentInteractionEvent\",\"ExtentInteraction\",\"pointerHandler_\",\"pixelTolerance_\",\"pixelTolerance\",\"snappedToVertex_\",\"extentFeature_\",\"vertexFeature_\",\"Extent_handleDownEvent\",\"Extent_handleDragEvent\",\"Extent_handleEvent\",\"Extent_handleUpEvent\",\"extentOverlay_\",\"boxStyle\",\"getDefaultExtentStyleFunction\",\"vertexOverlay_\",\"pointerStyle\",\"getDefaultPointerStyleFunction\",\"vertex\",\"snapToVertex_\",\"getOpposingPoint\",\"x_\",\"y_\",\"getPointHandler\",\"getEdgeHandler\",\"pixelCoordinate\",\"createOrUpdatePointerFeature_\",\"fixedPoint\",\"fixedP1\",\"fixedP2\",\"sortByDistance\",\"segments\",\"getSegments\",\"closestSegment\",\"vertexPixel\",\"pixel1\",\"pixel2\",\"squaredDist1\",\"squaredDist2\",\"dist\",\"createOrUpdateExtentFeature_\",\"extentFeature\",\"vertexFeature\",\"ModifyEventType\",\"MODIFYSTART\",\"MODIFYEND\",\"ModifyEvent\",\"mapBrowserPointerEvent\",\"Modify\",\"Modify_handleDownEvent\",\"Modify_handleDragEvent\",\"Modify_handleEvent\",\"Modify_handleUpEvent\",\"defaultDeleteCondition_\",\"altKeyOnly\",\"deleteCondition_\",\"deleteCondition\",\"insertVertexCondition_\",\"insertVertexCondition\",\"vertexSegments_\",\"lastPixel_\",\"ignoreNextSingleClick_\",\"modified_\",\"rBush_\",\"changingFeature_\",\"dragSegments_\",\"Modify_getDefaultStyleFunction\",\"SEGMENT_WRITERS_\",\"writePointGeometry_\",\"writeLineStringGeometry_\",\"writePolygonGeometry_\",\"writeMultiPointGeometry_\",\"writeMultiLineStringGeometry_\",\"writeMultiPolygonGeometry_\",\"writeCircleGeometry_\",\"writeGeometryCollectionGeometry_\",\"handleSourceAdd_\",\"handleSourceRemove_\",\"addFeature_\",\"handleFeatureAdd_\",\"handleFeatureRemove_\",\"lastPointerEvent_\",\"CIRCLE_CENTER_INDEX\",\"CIRCLE_CIRCUMFERENCE_INDEX\",\"compareIndexes\",\"handlePointerAtPixel_\",\"insertVertices\",\"vertexExtent\",\"segmentDataMatches\",\"componentSegments\",\"segmentDataMatch\",\"depth\",\"closestOnSegmentData\",\"willModifyFeatures_\",\"insertVertex_\",\"dragSegment\",\"segmentData\",\"setGeometryCoordinates_\",\"createOrUpdateVertexFeature_\",\"centerSegmentData\",\"featureSegments\",\"circumferenceSegmentData\",\"removePoint\",\"pointDistanceToSegmentDataSquared\",\"pointCoordinates\",\"circleGeometry\",\"distanceToCenterSquared\",\"distanceToCircumference\",\"removeFeature_\",\"removeFeatureSegmentData_\",\"rBush\",\"nodesToRemove\",\"lines\",\"rings\",\"kk\",\"box\",\"nodes\",\"vertexSegments\",\"rTree\",\"updateSegmentIndices_\",\"newSegmentData\",\"newSegmentData2\",\"removeVertex_\",\"dragSegments\",\"segmentsByFeature\",\"component\",\"newIndex\",\"deleted\",\"SelectEventType\",\"SELECT\",\"SelectEvent\",\"selected\",\"deselected\",\"Select\",\"Select_handleEvent\",\"addCondition_\",\"addCondition\",\"removeCondition_\",\"removeCondition\",\"toggleCondition_\",\"toggleCondition\",\"multi_\",\"multi\",\"filter_\",\"hitTolerance_\",\"featureOverlay\",\"Select_getDefaultStyleFunction\",\"featureOverlay_\",\"layerFilter_\",\"featureLayerAssociation_\",\"addFeatureLayerAssociation_\",\"removeFeatureLayerAssociation_\",\"getHitTolerance\",\"getLayer\",\"setHitTolerance\",\"currentMap\",\"selectedFeatures\",\"Snap\",\"Snap_handleEvent\",\"Snap_handleUpEvent\",\"vertex_\",\"edge_\",\"featuresListenerKeys_\",\"featureChangeListenerKeys_\",\"indexedFeaturesExtents_\",\"pendingFeatures_\",\"pixelCoordinate_\",\"sortByDistance_\",\"deltaA\",\"deltaB\",\"snapTo\",\"snapped\",\"featuresToUpdate\",\"updateFeature_\",\"opt_listen\",\"register\",\"feature_uid\",\"segmentWriter\",\"forEachFeatureAdd_\",\"forEachFeatureRemove_\",\"getFeatures_\",\"opt_unlisten\",\"unregister\",\"snappedToVertex\",\"isCircle\",\"closestOnCircle\",\"TranslateEventType\",\"TRANSLATESTART\",\"TRANSLATING\",\"TRANSLATEEND\",\"TranslateEvent\",\"Translate\",\"Translate_handleDownEvent\",\"Translate_handleDragEvent\",\"Translate_handleMoveEvent\",\"Translate_handleUpEvent\",\"lastCoordinate_\",\"lastFeature_\",\"handleActiveChanged_\",\"featuresAtPixel_\",\"newCoordinate\",\"geom\",\"oldMap\",\"ImageBase\",\"getPixelRatio\",\"ol_ImageBase\",\"ImageCanvas\",\"opt_loader\",\"error_\",\"getError\",\"handleLoad_\",\"err\",\"ol_ImageCanvas\",\"RenderEvent\",\"opt_vectorContext\",\"opt_context\",\"opt_glContext\",\"vectorContext\",\"glContext\",\"render_Event\",\"VectorContext\",\"drawCustom\",\"drawGeometry\",\"drawCircle\",\"drawFeature\",\"drawGeometryCollection\",\"geometryCollectionGeometry\",\"drawLineString\",\"lineStringGeometry\",\"drawMultiLineString\",\"multiLineStringGeometry\",\"drawMultiPoint\",\"multiPointGeometry\",\"drawMultiPolygon\",\"multiPolygonGeometry\",\"drawPoint\",\"pointGeometry\",\"drawPolygon\",\"polygonGeometry\",\"drawText\",\"setFillStrokeStyle\",\"setImageStyle\",\"imageStyle\",\"opt_declutterGroup\",\"setTextStyle\",\"textStyle\",\"render_VectorContext\",\"CanvasImmediateRenderer\",\"viewRotation\",\"context_\",\"transform_\",\"viewRotation_\",\"contextFillState_\",\"contextStrokeState_\",\"contextTextState_\",\"fillState_\",\"strokeState_\",\"imageAnchorX_\",\"imageAnchorY_\",\"imageHeight_\",\"imageOpacity_\",\"imageOriginX_\",\"imageOriginY_\",\"imageRotateWithView_\",\"imageRotation_\",\"imageScale_\",\"imageSnapToPixel_\",\"imageWidth_\",\"textOffsetX_\",\"textOffsetY_\",\"textRotateWithView_\",\"textRotation_\",\"textScale_\",\"textFillState_\",\"textStrokeState_\",\"textState_\",\"pixelCoordinates_\",\"tmpLocalTransform_\",\"drawImages_\",\"pixelCoordinates\",\"localTransform\",\"drawText_\",\"setContextFillState_\",\"setContextStrokeState_\",\"setContextTextState_\",\"strokeText\",\"fillText\",\"moveToLineTo_\",\"close\",\"moveTo\",\"drawRings_\",\"simpleGeometry\",\"transformGeom2D\",\"flatMidpoint\",\"geometryExtent\",\"flatMidpoints\",\"flatInteriorPoint\",\"flatInteriorPoints\",\"fillState\",\"contextFillState\",\"strokeState\",\"contextStrokeState\",\"textState\",\"contextTextState\",\"textAlign\",\"textBaseline\",\"fillStyleColor\",\"strokeStyleColor\",\"strokeStyleLineCap\",\"strokeStyleLineDash\",\"strokeStyleLineDashOffset\",\"strokeStyleLineJoin\",\"strokeStyleWidth\",\"strokeStyleMiterLimit\",\"imageAnchor\",\"imageImage\",\"imageOrigin\",\"textFillStyle\",\"textFillStyleColor\",\"textStrokeStyle\",\"textStrokeStyleColor\",\"textStrokeStyleLineCap\",\"textStrokeStyleLineDash\",\"textStrokeStyleLineDashOffset\",\"textStrokeStyleLineJoin\",\"textStrokeStyleWidth\",\"textStrokeStyleMiterLimit\",\"textFont\",\"getFont\",\"textOffsetX\",\"getOffsetX\",\"textOffsetY\",\"getOffsetY\",\"textRotateWithView\",\"textRotation\",\"textScale\",\"textText\",\"textTextAlign\",\"getTextAlign\",\"textTextBaseline\",\"getTextBaseline\",\"Immediate\",\"IconImageCache\",\"cache_\",\"cacheSize_\",\"maxCacheSize_\",\"src\",\"crossOrigin\",\"expire\",\"iconImage\",\"maxCacheSize\",\"shared\",\"MapRenderer\",\"layerRenderers_\",\"layerRendererListeners_\",\"layerRendererConstructors_\",\"expireIconCache\",\"sortByZIndex\",\"state1\",\"state2\",\"registerLayerRenderers\",\"constructors\",\"getLayerRendererConstructors\",\"calculateMatrices2D\",\"det\",\"mat\",\"invert\",\"removeLayerRendererByKey_\",\"viewResolution\",\"translatedCoordinate\",\"projectionExtent\",\"worldWidth\",\"layerRenderer\",\"getLayerRenderer\",\"layerKey\",\"candidate\",\"handleLayerRendererChange_\",\"getLayerRendererByKey\",\"getLayerRenderers\",\"removeUnusedLayerRenderers_\",\"scheduleExpireIconCache\",\"scheduleRemoveUnusedLayerRenderers\",\"Map\",\"layerRendererConstructors\",\"CanvasMapRenderer\",\"insertBefore\",\"childNodes\",\"dispatchComposeEvent_\",\"composeEvent\",\"clearRect\",\"compareFnc\",\"stableSort\",\"save\",\"prepareFrame\",\"composeFrame\",\"restore\",\"numLayers\",\"forEachLayerAtCoordinate\",\"ctor\",\"canvas_Map\",\"LayerRenderer\",\"layer_\",\"createLoadedTileFinder\",\"tiles\",\"tileRange\",\"forEachLoadedTile\",\"tileCoord\",\"handleImageChange_\",\"renderIfReadyAndVisible\",\"loadImage\",\"imageState\",\"scheduleExpireCache\",\"tileSource\",\"postRenderFunction\",\"expireCache\",\"updateUsedTiles\",\"zKey\",\"manageTilePyramid\",\"currentZ\",\"preload\",\"opt_tileCallback\",\"getTileRangeForExtentAndZ\",\"getTile\",\"getTileCoordCenter\",\"useTile\",\"renderer_Layer\",\"CanvasLayerRenderer\",\"renderedResolution\",\"clip\",\"topLeft\",\"topRight\",\"bottomRight\",\"bottomLeft\",\"opt_transform\",\"postCompose\",\"preCompose\",\"dispatchRenderEvent\",\"canvas_Layer\",\"IntermediateCanvasRenderer\",\"coordinateToCanvasPixelTransform\",\"hitCanvasContext_\",\"clipped\",\"imageTransform\",\"getImageTransform\",\"dw\",\"dh\",\"imageData\",\"getImageData\",\"IntermediateCanvas\",\"CanvasImageLayerRenderer\",\"imageLayer\",\"imageTransform_\",\"skippedFeatures_\",\"vectorRenderer_\",\"mapRenderer\",\"viewCenter\",\"imageSource\",\"vectorRenderer\",\"renderedExtent\",\"skippedFeatures\",\"imageFrameState\",\"newSkippedFeatures\",\"replayGroupChanged\",\"imageExtent\",\"imageResolution\",\"imagePixelRatio\",\"ImageLayer\",\"TileRange\",\"TileRange_createOrUpdate\",\"containsTileRange\",\"ol_TileRange\",\"CanvasTileLayerRenderer\",\"tileLayer\",\"oversampling_\",\"renderedExtent_\",\"renderedRevision\",\"renderedTiles\",\"newTiles_\",\"tmpExtent\",\"tmpTileRange_\",\"zDirection\",\"isDrawableTile_\",\"tileState\",\"useInterimTilesOnError\",\"getUseInterimTilesOnError\",\"getPreload\",\"getInterimTile\",\"sourceRevision\",\"getTileGridForProjection\",\"getZForResolution\",\"oversampling\",\"getTileRangeExtent\",\"tilePixelRatio\",\"getTilePixelRatio\",\"tilesToDrawByZ\",\"findLoadedTiles\",\"animatingOrInteracting\",\"tmpTileRange\",\"inTransition\",\"getAlpha\",\"childTileRange\",\"getTileCoordChildTileRange\",\"covered\",\"forEachTileCoordParentTileRange\",\"tilePixelSize\",\"getTilePixelSize\",\"zs\",\"currentScale\",\"currentTilePixelSize\",\"tileExtent\",\"tileGutter\",\"tilesToDraw\",\"getGutter\",\"tileCoordKey\",\"getTileCoordExtent\",\"getTileCoord\",\"drawTileImage\",\"gutter\",\"transition\",\"getOpaque\",\"alphaChanged\",\"endTransition\",\"TileLayer\",\"ReplayGroup\",\"getReplay\",\"replayType\",\"render_ReplayGroup\",\"ReplayType\",\"DEFAULT\",\"IMAGE\",\"drawTextOnPath\",\"measure\",\"startM\",\"maxAngle\",\"reverse\",\"numChars\",\"previousAngle\",\"segmentM\",\"chunk\",\"chunkLength\",\"char\",\"charAt\",\"charLength\",\"charM\",\"segmentPos\",\"unshift\",\"Instruction\",\"BEGIN_GEOMETRY\",\"BEGIN_PATH\",\"CLOSE_PATH\",\"CUSTOM\",\"DRAW_CHARS\",\"DRAW_IMAGE\",\"END_GEOMETRY\",\"FILL\",\"MOVE_TO_LINE_TO\",\"SET_FILL_STYLE\",\"SET_STROKE_STYLE\",\"STROKE\",\"Instruction_fillInstruction\",\"Instruction_strokeInstruction\",\"beginPathInstruction\",\"closePathInstruction\",\"canvas_Instruction\",\"ORDER\",\"TEXT_ALIGN\",\"middle\",\"hanging\",\"alphabetic\",\"ideographic\",\"bottom\",\"CanvasReplay\",\"maxExtent\",\"declutterTree\",\"maxLineWidth\",\"alignFill_\",\"beginGeometryInstruction1_\",\"beginGeometryInstruction2_\",\"bufferedMaxExtent_\",\"instructions\",\"coordinateCache_\",\"renderedTransform_\",\"hitDetectionInstructions\",\"Replay_tmpExtent\",\"Replay_tmpTransform\",\"replayTextBackground_\",\"p1\",\"p2\",\"p3\",\"p4\",\"fillInstruction\",\"strokeInstruction\",\"setStrokeStyle_\",\"replayImage_\",\"declutterGroup\",\"fillStroke\",\"boxW\",\"boxH\",\"boxX\",\"boxY\",\"strokePadding\",\"declutterArgs\",\"applyPixelRatio\",\"dashArray\",\"dash\",\"appendFlatCoordinates\",\"closed\",\"skipFirst\",\"myEnd\",\"getBufferedMaxExtent\",\"lastCoord\",\"nextCoord\",\"lastRel\",\"nextRel\",\"skipped\",\"drawCustomCoordinates_\",\"replayEnds\",\"replayEnd\",\"beginGeometry\",\"replayBegin\",\"replayEndss\",\"myEnds\",\"endGeometry\",\"origin\",\"repeatSize\",\"instruction\",\"renderDeclutter_\",\"groupCount\",\"declutterData\",\"replay_\",\"skippedFeaturesHash\",\"featureCallback\",\"opt_hitExtent\",\"skipFeatures\",\"dd\",\"prevX\",\"prevY\",\"roundX\",\"roundY\",\"pendingFill\",\"pendingStroke\",\"lastFillInstruction\",\"lastStrokeInstruction\",\"coordinateCache\",\"batchSize\",\"fn\",\"backgroundFill\",\"backgroundStroke\",\"baseline\",\"fillKey\",\"strokeKey\",\"textKey\",\"pathLength\",\"textLength\",\"textStates\",\"parts\",\"cc\",\"chars\",\"part\",\"replay\",\"replayHitDetection\",\"opt_featureCallback\",\"reverseHitDetectionInstructions\",\"createFill\",\"applyStroke\",\"createStroke\",\"updateFillStyle\",\"currentFillStyle\",\"updateStrokeStyle\",\"currentStrokeStyle\",\"currentLineCap\",\"currentLineDash\",\"currentLineDashOffset\",\"currentLineJoin\",\"currentLineWidth\",\"currentMiterLimit\",\"endGeometryInstruction\",\"finish\",\"Replay\",\"CanvasImageReplay\",\"declutterGroup_\",\"hitDetectionImage_\",\"anchorX_\",\"anchorY_\",\"height_\",\"originX_\",\"originY_\",\"drawCoordinates_\",\"myBegin\",\"hitDetectionImage\",\"ImageReplay\",\"CanvasLineStringReplay\",\"drawFlatCoordinates_\",\"moveToLineToInstruction\",\"lastStroke\",\"LineStringReplay\",\"CanvasPolygonReplay\",\"drawFlatCoordinatess_\",\"numEnds\",\"setFillStrokeStyles_\",\"circleInstruction\",\"PolygonReplay\",\"matchingChunk\",\"acos\",\"m12\",\"m23\",\"x12\",\"y12\",\"x23\",\"y23\",\"chunkStart\",\"chunkEnd\",\"chunkM\",\"TextPlacement\",\"CanvasTextReplay\",\"labels_\",\"fillStates\",\"strokeStates\",\"textKey_\",\"fillKey_\",\"strokeKey_\",\"widths_\",\"geometryType\",\"placement\",\"flatEnd\",\"flatOffset\",\"oo\",\"range\",\"drawChars_\",\"drawTextImage_\",\"align\",\"numLines\",\"widths\",\"currentWidth\",\"measureTextWidths\",\"lineHeight\",\"renderWidth\",\"leftRight\",\"getOverflow\",\"getMaxAngle\",\"getPlacement\",\"getBackgroundFill\",\"getBackgroundStroke\",\"getPadding\",\"BATCH_CONSTRUCTORS\",\"Default\",\"Image\",\"Text\",\"CanvasReplayGroup\",\"opt_renderBuffer\",\"declutterTree_\",\"tolerance_\",\"maxExtent_\",\"resolution_\",\"replaysByZIndex_\",\"hitDetectionContext_\",\"hitDetectionTransform_\",\"circleArrayCache\",\"0\",\"fillCircleArrayRowToMiddle\",\"addDeclutter\",\"group\",\"flatClipCoords\",\"getClipCoords\",\"hasReplays\",\"replays\",\"candidates\",\"replayKey\",\"declutterReplays\",\"contextSize\",\"hitExtent\",\"mask\",\"arraySize\",\"error\",\"getCircleArray\",\"declutteredFeatures\",\"zIndexKey\",\"getReplays\",\"opt_replayTypes\",\"opt_declutterReplays\",\"replayTypes\",\"canvas_ReplayGroup\",\"SIMPLIFY_TOLERANCE\",\"GEOMETRY_RENDERERS\",\"replayGroup\",\"imageReplay\",\"textReplay\",\"lineStringReplay\",\"polygonReplay\",\"geometryRenderer\",\"circleReplay\",\"defaultOrder\",\"feature1\",\"feature2\",\"getSquaredTolerance\",\"getTolerance\",\"renderFeature\",\"loading\",\"renderGeometry\",\"renderFeatureInternal\",\"CanvasVectorLayerRenderer\",\"vectorLayer\",\"dirty_\",\"renderedRevision_\",\"renderedResolution_\",\"renderedRenderOrder_\",\"replayGroup_\",\"handleFontsChanged_\",\"vectorSource\",\"clipExtent\",\"replayContext\",\"drawOffsetX\",\"drawOffsetY\",\"transparentLayer\",\"hasRenderListeners\",\"drawWidth\",\"drawHeight\",\"drawSize\",\"world\",\"mainContextAlpha\",\"handleStyleImageChange_\",\"animating\",\"interacting\",\"frameStateExtent\",\"vectorLayerRevision\",\"vectorLayerRenderBuffer\",\"vectorLayerRenderOrder\",\"dirty\",\"canvas_VectorLayer\",\"VectorTileRenderType\",\"IMAGE_REPLAYS\",\"hybrid\",\"VECTOR_REPLAYS\",\"vector\",\"CanvasVectorTileLayerRenderer\",\"renderedLayerRevision_\",\"tmpTransform_\",\"createReplayGroup_\",\"renderTileImage_\",\"layerRevision\",\"revision\",\"replayState\",\"getReplayState\",\"renderedRenderOrder\",\"sourceTileGrid\",\"getTileGrid\",\"zIndexKeys\",\"tt\",\"tileKeys\",\"sourceTile\",\"sourceTileCoord\",\"sourceTileExtent\",\"sharedExtent\",\"bufferedExtent\",\"tileProjection\",\"reproject\",\"setProjection\",\"setReplayGroup\",\"getReplayGroup\",\"getReplayTransform_\",\"renderResolution\",\"clips\",\"worldOffset\",\"currentClip\",\"zz\",\"replayData\",\"replayDeclutter\",\"renderedTileRevision\",\"wrappedTileCoord\",\"pixelScale\",\"VectorTileLayer\",\"Map_Map\",\"zoomOptions\",\"rotateOptions\",\"attribution\",\"attributionOptions\",\"defaults\",\"altShiftDragRotate\",\"doubleClickZoom\",\"zoomDelta\",\"zoomDuration\",\"dragPan\",\"pinchRotate\",\"pinchZoom\",\"keyboard\",\"mouseWheelZoom\",\"shiftDragZoom\",\"interaction_defaults\",\"ol_Map\",\"TileProperty\",\"Tile_TileLayer\",\"setPreload\",\"setUseInterimTilesOnError\",\"Tile\",\"Tile_Tile\",\"interimTile\",\"transition_\",\"transitionStarts_\",\"refreshInterimChain\",\"ol_Tile\",\"ImageTile\",\"tileLoadFunction\",\"crossOrigin_\",\"src_\",\"imageListenerKeys_\",\"tileLoadFunction_\",\"getBlankImage\",\"ctx\",\"fillRect\",\"unlistenImage_\",\"handleImageError_\",\"handleImageLoad_\",\"naturalWidth\",\"naturalHeight\",\"ol_ImageTile\",\"tilecoord_createOrUpdate\",\"opt_tileCoord\",\"getKeyZXY\",\"tilecoord_getKey\",\"TileCache\",\"pruneExceptNewestZ\",\"fromKey\",\"ol_TileCache\",\"enlargeClipPoint\",\"centroidX\",\"centroidY\",\"dX\",\"dY\",\"reproj_render\",\"sourceExtent\",\"targetExtent\",\"triangulation\",\"sources\",\"opt_renderEdges\",\"sourceDataExtent\",\"canvasWidthInUnits\",\"canvasHeightInUnits\",\"stitchContext\",\"stitchScale\",\"xPos\",\"yPos\",\"srcWidth\",\"srcHeight\",\"targetTopLeft\",\"getTriangles\",\"triangle\",\"u0\",\"v0\",\"u1\",\"v1\",\"u2\",\"v2\",\"sourceNumericalShiftX\",\"sourceNumericalShiftY\",\"affineCoefs\",\"maxRow\",\"maxEl\",\"absValue\",\"coef\",\"solveLinearSystem\",\"p0\",\"Triangulation\",\"sourceProj\",\"targetProj\",\"maxSourceExtent\",\"errorThreshold\",\"sourceProj_\",\"targetProj_\",\"transformInvCache\",\"transformInv\",\"transformInv_\",\"maxSourceExtent_\",\"errorThresholdSquared_\",\"triangles_\",\"wrapsXInSource_\",\"canWrapXInSource_\",\"sourceWorldWidth_\",\"targetWorldWidth_\",\"destinationTopLeft\",\"destinationTopRight\",\"destinationBottomRight\",\"destinationBottomLeft\",\"sourceTopLeft\",\"sourceTopRight\",\"sourceBottomRight\",\"sourceBottomLeft\",\"addQuad_\",\"leftBound\",\"newTriangle\",\"addTriangle_\",\"aSrc\",\"bSrc\",\"cSrc\",\"dSrc\",\"maxSubdivision\",\"sourceQuadExtent\",\"sourceCoverageX\",\"sourceWorldWidth\",\"wrapsX\",\"needsSubdivision\",\"isFinite\",\"centerSrc\",\"bc\",\"bcSrc\",\"da\",\"daSrc\",\"ab\",\"abSrc\",\"cd\",\"cdSrc\",\"calculateSourceExtent\",\"reproj_Triangulation\",\"ReprojTile\",\"targetTileGrid\",\"getTileFunction\",\"opt_errorThreshold\",\"renderEdges_\",\"gutter_\",\"sourceTileGrid_\",\"targetTileGrid_\",\"wrappedTileCoord_\",\"sourceTiles_\",\"sourcesListenerKeys_\",\"sourceZ_\",\"maxTargetExtent\",\"limitedTargetExtent\",\"sourceProjExtent\",\"targetMetersPerUnit\",\"sourceMetersPerUnit\",\"compensationFactor\",\"calculateSourceResolution\",\"errorThresholdInPixels\",\"triangulation_\",\"sourceRange\",\"srcX\",\"srcY\",\"unlistenSources_\",\"reproject_\",\"getTileSize\",\"leftToLoad\",\"sourceListenKey\",\"reproj_Tile\",\"createFromTemplate\",\"template\",\"zRegEx\",\"xRegEx\",\"yRegEx\",\"dashYRegEx\",\"getFullTileRange\",\"createFromTemplates\",\"templates\",\"tileUrlFunctions\",\"hash\",\"createFromTileUrlFunctions\",\"nullTileUrlFunction\",\"TileGrid\",\"opt_func\",\"opt_strict\",\"every\",\"currentVal\",\"res\",\"isSorted\",\"origins\",\"origins_\",\"tileSizes_\",\"tileSizes\",\"tileSize_\",\"tileSize\",\"fullTileRanges_\",\"tmpSize_\",\"sizes\",\"calculateTileRanges_\",\"tmpTileCoord\",\"forEachTileCoord\",\"opt_tileRange\",\"tileCoordExtent\",\"getTileCoordForXYAndZ_\",\"getTileCoordForCoordAndResolution\",\"getTileCoordForXYAndResolution_\",\"reverseIntersectionPolicy\",\"adjustX\",\"adjustY\",\"xFromOrigin\",\"yFromOrigin\",\"tileCoordX\",\"tileCoordY\",\"getTileCoordForCoordAndZ\",\"getTileCoordResolution\",\"fullTileRanges\",\"tilegrid_TileGrid\",\"getForProjection\",\"opt_maxZoom\",\"opt_tileSize\",\"opt_corner\",\"corner\",\"resolutionsFromExtent\",\"getCorner\",\"createForExtent\",\"extentFromProjection\",\"createForProjection\",\"half\",\"TileSource\",\"opaque_\",\"opaque\",\"tilePixelRatio_\",\"tileCache\",\"tmpSize\",\"tileOptions\",\"getTileCacheForProjection\",\"loaded\",\"setKey\",\"thisProj\",\"ratio\",\"getTileCoordForTileUrlFunction\",\"worldsAway\",\"withinExtentAndZ\",\"TileSourceEvent\",\"source_Tile\",\"TileEventType\",\"UrlTile\",\"tileUrlFunction\",\"fixedTileUrlFunction\",\"urls\",\"setUrls\",\"setUrl\",\"setTileUrlFunction\",\"tileLoadingKeys_\",\"getTileLoadFunction\",\"getTileUrlFunction\",\"getUrls\",\"setTileLoadFunction\",\"opt_key\",\"match\",\"startCharCode\",\"stopCharCode\",\"String\",\"fromCharCode\",\"stop\",\"expandUrl\",\"source_UrlTile\",\"TileImage\",\"defaultTileLoadFunction\",\"tileClass\",\"tileCacheForProjection\",\"tileGridForProjection\",\"reprojectionErrorThreshold_\",\"reprojectionErrorThreshold\",\"renderReprojectionEdges_\",\"imageTile\",\"usedTileCache\",\"getGutterInternal\",\"projKey\",\"createTile_\",\"urlTileCoord\",\"tileUrl\",\"newTile\",\"getTileInternal\",\"setRenderReprojectionEdges\",\"setTileGridForProjection\",\"tilegrid\",\"proj\",\"source_TileImage\",\"createXYZ\",\"source_XYZ\",\"OSM\",\"source_OSM\",\"Atlas\",\"space\",\"space_\",\"emptyBlocks_\",\"renderCallback\",\"block\",\"split_\",\"newBlock1\",\"newBlock2\",\"updateBlocks_\",\"args\",\"style_Atlas\",\"AtlasManager\",\"currentSize_\",\"initialSize\",\"maxSize_\",\"maxSize\",\"atlases_\",\"currentHitSize_\",\"hitAtlases_\",\"getInfo\",\"getInfo_\",\"hitInfo\",\"mergeInfos_\",\"atlases\",\"opt_renderHitCallback\",\"add_\",\"renderHitCallback\",\"isHitAtlas\",\"atlas\",\"IconAnchorUnits\",\"IconImage\",\"imageState_\",\"tainting_\",\"determineTainting_\",\"dispatchChangeEvent_\",\"replaceColor_\",\"getSrc\",\"imgData\",\"putImageData\",\"IconOrigin\",\"Icon\",\"normalizedAnchor_\",\"anchorOrigin_\",\"anchorOrigin\",\"anchorXUnits_\",\"anchorXUnits\",\"anchorYUnits_\",\"anchorYUnits\",\"img\",\"imgSize\",\"iconImage_\",\"IconImage_get\",\"offset_\",\"offsetOrigin_\",\"offsetOrigin\",\"iconImageSize\",\"font_\",\"textAlign_\",\"textBaseline_\",\"maxAngle_\",\"placement_\",\"overflow_\",\"offsetX_\",\"offsetY_\",\"backgroundFill_\",\"backgroundStroke_\",\"padding_\",\"setOverflow\",\"setFont\",\"setMaxAngle\",\"setOffsetX\",\"setOffsetY\",\"setPlacement\",\"setTextAlign\",\"setTextBaseline\",\"setBackgroundFill\",\"setBackgroundStroke\",\"setPadding\",\"OverlayPositioning\",\"Overlay_Property\",\"Overlay\",\"insertFirst\",\"autoPan\",\"autoPanAnimation\",\"autoPanMargin\",\"rendered\",\"bottom_\",\"left_\",\"right_\",\"top_\",\"mapPostrenderListenerKey\",\"handleElementChanged\",\"handleMapChanged\",\"handleOffsetChanged\",\"handlePositionChanged\",\"handlePositioningChanged\",\"setElement\",\"setOffset\",\"setPositioning\",\"positioning\",\"setPosition\",\"getElement\",\"getOffset\",\"getPosition\",\"getPositioning\",\"updatePixelPosition\",\"panIntoView\",\"mapRect\",\"getRect\",\"overlayRect\",\"marginLeft\",\"marginRight\",\"dom_outerWidth\",\"marginTop\",\"marginBottom\",\"dom_outerHeight\",\"offsetLeft\",\"offsetRight\",\"offsetTop\",\"offsetBottom\",\"centerPx\",\"newCenterPx\",\"pageXOffset\",\"pageYOffset\",\"mapSize\",\"updateRenderedPosition\",\"getOptions\",\"ol_Overlay\",\"txStateWebMercator\",\"buildingLayer\",\"baseLayer\",\"main_map\",\"markup\",\"bldg_name\",\"swap\",\"defaultCompare\",\"quickselectStep\",\"sd\",\"newLeft\",\"newRight\",\"factory\",\"css\",\"location\",\"baseUrl\",\"protocol\",\"host\",\"currentDir\",\"pathname\",\"fullMatch\",\"origUrl\",\"newUrl\",\"unquotedOrigUrl\",\"trim\",\"$1\",\"test\",\"memo\",\"stylesInDom\",\"isOldIE\",\"atob\",\"styleTarget\",\"HTMLIFrameElement\",\"contentDocument\",\"head\",\"singleton\",\"singletonCounter\",\"stylesInsertedAtTop\",\"fixUrls\",\"addStylesToDom\",\"domStyle\",\"refs\",\"addStyle\",\"listToStyles\",\"list\",\"newStyles\",\"base\",\"media\",\"sourceMap\",\"insertStyleElement\",\"insertInto\",\"lastStyleElementInsertedAtTop\",\"nextSibling\",\"firstChild\",\"before\",\"removeStyleElement\",\"idx\",\"createStyleElement\",\"attrs\",\"addAttrs\",\"styleIndex\",\"applyToSingletonTag\",\"URL\",\"createObjectURL\",\"revokeObjectURL\",\"Blob\",\"btoa\",\"link\",\"rel\",\"createLinkElement\",\"autoFixUrls\",\"convertToAbsoluteUrls\",\"unescape\",\"encodeURIComponent\",\"blob\",\"oldSrc\",\"href\",\"styleSheet\",\"cssText\",\"newObj\",\"DEBUG\",\"newList\",\"mayRemove\",\"textStore\",\"replaceText\",\"replacement\",\"cssNode\",\"useSourceMap\",\"content\",\"cssMapping\",\"sourceMapping\",\"sourceURLs\",\"sourceRoot\",\"cssWithMappingToString\",\"mediaQuery\",\"alreadyImportedModules\",\"hmr\",\"locals\"],\"mappings\":\"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\",\"sourcesContent\":[\" \\t// The module cache\\n \\tvar installedModules = {};\\n\\n \\t// The require function\\n \\tfunction __webpack_require__(moduleId) {\\n\\n \\t\\t// Check if module is in cache\\n \\t\\tif(installedModules[moduleId]) {\\n \\t\\t\\treturn installedModules[moduleId].exports;\\n \\t\\t}\\n \\t\\t// Create a new module (and put it into the cache)\\n \\t\\tvar module = installedModules[moduleId] = {\\n \\t\\t\\ti: moduleId,\\n \\t\\t\\tl: false,\\n \\t\\t\\texports: {}\\n \\t\\t};\\n\\n \\t\\t// Execute the module function\\n \\t\\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\\n\\n \\t\\t// Flag the module as loaded\\n \\t\\tmodule.l = true;\\n\\n \\t\\t// Return the exports of the module\\n \\t\\treturn module.exports;\\n \\t}\\n\\n\\n \\t// expose the modules object (__webpack_modules__)\\n \\t__webpack_require__.m = modules;\\n\\n \\t// expose the module cache\\n \\t__webpack_require__.c = installedModules;\\n\\n \\t// define getter function for harmony exports\\n \\t__webpack_require__.d = function(exports, name, getter) {\\n \\t\\tif(!__webpack_require__.o(exports, name)) {\\n \\t\\t\\tObject.defineProperty(exports, name, {\\n \\t\\t\\t\\tconfigurable: false,\\n \\t\\t\\t\\tenumerable: true,\\n \\t\\t\\t\\tget: getter\\n \\t\\t\\t});\\n \\t\\t}\\n \\t};\\n\\n \\t// define __esModule on exports\\n \\t__webpack_require__.r = function(exports) {\\n \\t\\tObject.defineProperty(exports, '__esModule', { value: true });\\n \\t};\\n\\n \\t// getDefaultExport function for compatibility with non-harmony modules\\n \\t__webpack_require__.n = function(module) {\\n \\t\\tvar getter = module && module.__esModule ?\\n \\t\\t\\tfunction getDefault() { return module['default']; } :\\n \\t\\t\\tfunction getModuleExports() { return module; };\\n \\t\\t__webpack_require__.d(getter, 'a', getter);\\n \\t\\treturn getter;\\n \\t};\\n\\n \\t// Object.prototype.hasOwnProperty.call\\n \\t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\\n\\n \\t// __webpack_public_path__\\n \\t__webpack_require__.p = \\\"\\\";\\n\\n\\n \\t// Load entry module and return exports\\n \\treturn __webpack_require__(__webpack_require__.s = 1);\\n\",\"'use strict';\\n\\nmodule.exports = rbush;\\nmodule.exports.default = rbush;\\n\\nvar quickselect = require('quickselect');\\n\\nfunction rbush(maxEntries, format) {\\n    if (!(this instanceof rbush)) return new rbush(maxEntries, format);\\n\\n    // max entries in a node is 9 by default; min node fill is 40% for best performance\\n    this._maxEntries = Math.max(4, maxEntries || 9);\\n    this._minEntries = Math.max(2, Math.ceil(this._maxEntries * 0.4));\\n\\n    if (format) {\\n        this._initFormat(format);\\n    }\\n\\n    this.clear();\\n}\\n\\nrbush.prototype = {\\n\\n    all: function () {\\n        return this._all(this.data, []);\\n    },\\n\\n    search: function (bbox) {\\n\\n        var node = this.data,\\n            result = [],\\n            toBBox = this.toBBox;\\n\\n        if (!intersects(bbox, node)) return result;\\n\\n        var nodesToSearch = [],\\n            i, len, child, childBBox;\\n\\n        while (node) {\\n            for (i = 0, len = node.children.length; i < len; i++) {\\n\\n                child = node.children[i];\\n                childBBox = node.leaf ? toBBox(child) : child;\\n\\n                if (intersects(bbox, childBBox)) {\\n                    if (node.leaf) result.push(child);\\n                    else if (contains(bbox, childBBox)) this._all(child, result);\\n                    else nodesToSearch.push(child);\\n                }\\n            }\\n            node = nodesToSearch.pop();\\n        }\\n\\n        return result;\\n    },\\n\\n    collides: function (bbox) {\\n\\n        var node = this.data,\\n            toBBox = this.toBBox;\\n\\n        if (!intersects(bbox, node)) return false;\\n\\n        var nodesToSearch = [],\\n            i, len, child, childBBox;\\n\\n        while (node) {\\n            for (i = 0, len = node.children.length; i < len; i++) {\\n\\n                child = node.children[i];\\n                childBBox = node.leaf ? toBBox(child) : child;\\n\\n                if (intersects(bbox, childBBox)) {\\n                    if (node.leaf || contains(bbox, childBBox)) return true;\\n                    nodesToSearch.push(child);\\n                }\\n            }\\n            node = nodesToSearch.pop();\\n        }\\n\\n        return false;\\n    },\\n\\n    load: function (data) {\\n        if (!(data && data.length)) return this;\\n\\n        if (data.length < this._minEntries) {\\n            for (var i = 0, len = data.length; i < len; i++) {\\n                this.insert(data[i]);\\n            }\\n            return this;\\n        }\\n\\n        // recursively build the tree with the given data from scratch using OMT algorithm\\n        var node = this._build(data.slice(), 0, data.length - 1, 0);\\n\\n        if (!this.data.children.length) {\\n            // save as is if tree is empty\\n            this.data = node;\\n\\n        } else if (this.data.height === node.height) {\\n            // split root if trees have the same height\\n            this._splitRoot(this.data, node);\\n\\n        } else {\\n            if (this.data.height < node.height) {\\n                // swap trees if inserted one is bigger\\n                var tmpNode = this.data;\\n                this.data = node;\\n                node = tmpNode;\\n            }\\n\\n            // insert the small tree into the large tree at appropriate level\\n            this._insert(node, this.data.height - node.height - 1, true);\\n        }\\n\\n        return this;\\n    },\\n\\n    insert: function (item) {\\n        if (item) this._insert(item, this.data.height - 1);\\n        return this;\\n    },\\n\\n    clear: function () {\\n        this.data = createNode([]);\\n        return this;\\n    },\\n\\n    remove: function (item, equalsFn) {\\n        if (!item) return this;\\n\\n        var node = this.data,\\n            bbox = this.toBBox(item),\\n            path = [],\\n            indexes = [],\\n            i, parent, index, goingUp;\\n\\n        // depth-first iterative tree traversal\\n        while (node || path.length) {\\n\\n            if (!node) { // go up\\n                node = path.pop();\\n                parent = path[path.length - 1];\\n                i = indexes.pop();\\n                goingUp = true;\\n            }\\n\\n            if (node.leaf) { // check current node\\n                index = findItem(item, node.children, equalsFn);\\n\\n                if (index !== -1) {\\n                    // item found, remove the item and condense tree upwards\\n                    node.children.splice(index, 1);\\n                    path.push(node);\\n                    this._condense(path);\\n                    return this;\\n                }\\n            }\\n\\n            if (!goingUp && !node.leaf && contains(node, bbox)) { // go down\\n                path.push(node);\\n                indexes.push(i);\\n                i = 0;\\n                parent = node;\\n                node = node.children[0];\\n\\n            } else if (parent) { // go right\\n                i++;\\n                node = parent.children[i];\\n                goingUp = false;\\n\\n            } else node = null; // nothing found\\n        }\\n\\n        return this;\\n    },\\n\\n    toBBox: function (item) { return item; },\\n\\n    compareMinX: compareNodeMinX,\\n    compareMinY: compareNodeMinY,\\n\\n    toJSON: function () { return this.data; },\\n\\n    fromJSON: function (data) {\\n        this.data = data;\\n        return this;\\n    },\\n\\n    _all: function (node, result) {\\n        var nodesToSearch = [];\\n        while (node) {\\n            if (node.leaf) result.push.apply(result, node.children);\\n            else nodesToSearch.push.apply(nodesToSearch, node.children);\\n\\n            node = nodesToSearch.pop();\\n        }\\n        return result;\\n    },\\n\\n    _build: function (items, left, right, height) {\\n\\n        var N = right - left + 1,\\n            M = this._maxEntries,\\n            node;\\n\\n        if (N <= M) {\\n            // reached leaf level; return leaf\\n            node = createNode(items.slice(left, right + 1));\\n            calcBBox(node, this.toBBox);\\n            return node;\\n        }\\n\\n        if (!height) {\\n            // target height of the bulk-loaded tree\\n            height = Math.ceil(Math.log(N) / Math.log(M));\\n\\n            // target number of root entries to maximize storage utilization\\n            M = Math.ceil(N / Math.pow(M, height - 1));\\n        }\\n\\n        node = createNode([]);\\n        node.leaf = false;\\n        node.height = height;\\n\\n        // split the items into M mostly square tiles\\n\\n        var N2 = Math.ceil(N / M),\\n            N1 = N2 * Math.ceil(Math.sqrt(M)),\\n            i, j, right2, right3;\\n\\n        multiSelect(items, left, right, N1, this.compareMinX);\\n\\n        for (i = left; i <= right; i += N1) {\\n\\n            right2 = Math.min(i + N1 - 1, right);\\n\\n            multiSelect(items, i, right2, N2, this.compareMinY);\\n\\n            for (j = i; j <= right2; j += N2) {\\n\\n                right3 = Math.min(j + N2 - 1, right2);\\n\\n                // pack each entry recursively\\n                node.children.push(this._build(items, j, right3, height - 1));\\n            }\\n        }\\n\\n        calcBBox(node, this.toBBox);\\n\\n        return node;\\n    },\\n\\n    _chooseSubtree: function (bbox, node, level, path) {\\n\\n        var i, len, child, targetNode, area, enlargement, minArea, minEnlargement;\\n\\n        while (true) {\\n            path.push(node);\\n\\n            if (node.leaf || path.length - 1 === level) break;\\n\\n            minArea = minEnlargement = Infinity;\\n\\n            for (i = 0, len = node.children.length; i < len; i++) {\\n                child = node.children[i];\\n                area = bboxArea(child);\\n                enlargement = enlargedArea(bbox, child) - area;\\n\\n                // choose entry with the least area enlargement\\n                if (enlargement < minEnlargement) {\\n                    minEnlargement = enlargement;\\n                    minArea = area < minArea ? area : minArea;\\n                    targetNode = child;\\n\\n                } else if (enlargement === minEnlargement) {\\n                    // otherwise choose one with the smallest area\\n                    if (area < minArea) {\\n                        minArea = area;\\n                        targetNode = child;\\n                    }\\n                }\\n            }\\n\\n            node = targetNode || node.children[0];\\n        }\\n\\n        return node;\\n    },\\n\\n    _insert: function (item, level, isNode) {\\n\\n        var toBBox = this.toBBox,\\n            bbox = isNode ? item : toBBox(item),\\n            insertPath = [];\\n\\n        // find the best node for accommodating the item, saving all nodes along the path too\\n        var node = this._chooseSubtree(bbox, this.data, level, insertPath);\\n\\n        // put the item into the node\\n        node.children.push(item);\\n        extend(node, bbox);\\n\\n        // split on node overflow; propagate upwards if necessary\\n        while (level >= 0) {\\n            if (insertPath[level].children.length > this._maxEntries) {\\n                this._split(insertPath, level);\\n                level--;\\n            } else break;\\n        }\\n\\n        // adjust bboxes along the insertion path\\n        this._adjustParentBBoxes(bbox, insertPath, level);\\n    },\\n\\n    // split overflowed node into two\\n    _split: function (insertPath, level) {\\n\\n        var node = insertPath[level],\\n            M = node.children.length,\\n            m = this._minEntries;\\n\\n        this._chooseSplitAxis(node, m, M);\\n\\n        var splitIndex = this._chooseSplitIndex(node, m, M);\\n\\n        var newNode = createNode(node.children.splice(splitIndex, node.children.length - splitIndex));\\n        newNode.height = node.height;\\n        newNode.leaf = node.leaf;\\n\\n        calcBBox(node, this.toBBox);\\n        calcBBox(newNode, this.toBBox);\\n\\n        if (level) insertPath[level - 1].children.push(newNode);\\n        else this._splitRoot(node, newNode);\\n    },\\n\\n    _splitRoot: function (node, newNode) {\\n        // split root node\\n        this.data = createNode([node, newNode]);\\n        this.data.height = node.height + 1;\\n        this.data.leaf = false;\\n        calcBBox(this.data, this.toBBox);\\n    },\\n\\n    _chooseSplitIndex: function (node, m, M) {\\n\\n        var i, bbox1, bbox2, overlap, area, minOverlap, minArea, index;\\n\\n        minOverlap = minArea = Infinity;\\n\\n        for (i = m; i <= M - m; i++) {\\n            bbox1 = distBBox(node, 0, i, this.toBBox);\\n            bbox2 = distBBox(node, i, M, this.toBBox);\\n\\n            overlap = intersectionArea(bbox1, bbox2);\\n            area = bboxArea(bbox1) + bboxArea(bbox2);\\n\\n            // choose distribution with minimum overlap\\n            if (overlap < minOverlap) {\\n                minOverlap = overlap;\\n                index = i;\\n\\n                minArea = area < minArea ? area : minArea;\\n\\n            } else if (overlap === minOverlap) {\\n                // otherwise choose distribution with minimum area\\n                if (area < minArea) {\\n                    minArea = area;\\n                    index = i;\\n                }\\n            }\\n        }\\n\\n        return index;\\n    },\\n\\n    // sorts node children by the best axis for split\\n    _chooseSplitAxis: function (node, m, M) {\\n\\n        var compareMinX = node.leaf ? this.compareMinX : compareNodeMinX,\\n            compareMinY = node.leaf ? this.compareMinY : compareNodeMinY,\\n            xMargin = this._allDistMargin(node, m, M, compareMinX),\\n            yMargin = this._allDistMargin(node, m, M, compareMinY);\\n\\n        // if total distributions margin value is minimal for x, sort by minX,\\n        // otherwise it's already sorted by minY\\n        if (xMargin < yMargin) node.children.sort(compareMinX);\\n    },\\n\\n    // total margin of all possible split distributions where each node is at least m full\\n    _allDistMargin: function (node, m, M, compare) {\\n\\n        node.children.sort(compare);\\n\\n        var toBBox = this.toBBox,\\n            leftBBox = distBBox(node, 0, m, toBBox),\\n            rightBBox = distBBox(node, M - m, M, toBBox),\\n            margin = bboxMargin(leftBBox) + bboxMargin(rightBBox),\\n            i, child;\\n\\n        for (i = m; i < M - m; i++) {\\n            child = node.children[i];\\n            extend(leftBBox, node.leaf ? toBBox(child) : child);\\n            margin += bboxMargin(leftBBox);\\n        }\\n\\n        for (i = M - m - 1; i >= m; i--) {\\n            child = node.children[i];\\n            extend(rightBBox, node.leaf ? toBBox(child) : child);\\n            margin += bboxMargin(rightBBox);\\n        }\\n\\n        return margin;\\n    },\\n\\n    _adjustParentBBoxes: function (bbox, path, level) {\\n        // adjust bboxes along the given tree path\\n        for (var i = level; i >= 0; i--) {\\n            extend(path[i], bbox);\\n        }\\n    },\\n\\n    _condense: function (path) {\\n        // go through the path, removing empty nodes and updating bboxes\\n        for (var i = path.length - 1, siblings; i >= 0; i--) {\\n            if (path[i].children.length === 0) {\\n                if (i > 0) {\\n                    siblings = path[i - 1].children;\\n                    siblings.splice(siblings.indexOf(path[i]), 1);\\n\\n                } else this.clear();\\n\\n            } else calcBBox(path[i], this.toBBox);\\n        }\\n    },\\n\\n    _initFormat: function (format) {\\n        // data format (minX, minY, maxX, maxY accessors)\\n\\n        // uses eval-type function compilation instead of just accepting a toBBox function\\n        // because the algorithms are very sensitive to sorting functions performance,\\n        // so they should be dead simple and without inner calls\\n\\n        var compareArr = ['return a', ' - b', ';'];\\n\\n        this.compareMinX = new Function('a', 'b', compareArr.join(format[0]));\\n        this.compareMinY = new Function('a', 'b', compareArr.join(format[1]));\\n\\n        this.toBBox = new Function('a',\\n            'return {minX: a' + format[0] +\\n            ', minY: a' + format[1] +\\n            ', maxX: a' + format[2] +\\n            ', maxY: a' + format[3] + '};');\\n    }\\n};\\n\\nfunction findItem(item, items, equalsFn) {\\n    if (!equalsFn) return items.indexOf(item);\\n\\n    for (var i = 0; i < items.length; i++) {\\n        if (equalsFn(item, items[i])) return i;\\n    }\\n    return -1;\\n}\\n\\n// calculate node's bbox from bboxes of its children\\nfunction calcBBox(node, toBBox) {\\n    distBBox(node, 0, node.children.length, toBBox, node);\\n}\\n\\n// min bounding rectangle of node children from k to p-1\\nfunction distBBox(node, k, p, toBBox, destNode) {\\n    if (!destNode) destNode = createNode(null);\\n    destNode.minX = Infinity;\\n    destNode.minY = Infinity;\\n    destNode.maxX = -Infinity;\\n    destNode.maxY = -Infinity;\\n\\n    for (var i = k, child; i < p; i++) {\\n        child = node.children[i];\\n        extend(destNode, node.leaf ? toBBox(child) : child);\\n    }\\n\\n    return destNode;\\n}\\n\\nfunction extend(a, b) {\\n    a.minX = Math.min(a.minX, b.minX);\\n    a.minY = Math.min(a.minY, b.minY);\\n    a.maxX = Math.max(a.maxX, b.maxX);\\n    a.maxY = Math.max(a.maxY, b.maxY);\\n    return a;\\n}\\n\\nfunction compareNodeMinX(a, b) { return a.minX - b.minX; }\\nfunction compareNodeMinY(a, b) { return a.minY - b.minY; }\\n\\nfunction bboxArea(a)   { return (a.maxX - a.minX) * (a.maxY - a.minY); }\\nfunction bboxMargin(a) { return (a.maxX - a.minX) + (a.maxY - a.minY); }\\n\\nfunction enlargedArea(a, b) {\\n    return (Math.max(b.maxX, a.maxX) - Math.min(b.minX, a.minX)) *\\n           (Math.max(b.maxY, a.maxY) - Math.min(b.minY, a.minY));\\n}\\n\\nfunction intersectionArea(a, b) {\\n    var minX = Math.max(a.minX, b.minX),\\n        minY = Math.max(a.minY, b.minY),\\n        maxX = Math.min(a.maxX, b.maxX),\\n        maxY = Math.min(a.maxY, b.maxY);\\n\\n    return Math.max(0, maxX - minX) *\\n           Math.max(0, maxY - minY);\\n}\\n\\nfunction contains(a, b) {\\n    return a.minX <= b.minX &&\\n           a.minY <= b.minY &&\\n           b.maxX <= a.maxX &&\\n           b.maxY <= a.maxY;\\n}\\n\\nfunction intersects(a, b) {\\n    return b.minX <= a.maxX &&\\n           b.minY <= a.maxY &&\\n           b.maxX >= a.minX &&\\n           b.maxY >= a.minY;\\n}\\n\\nfunction createNode(children) {\\n    return {\\n        children: children,\\n        height: 1,\\n        leaf: true,\\n        minX: Infinity,\\n        minY: Infinity,\\n        maxX: -Infinity,\\n        maxY: -Infinity\\n    };\\n}\\n\\n// sort an array so that items come in groups of n unsorted items, with groups sorted between each other;\\n// combines selection algorithm with binary divide & conquer approach\\n\\nfunction multiSelect(arr, left, right, n, compare) {\\n    var stack = [left, right],\\n        mid;\\n\\n    while (stack.length) {\\n        right = stack.pop();\\n        left = stack.pop();\\n\\n        if (right - left <= n) continue;\\n\\n        mid = left + Math.ceil((right - left) / n / 2) * n;\\n        quickselect(arr, mid, left, right, compare);\\n\\n        stack.push(left, mid, mid, right);\\n    }\\n}\\n\",\"/**\\n * @module ol/webgl\\n */\\n\\n/**\\n * Constants taken from goog.webgl\\n */\\n\\n\\n/**\\n * @const\\n * @type {number}\\n */\\nexport const ONE = 1;\\n\\n\\n/**\\n * @const\\n * @type {number}\\n */\\nexport const SRC_ALPHA = 0x0302;\\n\\n\\n/**\\n * @const\\n * @type {number}\\n */\\nexport const COLOR_ATTACHMENT0 = 0x8CE0;\\n\\n\\n/**\\n * @const\\n * @type {number}\\n */\\nexport const COLOR_BUFFER_BIT = 0x00004000;\\n\\n\\n/**\\n * @const\\n * @type {number}\\n */\\nexport const TRIANGLES = 0x0004;\\n\\n\\n/**\\n * @const\\n * @type {number}\\n */\\nexport const TRIANGLE_STRIP = 0x0005;\\n\\n\\n/**\\n * @const\\n * @type {number}\\n */\\nexport const ONE_MINUS_SRC_ALPHA = 0x0303;\\n\\n\\n/**\\n * @const\\n * @type {number}\\n */\\nexport const ARRAY_BUFFER = 0x8892;\\n\\n\\n/**\\n * @const\\n * @type {number}\\n */\\nexport const ELEMENT_ARRAY_BUFFER = 0x8893;\\n\\n\\n/**\\n * @const\\n * @type {number}\\n */\\nexport const STREAM_DRAW = 0x88E0;\\n\\n\\n/**\\n * @const\\n * @type {number}\\n */\\nexport const STATIC_DRAW = 0x88E4;\\n\\n\\n/**\\n * @const\\n * @type {number}\\n */\\nexport const DYNAMIC_DRAW = 0x88E8;\\n\\n\\n/**\\n * @const\\n * @type {number}\\n */\\nexport const CULL_FACE = 0x0B44;\\n\\n\\n/**\\n * @const\\n * @type {number}\\n */\\nexport const BLEND = 0x0BE2;\\n\\n\\n/**\\n * @const\\n * @type {number}\\n */\\nexport const STENCIL_TEST = 0x0B90;\\n\\n\\n/**\\n * @const\\n * @type {number}\\n */\\nexport const DEPTH_TEST = 0x0B71;\\n\\n\\n/**\\n * @const\\n * @type {number}\\n */\\nexport const SCISSOR_TEST = 0x0C11;\\n\\n\\n/**\\n * @const\\n * @type {number}\\n */\\nexport const UNSIGNED_BYTE = 0x1401;\\n\\n\\n/**\\n * @const\\n * @type {number}\\n */\\nexport const UNSIGNED_SHORT = 0x1403;\\n\\n\\n/**\\n * @const\\n * @type {number}\\n */\\nexport const UNSIGNED_INT = 0x1405;\\n\\n\\n/**\\n * @const\\n * @type {number}\\n */\\nexport const FLOAT = 0x1406;\\n\\n\\n/**\\n * @const\\n * @type {number}\\n */\\nexport const RGBA = 0x1908;\\n\\n\\n/**\\n * @const\\n * @type {number}\\n */\\nexport const FRAGMENT_SHADER = 0x8B30;\\n\\n\\n/**\\n * @const\\n * @type {number}\\n */\\nexport const VERTEX_SHADER = 0x8B31;\\n\\n\\n/**\\n * @const\\n * @type {number}\\n */\\nexport const LINK_STATUS = 0x8B82;\\n\\n\\n/**\\n * @const\\n * @type {number}\\n */\\nexport const LINEAR = 0x2601;\\n\\n\\n/**\\n * @const\\n * @type {number}\\n */\\nexport const TEXTURE_MAG_FILTER = 0x2800;\\n\\n\\n/**\\n * @const\\n * @type {number}\\n */\\nexport const TEXTURE_MIN_FILTER = 0x2801;\\n\\n\\n/**\\n * @const\\n * @type {number}\\n */\\nexport const TEXTURE_WRAP_S = 0x2802;\\n\\n\\n/**\\n * @const\\n * @type {number}\\n */\\nexport const TEXTURE_WRAP_T = 0x2803;\\n\\n\\n/**\\n * @const\\n * @type {number}\\n */\\nexport const TEXTURE_2D = 0x0DE1;\\n\\n\\n/**\\n * @const\\n * @type {number}\\n */\\nexport const TEXTURE0 = 0x84C0;\\n\\n\\n/**\\n * @const\\n * @type {number}\\n */\\nexport const CLAMP_TO_EDGE = 0x812F;\\n\\n\\n/**\\n * @const\\n * @type {number}\\n */\\nexport const COMPILE_STATUS = 0x8B81;\\n\\n\\n/**\\n * @const\\n * @type {number}\\n */\\nexport const FRAMEBUFFER = 0x8D40;\\n\\n\\n/** end of goog.webgl constants\\n */\\n\\n\\n/**\\n * @const\\n * @type {Array.<string>}\\n */\\nconst CONTEXT_IDS = [\\n  'experimental-webgl',\\n  'webgl',\\n  'webkit-3d',\\n  'moz-webgl'\\n];\\n\\n\\n/**\\n * @param {HTMLCanvasElement} canvas Canvas.\\n * @param {Object=} opt_attributes Attributes.\\n * @return {WebGLRenderingContext} WebGL rendering context.\\n */\\nexport function getContext(canvas, opt_attributes) {\\n  const ii = CONTEXT_IDS.length;\\n  for (let i = 0; i < ii; ++i) {\\n    try {\\n      const context = canvas.getContext(CONTEXT_IDS[i], opt_attributes);\\n      if (context) {\\n        return /** @type {!WebGLRenderingContext} */ (context);\\n      }\\n    } catch (e) {\\n      // pass\\n    }\\n  }\\n  return null;\\n}\\n\",\"/**\\n * @module ol\\n */\\n\\nimport {getContext} from './webgl.js';\\n\\n\\n/**\\n * An array with two elements, representing a pixel. The first element is the\\n * x-coordinate, the second the y-coordinate of the pixel.\\n * @typedef {Array.<number>} Pixel\\n * @api\\n */\\n\\n\\n/**\\n * Include debuggable shader sources.  Default is `true`. This should be set to\\n * `false` for production builds.\\n * TODO: move to a separate ol-webgl package\\n * @type {boolean}\\n */\\nexport const DEBUG_WEBGL = true;\\n\\n\\n/**\\n * TODO: move to a separate ol-webgl package\\n * The maximum supported WebGL texture size in pixels. If WebGL is not\\n * supported, the value is set to `undefined`.\\n * @type {number|undefined}\\n */\\nlet WEBGL_MAX_TEXTURE_SIZE; // value is set below\\n\\n\\n/**\\n * TODO: move to a separate ol-webgl package\\n * List of supported WebGL extensions.\\n * @type {Array.<string>}\\n */\\nlet WEBGL_EXTENSIONS; // value is set below\\n\\n\\n/**\\n * TODO: move to a separate ol-webgl package\\n * WebGL is available.\\n * @type {boolean}\\n */\\nlet HAS_WEBGL = false;\\n\\n\\nif (typeof window !== 'undefined' && 'WebGLRenderingContext' in window) {\\n  try {\\n    const canvas = /** @type {HTMLCanvasElement} */ (document.createElement('CANVAS'));\\n    const gl = getContext(canvas, {failIfMajorPerformanceCaveat: true});\\n    if (gl) {\\n      HAS_WEBGL = true;\\n      WEBGL_MAX_TEXTURE_SIZE = /** @type {number} */ (gl.getParameter(gl.MAX_TEXTURE_SIZE));\\n      WEBGL_EXTENSIONS = gl.getSupportedExtensions();\\n    }\\n  } catch (e) {\\n    // pass\\n  }\\n}\\n\\nexport {HAS_WEBGL, WEBGL_MAX_TEXTURE_SIZE, WEBGL_EXTENSIONS};\\n\\n\\n/**\\n * OpenLayers version.\\n * @type {string}\\n */\\nexport const VERSION = 'v4.6.4';\\n\\n\\n/**\\n * Inherit the prototype methods from one constructor into another.\\n *\\n * Usage:\\n *\\n *     function ParentClass(a, b) { }\\n *     ParentClass.prototype.foo = function(a) { }\\n *\\n *     function ChildClass(a, b, c) {\\n *       // Call parent constructor\\n *       ParentClass.call(this, a, b);\\n *     }\\n *     inherits(ChildClass, ParentClass);\\n *\\n *     var child = new ChildClass('a', 'b', 'see');\\n *     child.foo(); // This works.\\n *\\n * @param {!Function} childCtor Child constructor.\\n * @param {!Function} parentCtor Parent constructor.\\n * @function\\n * @api\\n */\\nexport function inherits(childCtor, parentCtor) {\\n  childCtor.prototype = Object.create(parentCtor.prototype);\\n  childCtor.prototype.constructor = childCtor;\\n}\\n\\n\\n/**\\n * Counter for getUid.\\n * @type {number}\\n * @private\\n */\\nlet uidCounter_ = 0;\\n\\n/**\\n * Gets a unique ID for an object. This mutates the object so that further calls\\n * with the same object as a parameter returns the same value. Unique IDs are generated\\n * as a strictly increasing sequence. Adapted from goog.getUid.\\n *\\n * @param {Object} obj The object to get the unique ID for.\\n * @return {number} The unique ID for the object.\\n */\\nexport function getUid(obj) {\\n  return obj.ol_uid || (obj.ol_uid = ++uidCounter_);\\n}\\n\",\"/**\\n * @module ol/AssertionError\\n */\\nimport {VERSION, inherits} from './index.js';\\n\\n/**\\n * Error object thrown when an assertion failed. This is an ECMA-262 Error,\\n * extended with a `code` property.\\n * @see {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error}\\n * @constructor\\n * @extends {Error}\\n * @param {number} code Error code.\\n */\\nconst AssertionError = function(code) {\\n\\n  const path = VERSION ? VERSION.split('-')[0] : 'latest';\\n\\n  /**\\n   * @type {string}\\n   */\\n  this.message = 'Assertion failed. See https://openlayers.org/en/' + path +\\n      '/doc/errors/#' + code + ' for details.';\\n\\n  /**\\n   * Error code. The meaning of the code can be found on\\n   * {@link https://openlayers.org/en/latest/doc/errors/} (replace `latest` with\\n   * the version found in the OpenLayers script's header comment if a version\\n   * other than the latest is used).\\n   * @type {number}\\n   * @api\\n   */\\n  this.code = code;\\n\\n  this.name = 'AssertionError';\\n\\n};\\n\\ninherits(AssertionError, Error);\\n\\nexport default AssertionError;\\n\",\"/**\\n * @module ol/asserts\\n */\\nimport AssertionError from './AssertionError.js';\\n\\n/**\\n * @param {*} assertion Assertion we expected to be truthy.\\n * @param {number} errorCode Error code.\\n */\\nexport function assert(assertion, errorCode) {\\n  if (!assertion) {\\n    throw new AssertionError(errorCode);\\n  }\\n}\\n\",\"/**\\n * @module ol/obj\\n */\\n\\n\\n/**\\n * Polyfill for Object.assign().  Assigns enumerable and own properties from\\n * one or more source objects to a target object.\\n *\\n * @see https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Object/assign\\n * @param {!Object} target The target object.\\n * @param {...Object} var_sources The source object(s).\\n * @return {!Object} The modified target object.\\n */\\nexport const assign = (typeof Object.assign === 'function') ? Object.assign : function(target, var_sources) {\\n  if (target === undefined || target === null) {\\n    throw new TypeError('Cannot convert undefined or null to object');\\n  }\\n\\n  const output = Object(target);\\n  for (let i = 1, ii = arguments.length; i < ii; ++i) {\\n    const source = arguments[i];\\n    if (source !== undefined && source !== null) {\\n      for (const key in source) {\\n        if (source.hasOwnProperty(key)) {\\n          output[key] = source[key];\\n        }\\n      }\\n    }\\n  }\\n  return output;\\n};\\n\\n\\n/**\\n * Removes all properties from an object.\\n * @param {Object} object The object to clear.\\n */\\nexport function clear(object) {\\n  for (const property in object) {\\n    delete object[property];\\n  }\\n}\\n\\n\\n/**\\n * Get an array of property values from an object.\\n * @param {Object<K,V>} object The object from which to get the values.\\n * @return {!Array<V>} The property values.\\n * @template K,V\\n */\\nexport function getValues(object) {\\n  const values = [];\\n  for (const property in object) {\\n    values.push(object[property]);\\n  }\\n  return values;\\n}\\n\\n\\n/**\\n * Determine if an object has any properties.\\n * @param {Object} object The object to check.\\n * @return {boolean} The object is empty.\\n */\\nexport function isEmpty(object) {\\n  let property;\\n  for (property in object) {\\n    return false;\\n  }\\n  return !property;\\n}\\n\",\"/**\\n * @module ol/events\\n */\\nimport {clear} from './obj.js';\\n\\n\\n/**\\n * Key to use with {@link module:ol/Observable~Observable#unByKey}.\\n * @typedef {Object} EventsKey\\n * @property {Object} [bindTo]\\n * @property {module:ol/events~ListenerFunction} [boundListener]\\n * @property {boolean} callOnce\\n * @property {number} [deleteIndex]\\n * @property {module:ol/events~ListenerFunction} listener\\n * @property {EventTarget|module:ol/events/EventTarget} target\\n * @property {string} type\\n * @api\\n */\\n\\n\\n/**\\n * Listener function. This function is called with an event object as argument.\\n * When the function returns `false`, event propagation will stop.\\n *\\n * @typedef {function(module:ol/events/Event)|function(module:ol/events/Event): boolean} ListenerFunction\\n * @api\\n */\\n\\n\\n/**\\n * @param {module:ol/events~EventsKey} listenerObj Listener object.\\n * @return {module:ol/events~ListenerFunction} Bound listener.\\n */\\nexport function bindListener(listenerObj) {\\n  const boundListener = function(evt) {\\n    const listener = listenerObj.listener;\\n    const bindTo = listenerObj.bindTo || listenerObj.target;\\n    if (listenerObj.callOnce) {\\n      unlistenByKey(listenerObj);\\n    }\\n    return listener.call(bindTo, evt);\\n  };\\n  listenerObj.boundListener = boundListener;\\n  return boundListener;\\n}\\n\\n\\n/**\\n * Finds the matching {@link module:ol/events~EventsKey} in the given listener\\n * array.\\n *\\n * @param {!Array<!module:ol/events~EventsKey>} listeners Array of listeners.\\n * @param {!Function} listener The listener function.\\n * @param {Object=} opt_this The `this` value inside the listener.\\n * @param {boolean=} opt_setDeleteIndex Set the deleteIndex on the matching\\n *     listener, for {@link module:ol/events~unlistenByKey}.\\n * @return {module:ol/events~EventsKey|undefined} The matching listener object.\\n */\\nexport function findListener(listeners, listener, opt_this, opt_setDeleteIndex) {\\n  let listenerObj;\\n  for (let i = 0, ii = listeners.length; i < ii; ++i) {\\n    listenerObj = listeners[i];\\n    if (listenerObj.listener === listener &&\\n        listenerObj.bindTo === opt_this) {\\n      if (opt_setDeleteIndex) {\\n        listenerObj.deleteIndex = i;\\n      }\\n      return listenerObj;\\n    }\\n  }\\n  return undefined;\\n}\\n\\n\\n/**\\n * @param {module:ol/events/EventTarget~EventTargetLike} target Target.\\n * @param {string} type Type.\\n * @return {Array.<module:ol/events~EventsKey>|undefined} Listeners.\\n */\\nexport function getListeners(target, type) {\\n  const listenerMap = target.ol_lm;\\n  return listenerMap ? listenerMap[type] : undefined;\\n}\\n\\n\\n/**\\n * Get the lookup of listeners.  If one does not exist on the target, it is\\n * created.\\n * @param {module:ol/events/EventTarget~EventTargetLike} target Target.\\n * @return {!Object.<string, Array.<module:ol/events~EventsKey>>} Map of\\n *     listeners by event type.\\n */\\nfunction getListenerMap(target) {\\n  let listenerMap = target.ol_lm;\\n  if (!listenerMap) {\\n    listenerMap = target.ol_lm = {};\\n  }\\n  return listenerMap;\\n}\\n\\n\\n/**\\n * Clean up all listener objects of the given type.  All properties on the\\n * listener objects will be removed, and if no listeners remain in the listener\\n * map, it will be removed from the target.\\n * @param {module:ol/events/EventTarget~EventTargetLike} target Target.\\n * @param {string} type Type.\\n */\\nfunction removeListeners(target, type) {\\n  const listeners = getListeners(target, type);\\n  if (listeners) {\\n    for (let i = 0, ii = listeners.length; i < ii; ++i) {\\n      target.removeEventListener(type, listeners[i].boundListener);\\n      clear(listeners[i]);\\n    }\\n    listeners.length = 0;\\n    const listenerMap = target.ol_lm;\\n    if (listenerMap) {\\n      delete listenerMap[type];\\n      if (Object.keys(listenerMap).length === 0) {\\n        delete target.ol_lm;\\n      }\\n    }\\n  }\\n}\\n\\n\\n/**\\n * Registers an event listener on an event target. Inspired by\\n * {@link https://google.github.io/closure-library/api/source/closure/goog/events/events.js.src.html}\\n *\\n * This function efficiently binds a `listener` to a `this` object, and returns\\n * a key for use with {@link module:ol/events~unlistenByKey}.\\n *\\n * @param {module:ol/events/EventTarget~EventTargetLike} target Event target.\\n * @param {string} type Event type.\\n * @param {module:ol/events~ListenerFunction} listener Listener.\\n * @param {Object=} opt_this Object referenced by the `this` keyword in the\\n *     listener. Default is the `target`.\\n * @param {boolean=} opt_once If true, add the listener as one-off listener.\\n * @return {module:ol/events~EventsKey} Unique key for the listener.\\n */\\nexport function listen(target, type, listener, opt_this, opt_once) {\\n  const listenerMap = getListenerMap(target);\\n  let listeners = listenerMap[type];\\n  if (!listeners) {\\n    listeners = listenerMap[type] = [];\\n  }\\n  let listenerObj = findListener(listeners, listener, opt_this, false);\\n  if (listenerObj) {\\n    if (!opt_once) {\\n      // Turn one-off listener into a permanent one.\\n      listenerObj.callOnce = false;\\n    }\\n  } else {\\n    listenerObj = /** @type {module:ol/events~EventsKey} */ ({\\n      bindTo: opt_this,\\n      callOnce: !!opt_once,\\n      listener: listener,\\n      target: target,\\n      type: type\\n    });\\n    target.addEventListener(type, bindListener(listenerObj));\\n    listeners.push(listenerObj);\\n  }\\n\\n  return listenerObj;\\n}\\n\\n\\n/**\\n * Registers a one-off event listener on an event target. Inspired by\\n * {@link https://google.github.io/closure-library/api/source/closure/goog/events/events.js.src.html}\\n *\\n * This function efficiently binds a `listener` as self-unregistering listener\\n * to a `this` object, and returns a key for use with\\n * {@link module:ol/events~unlistenByKey} in case the listener needs to be\\n * unregistered before it is called.\\n *\\n * When {@link module:ol/events~listen} is called with the same arguments after this\\n * function, the self-unregistering listener will be turned into a permanent\\n * listener.\\n *\\n * @param {module:ol/events/EventTarget~EventTargetLike} target Event target.\\n * @param {string} type Event type.\\n * @param {module:ol/events~ListenerFunction} listener Listener.\\n * @param {Object=} opt_this Object referenced by the `this` keyword in the\\n *     listener. Default is the `target`.\\n * @return {module:ol/events~EventsKey} Key for unlistenByKey.\\n */\\nexport function listenOnce(target, type, listener, opt_this) {\\n  return listen(target, type, listener, opt_this, true);\\n}\\n\\n\\n/**\\n * Unregisters an event listener on an event target. Inspired by\\n * {@link https://google.github.io/closure-library/api/source/closure/goog/events/events.js.src.html}\\n *\\n * To return a listener, this function needs to be called with the exact same\\n * arguments that were used for a previous {@link module:ol/events~listen} call.\\n *\\n * @param {module:ol/events/EventTarget~EventTargetLike} target Event target.\\n * @param {string} type Event type.\\n * @param {module:ol/events~ListenerFunction} listener Listener.\\n * @param {Object=} opt_this Object referenced by the `this` keyword in the\\n *     listener. Default is the `target`.\\n */\\nexport function unlisten(target, type, listener, opt_this) {\\n  const listeners = getListeners(target, type);\\n  if (listeners) {\\n    const listenerObj = findListener(listeners, listener, opt_this, true);\\n    if (listenerObj) {\\n      unlistenByKey(listenerObj);\\n    }\\n  }\\n}\\n\\n\\n/**\\n * Unregisters event listeners on an event target. Inspired by\\n * {@link https://google.github.io/closure-library/api/source/closure/goog/events/events.js.src.html}\\n *\\n * The argument passed to this function is the key returned from\\n * {@link module:ol/events~listen} or {@link module:ol/events~listenOnce}.\\n *\\n * @param {module:ol/events~EventsKey} key The key.\\n */\\nexport function unlistenByKey(key) {\\n  if (key && key.target) {\\n    key.target.removeEventListener(key.type, key.boundListener);\\n    const listeners = getListeners(key.target, key.type);\\n    if (listeners) {\\n      const i = 'deleteIndex' in key ? key.deleteIndex : listeners.indexOf(key);\\n      if (i !== -1) {\\n        listeners.splice(i, 1);\\n      }\\n      if (listeners.length === 0) {\\n        removeListeners(key.target, key.type);\\n      }\\n    }\\n    clear(key);\\n  }\\n}\\n\\n\\n/**\\n * Unregisters all event listeners on an event target. Inspired by\\n * {@link https://google.github.io/closure-library/api/source/closure/goog/events/events.js.src.html}\\n *\\n * @param {module:ol/events/EventTarget~EventTargetLike} target Target.\\n */\\nexport function unlistenAll(target) {\\n  const listenerMap = getListenerMap(target);\\n  for (const type in listenerMap) {\\n    removeListeners(target, type);\\n  }\\n}\\n\",\"/**\\n * @module ol/events/EventType\\n */\\n\\n/**\\n * @enum {string}\\n * @const\\n */\\nexport default {\\n  /**\\n   * Generic change event. Triggered when the revision counter is increased.\\n   * @event module:ol/events/Event~Event#change\\n   * @api\\n   */\\n  CHANGE: 'change',\\n\\n  CLEAR: 'clear',\\n  CONTEXTMENU: 'contextmenu',\\n  CLICK: 'click',\\n  DBLCLICK: 'dblclick',\\n  DRAGENTER: 'dragenter',\\n  DRAGOVER: 'dragover',\\n  DROP: 'drop',\\n  ERROR: 'error',\\n  KEYDOWN: 'keydown',\\n  KEYPRESS: 'keypress',\\n  LOAD: 'load',\\n  MOUSEDOWN: 'mousedown',\\n  MOUSEMOVE: 'mousemove',\\n  MOUSEOUT: 'mouseout',\\n  MOUSEUP: 'mouseup',\\n  MOUSEWHEEL: 'mousewheel',\\n  MSPOINTERDOWN: 'MSPointerDown',\\n  RESIZE: 'resize',\\n  TOUCHSTART: 'touchstart',\\n  TOUCHMOVE: 'touchmove',\\n  TOUCHEND: 'touchend',\\n  WHEEL: 'wheel'\\n};\\n\",\"/**\\n * @module ol/ObjectEventType\\n */\\n\\n/**\\n * @enum {string}\\n */\\nexport default {\\n  /**\\n   * Triggered when a property is changed.\\n   * @event module:ol/Object~ObjectEvent#propertychange\\n   * @api\\n   */\\n  PROPERTYCHANGE: 'propertychange'\\n};\\n\",\"/**\\n * @module ol/functions\\n */\\n\\n/**\\n * Always returns true.\\n * @returns {boolean} true.\\n */\\nexport function TRUE() {\\n  return true;\\n}\\n\\n/**\\n * Always returns false.\\n * @returns {boolean} false.\\n */\\nexport function FALSE() {\\n  return false;\\n}\\n\\n/**\\n * A reusable function, used e.g. as a default for callbacks.\\n *\\n * @return {undefined} Nothing.\\n */\\nexport function UNDEFINED() {}\\n\",\"/**\\n * @module ol/Disposable\\n */\\nimport {UNDEFINED} from './functions.js';\\n\\n/**\\n * Objects that need to clean up after themselves.\\n * @constructor\\n */\\nconst Disposable = function() {};\\n\\n/**\\n * The object has already been disposed.\\n * @type {boolean}\\n * @private\\n */\\nDisposable.prototype.disposed_ = false;\\n\\n/**\\n * Clean up.\\n */\\nDisposable.prototype.dispose = function() {\\n  if (!this.disposed_) {\\n    this.disposed_ = true;\\n    this.disposeInternal();\\n  }\\n};\\n\\n/**\\n * Extension point for disposable objects.\\n * @protected\\n */\\nDisposable.prototype.disposeInternal = UNDEFINED;\\nexport default Disposable;\\n\",\"/**\\n * @module ol/events/Event\\n */\\n/**\\n * @classdesc\\n * Stripped down implementation of the W3C DOM Level 2 Event interface.\\n * @see {@link https://www.w3.org/TR/DOM-Level-2-Events/events.html#Events-interface}\\n *\\n * This implementation only provides `type` and `target` properties, and\\n * `stopPropagation` and `preventDefault` methods. It is meant as base class\\n * for higher level events defined in the library, and works with\\n * {@link module:ol/events/EventTarget~EventTarget}.\\n *\\n * @constructor\\n * @param {string} type Type.\\n */\\nconst Event = function(type) {\\n\\n  /**\\n   * @type {boolean}\\n   */\\n  this.propagationStopped;\\n\\n  /**\\n   * The event type.\\n   * @type {string}\\n   * @api\\n   */\\n  this.type = type;\\n\\n  /**\\n   * The event target.\\n   * @type {Object}\\n   * @api\\n   */\\n  this.target = null;\\n\\n};\\n\\n\\n/**\\n * Stop event propagation.\\n * @function\\n * @api\\n */\\nEvent.prototype.preventDefault =\\n\\n  /**\\n   * Stop event propagation.\\n   * @function\\n   * @api\\n   */\\n  Event.prototype.stopPropagation = function() {\\n    this.propagationStopped = true;\\n  };\\n\\n\\n/**\\n * @param {Event|module:ol/events/Event} evt Event\\n */\\nexport function stopPropagation(evt) {\\n  evt.stopPropagation();\\n}\\n\\n\\n/**\\n * @param {Event|module:ol/events/Event} evt Event\\n */\\nexport function preventDefault(evt) {\\n  evt.preventDefault();\\n}\\n\\nexport default Event;\\n\",\"/**\\n * @module ol/events/EventTarget\\n */\\nimport {inherits} from '../index.js';\\nimport Disposable from '../Disposable.js';\\nimport {unlistenAll} from '../events.js';\\nimport {UNDEFINED} from '../functions.js';\\nimport Event from '../events/Event.js';\\n\\n\\n/**\\n * @typedef {EventTarget|module:ol/events/EventTarget} EventTargetLike\\n */\\n\\n\\n/**\\n * @classdesc\\n * A simplified implementation of the W3C DOM Level 2 EventTarget interface.\\n * @see {@link https://www.w3.org/TR/2000/REC-DOM-Level-2-Events-20001113/events.html#Events-EventTarget}\\n *\\n * There are two important simplifications compared to the specification:\\n *\\n * 1. The handling of `useCapture` in `addEventListener` and\\n *    `removeEventListener`. There is no real capture model.\\n * 2. The handling of `stopPropagation` and `preventDefault` on `dispatchEvent`.\\n *    There is no event target hierarchy. When a listener calls\\n *    `stopPropagation` or `preventDefault` on an event object, it means that no\\n *    more listeners after this one will be called. Same as when the listener\\n *    returns false.\\n *\\n * @constructor\\n * @extends {module:ol/Disposable}\\n */\\nconst EventTarget = function() {\\n\\n  Disposable.call(this);\\n\\n  /**\\n   * @private\\n   * @type {!Object.<string, number>}\\n   */\\n  this.pendingRemovals_ = {};\\n\\n  /**\\n   * @private\\n   * @type {!Object.<string, number>}\\n   */\\n  this.dispatching_ = {};\\n\\n  /**\\n   * @private\\n   * @type {!Object.<string, Array.<module:ol/events~ListenerFunction>>}\\n   */\\n  this.listeners_ = {};\\n\\n};\\n\\ninherits(EventTarget, Disposable);\\n\\n\\n/**\\n * @param {string} type Type.\\n * @param {module:ol/events~ListenerFunction} listener Listener.\\n */\\nEventTarget.prototype.addEventListener = function(type, listener) {\\n  let listeners = this.listeners_[type];\\n  if (!listeners) {\\n    listeners = this.listeners_[type] = [];\\n  }\\n  if (listeners.indexOf(listener) === -1) {\\n    listeners.push(listener);\\n  }\\n};\\n\\n\\n/**\\n * @param {{type: string,\\n *     target: (EventTarget|module:ol/events/EventTarget|undefined)}|module:ol/events/Event|\\n *     string} event Event or event type.\\n * @return {boolean|undefined} `false` if anyone called preventDefault on the\\n *     event object or if any of the listeners returned false.\\n */\\nEventTarget.prototype.dispatchEvent = function(event) {\\n  const evt = typeof event === 'string' ? new Event(event) : event;\\n  const type = evt.type;\\n  evt.target = this;\\n  const listeners = this.listeners_[type];\\n  let propagate;\\n  if (listeners) {\\n    if (!(type in this.dispatching_)) {\\n      this.dispatching_[type] = 0;\\n      this.pendingRemovals_[type] = 0;\\n    }\\n    ++this.dispatching_[type];\\n    for (let i = 0, ii = listeners.length; i < ii; ++i) {\\n      if (listeners[i].call(this, evt) === false || evt.propagationStopped) {\\n        propagate = false;\\n        break;\\n      }\\n    }\\n    --this.dispatching_[type];\\n    if (this.dispatching_[type] === 0) {\\n      let pendingRemovals = this.pendingRemovals_[type];\\n      delete this.pendingRemovals_[type];\\n      while (pendingRemovals--) {\\n        this.removeEventListener(type, UNDEFINED);\\n      }\\n      delete this.dispatching_[type];\\n    }\\n    return propagate;\\n  }\\n};\\n\\n\\n/**\\n * @inheritDoc\\n */\\nEventTarget.prototype.disposeInternal = function() {\\n  unlistenAll(this);\\n};\\n\\n\\n/**\\n * Get the listeners for a specified event type. Listeners are returned in the\\n * order that they will be called in.\\n *\\n * @param {string} type Type.\\n * @return {Array.<module:ol/events~ListenerFunction>} Listeners.\\n */\\nEventTarget.prototype.getListeners = function(type) {\\n  return this.listeners_[type];\\n};\\n\\n\\n/**\\n * @param {string=} opt_type Type. If not provided,\\n *     `true` will be returned if this EventTarget has any listeners.\\n * @return {boolean} Has listeners.\\n */\\nEventTarget.prototype.hasListener = function(opt_type) {\\n  return opt_type ?\\n    opt_type in this.listeners_ :\\n    Object.keys(this.listeners_).length > 0;\\n};\\n\\n\\n/**\\n * @param {string} type Type.\\n * @param {module:ol/events~ListenerFunction} listener Listener.\\n */\\nEventTarget.prototype.removeEventListener = function(type, listener) {\\n  const listeners = this.listeners_[type];\\n  if (listeners) {\\n    const index = listeners.indexOf(listener);\\n    if (type in this.pendingRemovals_) {\\n      // make listener a no-op, and remove later in #dispatchEvent()\\n      listeners[index] = UNDEFINED;\\n      ++this.pendingRemovals_[type];\\n    } else {\\n      listeners.splice(index, 1);\\n      if (listeners.length === 0) {\\n        delete this.listeners_[type];\\n      }\\n    }\\n  }\\n};\\nexport default EventTarget;\\n\",\"/**\\n * @module ol/Observable\\n */\\nimport {inherits} from './index.js';\\nimport {listen, unlistenByKey, unlisten, listenOnce} from './events.js';\\nimport EventTarget from './events/EventTarget.js';\\nimport EventType from './events/EventType.js';\\n\\n/**\\n * @classdesc\\n * Abstract base class; normally only used for creating subclasses and not\\n * instantiated in apps.\\n * An event target providing convenient methods for listener registration\\n * and unregistration. A generic `change` event is always available through\\n * {@link module:ol/Observable~Observable#changed}.\\n *\\n * @constructor\\n * @extends {module:ol/events/EventTarget}\\n * @fires module:ol/events/Event~Event\\n * @struct\\n * @api\\n */\\nconst Observable = function() {\\n\\n  EventTarget.call(this);\\n\\n  /**\\n   * @private\\n   * @type {number}\\n   */\\n  this.revision_ = 0;\\n\\n};\\n\\ninherits(Observable, EventTarget);\\n\\n\\n/**\\n * Removes an event listener using the key returned by `on()` or `once()`.\\n * @param {module:ol/events~EventsKey|Array.<module:ol/events~EventsKey>} key The key returned by `on()`\\n *     or `once()` (or an array of keys).\\n * @api\\n */\\nexport function unByKey(key) {\\n  if (Array.isArray(key)) {\\n    for (let i = 0, ii = key.length; i < ii; ++i) {\\n      unlistenByKey(key[i]);\\n    }\\n  } else {\\n    unlistenByKey(/** @type {module:ol/events~EventsKey} */ (key));\\n  }\\n}\\n\\n\\n/**\\n * Increases the revision counter and dispatches a 'change' event.\\n * @api\\n */\\nObservable.prototype.changed = function() {\\n  ++this.revision_;\\n  this.dispatchEvent(EventType.CHANGE);\\n};\\n\\n\\n/**\\n * Dispatches an event and calls all listeners listening for events\\n * of this type. The event parameter can either be a string or an\\n * Object with a `type` property.\\n *\\n * @param {{type: string,\\n *     target: (EventTarget|module:ol/events/EventTarget|undefined)}|\\n *     module:ol/events/Event|string} event Event object.\\n * @function\\n * @api\\n */\\nObservable.prototype.dispatchEvent;\\n\\n\\n/**\\n * Get the version number for this object.  Each time the object is modified,\\n * its version number will be incremented.\\n * @return {number} Revision.\\n * @api\\n */\\nObservable.prototype.getRevision = function() {\\n  return this.revision_;\\n};\\n\\n\\n/**\\n * Listen for a certain type of event.\\n * @param {string|Array.<string>} type The event type or array of event types.\\n * @param {function(?): ?} listener The listener function.\\n * @return {module:ol/events~EventsKey|Array.<module:ol/events~EventsKey>} Unique key for the listener. If\\n *     called with an array of event types as the first argument, the return\\n *     will be an array of keys.\\n * @api\\n */\\nObservable.prototype.on = function(type, listener) {\\n  if (Array.isArray(type)) {\\n    const len = type.length;\\n    const keys = new Array(len);\\n    for (let i = 0; i < len; ++i) {\\n      keys[i] = listen(this, type[i], listener);\\n    }\\n    return keys;\\n  } else {\\n    return listen(this, /** @type {string} */ (type), listener);\\n  }\\n};\\n\\n\\n/**\\n * Listen once for a certain type of event.\\n * @param {string|Array.<string>} type The event type or array of event types.\\n * @param {function(?): ?} listener The listener function.\\n * @return {module:ol/events~EventsKey|Array.<module:ol/events~EventsKey>} Unique key for the listener. If\\n *     called with an array of event types as the first argument, the return\\n *     will be an array of keys.\\n * @api\\n */\\nObservable.prototype.once = function(type, listener) {\\n  if (Array.isArray(type)) {\\n    const len = type.length;\\n    const keys = new Array(len);\\n    for (let i = 0; i < len; ++i) {\\n      keys[i] = listenOnce(this, type[i], listener);\\n    }\\n    return keys;\\n  } else {\\n    return listenOnce(this, /** @type {string} */ (type), listener);\\n  }\\n};\\n\\n\\n/**\\n * Unlisten for a certain type of event.\\n * @param {string|Array.<string>} type The event type or array of event types.\\n * @param {function(?): ?} listener The listener function.\\n * @api\\n */\\nObservable.prototype.un = function(type, listener) {\\n  if (Array.isArray(type)) {\\n    for (let i = 0, ii = type.length; i < ii; ++i) {\\n      unlisten(this, type[i], listener);\\n    }\\n    return;\\n  } else {\\n    unlisten(this, /** @type {string} */ (type), listener);\\n  }\\n};\\nexport default Observable;\\n\",\"/**\\n * @module ol/Object\\n */\\nimport {getUid, inherits} from './index.js';\\nimport ObjectEventType from './ObjectEventType.js';\\nimport Observable from './Observable.js';\\nimport Event from './events/Event.js';\\nimport {assign} from './obj.js';\\n\\n\\n/**\\n * @classdesc\\n * Events emitted by {@link module:ol/Object~BaseObject} instances are instances of\\n * this type.\\n *\\n * @param {string} type The event type.\\n * @param {string} key The property name.\\n * @param {*} oldValue The old value for `key`.\\n * @extends {module:ol/events/Event}\\n * @constructor\\n */\\nconst ObjectEvent = function(type, key, oldValue) {\\n  Event.call(this, type);\\n\\n  /**\\n   * The name of the property whose value is changing.\\n   * @type {string}\\n   * @api\\n   */\\n  this.key = key;\\n\\n  /**\\n   * The old value. To get the new value use `e.target.get(e.key)` where\\n   * `e` is the event object.\\n   * @type {*}\\n   * @api\\n   */\\n  this.oldValue = oldValue;\\n\\n};\\ninherits(ObjectEvent, Event);\\n\\n\\n/**\\n * @classdesc\\n * Abstract base class; normally only used for creating subclasses and not\\n * instantiated in apps.\\n * Most non-trivial classes inherit from this.\\n *\\n * This extends {@link module:ol/Observable} with observable\\n * properties, where each property is observable as well as the object as a\\n * whole.\\n *\\n * Classes that inherit from this have pre-defined properties, to which you can\\n * add your owns. The pre-defined properties are listed in this documentation as\\n * 'Observable Properties', and have their own accessors; for example,\\n * {@link module:ol/Map~Map} has a `target` property, accessed with\\n * `getTarget()` and changed with `setTarget()`. Not all properties are however\\n * settable. There are also general-purpose accessors `get()` and `set()`. For\\n * example, `get('target')` is equivalent to `getTarget()`.\\n *\\n * The `set` accessors trigger a change event, and you can monitor this by\\n * registering a listener. For example, {@link module:ol/View~View} has a\\n * `center` property, so `view.on('change:center', function(evt) {...});` would\\n * call the function whenever the value of the center property changes. Within\\n * the function, `evt.target` would be the view, so `evt.target.getCenter()`\\n * would return the new center.\\n *\\n * You can add your own observable properties with\\n * `object.set('prop', 'value')`, and retrieve that with `object.get('prop')`.\\n * You can listen for changes on that property value with\\n * `object.on('change:prop', listener)`. You can get a list of all\\n * properties with {@link module:ol/Object~BaseObject#getProperties}.\\n *\\n * Note that the observable properties are separate from standard JS properties.\\n * You can, for example, give your map object a title with\\n * `map.title='New title'` and with `map.set('title', 'Another title')`. The\\n * first will be a `hasOwnProperty`; the second will appear in\\n * `getProperties()`. Only the second is observable.\\n *\\n * Properties can be deleted by using the unset method. E.g.\\n * object.unset('foo').\\n *\\n * @constructor\\n * @extends {module:ol/Observable}\\n * @param {Object.<string, *>=} opt_values An object with key-value pairs.\\n * @fires module:ol/Object~ObjectEvent\\n * @api\\n */\\nconst BaseObject = function(opt_values) {\\n  Observable.call(this);\\n\\n  // Call {@link module:ol~getUid} to ensure that the order of objects' ids is\\n  // the same as the order in which they were created.  This also helps to\\n  // ensure that object properties are always added in the same order, which\\n  // helps many JavaScript engines generate faster code.\\n  getUid(this);\\n\\n  /**\\n   * @private\\n   * @type {!Object.<string, *>}\\n   */\\n  this.values_ = {};\\n\\n  if (opt_values !== undefined) {\\n    this.setProperties(opt_values);\\n  }\\n};\\n\\ninherits(BaseObject, Observable);\\n\\n\\n/**\\n * @type {Object.<string, string>}\\n */\\nconst changeEventTypeCache = {};\\n\\n\\n/**\\n * @param {string} key Key name.\\n * @return {string} Change name.\\n */\\nexport function getChangeEventType(key) {\\n  return changeEventTypeCache.hasOwnProperty(key) ?\\n    changeEventTypeCache[key] :\\n    (changeEventTypeCache[key] = 'change:' + key);\\n}\\n\\n\\n/**\\n * Gets a value.\\n * @param {string} key Key name.\\n * @return {*} Value.\\n * @api\\n */\\nBaseObject.prototype.get = function(key) {\\n  let value;\\n  if (this.values_.hasOwnProperty(key)) {\\n    value = this.values_[key];\\n  }\\n  return value;\\n};\\n\\n\\n/**\\n * Get a list of object property names.\\n * @return {Array.<string>} List of property names.\\n * @api\\n */\\nBaseObject.prototype.getKeys = function() {\\n  return Object.keys(this.values_);\\n};\\n\\n\\n/**\\n * Get an object of all property names and values.\\n * @return {Object.<string, *>} Object.\\n * @api\\n */\\nBaseObject.prototype.getProperties = function() {\\n  return assign({}, this.values_);\\n};\\n\\n\\n/**\\n * @param {string} key Key name.\\n * @param {*} oldValue Old value.\\n */\\nBaseObject.prototype.notify = function(key, oldValue) {\\n  let eventType;\\n  eventType = getChangeEventType(key);\\n  this.dispatchEvent(new ObjectEvent(eventType, key, oldValue));\\n  eventType = ObjectEventType.PROPERTYCHANGE;\\n  this.dispatchEvent(new ObjectEvent(eventType, key, oldValue));\\n};\\n\\n\\n/**\\n * Sets a value.\\n * @param {string} key Key name.\\n * @param {*} value Value.\\n * @param {boolean=} opt_silent Update without triggering an event.\\n * @api\\n */\\nBaseObject.prototype.set = function(key, value, opt_silent) {\\n  if (opt_silent) {\\n    this.values_[key] = value;\\n  } else {\\n    const oldValue = this.values_[key];\\n    this.values_[key] = value;\\n    if (oldValue !== value) {\\n      this.notify(key, oldValue);\\n    }\\n  }\\n};\\n\\n\\n/**\\n * Sets a collection of key-value pairs.  Note that this changes any existing\\n * properties and adds new ones (it does not remove any existing properties).\\n * @param {Object.<string, *>} values Values.\\n * @param {boolean=} opt_silent Update without triggering an event.\\n * @api\\n */\\nBaseObject.prototype.setProperties = function(values, opt_silent) {\\n  for (const key in values) {\\n    this.set(key, values[key], opt_silent);\\n  }\\n};\\n\\n\\n/**\\n * Unsets a property.\\n * @param {string} key Key name.\\n * @param {boolean=} opt_silent Unset without triggering an event.\\n * @api\\n */\\nBaseObject.prototype.unset = function(key, opt_silent) {\\n  if (key in this.values_) {\\n    const oldValue = this.values_[key];\\n    delete this.values_[key];\\n    if (!opt_silent) {\\n      this.notify(key, oldValue);\\n    }\\n  }\\n};\\n\\n\\nexport default BaseObject;\\n\",\"/**\\n * @module ol/extent/Corner\\n */\\n\\n/**\\n * Extent corner.\\n * @enum {string}\\n */\\nexport default {\\n  BOTTOM_LEFT: 'bottom-left',\\n  BOTTOM_RIGHT: 'bottom-right',\\n  TOP_LEFT: 'top-left',\\n  TOP_RIGHT: 'top-right'\\n};\\n\",\"/**\\n * @module ol/extent/Relationship\\n */\\n\\n/**\\n * Relationship to an extent.\\n * @enum {number}\\n */\\nexport default {\\n  UNKNOWN: 0,\\n  INTERSECTING: 1,\\n  ABOVE: 2,\\n  RIGHT: 4,\\n  BELOW: 8,\\n  LEFT: 16\\n};\\n\",\"/**\\n * @module ol/extent\\n */\\nimport {assert} from './asserts.js';\\nimport Corner from './extent/Corner.js';\\nimport Relationship from './extent/Relationship.js';\\n\\n\\n/**\\n * An array of numbers representing an extent: `[minx, miny, maxx, maxy]`.\\n * @typedef {Array.<number>} Extent\\n * @api\\n */\\n\\n/**\\n * Build an extent that includes all given coordinates.\\n *\\n * @param {Array.<module:ol/coordinate~Coordinate>} coordinates Coordinates.\\n * @return {module:ol/extent~Extent} Bounding extent.\\n * @api\\n */\\nexport function boundingExtent(coordinates) {\\n  const extent = createEmpty();\\n  for (let i = 0, ii = coordinates.length; i < ii; ++i) {\\n    extendCoordinate(extent, coordinates[i]);\\n  }\\n  return extent;\\n}\\n\\n\\n/**\\n * @param {Array.<number>} xs Xs.\\n * @param {Array.<number>} ys Ys.\\n * @param {module:ol/extent~Extent=} opt_extent Destination extent.\\n * @private\\n * @return {module:ol/extent~Extent} Extent.\\n */\\nfunction _boundingExtentXYs(xs, ys, opt_extent) {\\n  const minX = Math.min.apply(null, xs);\\n  const minY = Math.min.apply(null, ys);\\n  const maxX = Math.max.apply(null, xs);\\n  const maxY = Math.max.apply(null, ys);\\n  return createOrUpdate(minX, minY, maxX, maxY, opt_extent);\\n}\\n\\n\\n/**\\n * Return extent increased by the provided value.\\n * @param {module:ol/extent~Extent} extent Extent.\\n * @param {number} value The amount by which the extent should be buffered.\\n * @param {module:ol/extent~Extent=} opt_extent Extent.\\n * @return {module:ol/extent~Extent} Extent.\\n * @api\\n */\\nexport function buffer(extent, value, opt_extent) {\\n  if (opt_extent) {\\n    opt_extent[0] = extent[0] - value;\\n    opt_extent[1] = extent[1] - value;\\n    opt_extent[2] = extent[2] + value;\\n    opt_extent[3] = extent[3] + value;\\n    return opt_extent;\\n  } else {\\n    return [\\n      extent[0] - value,\\n      extent[1] - value,\\n      extent[2] + value,\\n      extent[3] + value\\n    ];\\n  }\\n}\\n\\n\\n/**\\n * Creates a clone of an extent.\\n *\\n * @param {module:ol/extent~Extent} extent Extent to clone.\\n * @param {module:ol/extent~Extent=} opt_extent Extent.\\n * @return {module:ol/extent~Extent} The clone.\\n */\\nexport function clone(extent, opt_extent) {\\n  if (opt_extent) {\\n    opt_extent[0] = extent[0];\\n    opt_extent[1] = extent[1];\\n    opt_extent[2] = extent[2];\\n    opt_extent[3] = extent[3];\\n    return opt_extent;\\n  } else {\\n    return extent.slice();\\n  }\\n}\\n\\n\\n/**\\n * @param {module:ol/extent~Extent} extent Extent.\\n * @param {number} x X.\\n * @param {number} y Y.\\n * @return {number} Closest squared distance.\\n */\\nexport function closestSquaredDistanceXY(extent, x, y) {\\n  let dx, dy;\\n  if (x < extent[0]) {\\n    dx = extent[0] - x;\\n  } else if (extent[2] < x) {\\n    dx = x - extent[2];\\n  } else {\\n    dx = 0;\\n  }\\n  if (y < extent[1]) {\\n    dy = extent[1] - y;\\n  } else if (extent[3] < y) {\\n    dy = y - extent[3];\\n  } else {\\n    dy = 0;\\n  }\\n  return dx * dx + dy * dy;\\n}\\n\\n\\n/**\\n * Check if the passed coordinate is contained or on the edge of the extent.\\n *\\n * @param {module:ol/extent~Extent} extent Extent.\\n * @param {module:ol/coordinate~Coordinate} coordinate Coordinate.\\n * @return {boolean} The coordinate is contained in the extent.\\n * @api\\n */\\nexport function containsCoordinate(extent, coordinate) {\\n  return containsXY(extent, coordinate[0], coordinate[1]);\\n}\\n\\n\\n/**\\n * Check if one extent contains another.\\n *\\n * An extent is deemed contained if it lies completely within the other extent,\\n * including if they share one or more edges.\\n *\\n * @param {module:ol/extent~Extent} extent1 Extent 1.\\n * @param {module:ol/extent~Extent} extent2 Extent 2.\\n * @return {boolean} The second extent is contained by or on the edge of the\\n *     first.\\n * @api\\n */\\nexport function containsExtent(extent1, extent2) {\\n  return extent1[0] <= extent2[0] && extent2[2] <= extent1[2] &&\\n      extent1[1] <= extent2[1] && extent2[3] <= extent1[3];\\n}\\n\\n\\n/**\\n * Check if the passed coordinate is contained or on the edge of the extent.\\n *\\n * @param {module:ol/extent~Extent} extent Extent.\\n * @param {number} x X coordinate.\\n * @param {number} y Y coordinate.\\n * @return {boolean} The x, y values are contained in the extent.\\n * @api\\n */\\nexport function containsXY(extent, x, y) {\\n  return extent[0] <= x && x <= extent[2] && extent[1] <= y && y <= extent[3];\\n}\\n\\n\\n/**\\n * Get the relationship between a coordinate and extent.\\n * @param {module:ol/extent~Extent} extent The extent.\\n * @param {module:ol/coordinate~Coordinate} coordinate The coordinate.\\n * @return {module:ol/extent/Relationship} The relationship (bitwise compare with\\n *     module:ol/extent/Relationship~Relationship).\\n */\\nexport function coordinateRelationship(extent, coordinate) {\\n  const minX = extent[0];\\n  const minY = extent[1];\\n  const maxX = extent[2];\\n  const maxY = extent[3];\\n  const x = coordinate[0];\\n  const y = coordinate[1];\\n  let relationship = Relationship.UNKNOWN;\\n  if (x < minX) {\\n    relationship = relationship | Relationship.LEFT;\\n  } else if (x > maxX) {\\n    relationship = relationship | Relationship.RIGHT;\\n  }\\n  if (y < minY) {\\n    relationship = relationship | Relationship.BELOW;\\n  } else if (y > maxY) {\\n    relationship = relationship | Relationship.ABOVE;\\n  }\\n  if (relationship === Relationship.UNKNOWN) {\\n    relationship = Relationship.INTERSECTING;\\n  }\\n  return relationship;\\n}\\n\\n\\n/**\\n * Create an empty extent.\\n * @return {module:ol/extent~Extent} Empty extent.\\n * @api\\n */\\nexport function createEmpty() {\\n  return [Infinity, Infinity, -Infinity, -Infinity];\\n}\\n\\n\\n/**\\n * Create a new extent or update the provided extent.\\n * @param {number} minX Minimum X.\\n * @param {number} minY Minimum Y.\\n * @param {number} maxX Maximum X.\\n * @param {number} maxY Maximum Y.\\n * @param {module:ol/extent~Extent=} opt_extent Destination extent.\\n * @return {module:ol/extent~Extent} Extent.\\n */\\nexport function createOrUpdate(minX, minY, maxX, maxY, opt_extent) {\\n  if (opt_extent) {\\n    opt_extent[0] = minX;\\n    opt_extent[1] = minY;\\n    opt_extent[2] = maxX;\\n    opt_extent[3] = maxY;\\n    return opt_extent;\\n  } else {\\n    return [minX, minY, maxX, maxY];\\n  }\\n}\\n\\n\\n/**\\n * Create a new empty extent or make the provided one empty.\\n * @param {module:ol/extent~Extent=} opt_extent Extent.\\n * @return {module:ol/extent~Extent} Extent.\\n */\\nexport function createOrUpdateEmpty(opt_extent) {\\n  return createOrUpdate(\\n    Infinity, Infinity, -Infinity, -Infinity, opt_extent);\\n}\\n\\n\\n/**\\n * @param {module:ol/coordinate~Coordinate} coordinate Coordinate.\\n * @param {module:ol/extent~Extent=} opt_extent Extent.\\n * @return {module:ol/extent~Extent} Extent.\\n */\\nexport function createOrUpdateFromCoordinate(coordinate, opt_extent) {\\n  const x = coordinate[0];\\n  const y = coordinate[1];\\n  return createOrUpdate(x, y, x, y, opt_extent);\\n}\\n\\n\\n/**\\n * @param {Array.<module:ol/coordinate~Coordinate>} coordinates Coordinates.\\n * @param {module:ol/extent~Extent=} opt_extent Extent.\\n * @return {module:ol/extent~Extent} Extent.\\n */\\nexport function createOrUpdateFromCoordinates(coordinates, opt_extent) {\\n  const extent = createOrUpdateEmpty(opt_extent);\\n  return extendCoordinates(extent, coordinates);\\n}\\n\\n\\n/**\\n * @param {Array.<number>} flatCoordinates Flat coordinates.\\n * @param {number} offset Offset.\\n * @param {number} end End.\\n * @param {number} stride Stride.\\n * @param {module:ol/extent~Extent=} opt_extent Extent.\\n * @return {module:ol/extent~Extent} Extent.\\n */\\nexport function createOrUpdateFromFlatCoordinates(flatCoordinates, offset, end, stride, opt_extent) {\\n  const extent = createOrUpdateEmpty(opt_extent);\\n  return extendFlatCoordinates(extent, flatCoordinates, offset, end, stride);\\n}\\n\\n/**\\n * @param {Array.<Array.<module:ol/coordinate~Coordinate>>} rings Rings.\\n * @param {module:ol/extent~Extent=} opt_extent Extent.\\n * @return {module:ol/extent~Extent} Extent.\\n */\\nexport function createOrUpdateFromRings(rings, opt_extent) {\\n  const extent = createOrUpdateEmpty(opt_extent);\\n  return extendRings(extent, rings);\\n}\\n\\n\\n/**\\n * Determine if two extents are equivalent.\\n * @param {module:ol/extent~Extent} extent1 Extent 1.\\n * @param {module:ol/extent~Extent} extent2 Extent 2.\\n * @return {boolean} The two extents are equivalent.\\n * @api\\n */\\nexport function equals(extent1, extent2) {\\n  return extent1[0] == extent2[0] && extent1[2] == extent2[2] &&\\n      extent1[1] == extent2[1] && extent1[3] == extent2[3];\\n}\\n\\n\\n/**\\n * Modify an extent to include another extent.\\n * @param {module:ol/extent~Extent} extent1 The extent to be modified.\\n * @param {module:ol/extent~Extent} extent2 The extent that will be included in the first.\\n * @return {module:ol/extent~Extent} A reference to the first (extended) extent.\\n * @api\\n */\\nexport function extend(extent1, extent2) {\\n  if (extent2[0] < extent1[0]) {\\n    extent1[0] = extent2[0];\\n  }\\n  if (extent2[2] > extent1[2]) {\\n    extent1[2] = extent2[2];\\n  }\\n  if (extent2[1] < extent1[1]) {\\n    extent1[1] = extent2[1];\\n  }\\n  if (extent2[3] > extent1[3]) {\\n    extent1[3] = extent2[3];\\n  }\\n  return extent1;\\n}\\n\\n\\n/**\\n * @param {module:ol/extent~Extent} extent Extent.\\n * @param {module:ol/coordinate~Coordinate} coordinate Coordinate.\\n */\\nexport function extendCoordinate(extent, coordinate) {\\n  if (coordinate[0] < extent[0]) {\\n    extent[0] = coordinate[0];\\n  }\\n  if (coordinate[0] > extent[2]) {\\n    extent[2] = coordinate[0];\\n  }\\n  if (coordinate[1] < extent[1]) {\\n    extent[1] = coordinate[1];\\n  }\\n  if (coordinate[1] > extent[3]) {\\n    extent[3] = coordinate[1];\\n  }\\n}\\n\\n\\n/**\\n * @param {module:ol/extent~Extent} extent Extent.\\n * @param {Array.<module:ol/coordinate~Coordinate>} coordinates Coordinates.\\n * @return {module:ol/extent~Extent} Extent.\\n */\\nexport function extendCoordinates(extent, coordinates) {\\n  for (let i = 0, ii = coordinates.length; i < ii; ++i) {\\n    extendCoordinate(extent, coordinates[i]);\\n  }\\n  return extent;\\n}\\n\\n\\n/**\\n * @param {module:ol/extent~Extent} extent Extent.\\n * @param {Array.<number>} flatCoordinates Flat coordinates.\\n * @param {number} offset Offset.\\n * @param {number} end End.\\n * @param {number} stride Stride.\\n * @return {module:ol/extent~Extent} Extent.\\n */\\nexport function extendFlatCoordinates(extent, flatCoordinates, offset, end, stride) {\\n  for (; offset < end; offset += stride) {\\n    extendXY(extent, flatCoordinates[offset], flatCoordinates[offset + 1]);\\n  }\\n  return extent;\\n}\\n\\n\\n/**\\n * @param {module:ol/extent~Extent} extent Extent.\\n * @param {Array.<Array.<module:ol/coordinate~Coordinate>>} rings Rings.\\n * @return {module:ol/extent~Extent} Extent.\\n */\\nexport function extendRings(extent, rings) {\\n  for (let i = 0, ii = rings.length; i < ii; ++i) {\\n    extendCoordinates(extent, rings[i]);\\n  }\\n  return extent;\\n}\\n\\n\\n/**\\n * @param {module:ol/extent~Extent} extent Extent.\\n * @param {number} x X.\\n * @param {number} y Y.\\n */\\nexport function extendXY(extent, x, y) {\\n  extent[0] = Math.min(extent[0], x);\\n  extent[1] = Math.min(extent[1], y);\\n  extent[2] = Math.max(extent[2], x);\\n  extent[3] = Math.max(extent[3], y);\\n}\\n\\n\\n/**\\n * This function calls `callback` for each corner of the extent. If the\\n * callback returns a truthy value the function returns that value\\n * immediately. Otherwise the function returns `false`.\\n * @param {module:ol/extent~Extent} extent Extent.\\n * @param {function(this:T, module:ol/coordinate~Coordinate): S} callback Callback.\\n * @param {T=} opt_this Value to use as `this` when executing `callback`.\\n * @return {S|boolean} Value.\\n * @template S, T\\n */\\nexport function forEachCorner(extent, callback, opt_this) {\\n  let val;\\n  val = callback.call(opt_this, getBottomLeft(extent));\\n  if (val) {\\n    return val;\\n  }\\n  val = callback.call(opt_this, getBottomRight(extent));\\n  if (val) {\\n    return val;\\n  }\\n  val = callback.call(opt_this, getTopRight(extent));\\n  if (val) {\\n    return val;\\n  }\\n  val = callback.call(opt_this, getTopLeft(extent));\\n  if (val) {\\n    return val;\\n  }\\n  return false;\\n}\\n\\n\\n/**\\n * Get the size of an extent.\\n * @param {module:ol/extent~Extent} extent Extent.\\n * @return {number} Area.\\n * @api\\n */\\nexport function getArea(extent) {\\n  let area = 0;\\n  if (!isEmpty(extent)) {\\n    area = getWidth(extent) * getHeight(extent);\\n  }\\n  return area;\\n}\\n\\n\\n/**\\n * Get the bottom left coordinate of an extent.\\n * @param {module:ol/extent~Extent} extent Extent.\\n * @return {module:ol/coordinate~Coordinate} Bottom left coordinate.\\n * @api\\n */\\nexport function getBottomLeft(extent) {\\n  return [extent[0], extent[1]];\\n}\\n\\n\\n/**\\n * Get the bottom right coordinate of an extent.\\n * @param {module:ol/extent~Extent} extent Extent.\\n * @return {module:ol/coordinate~Coordinate} Bottom right coordinate.\\n * @api\\n */\\nexport function getBottomRight(extent) {\\n  return [extent[2], extent[1]];\\n}\\n\\n\\n/**\\n * Get the center coordinate of an extent.\\n * @param {module:ol/extent~Extent} extent Extent.\\n * @return {module:ol/coordinate~Coordinate} Center.\\n * @api\\n */\\nexport function getCenter(extent) {\\n  return [(extent[0] + extent[2]) / 2, (extent[1] + extent[3]) / 2];\\n}\\n\\n\\n/**\\n * Get a corner coordinate of an extent.\\n * @param {module:ol/extent~Extent} extent Extent.\\n * @param {module:ol/extent/Corner} corner Corner.\\n * @return {module:ol/coordinate~Coordinate} Corner coordinate.\\n */\\nexport function getCorner(extent, corner) {\\n  let coordinate;\\n  if (corner === Corner.BOTTOM_LEFT) {\\n    coordinate = getBottomLeft(extent);\\n  } else if (corner === Corner.BOTTOM_RIGHT) {\\n    coordinate = getBottomRight(extent);\\n  } else if (corner === Corner.TOP_LEFT) {\\n    coordinate = getTopLeft(extent);\\n  } else if (corner === Corner.TOP_RIGHT) {\\n    coordinate = getTopRight(extent);\\n  } else {\\n    assert(false, 13); // Invalid corner\\n  }\\n  return (\\n    /** @type {!module:ol/coordinate~Coordinate} */ (coordinate)\\n  );\\n}\\n\\n\\n/**\\n * @param {module:ol/extent~Extent} extent1 Extent 1.\\n * @param {module:ol/extent~Extent} extent2 Extent 2.\\n * @return {number} Enlarged area.\\n */\\nexport function getEnlargedArea(extent1, extent2) {\\n  const minX = Math.min(extent1[0], extent2[0]);\\n  const minY = Math.min(extent1[1], extent2[1]);\\n  const maxX = Math.max(extent1[2], extent2[2]);\\n  const maxY = Math.max(extent1[3], extent2[3]);\\n  return (maxX - minX) * (maxY - minY);\\n}\\n\\n\\n/**\\n * @param {module:ol/coordinate~Coordinate} center Center.\\n * @param {number} resolution Resolution.\\n * @param {number} rotation Rotation.\\n * @param {module:ol/size~Size} size Size.\\n * @param {module:ol/extent~Extent=} opt_extent Destination extent.\\n * @return {module:ol/extent~Extent} Extent.\\n */\\nexport function getForViewAndSize(center, resolution, rotation, size, opt_extent) {\\n  const dx = resolution * size[0] / 2;\\n  const dy = resolution * size[1] / 2;\\n  const cosRotation = Math.cos(rotation);\\n  const sinRotation = Math.sin(rotation);\\n  const xCos = dx * cosRotation;\\n  const xSin = dx * sinRotation;\\n  const yCos = dy * cosRotation;\\n  const ySin = dy * sinRotation;\\n  const x = center[0];\\n  const y = center[1];\\n  const x0 = x - xCos + ySin;\\n  const x1 = x - xCos - ySin;\\n  const x2 = x + xCos - ySin;\\n  const x3 = x + xCos + ySin;\\n  const y0 = y - xSin - yCos;\\n  const y1 = y - xSin + yCos;\\n  const y2 = y + xSin + yCos;\\n  const y3 = y + xSin - yCos;\\n  return createOrUpdate(\\n    Math.min(x0, x1, x2, x3), Math.min(y0, y1, y2, y3),\\n    Math.max(x0, x1, x2, x3), Math.max(y0, y1, y2, y3),\\n    opt_extent);\\n}\\n\\n\\n/**\\n * Get the height of an extent.\\n * @param {module:ol/extent~Extent} extent Extent.\\n * @return {number} Height.\\n * @api\\n */\\nexport function getHeight(extent) {\\n  return extent[3] - extent[1];\\n}\\n\\n\\n/**\\n * @param {module:ol/extent~Extent} extent1 Extent 1.\\n * @param {module:ol/extent~Extent} extent2 Extent 2.\\n * @return {number} Intersection area.\\n */\\nexport function getIntersectionArea(extent1, extent2) {\\n  const intersection = getIntersection(extent1, extent2);\\n  return getArea(intersection);\\n}\\n\\n\\n/**\\n * Get the intersection of two extents.\\n * @param {module:ol/extent~Extent} extent1 Extent 1.\\n * @param {module:ol/extent~Extent} extent2 Extent 2.\\n * @param {module:ol/extent~Extent=} opt_extent Optional extent to populate with intersection.\\n * @return {module:ol/extent~Extent} Intersecting extent.\\n * @api\\n */\\nexport function getIntersection(extent1, extent2, opt_extent) {\\n  const intersection = opt_extent ? opt_extent : createEmpty();\\n  if (intersects(extent1, extent2)) {\\n    if (extent1[0] > extent2[0]) {\\n      intersection[0] = extent1[0];\\n    } else {\\n      intersection[0] = extent2[0];\\n    }\\n    if (extent1[1] > extent2[1]) {\\n      intersection[1] = extent1[1];\\n    } else {\\n      intersection[1] = extent2[1];\\n    }\\n    if (extent1[2] < extent2[2]) {\\n      intersection[2] = extent1[2];\\n    } else {\\n      intersection[2] = extent2[2];\\n    }\\n    if (extent1[3] < extent2[3]) {\\n      intersection[3] = extent1[3];\\n    } else {\\n      intersection[3] = extent2[3];\\n    }\\n  } else {\\n    createOrUpdateEmpty(intersection);\\n  }\\n  return intersection;\\n}\\n\\n\\n/**\\n * @param {module:ol/extent~Extent} extent Extent.\\n * @return {number} Margin.\\n */\\nexport function getMargin(extent) {\\n  return getWidth(extent) + getHeight(extent);\\n}\\n\\n\\n/**\\n * Get the size (width, height) of an extent.\\n * @param {module:ol/extent~Extent} extent The extent.\\n * @return {module:ol/size~Size} The extent size.\\n * @api\\n */\\nexport function getSize(extent) {\\n  return [extent[2] - extent[0], extent[3] - extent[1]];\\n}\\n\\n\\n/**\\n * Get the top left coordinate of an extent.\\n * @param {module:ol/extent~Extent} extent Extent.\\n * @return {module:ol/coordinate~Coordinate} Top left coordinate.\\n * @api\\n */\\nexport function getTopLeft(extent) {\\n  return [extent[0], extent[3]];\\n}\\n\\n\\n/**\\n * Get the top right coordinate of an extent.\\n * @param {module:ol/extent~Extent} extent Extent.\\n * @return {module:ol/coordinate~Coordinate} Top right coordinate.\\n * @api\\n */\\nexport function getTopRight(extent) {\\n  return [extent[2], extent[3]];\\n}\\n\\n\\n/**\\n * Get the width of an extent.\\n * @param {module:ol/extent~Extent} extent Extent.\\n * @return {number} Width.\\n * @api\\n */\\nexport function getWidth(extent) {\\n  return extent[2] - extent[0];\\n}\\n\\n\\n/**\\n * Determine if one extent intersects another.\\n * @param {module:ol/extent~Extent} extent1 Extent 1.\\n * @param {module:ol/extent~Extent} extent2 Extent.\\n * @return {boolean} The two extents intersect.\\n * @api\\n */\\nexport function intersects(extent1, extent2) {\\n  return extent1[0] <= extent2[2] &&\\n      extent1[2] >= extent2[0] &&\\n      extent1[1] <= extent2[3] &&\\n      extent1[3] >= extent2[1];\\n}\\n\\n\\n/**\\n * Determine if an extent is empty.\\n * @param {module:ol/extent~Extent} extent Extent.\\n * @return {boolean} Is empty.\\n * @api\\n */\\nexport function isEmpty(extent) {\\n  return extent[2] < extent[0] || extent[3] < extent[1];\\n}\\n\\n\\n/**\\n * @param {module:ol/extent~Extent} extent Extent.\\n * @param {module:ol/extent~Extent=} opt_extent Extent.\\n * @return {module:ol/extent~Extent} Extent.\\n */\\nexport function returnOrUpdate(extent, opt_extent) {\\n  if (opt_extent) {\\n    opt_extent[0] = extent[0];\\n    opt_extent[1] = extent[1];\\n    opt_extent[2] = extent[2];\\n    opt_extent[3] = extent[3];\\n    return opt_extent;\\n  } else {\\n    return extent;\\n  }\\n}\\n\\n\\n/**\\n * @param {module:ol/extent~Extent} extent Extent.\\n * @param {number} value Value.\\n */\\nexport function scaleFromCenter(extent, value) {\\n  const deltaX = ((extent[2] - extent[0]) / 2) * (value - 1);\\n  const deltaY = ((extent[3] - extent[1]) / 2) * (value - 1);\\n  extent[0] -= deltaX;\\n  extent[2] += deltaX;\\n  extent[1] -= deltaY;\\n  extent[3] += deltaY;\\n}\\n\\n\\n/**\\n * Determine if the segment between two coordinates intersects (crosses,\\n * touches, or is contained by) the provided extent.\\n * @param {module:ol/extent~Extent} extent The extent.\\n * @param {module:ol/coordinate~Coordinate} start Segment start coordinate.\\n * @param {module:ol/coordinate~Coordinate} end Segment end coordinate.\\n * @return {boolean} The segment intersects the extent.\\n */\\nexport function intersectsSegment(extent, start, end) {\\n  let intersects = false;\\n  const startRel = coordinateRelationship(extent, start);\\n  const endRel = coordinateRelationship(extent, end);\\n  if (startRel === Relationship.INTERSECTING ||\\n      endRel === Relationship.INTERSECTING) {\\n    intersects = true;\\n  } else {\\n    const minX = extent[0];\\n    const minY = extent[1];\\n    const maxX = extent[2];\\n    const maxY = extent[3];\\n    const startX = start[0];\\n    const startY = start[1];\\n    const endX = end[0];\\n    const endY = end[1];\\n    const slope = (endY - startY) / (endX - startX);\\n    let x, y;\\n    if (!!(endRel & Relationship.ABOVE) &&\\n        !(startRel & Relationship.ABOVE)) {\\n      // potentially intersects top\\n      x = endX - ((endY - maxY) / slope);\\n      intersects = x >= minX && x <= maxX;\\n    }\\n    if (!intersects && !!(endRel & Relationship.RIGHT) &&\\n        !(startRel & Relationship.RIGHT)) {\\n      // potentially intersects right\\n      y = endY - ((endX - maxX) * slope);\\n      intersects = y >= minY && y <= maxY;\\n    }\\n    if (!intersects && !!(endRel & Relationship.BELOW) &&\\n        !(startRel & Relationship.BELOW)) {\\n      // potentially intersects bottom\\n      x = endX - ((endY - minY) / slope);\\n      intersects = x >= minX && x <= maxX;\\n    }\\n    if (!intersects && !!(endRel & Relationship.LEFT) &&\\n        !(startRel & Relationship.LEFT)) {\\n      // potentially intersects left\\n      y = endY - ((endX - minX) * slope);\\n      intersects = y >= minY && y <= maxY;\\n    }\\n\\n  }\\n  return intersects;\\n}\\n\\n\\n/**\\n * Apply a transform function to the extent.\\n * @param {module:ol/extent~Extent} extent Extent.\\n * @param {module:ol/proj~TransformFunction} transformFn Transform function.\\n * Called with `[minX, minY, maxX, maxY]` extent coordinates.\\n * @param {module:ol/extent~Extent=} opt_extent Destination extent.\\n * @return {module:ol/extent~Extent} Extent.\\n * @api\\n */\\nexport function applyTransform(extent, transformFn, opt_extent) {\\n  const coordinates = [\\n    extent[0], extent[1],\\n    extent[0], extent[3],\\n    extent[2], extent[1],\\n    extent[2], extent[3]\\n  ];\\n  transformFn(coordinates, coordinates, 2);\\n  const xs = [coordinates[0], coordinates[2], coordinates[4], coordinates[6]];\\n  const ys = [coordinates[1], coordinates[3], coordinates[5], coordinates[7]];\\n  return _boundingExtentXYs(xs, ys, opt_extent);\\n}\\n\",\"/**\\n * @module ol/geom/flat/transform\\n */\\n\\n\\n/**\\n * @param {Array.<number>} flatCoordinates Flat coordinates.\\n * @param {number} offset Offset.\\n * @param {number} end End.\\n * @param {number} stride Stride.\\n * @param {module:ol/transform~Transform} transform Transform.\\n * @param {Array.<number>=} opt_dest Destination.\\n * @return {Array.<number>} Transformed coordinates.\\n */\\nexport function transform2D(flatCoordinates, offset, end, stride, transform, opt_dest) {\\n  const dest = opt_dest ? opt_dest : [];\\n  let i = 0;\\n  for (let j = offset; j < end; j += stride) {\\n    const x = flatCoordinates[j];\\n    const y = flatCoordinates[j + 1];\\n    dest[i++] = transform[0] * x + transform[2] * y + transform[4];\\n    dest[i++] = transform[1] * x + transform[3] * y + transform[5];\\n  }\\n  if (opt_dest && dest.length != i) {\\n    dest.length = i;\\n  }\\n  return dest;\\n}\\n\\n\\n/**\\n * @param {Array.<number>} flatCoordinates Flat coordinates.\\n * @param {number} offset Offset.\\n * @param {number} end End.\\n * @param {number} stride Stride.\\n * @param {number} angle Angle.\\n * @param {Array.<number>} anchor Rotation anchor point.\\n * @param {Array.<number>=} opt_dest Destination.\\n * @return {Array.<number>} Transformed coordinates.\\n */\\nexport function rotate(flatCoordinates, offset, end, stride, angle, anchor, opt_dest) {\\n  const dest = opt_dest ? opt_dest : [];\\n  const cos = Math.cos(angle);\\n  const sin = Math.sin(angle);\\n  const anchorX = anchor[0];\\n  const anchorY = anchor[1];\\n  let i = 0;\\n  for (let j = offset; j < end; j += stride) {\\n    const deltaX = flatCoordinates[j] - anchorX;\\n    const deltaY = flatCoordinates[j + 1] - anchorY;\\n    dest[i++] = anchorX + deltaX * cos - deltaY * sin;\\n    dest[i++] = anchorY + deltaX * sin + deltaY * cos;\\n    for (let k = j + 2; k < j + stride; ++k) {\\n      dest[i++] = flatCoordinates[k];\\n    }\\n  }\\n  if (opt_dest && dest.length != i) {\\n    dest.length = i;\\n  }\\n  return dest;\\n}\\n\\n\\n/**\\n * Scale the coordinates.\\n * @param {Array.<number>} flatCoordinates Flat coordinates.\\n * @param {number} offset Offset.\\n * @param {number} end End.\\n * @param {number} stride Stride.\\n * @param {number} sx Scale factor in the x-direction.\\n * @param {number} sy Scale factor in the y-direction.\\n * @param {Array.<number>} anchor Scale anchor point.\\n * @param {Array.<number>=} opt_dest Destination.\\n * @return {Array.<number>} Transformed coordinates.\\n */\\nexport function scale(flatCoordinates, offset, end, stride, sx, sy, anchor, opt_dest) {\\n  const dest = opt_dest ? opt_dest : [];\\n  const anchorX = anchor[0];\\n  const anchorY = anchor[1];\\n  let i = 0;\\n  for (let j = offset; j < end; j += stride) {\\n    const deltaX = flatCoordinates[j] - anchorX;\\n    const deltaY = flatCoordinates[j + 1] - anchorY;\\n    dest[i++] = anchorX + sx * deltaX;\\n    dest[i++] = anchorY + sy * deltaY;\\n    for (let k = j + 2; k < j + stride; ++k) {\\n      dest[i++] = flatCoordinates[k];\\n    }\\n  }\\n  if (opt_dest && dest.length != i) {\\n    dest.length = i;\\n  }\\n  return dest;\\n}\\n\\n\\n/**\\n * @param {Array.<number>} flatCoordinates Flat coordinates.\\n * @param {number} offset Offset.\\n * @param {number} end End.\\n * @param {number} stride Stride.\\n * @param {number} deltaX Delta X.\\n * @param {number} deltaY Delta Y.\\n * @param {Array.<number>=} opt_dest Destination.\\n * @return {Array.<number>} Transformed coordinates.\\n */\\nexport function translate(flatCoordinates, offset, end, stride, deltaX, deltaY, opt_dest) {\\n  const dest = opt_dest ? opt_dest : [];\\n  let i = 0;\\n  for (let j = offset; j < end; j += stride) {\\n    dest[i++] = flatCoordinates[j] + deltaX;\\n    dest[i++] = flatCoordinates[j + 1] + deltaY;\\n    for (let k = j + 2; k < j + stride; ++k) {\\n      dest[i++] = flatCoordinates[k];\\n    }\\n  }\\n  if (opt_dest && dest.length != i) {\\n    dest.length = i;\\n  }\\n  return dest;\\n}\\n\",\"/**\\n * @module ol/math\\n */\\nimport {assert} from './asserts.js';\\n\\n/**\\n * Takes a number and clamps it to within the provided bounds.\\n * @param {number} value The input number.\\n * @param {number} min The minimum value to return.\\n * @param {number} max The maximum value to return.\\n * @return {number} The input number if it is within bounds, or the nearest\\n *     number within the bounds.\\n */\\nexport function clamp(value, min, max) {\\n  return Math.min(Math.max(value, min), max);\\n}\\n\\n\\n/**\\n * Return the hyperbolic cosine of a given number. The method will use the\\n * native `Math.cosh` function if it is available, otherwise the hyperbolic\\n * cosine will be calculated via the reference implementation of the Mozilla\\n * developer network.\\n *\\n * @param {number} x X.\\n * @return {number} Hyperbolic cosine of x.\\n */\\nexport const cosh  = (function() {\\n  // Wrapped in a iife, to save the overhead of checking for the native\\n  // implementation on every invocation.\\n  let cosh;\\n  if ('cosh' in Math) {\\n    // The environment supports the native Math.cosh function, use it\\n    cosh = Math.cosh;\\n  } else {\\n    //  else, use the reference implementation of MDN:\\n    cosh = function(x) {\\n      const y = Math.exp(x);\\n      return (y + 1 / y) / 2;\\n    };\\n  }\\n  return cosh;\\n}());\\n\\n\\n/**\\n * @param {number} x X.\\n * @return {number} The smallest power of two greater than or equal to x.\\n */\\nexport function roundUpToPowerOfTwo(x) {\\n  assert(0 < x, 29); // `x` must be greater than `0`\\n  return Math.pow(2, Math.ceil(Math.log(x) / Math.LN2));\\n}\\n\\n\\n/**\\n * Returns the square of the closest distance between the point (x, y) and the\\n * line segment (x1, y1) to (x2, y2).\\n * @param {number} x X.\\n * @param {number} y Y.\\n * @param {number} x1 X1.\\n * @param {number} y1 Y1.\\n * @param {number} x2 X2.\\n * @param {number} y2 Y2.\\n * @return {number} Squared distance.\\n */\\nexport function squaredSegmentDistance(x, y, x1, y1, x2, y2) {\\n  const dx = x2 - x1;\\n  const dy = y2 - y1;\\n  if (dx !== 0 || dy !== 0) {\\n    const t = ((x - x1) * dx + (y - y1) * dy) / (dx * dx + dy * dy);\\n    if (t > 1) {\\n      x1 = x2;\\n      y1 = y2;\\n    } else if (t > 0) {\\n      x1 += dx * t;\\n      y1 += dy * t;\\n    }\\n  }\\n  return squaredDistance(x, y, x1, y1);\\n}\\n\\n\\n/**\\n * Returns the square of the distance between the points (x1, y1) and (x2, y2).\\n * @param {number} x1 X1.\\n * @param {number} y1 Y1.\\n * @param {number} x2 X2.\\n * @param {number} y2 Y2.\\n * @return {number} Squared distance.\\n */\\nexport function squaredDistance(x1, y1, x2, y2) {\\n  const dx = x2 - x1;\\n  const dy = y2 - y1;\\n  return dx * dx + dy * dy;\\n}\\n\\n\\n/**\\n * Solves system of linear equations using Gaussian elimination method.\\n *\\n * @param {Array.<Array.<number>>} mat Augmented matrix (n x n + 1 column)\\n *                                     in row-major order.\\n * @return {Array.<number>} The resulting vector.\\n */\\nexport function solveLinearSystem(mat) {\\n  const n = mat.length;\\n\\n  for (let i = 0; i < n; i++) {\\n    // Find max in the i-th column (ignoring i - 1 first rows)\\n    let maxRow = i;\\n    let maxEl = Math.abs(mat[i][i]);\\n    for (let r = i + 1; r < n; r++) {\\n      const absValue = Math.abs(mat[r][i]);\\n      if (absValue > maxEl) {\\n        maxEl = absValue;\\n        maxRow = r;\\n      }\\n    }\\n\\n    if (maxEl === 0) {\\n      return null; // matrix is singular\\n    }\\n\\n    // Swap max row with i-th (current) row\\n    const tmp = mat[maxRow];\\n    mat[maxRow] = mat[i];\\n    mat[i] = tmp;\\n\\n    // Subtract the i-th row to make all the remaining rows 0 in the i-th column\\n    for (let j = i + 1; j < n; j++) {\\n      const coef = -mat[j][i] / mat[i][i];\\n      for (let k = i; k < n + 1; k++) {\\n        if (i == k) {\\n          mat[j][k] = 0;\\n        } else {\\n          mat[j][k] += coef * mat[i][k];\\n        }\\n      }\\n    }\\n  }\\n\\n  // Solve Ax=b for upper triangular matrix A (mat)\\n  const x = new Array(n);\\n  for (let l = n - 1; l >= 0; l--) {\\n    x[l] = mat[l][n] / mat[l][l];\\n    for (let m = l - 1; m >= 0; m--) {\\n      mat[m][n] -= mat[m][l] * x[l];\\n    }\\n  }\\n  return x;\\n}\\n\\n\\n/**\\n * Converts radians to to degrees.\\n *\\n * @param {number} angleInRadians Angle in radians.\\n * @return {number} Angle in degrees.\\n */\\nexport function toDegrees(angleInRadians) {\\n  return angleInRadians * 180 / Math.PI;\\n}\\n\\n\\n/**\\n * Converts degrees to radians.\\n *\\n * @param {number} angleInDegrees Angle in degrees.\\n * @return {number} Angle in radians.\\n */\\nexport function toRadians(angleInDegrees) {\\n  return angleInDegrees * Math.PI / 180;\\n}\\n\\n/**\\n * Returns the modulo of a / b, depending on the sign of b.\\n *\\n * @param {number} a Dividend.\\n * @param {number} b Divisor.\\n * @return {number} Modulo.\\n */\\nexport function modulo(a, b) {\\n  const r = a % b;\\n  return r * b < 0 ? r + b : r;\\n}\\n\\n/**\\n * Calculates the linearly interpolated value of x between a and b.\\n *\\n * @param {number} a Number\\n * @param {number} b Number\\n * @param {number} x Value to be interpolated.\\n * @return {number} Interpolated value.\\n */\\nexport function lerp(a, b, x) {\\n  return a + x * (b - a);\\n}\\n\",\"/**\\n * @module ol/geom/GeometryType\\n */\\n\\n/**\\n * The geometry type. One of `'Point'`, `'LineString'`, `'LinearRing'`,\\n * `'Polygon'`, `'MultiPoint'`, `'MultiLineString'`, `'MultiPolygon'`,\\n * `'GeometryCollection'`, `'Circle'`.\\n * @enum {string}\\n */\\nexport default {\\n  POINT: 'Point',\\n  LINE_STRING: 'LineString',\\n  LINEAR_RING: 'LinearRing',\\n  POLYGON: 'Polygon',\\n  MULTI_POINT: 'MultiPoint',\\n  MULTI_LINE_STRING: 'MultiLineString',\\n  MULTI_POLYGON: 'MultiPolygon',\\n  GEOMETRY_COLLECTION: 'GeometryCollection',\\n  CIRCLE: 'Circle'\\n};\\n\",\"/**\\n * @license\\n * Latitude/longitude spherical geodesy formulae taken from\\n * http://www.movable-type.co.uk/scripts/latlong.html\\n * Licensed under CC-BY-3.0.\\n */\\n\\n/**\\n * @module ol/sphere\\n */\\nimport {toRadians, toDegrees} from './math.js';\\nimport GeometryType from './geom/GeometryType.js';\\n\\n\\n/**\\n * Object literal with options for the {@link getLength} or {@link getArea}\\n * functions.\\n * @typedef {Object} SphereMetricOptions\\n * @property {module:ol/proj~ProjectionLike} [projection='EPSG:3857']\\n * Projection of the  geometry.  By default, the geometry is assumed to be in\\n * Web Mercator.\\n * @property {number} [radius=6371008.8] Sphere radius.  By default, the radius of the\\n * earth is used (Clarke 1866 Authalic Sphere).\\n */\\n\\n\\n/**\\n * The mean Earth radius (1/3 * (2a + b)) for the WGS84 ellipsoid.\\n * https://en.wikipedia.org/wiki/Earth_radius#Mean_radius\\n * @type {number}\\n */\\nexport const DEFAULT_RADIUS = 6371008.8;\\n\\n\\n/**\\n * Get the great circle distance (in meters) between two geographic coordinates.\\n * @param {Array} c1 Starting coordinate.\\n * @param {Array} c2 Ending coordinate.\\n * @param {number=} opt_radius The sphere radius to use.  Defaults to the Earth's\\n *     mean radius using the WGS84 ellipsoid.\\n * @return {number} The great circle distance between the points (in meters).\\n * @api\\n */\\nexport function getDistance(c1, c2, opt_radius) {\\n  const radius = opt_radius || DEFAULT_RADIUS;\\n  const lat1 = toRadians(c1[1]);\\n  const lat2 = toRadians(c2[1]);\\n  const deltaLatBy2 = (lat2 - lat1) / 2;\\n  const deltaLonBy2 = toRadians(c2[0] - c1[0]) / 2;\\n  const a = Math.sin(deltaLatBy2) * Math.sin(deltaLatBy2) +\\n      Math.sin(deltaLonBy2) * Math.sin(deltaLonBy2) *\\n      Math.cos(lat1) * Math.cos(lat2);\\n  return 2 * radius * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));\\n}\\n\\n\\n/**\\n * Get the cumulative great circle length of linestring coordinates (geographic).\\n * @param {Array} coordinates Linestring coordinates.\\n * @param {number} radius The sphere radius to use.\\n * @return {number} The length (in meters).\\n */\\nfunction getLengthInternal(coordinates, radius) {\\n  let length = 0;\\n  for (let i = 0, ii = coordinates.length; i < ii - 1; ++i) {\\n    length += getDistance(coordinates[i], coordinates[i + 1], radius);\\n  }\\n  return length;\\n}\\n\\n\\n/**\\n * Get the spherical length of a geometry.  This length is the sum of the\\n * great circle distances between coordinates.  For polygons, the length is\\n * the sum of all rings.  For points, the length is zero.  For multi-part\\n * geometries, the length is the sum of the length of each part.\\n * @param {module:ol/geom/Geometry} geometry A geometry.\\n * @param {module:ol/sphere~SphereMetricOptions=} opt_options Options for the\\n * length calculation.  By default, geometries are assumed to be in 'EPSG:3857'.\\n * You can change this by providing a `projection` option.\\n * @return {number} The spherical length (in meters).\\n * @api\\n */\\nexport function getLength(geometry, opt_options) {\\n  const options = opt_options || {};\\n  const radius = options.radius || DEFAULT_RADIUS;\\n  const projection = options.projection || 'EPSG:3857';\\n  const type = geometry.getType();\\n  if (type !== GeometryType.GEOMETRY_COLLECTION) {\\n    geometry = geometry.clone().transform(projection, 'EPSG:4326');\\n  }\\n  let length = 0;\\n  let coordinates, coords, i, ii, j, jj;\\n  switch (type) {\\n    case GeometryType.POINT:\\n    case GeometryType.MULTI_POINT: {\\n      break;\\n    }\\n    case GeometryType.LINE_STRING:\\n    case GeometryType.LINEAR_RING: {\\n      coordinates = /** @type {module:ol/geom/SimpleGeometry} */ (geometry).getCoordinates();\\n      length = getLengthInternal(coordinates, radius);\\n      break;\\n    }\\n    case GeometryType.MULTI_LINE_STRING:\\n    case GeometryType.POLYGON: {\\n      coordinates = /** @type {module:ol/geom/SimpleGeometry} */ (geometry).getCoordinates();\\n      for (i = 0, ii = coordinates.length; i < ii; ++i) {\\n        length += getLengthInternal(coordinates[i], radius);\\n      }\\n      break;\\n    }\\n    case GeometryType.MULTI_POLYGON: {\\n      coordinates = /** @type {module:ol/geom/SimpleGeometry} */ (geometry).getCoordinates();\\n      for (i = 0, ii = coordinates.length; i < ii; ++i) {\\n        coords = coordinates[i];\\n        for (j = 0, jj = coords.length; j < jj; ++j) {\\n          length += getLengthInternal(coords[j], radius);\\n        }\\n      }\\n      break;\\n    }\\n    case GeometryType.GEOMETRY_COLLECTION: {\\n      const geometries = /** @type {module:ol/geom/GeometryCollection} */ (geometry).getGeometries();\\n      for (i = 0, ii = geometries.length; i < ii; ++i) {\\n        length += getLength(geometries[i], opt_options);\\n      }\\n      break;\\n    }\\n    default: {\\n      throw new Error('Unsupported geometry type: ' + type);\\n    }\\n  }\\n  return length;\\n}\\n\\n\\n/**\\n * Returns the spherical area for a list of coordinates.\\n *\\n * [Reference](https://trs-new.jpl.nasa.gov/handle/2014/40409)\\n * Robert. G. Chamberlain and William H. Duquette, \\\"Some Algorithms for\\n * Polygons on a Sphere\\\", JPL Publication 07-03, Jet Propulsion\\n * Laboratory, Pasadena, CA, June 2007\\n *\\n * @param {Array.<module:ol/coordinate~Coordinate>} coordinates List of coordinates of a linear\\n * ring. If the ring is oriented clockwise, the area will be positive,\\n * otherwise it will be negative.\\n * @param {number} radius The sphere radius.\\n * @return {number} Area (in square meters).\\n */\\nfunction getAreaInternal(coordinates, radius) {\\n  let area = 0;\\n  const len = coordinates.length;\\n  let x1 = coordinates[len - 1][0];\\n  let y1 = coordinates[len - 1][1];\\n  for (let i = 0; i < len; i++) {\\n    const x2 = coordinates[i][0];\\n    const y2 = coordinates[i][1];\\n    area += toRadians(x2 - x1) *\\n        (2 + Math.sin(toRadians(y1)) +\\n        Math.sin(toRadians(y2)));\\n    x1 = x2;\\n    y1 = y2;\\n  }\\n  return area * radius * radius / 2.0;\\n}\\n\\n\\n/**\\n * Get the spherical area of a geometry.  This is the area (in meters) assuming\\n * that polygon edges are segments of great circles on a sphere.\\n * @param {module:ol/geom/Geometry} geometry A geometry.\\n * @param {module:ol/sphere~SphereMetricOptions=} opt_options Options for the area\\n *     calculation.  By default, geometries are assumed to be in 'EPSG:3857'.\\n *     You can change this by providing a `projection` option.\\n * @return {number} The spherical area (in square meters).\\n * @api\\n */\\nexport function getArea(geometry, opt_options) {\\n  const options = opt_options || {};\\n  const radius = options.radius || DEFAULT_RADIUS;\\n  const projection = options.projection || 'EPSG:3857';\\n  const type = geometry.getType();\\n  if (type !== GeometryType.GEOMETRY_COLLECTION) {\\n    geometry = geometry.clone().transform(projection, 'EPSG:4326');\\n  }\\n  let area = 0;\\n  let coordinates, coords, i, ii, j, jj;\\n  switch (type) {\\n    case GeometryType.POINT:\\n    case GeometryType.MULTI_POINT:\\n    case GeometryType.LINE_STRING:\\n    case GeometryType.MULTI_LINE_STRING:\\n    case GeometryType.LINEAR_RING: {\\n      break;\\n    }\\n    case GeometryType.POLYGON: {\\n      coordinates = /** @type {module:ol/geom/Polygon} */ (geometry).getCoordinates();\\n      area = Math.abs(getAreaInternal(coordinates[0], radius));\\n      for (i = 1, ii = coordinates.length; i < ii; ++i) {\\n        area -= Math.abs(getAreaInternal(coordinates[i], radius));\\n      }\\n      break;\\n    }\\n    case GeometryType.MULTI_POLYGON: {\\n      coordinates = /** @type {module:ol/geom/SimpleGeometry} */ (geometry).getCoordinates();\\n      for (i = 0, ii = coordinates.length; i < ii; ++i) {\\n        coords = coordinates[i];\\n        area += Math.abs(getAreaInternal(coords[0], radius));\\n        for (j = 1, jj = coords.length; j < jj; ++j) {\\n          area -= Math.abs(getAreaInternal(coords[j], radius));\\n        }\\n      }\\n      break;\\n    }\\n    case GeometryType.GEOMETRY_COLLECTION: {\\n      const geometries = /** @type {module:ol/geom/GeometryCollection} */ (geometry).getGeometries();\\n      for (i = 0, ii = geometries.length; i < ii; ++i) {\\n        area += getArea(geometries[i], opt_options);\\n      }\\n      break;\\n    }\\n    default: {\\n      throw new Error('Unsupported geometry type: ' + type);\\n    }\\n  }\\n  return area;\\n}\\n\\n\\n/**\\n * Returns the coordinate at the given distance and bearing from `c1`.\\n *\\n * @param {module:ol/coordinate~Coordinate} c1 The origin point (`[lon, lat]` in degrees).\\n * @param {number} distance The great-circle distance between the origin\\n *     point and the target point.\\n * @param {number} bearing The bearing (in radians).\\n * @param {number=} opt_radius The sphere radius to use.  Defaults to the Earth's\\n *     mean radius using the WGS84 ellipsoid.\\n * @return {module:ol/coordinate~Coordinate} The target point.\\n */\\nexport function offset(c1, distance, bearing, opt_radius) {\\n  const radius = opt_radius || DEFAULT_RADIUS;\\n  const lat1 = toRadians(c1[1]);\\n  const lon1 = toRadians(c1[0]);\\n  const dByR = distance / radius;\\n  const lat = Math.asin(\\n    Math.sin(lat1) * Math.cos(dByR) +\\n      Math.cos(lat1) * Math.sin(dByR) * Math.cos(bearing));\\n  const lon = lon1 + Math.atan2(\\n    Math.sin(bearing) * Math.sin(dByR) * Math.cos(lat1),\\n    Math.cos(dByR) - Math.sin(lat1) * Math.sin(lat));\\n  return [toDegrees(lon), toDegrees(lat)];\\n}\\n\",\"/**\\n * @module ol/proj/Units\\n */\\n\\n/**\\n * Projection units: `'degrees'`, `'ft'`, `'m'`, `'pixels'`, `'tile-pixels'` or\\n * `'us-ft'`.\\n * @enum {string}\\n */\\nconst Units = {\\n  DEGREES: 'degrees',\\n  FEET: 'ft',\\n  METERS: 'm',\\n  PIXELS: 'pixels',\\n  TILE_PIXELS: 'tile-pixels',\\n  USFEET: 'us-ft'\\n};\\n\\n\\n/**\\n * Meters per unit lookup table.\\n * @const\\n * @type {Object.<module:ol/proj/Units, number>}\\n * @api\\n */\\nexport const METERS_PER_UNIT = {};\\n// use the radius of the Normal sphere\\nMETERS_PER_UNIT[Units.DEGREES] = 2 * Math.PI * 6370997 / 360;\\nMETERS_PER_UNIT[Units.FEET] = 0.3048;\\nMETERS_PER_UNIT[Units.METERS] = 1;\\nMETERS_PER_UNIT[Units.USFEET] = 1200 / 3937;\\n\\nexport default Units;\\n\",\"/**\\n * @module ol/proj/Projection\\n */\\nimport {METERS_PER_UNIT} from '../proj/Units.js';\\n\\n\\n/**\\n * @typedef {Object} Options\\n * @property {string} code The SRS identifier code, e.g. `EPSG:4326`.\\n * @property {module:ol/proj/Units|string} [units] Units. Required unless a\\n * proj4 projection is defined for `code`.\\n * @property {module:ol/extent~Extent} [extent] The validity extent for the SRS.\\n * @property {string} [axisOrientation='enu'] The axis orientation as specified in Proj4.\\n * @property {boolean} [global=false] Whether the projection is valid for the whole globe.\\n * @property {number} [metersPerUnit] The meters per unit for the SRS.\\n * If not provided, the `units` are used to get the meters per unit from the {@link module:ol/proj/Units~METERS_PER_UNIT}\\n * lookup table.\\n * @property {module:ol/extent~Extent} [worldExtent] The world extent for the SRS.\\n * @property {function(number, module:ol/coordinate~Coordinate):number} [getPointResolution]\\n * Function to determine resolution at a point. The function is called with a\\n * `{number}` view resolution and an `{module:ol/coordinate~Coordinate}` as arguments, and returns\\n * the `{number}` resolution at the passed coordinate. If this is `undefined`,\\n * the default {@link module:ol/proj#getPointResolution} function will be used.\\n */\\n\\n\\n/**\\n * @classdesc\\n * Projection definition class. One of these is created for each projection\\n * supported in the application and stored in the {@link module:ol/proj} namespace.\\n * You can use these in applications, but this is not required, as API params\\n * and options use {@link module:ol/proj~ProjectionLike} which means the simple string\\n * code will suffice.\\n *\\n * You can use {@link module:ol/proj~get} to retrieve the object for a particular\\n * projection.\\n *\\n * The library includes definitions for `EPSG:4326` and `EPSG:3857`, together\\n * with the following aliases:\\n * * `EPSG:4326`: CRS:84, urn:ogc:def:crs:EPSG:6.6:4326,\\n *     urn:ogc:def:crs:OGC:1.3:CRS84, urn:ogc:def:crs:OGC:2:84,\\n *     http://www.opengis.net/gml/srs/epsg.xml#4326,\\n *     urn:x-ogc:def:crs:EPSG:4326\\n * * `EPSG:3857`: EPSG:102100, EPSG:102113, EPSG:900913,\\n *     urn:ogc:def:crs:EPSG:6.18:3:3857,\\n *     http://www.opengis.net/gml/srs/epsg.xml#3857\\n *\\n * If you use proj4js, aliases can be added using `proj4.defs()`; see\\n * [documentation](https://github.com/proj4js/proj4js). To set an alternative\\n * namespace for proj4, use {@link module:ol/proj~setProj4}.\\n *\\n * @constructor\\n * @param {module:ol/proj/Projection~Options} options Projection options.\\n * @struct\\n * @api\\n */\\nconst Projection = function(options) {\\n  /**\\n   * @private\\n   * @type {string}\\n   */\\n  this.code_ = options.code;\\n\\n  /**\\n   * Units of projected coordinates. When set to `TILE_PIXELS`, a\\n   * `this.extent_` and `this.worldExtent_` must be configured properly for each\\n   * tile.\\n   * @private\\n   * @type {module:ol/proj/Units}\\n   */\\n  this.units_ = /** @type {module:ol/proj/Units} */ (options.units);\\n\\n  /**\\n   * Validity extent of the projection in projected coordinates. For projections\\n   * with `TILE_PIXELS` units, this is the extent of the tile in\\n   * tile pixel space.\\n   * @private\\n   * @type {module:ol/extent~Extent}\\n   */\\n  this.extent_ = options.extent !== undefined ? options.extent : null;\\n\\n  /**\\n   * Extent of the world in EPSG:4326. For projections with\\n   * `TILE_PIXELS` units, this is the extent of the tile in\\n   * projected coordinate space.\\n   * @private\\n   * @type {module:ol/extent~Extent}\\n   */\\n  this.worldExtent_ = options.worldExtent !== undefined ?\\n    options.worldExtent : null;\\n\\n  /**\\n   * @private\\n   * @type {string}\\n   */\\n  this.axisOrientation_ = options.axisOrientation !== undefined ?\\n    options.axisOrientation : 'enu';\\n\\n  /**\\n   * @private\\n   * @type {boolean}\\n   */\\n  this.global_ = options.global !== undefined ? options.global : false;\\n\\n  /**\\n   * @private\\n   * @type {boolean}\\n   */\\n  this.canWrapX_ = !!(this.global_ && this.extent_);\\n\\n  /**\\n   * @private\\n   * @type {function(number, module:ol/coordinate~Coordinate):number|undefined}\\n   */\\n  this.getPointResolutionFunc_ = options.getPointResolution;\\n\\n  /**\\n   * @private\\n   * @type {module:ol/tilegrid/TileGrid}\\n   */\\n  this.defaultTileGrid_ = null;\\n\\n  /**\\n   * @private\\n   * @type {number|undefined}\\n   */\\n  this.metersPerUnit_ = options.metersPerUnit;\\n};\\n\\n\\n/**\\n * @return {boolean} The projection is suitable for wrapping the x-axis\\n */\\nProjection.prototype.canWrapX = function() {\\n  return this.canWrapX_;\\n};\\n\\n\\n/**\\n * Get the code for this projection, e.g. 'EPSG:4326'.\\n * @return {string} Code.\\n * @api\\n */\\nProjection.prototype.getCode = function() {\\n  return this.code_;\\n};\\n\\n\\n/**\\n * Get the validity extent for this projection.\\n * @return {module:ol/extent~Extent} Extent.\\n * @api\\n */\\nProjection.prototype.getExtent = function() {\\n  return this.extent_;\\n};\\n\\n\\n/**\\n * Get the units of this projection.\\n * @return {module:ol/proj/Units} Units.\\n * @api\\n */\\nProjection.prototype.getUnits = function() {\\n  return this.units_;\\n};\\n\\n\\n/**\\n * Get the amount of meters per unit of this projection.  If the projection is\\n * not configured with `metersPerUnit` or a units identifier, the return is\\n * `undefined`.\\n * @return {number|undefined} Meters.\\n * @api\\n */\\nProjection.prototype.getMetersPerUnit = function() {\\n  return this.metersPerUnit_ || METERS_PER_UNIT[this.units_];\\n};\\n\\n\\n/**\\n * Get the world extent for this projection.\\n * @return {module:ol/extent~Extent} Extent.\\n * @api\\n */\\nProjection.prototype.getWorldExtent = function() {\\n  return this.worldExtent_;\\n};\\n\\n\\n/**\\n * Get the axis orientation of this projection.\\n * Example values are:\\n * enu - the default easting, northing, elevation.\\n * neu - northing, easting, up - useful for \\\"lat/long\\\" geographic coordinates,\\n *     or south orientated transverse mercator.\\n * wnu - westing, northing, up - some planetary coordinate systems have\\n *     \\\"west positive\\\" coordinate systems\\n * @return {string} Axis orientation.\\n * @api\\n */\\nProjection.prototype.getAxisOrientation = function() {\\n  return this.axisOrientation_;\\n};\\n\\n\\n/**\\n * Is this projection a global projection which spans the whole world?\\n * @return {boolean} Whether the projection is global.\\n * @api\\n */\\nProjection.prototype.isGlobal = function() {\\n  return this.global_;\\n};\\n\\n\\n/**\\n* Set if the projection is a global projection which spans the whole world\\n* @param {boolean} global Whether the projection is global.\\n* @api\\n*/\\nProjection.prototype.setGlobal = function(global) {\\n  this.global_ = global;\\n  this.canWrapX_ = !!(global && this.extent_);\\n};\\n\\n\\n/**\\n * @return {module:ol/tilegrid/TileGrid} The default tile grid.\\n */\\nProjection.prototype.getDefaultTileGrid = function() {\\n  return this.defaultTileGrid_;\\n};\\n\\n\\n/**\\n * @param {module:ol/tilegrid/TileGrid} tileGrid The default tile grid.\\n */\\nProjection.prototype.setDefaultTileGrid = function(tileGrid) {\\n  this.defaultTileGrid_ = tileGrid;\\n};\\n\\n\\n/**\\n * Set the validity extent for this projection.\\n * @param {module:ol/extent~Extent} extent Extent.\\n * @api\\n */\\nProjection.prototype.setExtent = function(extent) {\\n  this.extent_ = extent;\\n  this.canWrapX_ = !!(this.global_ && extent);\\n};\\n\\n\\n/**\\n * Set the world extent for this projection.\\n * @param {module:ol/extent~Extent} worldExtent World extent\\n *     [minlon, minlat, maxlon, maxlat].\\n * @api\\n */\\nProjection.prototype.setWorldExtent = function(worldExtent) {\\n  this.worldExtent_ = worldExtent;\\n};\\n\\n\\n/**\\n * Set the getPointResolution function (see {@link module:ol/proj~getPointResolution}\\n * for this projection.\\n * @param {function(number, module:ol/coordinate~Coordinate):number} func Function\\n * @api\\n */\\nProjection.prototype.setGetPointResolution = function(func) {\\n  this.getPointResolutionFunc_ = func;\\n};\\n\\n\\n/**\\n * Get the custom point resolution function for this projection (if set).\\n * @return {function(number, module:ol/coordinate~Coordinate):number|undefined} The custom point\\n * resolution function (if set).\\n */\\nProjection.prototype.getPointResolutionFunc = function() {\\n  return this.getPointResolutionFunc_;\\n};\\nexport default Projection;\\n\",\"/**\\n * @module ol/proj/epsg3857\\n */\\nimport {inherits} from '../index.js';\\nimport {cosh} from '../math.js';\\nimport Projection from '../proj/Projection.js';\\nimport Units from '../proj/Units.js';\\n\\n\\n/**\\n * Radius of WGS84 sphere\\n *\\n * @const\\n * @type {number}\\n */\\nexport const RADIUS = 6378137;\\n\\n\\n/**\\n * @const\\n * @type {number}\\n */\\nexport const HALF_SIZE = Math.PI * RADIUS;\\n\\n\\n/**\\n * @const\\n * @type {module:ol/extent~Extent}\\n */\\nexport const EXTENT = [\\n  -HALF_SIZE, -HALF_SIZE,\\n  HALF_SIZE, HALF_SIZE\\n];\\n\\n\\n/**\\n * @const\\n * @type {module:ol/extent~Extent}\\n */\\nexport const WORLD_EXTENT = [-180, -85, 180, 85];\\n\\n\\n/**\\n * @classdesc\\n * Projection object for web/spherical Mercator (EPSG:3857).\\n *\\n * @constructor\\n * @extends {module:ol/proj/Projection}\\n * @param {string} code Code.\\n */\\nfunction EPSG3857Projection(code) {\\n  Projection.call(this, {\\n    code: code,\\n    units: Units.METERS,\\n    extent: EXTENT,\\n    global: true,\\n    worldExtent: WORLD_EXTENT,\\n    getPointResolution: function(resolution, point) {\\n      return resolution / cosh(point[1] / RADIUS);\\n    }\\n  });\\n}\\ninherits(EPSG3857Projection, Projection);\\n\\n\\n/**\\n * Projections equal to EPSG:3857.\\n *\\n * @const\\n * @type {Array.<module:ol/proj/Projection>}\\n */\\nexport const PROJECTIONS = [\\n  new EPSG3857Projection('EPSG:3857'),\\n  new EPSG3857Projection('EPSG:102100'),\\n  new EPSG3857Projection('EPSG:102113'),\\n  new EPSG3857Projection('EPSG:900913'),\\n  new EPSG3857Projection('urn:ogc:def:crs:EPSG:6.18:3:3857'),\\n  new EPSG3857Projection('urn:ogc:def:crs:EPSG::3857'),\\n  new EPSG3857Projection('http://www.opengis.net/gml/srs/epsg.xml#3857')\\n];\\n\\n\\n/**\\n * Transformation from EPSG:4326 to EPSG:3857.\\n *\\n * @param {Array.<number>} input Input array of coordinate values.\\n * @param {Array.<number>=} opt_output Output array of coordinate values.\\n * @param {number=} opt_dimension Dimension (default is `2`).\\n * @return {Array.<number>} Output array of coordinate values.\\n */\\nexport function fromEPSG4326(input, opt_output, opt_dimension) {\\n  const length = input.length;\\n  const dimension = opt_dimension > 1 ? opt_dimension : 2;\\n  let output = opt_output;\\n  if (output === undefined) {\\n    if (dimension > 2) {\\n      // preserve values beyond second dimension\\n      output = input.slice();\\n    } else {\\n      output = new Array(length);\\n    }\\n  }\\n  const halfSize = HALF_SIZE;\\n  for (let i = 0; i < length; i += dimension) {\\n    output[i] = halfSize * input[i] / 180;\\n    let y = RADIUS *\\n        Math.log(Math.tan(Math.PI * (input[i + 1] + 90) / 360));\\n    if (y > halfSize) {\\n      y = halfSize;\\n    } else if (y < -halfSize) {\\n      y = -halfSize;\\n    }\\n    output[i + 1] = y;\\n  }\\n  return output;\\n}\\n\\n\\n/**\\n * Transformation from EPSG:3857 to EPSG:4326.\\n *\\n * @param {Array.<number>} input Input array of coordinate values.\\n * @param {Array.<number>=} opt_output Output array of coordinate values.\\n * @param {number=} opt_dimension Dimension (default is `2`).\\n * @return {Array.<number>} Output array of coordinate values.\\n */\\nexport function toEPSG4326(input, opt_output, opt_dimension) {\\n  const length = input.length;\\n  const dimension = opt_dimension > 1 ? opt_dimension : 2;\\n  let output = opt_output;\\n  if (output === undefined) {\\n    if (dimension > 2) {\\n      // preserve values beyond second dimension\\n      output = input.slice();\\n    } else {\\n      output = new Array(length);\\n    }\\n  }\\n  for (let i = 0; i < length; i += dimension) {\\n    output[i] = 180 * input[i] / HALF_SIZE;\\n    output[i + 1] = 360 * Math.atan(\\n      Math.exp(input[i + 1] / RADIUS)) / Math.PI - 90;\\n  }\\n  return output;\\n}\\n\",\"/**\\n * @module ol/proj/epsg4326\\n */\\nimport {inherits} from '../index.js';\\nimport Projection from '../proj/Projection.js';\\nimport Units from '../proj/Units.js';\\n\\n\\n/**\\n * Semi-major radius of the WGS84 ellipsoid.\\n *\\n * @const\\n * @type {number}\\n */\\nexport const RADIUS = 6378137;\\n\\n\\n/**\\n * Extent of the EPSG:4326 projection which is the whole world.\\n *\\n * @const\\n * @type {module:ol/extent~Extent}\\n */\\nexport const EXTENT = [-180, -90, 180, 90];\\n\\n\\n/**\\n * @const\\n * @type {number}\\n */\\nexport const METERS_PER_UNIT = Math.PI * RADIUS / 180;\\n\\n\\n/**\\n * @classdesc\\n * Projection object for WGS84 geographic coordinates (EPSG:4326).\\n *\\n * Note that OpenLayers does not strictly comply with the EPSG definition.\\n * The EPSG registry defines 4326 as a CRS for Latitude,Longitude (y,x).\\n * OpenLayers treats EPSG:4326 as a pseudo-projection, with x,y coordinates.\\n *\\n * @constructor\\n * @extends {module:ol/proj/Projection}\\n * @param {string} code Code.\\n * @param {string=} opt_axisOrientation Axis orientation.\\n */\\nfunction EPSG4326Projection(code, opt_axisOrientation) {\\n  Projection.call(this, {\\n    code: code,\\n    units: Units.DEGREES,\\n    extent: EXTENT,\\n    axisOrientation: opt_axisOrientation,\\n    global: true,\\n    metersPerUnit: METERS_PER_UNIT,\\n    worldExtent: EXTENT\\n  });\\n}\\ninherits(EPSG4326Projection, Projection);\\n\\n\\n/**\\n * Projections equal to EPSG:4326.\\n *\\n * @const\\n * @type {Array.<module:ol/proj/Projection>}\\n */\\nexport const PROJECTIONS = [\\n  new EPSG4326Projection('CRS:84'),\\n  new EPSG4326Projection('EPSG:4326', 'neu'),\\n  new EPSG4326Projection('urn:ogc:def:crs:EPSG::4326', 'neu'),\\n  new EPSG4326Projection('urn:ogc:def:crs:EPSG:6.6:4326', 'neu'),\\n  new EPSG4326Projection('urn:ogc:def:crs:OGC:1.3:CRS84'),\\n  new EPSG4326Projection('urn:ogc:def:crs:OGC:2:84'),\\n  new EPSG4326Projection('http://www.opengis.net/gml/srs/epsg.xml#4326', 'neu'),\\n  new EPSG4326Projection('urn:x-ogc:def:crs:EPSG:4326', 'neu')\\n];\\n\",\"/**\\n * @module ol/proj/projections\\n */\\n\\n\\n/**\\n * @type {Object.<string, module:ol/proj/Projection>}\\n */\\nlet cache = {};\\n\\n\\n/**\\n * Clear the projections cache.\\n */\\nexport function clear() {\\n  cache = {};\\n}\\n\\n\\n/**\\n * Get a cached projection by code.\\n * @param {string} code The code for the projection.\\n * @return {module:ol/proj/Projection} The projection (if cached).\\n */\\nexport function get(code) {\\n  return cache[code] || null;\\n}\\n\\n\\n/**\\n * Add a projection to the cache.\\n * @param {string} code The projection code.\\n * @param {module:ol/proj/Projection} projection The projection to cache.\\n */\\nexport function add(code, projection) {\\n  cache[code] = projection;\\n}\\n\",\"/**\\n * @module ol/proj/transforms\\n */\\nimport {isEmpty} from '../obj.js';\\n\\n\\n/**\\n * @private\\n * @type {!Object.<string, Object.<string, module:ol/proj~TransformFunction>>}\\n */\\nlet transforms = {};\\n\\n\\n/**\\n * Clear the transform cache.\\n */\\nexport function clear() {\\n  transforms = {};\\n}\\n\\n\\n/**\\n * Registers a conversion function to convert coordinates from the source\\n * projection to the destination projection.\\n *\\n * @param {module:ol/proj/Projection} source Source.\\n * @param {module:ol/proj/Projection} destination Destination.\\n * @param {module:ol/proj~TransformFunction} transformFn Transform.\\n */\\nexport function add(source, destination, transformFn) {\\n  const sourceCode = source.getCode();\\n  const destinationCode = destination.getCode();\\n  if (!(sourceCode in transforms)) {\\n    transforms[sourceCode] = {};\\n  }\\n  transforms[sourceCode][destinationCode] = transformFn;\\n}\\n\\n\\n/**\\n * Unregisters the conversion function to convert coordinates from the source\\n * projection to the destination projection.  This method is used to clean up\\n * cached transforms during testing.\\n *\\n * @param {module:ol/proj/Projection} source Source projection.\\n * @param {module:ol/proj/Projection} destination Destination projection.\\n * @return {module:ol/proj~TransformFunction} transformFn The unregistered transform.\\n */\\nexport function remove(source, destination) {\\n  const sourceCode = source.getCode();\\n  const destinationCode = destination.getCode();\\n  const transform = transforms[sourceCode][destinationCode];\\n  delete transforms[sourceCode][destinationCode];\\n  if (isEmpty(transforms[sourceCode])) {\\n    delete transforms[sourceCode];\\n  }\\n  return transform;\\n}\\n\\n\\n/**\\n * Get a transform given a source code and a destination code.\\n * @param {string} sourceCode The code for the source projection.\\n * @param {string} destinationCode The code for the destination projection.\\n * @return {module:ol/proj~TransformFunction|undefined} The transform function (if found).\\n */\\nexport function get(sourceCode, destinationCode) {\\n  let transform;\\n  if (sourceCode in transforms && destinationCode in transforms[sourceCode]) {\\n    transform = transforms[sourceCode][destinationCode];\\n  }\\n  return transform;\\n}\\n\",\"/**\\n * @module ol/proj\\n */\\n\\n/**\\n * The ol/proj module stores:\\n * * a list of {@link module:ol/proj/Projection}\\n * objects, one for each projection supported by the application\\n * * a list of transform functions needed to convert coordinates in one projection\\n * into another.\\n *\\n * The static functions are the methods used to maintain these.\\n * Each transform function can handle not only simple coordinate pairs, but also\\n * large arrays of coordinates such as vector geometries.\\n *\\n * When loaded, the library adds projection objects for EPSG:4326 (WGS84\\n * geographic coordinates) and EPSG:3857 (Web or Spherical Mercator, as used\\n * for example by Bing Maps or OpenStreetMap), together with the relevant\\n * transform functions.\\n *\\n * Additional transforms may be added by using the {@link http://proj4js.org/}\\n * library (version 2.2 or later). You can use the full build supplied by\\n * Proj4js, or create a custom build to support those projections you need; see\\n * the Proj4js website for how to do this. You also need the Proj4js definitions\\n * for the required projections. These definitions can be obtained from\\n * {@link https://epsg.io/}, and are a JS function, so can be loaded in a script\\n * tag (as in the examples) or pasted into your application.\\n *\\n * After all required projection definitions are added to proj4's registry (by\\n * using `proj4.defs()`), simply call `register(proj4)` from the `ol/proj/proj4`\\n * package. Existing transforms are not changed by this function. See\\n * examples/wms-image-custom-proj for an example of this.\\n *\\n * Additional projection definitions can be registered with `proj4.defs()` any\\n * time. Just make sure to call `register(proj4)` again; for example, with user-supplied data where you don't\\n * know in advance what projections are needed, you can initially load minimal\\n * support and then load whichever are requested.\\n *\\n * Note that Proj4js does not support projection extents. If you want to add\\n * one for creating default tile grids, you can add it after the Projection\\n * object has been created with `setExtent`, for example,\\n * `get('EPSG:1234').setExtent(extent)`.\\n *\\n * In addition to Proj4js support, any transform functions can be added with\\n * {@link module:ol/proj~addCoordinateTransforms}. To use this, you must first create\\n * a {@link module:ol/proj/Projection} object for the new projection and add it with\\n * {@link module:ol/proj~addProjection}. You can then add the forward and inverse\\n * functions with {@link module:ol/proj~addCoordinateTransforms}. See\\n * examples/wms-custom-proj for an example of this.\\n *\\n * Note that if no transforms are needed and you only need to define the\\n * projection, just add a {@link module:ol/proj/Projection} with\\n * {@link module:ol/proj~addProjection}. See examples/wms-no-proj for an example of\\n * this.\\n */\\nimport {getDistance} from './sphere.js';\\nimport {applyTransform} from './extent.js';\\nimport {modulo} from './math.js';\\nimport {toEPSG4326, fromEPSG4326, PROJECTIONS as EPSG3857_PROJECTIONS} from './proj/epsg3857.js';\\nimport {PROJECTIONS as EPSG4326_PROJECTIONS} from './proj/epsg4326.js';\\nimport Projection from './proj/Projection.js';\\nimport Units, {METERS_PER_UNIT} from './proj/Units.js';\\nimport * as projections from './proj/projections.js';\\nimport {add as addTransformFunc, clear as clearTransformFuncs, get as getTransformFunc} from './proj/transforms.js';\\n\\n\\n/**\\n * A projection as {@link module:ol/proj/Projection}, SRS identifier\\n * string or undefined.\\n * @typedef {module:ol/proj/Projection|string|undefined} ProjectionLike\\n * @api\\n */\\n\\n\\n/**\\n * A transform function accepts an array of input coordinate values, an optional\\n * output array, and an optional dimension (default should be 2).  The function\\n * transforms the input coordinate values, populates the output array, and\\n * returns the output array.\\n *\\n * @typedef {function(Array.<number>, Array.<number>=, number=): Array.<number>} TransformFunction\\n * @api\\n */\\n\\n\\nexport {METERS_PER_UNIT};\\n\\n\\n/**\\n * @param {Array.<number>} input Input coordinate array.\\n * @param {Array.<number>=} opt_output Output array of coordinate values.\\n * @param {number=} opt_dimension Dimension.\\n * @return {Array.<number>} Output coordinate array (new array, same coordinate\\n *     values).\\n */\\nexport function cloneTransform(input, opt_output, opt_dimension) {\\n  let output;\\n  if (opt_output !== undefined) {\\n    for (let i = 0, ii = input.length; i < ii; ++i) {\\n      opt_output[i] = input[i];\\n    }\\n    output = opt_output;\\n  } else {\\n    output = input.slice();\\n  }\\n  return output;\\n}\\n\\n\\n/**\\n * @param {Array.<number>} input Input coordinate array.\\n * @param {Array.<number>=} opt_output Output array of coordinate values.\\n * @param {number=} opt_dimension Dimension.\\n * @return {Array.<number>} Input coordinate array (same array as input).\\n */\\nexport function identityTransform(input, opt_output, opt_dimension) {\\n  if (opt_output !== undefined && input !== opt_output) {\\n    for (let i = 0, ii = input.length; i < ii; ++i) {\\n      opt_output[i] = input[i];\\n    }\\n    input = opt_output;\\n  }\\n  return input;\\n}\\n\\n\\n/**\\n * Add a Projection object to the list of supported projections that can be\\n * looked up by their code.\\n *\\n * @param {module:ol/proj/Projection} projection Projection instance.\\n * @api\\n */\\nexport function addProjection(projection) {\\n  projections.add(projection.getCode(), projection);\\n  addTransformFunc(projection, projection, cloneTransform);\\n}\\n\\n\\n/**\\n * @param {Array.<module:ol/proj/Projection>} projections Projections.\\n */\\nexport function addProjections(projections) {\\n  projections.forEach(addProjection);\\n}\\n\\n\\n/**\\n * Fetches a Projection object for the code specified.\\n *\\n * @param {module:ol/proj~ProjectionLike} projectionLike Either a code string which is\\n *     a combination of authority and identifier such as \\\"EPSG:4326\\\", or an\\n *     existing projection object, or undefined.\\n * @return {module:ol/proj/Projection} Projection object, or null if not in list.\\n * @api\\n */\\nexport function get(projectionLike) {\\n  let projection = null;\\n  if (projectionLike instanceof Projection) {\\n    projection = projectionLike;\\n  } else if (typeof projectionLike === 'string') {\\n    const code = projectionLike;\\n    projection = projections.get(code);\\n  }\\n  return projection;\\n}\\n\\n\\n/**\\n * Get the resolution of the point in degrees or distance units.\\n * For projections with degrees as the unit this will simply return the\\n * provided resolution. For other projections the point resolution is\\n * by default estimated by transforming the 'point' pixel to EPSG:4326,\\n * measuring its width and height on the normal sphere,\\n * and taking the average of the width and height.\\n * A custom function can be provided for a specific projection, either\\n * by setting the `getPointResolution` option in the\\n * {@link module:ol/proj/Projection~Projection} constructor or by using\\n * {@link module:ol/proj/Projection~Projection#setGetPointResolution} to change an existing\\n * projection object.\\n * @param {module:ol/proj~ProjectionLike} projection The projection.\\n * @param {number} resolution Nominal resolution in projection units.\\n * @param {module:ol/coordinate~Coordinate} point Point to find adjusted resolution at.\\n * @param {module:ol/proj/Units=} opt_units Units to get the point resolution in.\\n * Default is the projection's units.\\n * @return {number} Point resolution.\\n * @api\\n */\\nexport function getPointResolution(projection, resolution, point, opt_units) {\\n  projection = get(projection);\\n  let pointResolution;\\n  const getter = projection.getPointResolutionFunc();\\n  if (getter) {\\n    pointResolution = getter(resolution, point);\\n  } else {\\n    const units = projection.getUnits();\\n    if (units == Units.DEGREES && !opt_units || opt_units == Units.DEGREES) {\\n      pointResolution = resolution;\\n    } else {\\n      // Estimate point resolution by transforming the center pixel to EPSG:4326,\\n      // measuring its width and height on the normal sphere, and taking the\\n      // average of the width and height.\\n      const toEPSG4326 = getTransformFromProjections(projection, get('EPSG:4326'));\\n      let vertices = [\\n        point[0] - resolution / 2, point[1],\\n        point[0] + resolution / 2, point[1],\\n        point[0], point[1] - resolution / 2,\\n        point[0], point[1] + resolution / 2\\n      ];\\n      vertices = toEPSG4326(vertices, vertices, 2);\\n      const width = getDistance(vertices.slice(0, 2), vertices.slice(2, 4));\\n      const height = getDistance(vertices.slice(4, 6), vertices.slice(6, 8));\\n      pointResolution = (width + height) / 2;\\n      const metersPerUnit = opt_units ?\\n        METERS_PER_UNIT[opt_units] :\\n        projection.getMetersPerUnit();\\n      if (metersPerUnit !== undefined) {\\n        pointResolution /= metersPerUnit;\\n      }\\n    }\\n  }\\n  return pointResolution;\\n}\\n\\n\\n/**\\n * Registers transformation functions that don't alter coordinates. Those allow\\n * to transform between projections with equal meaning.\\n *\\n * @param {Array.<module:ol/proj/Projection>} projections Projections.\\n * @api\\n */\\nexport function addEquivalentProjections(projections) {\\n  addProjections(projections);\\n  projections.forEach(function(source) {\\n    projections.forEach(function(destination) {\\n      if (source !== destination) {\\n        addTransformFunc(source, destination, cloneTransform);\\n      }\\n    });\\n  });\\n}\\n\\n\\n/**\\n * Registers transformation functions to convert coordinates in any projection\\n * in projection1 to any projection in projection2.\\n *\\n * @param {Array.<module:ol/proj/Projection>} projections1 Projections with equal\\n *     meaning.\\n * @param {Array.<module:ol/proj/Projection>} projections2 Projections with equal\\n *     meaning.\\n * @param {module:ol/proj~TransformFunction} forwardTransform Transformation from any\\n *   projection in projection1 to any projection in projection2.\\n * @param {module:ol/proj~TransformFunction} inverseTransform Transform from any projection\\n *   in projection2 to any projection in projection1..\\n */\\nexport function addEquivalentTransforms(projections1, projections2, forwardTransform, inverseTransform) {\\n  projections1.forEach(function(projection1) {\\n    projections2.forEach(function(projection2) {\\n      addTransformFunc(projection1, projection2, forwardTransform);\\n      addTransformFunc(projection2, projection1, inverseTransform);\\n    });\\n  });\\n}\\n\\n\\n/**\\n * Clear all cached projections and transforms.\\n */\\nexport function clearAllProjections() {\\n  projections.clear();\\n  clearTransformFuncs();\\n}\\n\\n\\n/**\\n * @param {module:ol/proj/Projection|string|undefined} projection Projection.\\n * @param {string} defaultCode Default code.\\n * @return {module:ol/proj/Projection} Projection.\\n */\\nexport function createProjection(projection, defaultCode) {\\n  if (!projection) {\\n    return get(defaultCode);\\n  } else if (typeof projection === 'string') {\\n    return get(projection);\\n  } else {\\n    return (\\n      /** @type {module:ol/proj/Projection} */ (projection)\\n    );\\n  }\\n}\\n\\n\\n/**\\n * Creates a {@link module:ol/proj~TransformFunction} from a simple 2D coordinate transform\\n * function.\\n * @param {function(module:ol/coordinate~Coordinate): module:ol/coordinate~Coordinate} coordTransform Coordinate\\n *     transform.\\n * @return {module:ol/proj~TransformFunction} Transform function.\\n */\\nexport function createTransformFromCoordinateTransform(coordTransform) {\\n  return (\\n    /**\\n     * @param {Array.<number>} input Input.\\n     * @param {Array.<number>=} opt_output Output.\\n     * @param {number=} opt_dimension Dimension.\\n     * @return {Array.<number>} Output.\\n     */\\n    function(input, opt_output, opt_dimension) {\\n      const length = input.length;\\n      const dimension = opt_dimension !== undefined ? opt_dimension : 2;\\n      const output = opt_output !== undefined ? opt_output : new Array(length);\\n      for (let i = 0; i < length; i += dimension) {\\n        const point = coordTransform([input[i], input[i + 1]]);\\n        output[i] = point[0];\\n        output[i + 1] = point[1];\\n        for (let j = dimension - 1; j >= 2; --j) {\\n          output[i + j] = input[i + j];\\n        }\\n      }\\n      return output;\\n    });\\n}\\n\\n\\n/**\\n * Registers coordinate transform functions to convert coordinates between the\\n * source projection and the destination projection.\\n * The forward and inverse functions convert coordinate pairs; this function\\n * converts these into the functions used internally which also handle\\n * extents and coordinate arrays.\\n *\\n * @param {module:ol/proj~ProjectionLike} source Source projection.\\n * @param {module:ol/proj~ProjectionLike} destination Destination projection.\\n * @param {function(module:ol/coordinate~Coordinate): module:ol/coordinate~Coordinate} forward The forward transform\\n *     function (that is, from the source projection to the destination\\n *     projection) that takes a {@link module:ol/coordinate~Coordinate} as argument and returns\\n *     the transformed {@link module:ol/coordinate~Coordinate}.\\n * @param {function(module:ol/coordinate~Coordinate): module:ol/coordinate~Coordinate} inverse The inverse transform\\n *     function (that is, from the destination projection to the source\\n *     projection) that takes a {@link module:ol/coordinate~Coordinate} as argument and returns\\n *     the transformed {@link module:ol/coordinate~Coordinate}.\\n * @api\\n */\\nexport function addCoordinateTransforms(source, destination, forward, inverse) {\\n  const sourceProj = get(source);\\n  const destProj = get(destination);\\n  addTransformFunc(sourceProj, destProj, createTransformFromCoordinateTransform(forward));\\n  addTransformFunc(destProj, sourceProj, createTransformFromCoordinateTransform(inverse));\\n}\\n\\n\\n/**\\n * Transforms a coordinate from longitude/latitude to a different projection.\\n * @param {module:ol/coordinate~Coordinate} coordinate Coordinate as longitude and latitude, i.e.\\n *     an array with longitude as 1st and latitude as 2nd element.\\n * @param {module:ol/proj~ProjectionLike=} opt_projection Target projection. The\\n *     default is Web Mercator, i.e. 'EPSG:3857'.\\n * @return {module:ol/coordinate~Coordinate} Coordinate projected to the target projection.\\n * @api\\n */\\nexport function fromLonLat(coordinate, opt_projection) {\\n  return transform(coordinate, 'EPSG:4326',\\n    opt_projection !== undefined ? opt_projection : 'EPSG:3857');\\n}\\n\\n\\n/**\\n * Transforms a coordinate to longitude/latitude.\\n * @param {module:ol/coordinate~Coordinate} coordinate Projected coordinate.\\n * @param {module:ol/proj~ProjectionLike=} opt_projection Projection of the coordinate.\\n *     The default is Web Mercator, i.e. 'EPSG:3857'.\\n * @return {module:ol/coordinate~Coordinate} Coordinate as longitude and latitude, i.e. an array\\n *     with longitude as 1st and latitude as 2nd element.\\n * @api\\n */\\nexport function toLonLat(coordinate, opt_projection) {\\n  const lonLat = transform(coordinate,\\n    opt_projection !== undefined ? opt_projection : 'EPSG:3857', 'EPSG:4326');\\n  const lon = lonLat[0];\\n  if (lon < -180 || lon > 180) {\\n    lonLat[0] = modulo(lon + 180, 360) - 180;\\n  }\\n  return lonLat;\\n}\\n\\n\\n/**\\n * Checks if two projections are the same, that is every coordinate in one\\n * projection does represent the same geographic point as the same coordinate in\\n * the other projection.\\n *\\n * @param {module:ol/proj/Projection} projection1 Projection 1.\\n * @param {module:ol/proj/Projection} projection2 Projection 2.\\n * @return {boolean} Equivalent.\\n * @api\\n */\\nexport function equivalent(projection1, projection2) {\\n  if (projection1 === projection2) {\\n    return true;\\n  }\\n  const equalUnits = projection1.getUnits() === projection2.getUnits();\\n  if (projection1.getCode() === projection2.getCode()) {\\n    return equalUnits;\\n  } else {\\n    const transformFunc = getTransformFromProjections(projection1, projection2);\\n    return transformFunc === cloneTransform && equalUnits;\\n  }\\n}\\n\\n\\n/**\\n * Searches in the list of transform functions for the function for converting\\n * coordinates from the source projection to the destination projection.\\n *\\n * @param {module:ol/proj/Projection} sourceProjection Source Projection object.\\n * @param {module:ol/proj/Projection} destinationProjection Destination Projection\\n *     object.\\n * @return {module:ol/proj~TransformFunction} Transform function.\\n */\\nexport function getTransformFromProjections(sourceProjection, destinationProjection) {\\n  const sourceCode = sourceProjection.getCode();\\n  const destinationCode = destinationProjection.getCode();\\n  let transformFunc = getTransformFunc(sourceCode, destinationCode);\\n  if (!transformFunc) {\\n    transformFunc = identityTransform;\\n  }\\n  return transformFunc;\\n}\\n\\n\\n/**\\n * Given the projection-like objects, searches for a transformation\\n * function to convert a coordinates array from the source projection to the\\n * destination projection.\\n *\\n * @param {module:ol/proj~ProjectionLike} source Source.\\n * @param {module:ol/proj~ProjectionLike} destination Destination.\\n * @return {module:ol/proj~TransformFunction} Transform function.\\n * @api\\n */\\nexport function getTransform(source, destination) {\\n  const sourceProjection = get(source);\\n  const destinationProjection = get(destination);\\n  return getTransformFromProjections(sourceProjection, destinationProjection);\\n}\\n\\n\\n/**\\n * Transforms a coordinate from source projection to destination projection.\\n * This returns a new coordinate (and does not modify the original).\\n *\\n * See {@link module:ol/proj~transformExtent} for extent transformation.\\n * See the transform method of {@link module:ol/geom/Geometry~Geometry} and its\\n * subclasses for geometry transforms.\\n *\\n * @param {module:ol/coordinate~Coordinate} coordinate Coordinate.\\n * @param {module:ol/proj~ProjectionLike} source Source projection-like.\\n * @param {module:ol/proj~ProjectionLike} destination Destination projection-like.\\n * @return {module:ol/coordinate~Coordinate} Coordinate.\\n * @api\\n */\\nexport function transform(coordinate, source, destination) {\\n  const transformFunc = getTransform(source, destination);\\n  return transformFunc(coordinate, undefined, coordinate.length);\\n}\\n\\n\\n/**\\n * Transforms an extent from source projection to destination projection.  This\\n * returns a new extent (and does not modify the original).\\n *\\n * @param {module:ol/extent~Extent} extent The extent to transform.\\n * @param {module:ol/proj~ProjectionLike} source Source projection-like.\\n * @param {module:ol/proj~ProjectionLike} destination Destination projection-like.\\n * @return {module:ol/extent~Extent} The transformed extent.\\n * @api\\n */\\nexport function transformExtent(extent, source, destination) {\\n  const transformFunc = getTransform(source, destination);\\n  return applyTransform(extent, transformFunc);\\n}\\n\\n\\n/**\\n * Transforms the given point to the destination projection.\\n *\\n * @param {module:ol/coordinate~Coordinate} point Point.\\n * @param {module:ol/proj/Projection} sourceProjection Source projection.\\n * @param {module:ol/proj/Projection} destinationProjection Destination projection.\\n * @return {module:ol/coordinate~Coordinate} Point.\\n */\\nexport function transformWithProjections(point, sourceProjection, destinationProjection) {\\n  const transformFunc = getTransformFromProjections(sourceProjection, destinationProjection);\\n  return transformFunc(point);\\n}\\n\\n/**\\n * Add transforms to and from EPSG:4326 and EPSG:3857.  This function is called\\n * by when this module is executed and should only need to be called again after\\n * `clearAllProjections()` is called (e.g. in tests).\\n */\\nexport function addCommon() {\\n  // Add transformations that don't alter coordinates to convert within set of\\n  // projections with equal meaning.\\n  addEquivalentProjections(EPSG3857_PROJECTIONS);\\n  addEquivalentProjections(EPSG4326_PROJECTIONS);\\n  // Add transformations to convert EPSG:4326 like coordinates to EPSG:3857 like\\n  // coordinates and back.\\n  addEquivalentTransforms(EPSG4326_PROJECTIONS, EPSG3857_PROJECTIONS, fromEPSG4326, toEPSG4326);\\n}\\n\\naddCommon();\\n\",\"/**\\n * @module ol/transform\\n */\\nimport {assert} from './asserts.js';\\n\\n\\n/**\\n * An array representing an affine 2d transformation for use with\\n * {@link module:ol/transform} functions. The array has 6 elements.\\n * @typedef {!Array.<number>} Transform\\n */\\n\\n\\n/**\\n * Collection of affine 2d transformation functions. The functions work on an\\n * array of 6 elements. The element order is compatible with the [SVGMatrix\\n * interface](https://developer.mozilla.org/en-US/docs/Web/API/SVGMatrix) and is\\n * a subset (elements a to f) of a 33 matrix:\\n * ```\\n * [ a c e ]\\n * [ b d f ]\\n * [ 0 0 1 ]\\n * ```\\n */\\n\\n\\n/**\\n * @private\\n * @type {module:ol/transform~Transform}\\n */\\nconst tmp_ = new Array(6);\\n\\n\\n/**\\n * Create an identity transform.\\n * @return {!module:ol/transform~Transform} Identity transform.\\n */\\nexport function create() {\\n  return [1, 0, 0, 1, 0, 0];\\n}\\n\\n\\n/**\\n * Resets the given transform to an identity transform.\\n * @param {!module:ol/transform~Transform} transform Transform.\\n * @return {!module:ol/transform~Transform} Transform.\\n */\\nexport function reset(transform) {\\n  return set(transform, 1, 0, 0, 1, 0, 0);\\n}\\n\\n\\n/**\\n * Multiply the underlying matrices of two transforms and return the result in\\n * the first transform.\\n * @param {!module:ol/transform~Transform} transform1 Transform parameters of matrix 1.\\n * @param {!module:ol/transform~Transform} transform2 Transform parameters of matrix 2.\\n * @return {!module:ol/transform~Transform} transform1 multiplied with transform2.\\n */\\nexport function multiply(transform1, transform2) {\\n  const a1 = transform1[0];\\n  const b1 = transform1[1];\\n  const c1 = transform1[2];\\n  const d1 = transform1[3];\\n  const e1 = transform1[4];\\n  const f1 = transform1[5];\\n  const a2 = transform2[0];\\n  const b2 = transform2[1];\\n  const c2 = transform2[2];\\n  const d2 = transform2[3];\\n  const e2 = transform2[4];\\n  const f2 = transform2[5];\\n\\n  transform1[0] = a1 * a2 + c1 * b2;\\n  transform1[1] = b1 * a2 + d1 * b2;\\n  transform1[2] = a1 * c2 + c1 * d2;\\n  transform1[3] = b1 * c2 + d1 * d2;\\n  transform1[4] = a1 * e2 + c1 * f2 + e1;\\n  transform1[5] = b1 * e2 + d1 * f2 + f1;\\n\\n  return transform1;\\n}\\n\\n/**\\n * Set the transform components a-f on a given transform.\\n * @param {!module:ol/transform~Transform} transform Transform.\\n * @param {number} a The a component of the transform.\\n * @param {number} b The b component of the transform.\\n * @param {number} c The c component of the transform.\\n * @param {number} d The d component of the transform.\\n * @param {number} e The e component of the transform.\\n * @param {number} f The f component of the transform.\\n * @return {!module:ol/transform~Transform} Matrix with transform applied.\\n */\\nexport function set(transform, a, b, c, d, e, f) {\\n  transform[0] = a;\\n  transform[1] = b;\\n  transform[2] = c;\\n  transform[3] = d;\\n  transform[4] = e;\\n  transform[5] = f;\\n  return transform;\\n}\\n\\n\\n/**\\n * Set transform on one matrix from another matrix.\\n * @param {!module:ol/transform~Transform} transform1 Matrix to set transform to.\\n * @param {!module:ol/transform~Transform} transform2 Matrix to set transform from.\\n * @return {!module:ol/transform~Transform} transform1 with transform from transform2 applied.\\n */\\nexport function setFromArray(transform1, transform2) {\\n  transform1[0] = transform2[0];\\n  transform1[1] = transform2[1];\\n  transform1[2] = transform2[2];\\n  transform1[3] = transform2[3];\\n  transform1[4] = transform2[4];\\n  transform1[5] = transform2[5];\\n  return transform1;\\n}\\n\\n\\n/**\\n * Transforms the given coordinate with the given transform returning the\\n * resulting, transformed coordinate. The coordinate will be modified in-place.\\n *\\n * @param {module:ol/transform~Transform} transform The transformation.\\n * @param {module:ol/coordinate~Coordinate|module:ol~Pixel} coordinate The coordinate to transform.\\n * @return {module:ol/coordinate~Coordinate|module:ol~Pixel} return coordinate so that operations can be\\n *     chained together.\\n */\\nexport function apply(transform, coordinate) {\\n  const x = coordinate[0];\\n  const y = coordinate[1];\\n  coordinate[0] = transform[0] * x + transform[2] * y + transform[4];\\n  coordinate[1] = transform[1] * x + transform[3] * y + transform[5];\\n  return coordinate;\\n}\\n\\n\\n/**\\n * Applies rotation to the given transform.\\n * @param {!module:ol/transform~Transform} transform Transform.\\n * @param {number} angle Angle in radians.\\n * @return {!module:ol/transform~Transform} The rotated transform.\\n */\\nexport function rotate(transform, angle) {\\n  const cos = Math.cos(angle);\\n  const sin = Math.sin(angle);\\n  return multiply(transform, set(tmp_, cos, sin, -sin, cos, 0, 0));\\n}\\n\\n\\n/**\\n * Applies scale to a given transform.\\n * @param {!module:ol/transform~Transform} transform Transform.\\n * @param {number} x Scale factor x.\\n * @param {number} y Scale factor y.\\n * @return {!module:ol/transform~Transform} The scaled transform.\\n */\\nexport function scale(transform, x, y) {\\n  return multiply(transform, set(tmp_, x, 0, 0, y, 0, 0));\\n}\\n\\n\\n/**\\n * Applies translation to the given transform.\\n * @param {!module:ol/transform~Transform} transform Transform.\\n * @param {number} dx Translation x.\\n * @param {number} dy Translation y.\\n * @return {!module:ol/transform~Transform} The translated transform.\\n */\\nexport function translate(transform, dx, dy) {\\n  return multiply(transform, set(tmp_, 1, 0, 0, 1, dx, dy));\\n}\\n\\n\\n/**\\n * Creates a composite transform given an initial translation, scale, rotation, and\\n * final translation (in that order only, not commutative).\\n * @param {!module:ol/transform~Transform} transform The transform (will be modified in place).\\n * @param {number} dx1 Initial translation x.\\n * @param {number} dy1 Initial translation y.\\n * @param {number} sx Scale factor x.\\n * @param {number} sy Scale factor y.\\n * @param {number} angle Rotation (in counter-clockwise radians).\\n * @param {number} dx2 Final translation x.\\n * @param {number} dy2 Final translation y.\\n * @return {!module:ol/transform~Transform} The composite transform.\\n */\\nexport function compose(transform, dx1, dy1, sx, sy, angle, dx2, dy2) {\\n  const sin = Math.sin(angle);\\n  const cos = Math.cos(angle);\\n  transform[0] = sx * cos;\\n  transform[1] = sy * sin;\\n  transform[2] = -sx * sin;\\n  transform[3] = sy * cos;\\n  transform[4] = dx2 * sx * cos - dy2 * sx * sin + dx1;\\n  transform[5] = dx2 * sy * sin + dy2 * sy * cos + dy1;\\n  return transform;\\n}\\n\\n\\n/**\\n * Invert the given transform.\\n * @param {!module:ol/transform~Transform} transform Transform.\\n * @return {!module:ol/transform~Transform} Inverse of the transform.\\n */\\nexport function invert(transform) {\\n  const det = determinant(transform);\\n  assert(det !== 0, 32); // Transformation matrix cannot be inverted\\n\\n  const a = transform[0];\\n  const b = transform[1];\\n  const c = transform[2];\\n  const d = transform[3];\\n  const e = transform[4];\\n  const f = transform[5];\\n\\n  transform[0] = d / det;\\n  transform[1] = -b / det;\\n  transform[2] = -c / det;\\n  transform[3] = a / det;\\n  transform[4] = (c * f - d * e) / det;\\n  transform[5] = -(a * f - b * e) / det;\\n\\n  return transform;\\n}\\n\\n\\n/**\\n * Returns the determinant of the given matrix.\\n * @param {!module:ol/transform~Transform} mat Matrix.\\n * @return {number} Determinant.\\n */\\nexport function determinant(mat) {\\n  return mat[0] * mat[3] - mat[1] * mat[2];\\n}\\n\",\"/**\\n * @module ol/geom/Geometry\\n */\\nimport {inherits} from '../index.js';\\nimport BaseObject from '../Object.js';\\nimport {createEmpty, getHeight, returnOrUpdate} from '../extent.js';\\nimport {FALSE} from '../functions.js';\\nimport {transform2D} from '../geom/flat/transform.js';\\nimport {get as getProjection, getTransform} from '../proj.js';\\nimport Units from '../proj/Units.js';\\nimport {create as createTransform, compose as composeTransform} from '../transform.js';\\n\\n\\n/**\\n * @classdesc\\n * Abstract base class; normally only used for creating subclasses and not\\n * instantiated in apps.\\n * Base class for vector geometries.\\n *\\n * To get notified of changes to the geometry, register a listener for the\\n * generic `change` event on your geometry instance.\\n *\\n * @constructor\\n * @abstract\\n * @extends {module:ol/Object}\\n * @api\\n */\\nconst Geometry = function() {\\n\\n  BaseObject.call(this);\\n\\n  /**\\n   * @private\\n   * @type {module:ol/extent~Extent}\\n   */\\n  this.extent_ = createEmpty();\\n\\n  /**\\n   * @private\\n   * @type {number}\\n   */\\n  this.extentRevision_ = -1;\\n\\n  /**\\n   * @protected\\n   * @type {Object.<string, module:ol/geom/Geometry>}\\n   */\\n  this.simplifiedGeometryCache = {};\\n\\n  /**\\n   * @protected\\n   * @type {number}\\n   */\\n  this.simplifiedGeometryMaxMinSquaredTolerance = 0;\\n\\n  /**\\n   * @protected\\n   * @type {number}\\n   */\\n  this.simplifiedGeometryRevision = 0;\\n\\n};\\n\\ninherits(Geometry, BaseObject);\\n\\n\\n/**\\n * @type {module:ol/transform~Transform}\\n */\\nconst tmpTransform = createTransform();\\n\\n\\n/**\\n * Make a complete copy of the geometry.\\n * @abstract\\n * @return {!module:ol/geom/Geometry} Clone.\\n */\\nGeometry.prototype.clone = function() {};\\n\\n\\n/**\\n * @abstract\\n * @param {number} x X.\\n * @param {number} y Y.\\n * @param {module:ol/coordinate~Coordinate} closestPoint Closest point.\\n * @param {number} minSquaredDistance Minimum squared distance.\\n * @return {number} Minimum squared distance.\\n */\\nGeometry.prototype.closestPointXY = function(x, y, closestPoint, minSquaredDistance) {};\\n\\n\\n/**\\n * Return the closest point of the geometry to the passed point as\\n * {@link module:ol/coordinate~Coordinate coordinate}.\\n * @param {module:ol/coordinate~Coordinate} point Point.\\n * @param {module:ol/coordinate~Coordinate=} opt_closestPoint Closest point.\\n * @return {module:ol/coordinate~Coordinate} Closest point.\\n * @api\\n */\\nGeometry.prototype.getClosestPoint = function(point, opt_closestPoint) {\\n  const closestPoint = opt_closestPoint ? opt_closestPoint : [NaN, NaN];\\n  this.closestPointXY(point[0], point[1], closestPoint, Infinity);\\n  return closestPoint;\\n};\\n\\n\\n/**\\n * Returns true if this geometry includes the specified coordinate. If the\\n * coordinate is on the boundary of the geometry, returns false.\\n * @param {module:ol/coordinate~Coordinate} coordinate Coordinate.\\n * @return {boolean} Contains coordinate.\\n * @api\\n */\\nGeometry.prototype.intersectsCoordinate = function(coordinate) {\\n  return this.containsXY(coordinate[0], coordinate[1]);\\n};\\n\\n\\n/**\\n * @abstract\\n * @param {module:ol/extent~Extent} extent Extent.\\n * @protected\\n * @return {module:ol/extent~Extent} extent Extent.\\n */\\nGeometry.prototype.computeExtent = function(extent) {};\\n\\n\\n/**\\n * @param {number} x X.\\n * @param {number} y Y.\\n * @return {boolean} Contains (x, y).\\n */\\nGeometry.prototype.containsXY = FALSE;\\n\\n\\n/**\\n * Get the extent of the geometry.\\n * @param {module:ol/extent~Extent=} opt_extent Extent.\\n * @return {module:ol/extent~Extent} extent Extent.\\n * @api\\n */\\nGeometry.prototype.getExtent = function(opt_extent) {\\n  if (this.extentRevision_ != this.getRevision()) {\\n    this.extent_ = this.computeExtent(this.extent_);\\n    this.extentRevision_ = this.getRevision();\\n  }\\n  return returnOrUpdate(this.extent_, opt_extent);\\n};\\n\\n\\n/**\\n * Rotate the geometry around a given coordinate. This modifies the geometry\\n * coordinates in place.\\n * @abstract\\n * @param {number} angle Rotation angle in radians.\\n * @param {module:ol/coordinate~Coordinate} anchor The rotation center.\\n * @api\\n */\\nGeometry.prototype.rotate = function(angle, anchor) {};\\n\\n\\n/**\\n * Scale the geometry (with an optional origin).  This modifies the geometry\\n * coordinates in place.\\n * @abstract\\n * @param {number} sx The scaling factor in the x-direction.\\n * @param {number=} opt_sy The scaling factor in the y-direction (defaults to\\n *     sx).\\n * @param {module:ol/coordinate~Coordinate=} opt_anchor The scale origin (defaults to the center\\n *     of the geometry extent).\\n * @api\\n */\\nGeometry.prototype.scale = function(sx, opt_sy, opt_anchor) {};\\n\\n\\n/**\\n * Create a simplified version of this geometry.  For linestrings, this uses\\n * the the {@link\\n * https://en.wikipedia.org/wiki/Ramer-Douglas-Peucker_algorithm\\n * Douglas Peucker} algorithm.  For polygons, a quantization-based\\n * simplification is used to preserve topology.\\n * @function\\n * @param {number} tolerance The tolerance distance for simplification.\\n * @return {module:ol/geom/Geometry} A new, simplified version of the original\\n *     geometry.\\n * @api\\n */\\nGeometry.prototype.simplify = function(tolerance) {\\n  return this.getSimplifiedGeometry(tolerance * tolerance);\\n};\\n\\n\\n/**\\n * Create a simplified version of this geometry using the Douglas Peucker\\n * algorithm.\\n * @see https://en.wikipedia.org/wiki/Ramer-Douglas-Peucker_algorithm\\n * @abstract\\n * @param {number} squaredTolerance Squared tolerance.\\n * @return {module:ol/geom/Geometry} Simplified geometry.\\n */\\nGeometry.prototype.getSimplifiedGeometry = function(squaredTolerance) {};\\n\\n\\n/**\\n * Get the type of this geometry.\\n * @abstract\\n * @return {module:ol/geom/GeometryType} Geometry type.\\n */\\nGeometry.prototype.getType = function() {};\\n\\n\\n/**\\n * Apply a transform function to each coordinate of the geometry.\\n * The geometry is modified in place.\\n * If you do not want the geometry modified in place, first `clone()` it and\\n * then use this function on the clone.\\n * @abstract\\n * @param {module:ol/proj~TransformFunction} transformFn Transform.\\n */\\nGeometry.prototype.applyTransform = function(transformFn) {};\\n\\n\\n/**\\n * Test if the geometry and the passed extent intersect.\\n * @abstract\\n * @param {module:ol/extent~Extent} extent Extent.\\n * @return {boolean} `true` if the geometry and the extent intersect.\\n */\\nGeometry.prototype.intersectsExtent = function(extent) {};\\n\\n\\n/**\\n * Translate the geometry.  This modifies the geometry coordinates in place.  If\\n * instead you want a new geometry, first `clone()` this geometry.\\n * @abstract\\n * @param {number} deltaX Delta X.\\n * @param {number} deltaY Delta Y.\\n */\\nGeometry.prototype.translate = function(deltaX, deltaY) {};\\n\\n\\n/**\\n * Transform each coordinate of the geometry from one coordinate reference\\n * system to another. The geometry is modified in place.\\n * For example, a line will be transformed to a line and a circle to a circle.\\n * If you do not want the geometry modified in place, first `clone()` it and\\n * then use this function on the clone.\\n *\\n * @param {module:ol/proj~ProjectionLike} source The current projection.  Can be a\\n *     string identifier or a {@link module:ol/proj/Projection~Projection} object.\\n * @param {module:ol/proj~ProjectionLike} destination The desired projection.  Can be a\\n *     string identifier or a {@link module:ol/proj/Projection~Projection} object.\\n * @return {module:ol/geom/Geometry} This geometry.  Note that original geometry is\\n *     modified in place.\\n * @api\\n */\\nGeometry.prototype.transform = function(source, destination) {\\n  source = getProjection(source);\\n  const transformFn = source.getUnits() == Units.TILE_PIXELS ?\\n    function(inCoordinates, outCoordinates, stride) {\\n      const pixelExtent = source.getExtent();\\n      const projectedExtent = source.getWorldExtent();\\n      const scale = getHeight(projectedExtent) / getHeight(pixelExtent);\\n      composeTransform(tmpTransform,\\n        projectedExtent[0], projectedExtent[3],\\n        scale, -scale, 0,\\n        0, 0);\\n      transform2D(inCoordinates, 0, inCoordinates.length, stride,\\n        tmpTransform, outCoordinates);\\n      return getTransform(source, destination)(inCoordinates, outCoordinates, stride);\\n    } :\\n    getTransform(source, destination);\\n  this.applyTransform(transformFn);\\n  return this;\\n};\\nexport default Geometry;\\n\",\"/**\\n * @module ol/color\\n */\\nimport {assert} from './asserts.js';\\nimport {clamp} from './math.js';\\n\\n\\n/**\\n * A color represented as a short array [red, green, blue, alpha].\\n * red, green, and blue should be integers in the range 0..255 inclusive.\\n * alpha should be a float in the range 0..1 inclusive. If no alpha value is\\n * given then `1` will be used.\\n * @typedef {Array.<number>} Color\\n * @api\\n */\\n\\n\\n/**\\n * This RegExp matches # followed by 3, 4, 6, or 8 hex digits.\\n * @const\\n * @type {RegExp}\\n * @private\\n */\\nconst HEX_COLOR_RE_ = /^#([a-f0-9]{3}|[a-f0-9]{4}(?:[a-f0-9]{2}){0,2})$/i;\\n\\n\\n/**\\n * Regular expression for matching potential named color style strings.\\n * @const\\n * @type {RegExp}\\n * @private\\n */\\nconst NAMED_COLOR_RE_ = /^([a-z]*)$/i;\\n\\n\\n/**\\n * Return the color as an rgba string.\\n * @param {module:ol/color~Color|string} color Color.\\n * @return {string} Rgba string.\\n * @api\\n */\\nexport function asString(color) {\\n  if (typeof color === 'string') {\\n    return color;\\n  } else {\\n    return toString(color);\\n  }\\n}\\n\\n/**\\n * Return named color as an rgba string.\\n * @param {string} color Named color.\\n * @return {string} Rgb string.\\n */\\nfunction fromNamed(color) {\\n  const el = document.createElement('div');\\n  el.style.color = color;\\n  if (el.style.color !== '') {\\n    document.body.appendChild(el);\\n    const rgb = getComputedStyle(el).color;\\n    document.body.removeChild(el);\\n    return rgb;\\n  } else {\\n    return '';\\n  }\\n}\\n\\n\\n/**\\n * @param {string} s String.\\n * @return {module:ol/color~Color} Color.\\n */\\nexport const fromString = (\\n  function() {\\n\\n    // We maintain a small cache of parsed strings.  To provide cheap LRU-like\\n    // semantics, whenever the cache grows too large we simply delete an\\n    // arbitrary 25% of the entries.\\n\\n    /**\\n     * @const\\n     * @type {number}\\n     */\\n    const MAX_CACHE_SIZE = 1024;\\n\\n    /**\\n     * @type {Object.<string, module:ol/color~Color>}\\n     */\\n    const cache = {};\\n\\n    /**\\n     * @type {number}\\n     */\\n    let cacheSize = 0;\\n\\n    return (\\n      /**\\n       * @param {string} s String.\\n       * @return {module:ol/color~Color} Color.\\n       */\\n      function(s) {\\n        let color;\\n        if (cache.hasOwnProperty(s)) {\\n          color = cache[s];\\n        } else {\\n          if (cacheSize >= MAX_CACHE_SIZE) {\\n            let i = 0;\\n            for (const key in cache) {\\n              if ((i++ & 3) === 0) {\\n                delete cache[key];\\n                --cacheSize;\\n              }\\n            }\\n          }\\n          color = fromStringInternal_(s);\\n          cache[s] = color;\\n          ++cacheSize;\\n        }\\n        return color;\\n      }\\n    );\\n\\n  })();\\n\\n/**\\n * Return the color as an array. This function maintains a cache of calculated\\n * arrays which means the result should not be modified.\\n * @param {module:ol/color~Color|string} color Color.\\n * @return {module:ol/color~Color} Color.\\n * @api\\n */\\nexport function asArray(color) {\\n  if (Array.isArray(color)) {\\n    return color;\\n  } else {\\n    return fromString(/** @type {string} */ (color));\\n  }\\n}\\n\\n/**\\n * @param {string} s String.\\n * @private\\n * @return {module:ol/color~Color} Color.\\n */\\nfunction fromStringInternal_(s) {\\n  let r, g, b, a, color;\\n\\n  if (NAMED_COLOR_RE_.exec(s)) {\\n    s = fromNamed(s);\\n  }\\n\\n  if (HEX_COLOR_RE_.exec(s)) { // hex\\n    const n = s.length - 1; // number of hex digits\\n    let d; // number of digits per channel\\n    if (n <= 4) {\\n      d = 1;\\n    } else {\\n      d = 2;\\n    }\\n    const hasAlpha = n === 4 || n === 8;\\n    r = parseInt(s.substr(1 + 0 * d, d), 16);\\n    g = parseInt(s.substr(1 + 1 * d, d), 16);\\n    b = parseInt(s.substr(1 + 2 * d, d), 16);\\n    if (hasAlpha) {\\n      a = parseInt(s.substr(1 + 3 * d, d), 16);\\n    } else {\\n      a = 255;\\n    }\\n    if (d == 1) {\\n      r = (r << 4) + r;\\n      g = (g << 4) + g;\\n      b = (b << 4) + b;\\n      if (hasAlpha) {\\n        a = (a << 4) + a;\\n      }\\n    }\\n    color = [r, g, b, a / 255];\\n  } else if (s.indexOf('rgba(') == 0) { // rgba()\\n    color = s.slice(5, -1).split(',').map(Number);\\n    normalize(color);\\n  } else if (s.indexOf('rgb(') == 0) { // rgb()\\n    color = s.slice(4, -1).split(',').map(Number);\\n    color.push(1);\\n    normalize(color);\\n  } else {\\n    assert(false, 14); // Invalid color\\n  }\\n  return (\\n    /** @type {module:ol/color~Color} */ (color)\\n  );\\n}\\n\\n\\n/**\\n * TODO this function is only used in the test, we probably shouldn't export it\\n * @param {module:ol/color~Color} color Color.\\n * @return {module:ol/color~Color} Clamped color.\\n */\\nexport function normalize(color) {\\n  color[0] = clamp((color[0] + 0.5) | 0, 0, 255);\\n  color[1] = clamp((color[1] + 0.5) | 0, 0, 255);\\n  color[2] = clamp((color[2] + 0.5) | 0, 0, 255);\\n  color[3] = clamp(color[3], 0, 1);\\n  return color;\\n}\\n\\n\\n/**\\n * @param {module:ol/color~Color} color Color.\\n * @return {string} String.\\n */\\nexport function toString(color) {\\n  let r = color[0];\\n  if (r != (r | 0)) {\\n    r = (r + 0.5) | 0;\\n  }\\n  let g = color[1];\\n  if (g != (g | 0)) {\\n    g = (g + 0.5) | 0;\\n  }\\n  let b = color[2];\\n  if (b != (b | 0)) {\\n    b = (b + 0.5) | 0;\\n  }\\n  const a = color[3] === undefined ? 1 : color[3];\\n  return 'rgba(' + r + ',' + g + ',' + b + ',' + a + ')';\\n}\\n\",\"/**\\n * @module ol/colorlike\\n */\\nimport {toString} from './color.js';\\n\\n\\n/**\\n * A type accepted by CanvasRenderingContext2D.fillStyle\\n * or CanvasRenderingContext2D.strokeStyle.\\n * Represents a color, pattern, or gradient. The origin for patterns and\\n * gradients as fill style is an increment of 512 css pixels from map coordinate\\n * `[0, 0]`. For seamless repeat patterns, width and height of the pattern image\\n * must be a factor of two (2, 4, 8, ..., 512).\\n *\\n * @typedef {string|CanvasPattern|CanvasGradient} ColorLike\\n * @api\\n */\\n\\n\\n/**\\n * @param {module:ol/color~Color|module:ol/colorlike~ColorLike} color Color.\\n * @return {module:ol/colorlike~ColorLike} The color as an {@link ol/colorlike~ColorLike}.\\n * @api\\n */\\nexport function asColorLike(color) {\\n  if (isColorLike(color)) {\\n    return /** @type {string|CanvasPattern|CanvasGradient} */ (color);\\n  } else {\\n    return toString(/** @type {module:ol/color~Color} */ (color));\\n  }\\n}\\n\\n\\n/**\\n * @param {?} color The value that is potentially an {@link ol/colorlike~ColorLike}.\\n * @return {boolean} The color is an {@link ol/colorlike~ColorLike}.\\n */\\nexport function isColorLike(color) {\\n  return (\\n    typeof color === 'string' ||\\n    color instanceof CanvasPattern ||\\n    color instanceof CanvasGradient\\n  );\\n}\\n\",\"/**\\n * @module ol/dom\\n */\\n\\n\\n/**\\n * Create an html canvas element and returns its 2d context.\\n * @param {number=} opt_width Canvas width.\\n * @param {number=} opt_height Canvas height.\\n * @return {CanvasRenderingContext2D} The context.\\n */\\nexport function createCanvasContext2D(opt_width, opt_height) {\\n  const canvas = /** @type {HTMLCanvasElement} */ (document.createElement('CANVAS'));\\n  if (opt_width) {\\n    canvas.width = opt_width;\\n  }\\n  if (opt_height) {\\n    canvas.height = opt_height;\\n  }\\n  return /** @type {CanvasRenderingContext2D} */ (canvas.getContext('2d'));\\n}\\n\\n\\n/**\\n * Get the current computed width for the given element including margin,\\n * padding and border.\\n * Equivalent to jQuery's `$(el).outerWidth(true)`.\\n * @param {!Element} element Element.\\n * @return {number} The width.\\n */\\nexport function outerWidth(element) {\\n  let width = element.offsetWidth;\\n  const style = getComputedStyle(element);\\n  width += parseInt(style.marginLeft, 10) + parseInt(style.marginRight, 10);\\n\\n  return width;\\n}\\n\\n\\n/**\\n * Get the current computed height for the given element including margin,\\n * padding and border.\\n * Equivalent to jQuery's `$(el).outerHeight(true)`.\\n * @param {!Element} element Element.\\n * @return {number} The height.\\n */\\nexport function outerHeight(element) {\\n  let height = element.offsetHeight;\\n  const style = getComputedStyle(element);\\n  height += parseInt(style.marginTop, 10) + parseInt(style.marginBottom, 10);\\n\\n  return height;\\n}\\n\\n/**\\n * @param {Node} newNode Node to replace old node\\n * @param {Node} oldNode The node to be replaced\\n */\\nexport function replaceNode(newNode, oldNode) {\\n  const parent = oldNode.parentNode;\\n  if (parent) {\\n    parent.replaceChild(newNode, oldNode);\\n  }\\n}\\n\\n/**\\n * @param {Node} node The node to remove.\\n * @returns {Node} The node that was removed or null.\\n */\\nexport function removeNode(node) {\\n  return node && node.parentNode ? node.parentNode.removeChild(node) : null;\\n}\\n\\n/**\\n * @param {Node} node The node to remove the children from.\\n */\\nexport function removeChildren(node) {\\n  while (node.lastChild) {\\n    node.removeChild(node.lastChild);\\n  }\\n}\\n\",\"/**\\n * @module ol/has\\n */\\nimport {HAS_WEBGL} from './index.js';\\n\\nconst ua = typeof navigator !== 'undefined' ?\\n  navigator.userAgent.toLowerCase() : '';\\n\\n/**\\n * User agent string says we are dealing with Firefox as browser.\\n * @type {boolean}\\n */\\nexport const FIREFOX = ua.indexOf('firefox') !== -1;\\n\\n/**\\n * User agent string says we are dealing with Safari as browser.\\n * @type {boolean}\\n */\\nexport const SAFARI = ua.indexOf('safari') !== -1 && ua.indexOf('chrom') == -1;\\n\\n/**\\n * User agent string says we are dealing with a WebKit engine.\\n * @type {boolean}\\n */\\nexport const WEBKIT = ua.indexOf('webkit') !== -1 && ua.indexOf('edge') == -1;\\n\\n/**\\n * User agent string says we are dealing with a Mac as platform.\\n * @type {boolean}\\n */\\nexport const MAC = ua.indexOf('macintosh') !== -1;\\n\\n\\n/**\\n * The ratio between physical pixels and device-independent pixels\\n * (dips) on the device (`window.devicePixelRatio`).\\n * @const\\n * @type {number}\\n * @api\\n */\\nexport const DEVICE_PIXEL_RATIO = window.devicePixelRatio || 1;\\n\\n\\n/**\\n * True if the browser's Canvas implementation implements {get,set}LineDash.\\n * @type {boolean}\\n */\\nexport const CANVAS_LINE_DASH = function() {\\n  let has = false;\\n  try {\\n    has = !!document.createElement('CANVAS').getContext('2d').setLineDash;\\n  } catch (e) {\\n    // pass\\n  }\\n  return has;\\n}();\\n\\n\\n/**\\n * Is HTML5 geolocation supported in the current browser?\\n * @const\\n * @type {boolean}\\n * @api\\n */\\nexport const GEOLOCATION = 'geolocation' in navigator;\\n\\n\\n/**\\n * True if browser supports touch events.\\n * @const\\n * @type {boolean}\\n * @api\\n */\\nexport const TOUCH = 'ontouchstart' in window;\\n\\n\\n/**\\n * True if browser supports pointer events.\\n * @const\\n * @type {boolean}\\n */\\nexport const POINTER = 'PointerEvent' in window;\\n\\n\\n/**\\n * True if browser supports ms pointer events (IE 10).\\n * @const\\n * @type {boolean}\\n */\\nexport const MSPOINTER = !!(navigator.msPointerEnabled);\\n\\n\\n/**\\n * True if both OpenLayers and browser support WebGL.\\n * @const\\n * @type {boolean}\\n * @api\\n */\\nexport const WEBGL = HAS_WEBGL;\\n\",\"/**\\n * @module ol/ImageState\\n */\\n\\n/**\\n * @enum {number}\\n */\\nexport default {\\n  IDLE: 0,\\n  LOADING: 1,\\n  LOADED: 2,\\n  ERROR: 3\\n};\\n\",\"/**\\n * @module ol/css\\n */\\n\\n\\n/**\\n * The CSS class for hidden feature.\\n *\\n * @const\\n * @type {string}\\n */\\nexport const CLASS_HIDDEN = 'ol-hidden';\\n\\n\\n/**\\n * The CSS class that we'll give the DOM elements to have them selectable.\\n *\\n * @const\\n * @type {string}\\n */\\nexport const CLASS_SELECTABLE = 'ol-selectable';\\n\\n\\n/**\\n * The CSS class that we'll give the DOM elements to have them unselectable.\\n *\\n * @const\\n * @type {string}\\n */\\nexport const CLASS_UNSELECTABLE = 'ol-unselectable';\\n\\n\\n/**\\n * The CSS class for unsupported feature.\\n *\\n * @const\\n * @type {string}\\n */\\nexport const CLASS_UNSUPPORTED = 'ol-unsupported';\\n\\n\\n/**\\n * The CSS class for controls.\\n *\\n * @const\\n * @type {string}\\n */\\nexport const CLASS_CONTROL = 'ol-control';\\n\\n\\n/**\\n * The CSS class that we'll give the DOM elements that are collapsed, i.e.\\n * to those elements which usually can be expanded.\\n *\\n * @const\\n * @type {string}\\n */\\nexport const CLASS_COLLAPSED = 'ol-collapsed';\\n\\n\\n/**\\n * Get the list of font families from a font spec.  Note that this doesn't work\\n * for font families that have commas in them.\\n * @param {string} The CSS font property.\\n * @return {Object.<string>} The font families (or null if the input spec is invalid).\\n */\\nexport const getFontFamilies = (function() {\\n  let style;\\n  const cache = {};\\n  return function(font) {\\n    if (!style) {\\n      style = document.createElement('div').style;\\n    }\\n    if (!(font in cache)) {\\n      style.font = font;\\n      const family = style.fontFamily;\\n      style.font = '';\\n      if (!family) {\\n        return null;\\n      }\\n      cache[font] = family.split(/,\\\\s?/);\\n    }\\n    return cache[font];\\n  };\\n})();\\n\",\"/**\\n * @module ol/structs/LRUCache\\n */\\nimport {inherits} from '../index.js';\\nimport {assert} from '../asserts.js';\\nimport EventTarget from '../events/EventTarget.js';\\nimport EventType from '../events/EventType.js';\\n\\n\\n/**\\n * @typedef {Object} Entry\\n * @property {string} key_\\n * @property {Object} newer\\n * @property {Object} older\\n * @property {*} value_\\n */\\n\\n\\n/**\\n * Implements a Least-Recently-Used cache where the keys do not conflict with\\n * Object's properties (e.g. 'hasOwnProperty' is not allowed as a key). Expiring\\n * items from the cache is the responsibility of the user.\\n * @constructor\\n * @extends {module:ol/events/EventTarget}\\n * @fires module:ol/events/Event~Event\\n * @struct\\n * @template T\\n * @param {number=} opt_highWaterMark High water mark.\\n */\\nconst LRUCache = function(opt_highWaterMark) {\\n\\n  EventTarget.call(this);\\n\\n  /**\\n   * @type {number}\\n   */\\n  this.highWaterMark = opt_highWaterMark !== undefined ? opt_highWaterMark : 2048;\\n\\n  /**\\n   * @private\\n   * @type {number}\\n   */\\n  this.count_ = 0;\\n\\n  /**\\n   * @private\\n   * @type {!Object.<string, module:ol/structs/LRUCache~Entry>}\\n   */\\n  this.entries_ = {};\\n\\n  /**\\n   * @private\\n   * @type {?module:ol/structs/LRUCache~Entry}\\n   */\\n  this.oldest_ = null;\\n\\n  /**\\n   * @private\\n   * @type {?module:ol/structs/LRUCache~Entry}\\n   */\\n  this.newest_ = null;\\n\\n};\\n\\ninherits(LRUCache, EventTarget);\\n\\n\\n/**\\n * @return {boolean} Can expire cache.\\n */\\nLRUCache.prototype.canExpireCache = function() {\\n  return this.getCount() > this.highWaterMark;\\n};\\n\\n\\n/**\\n * FIXME empty description for jsdoc\\n */\\nLRUCache.prototype.clear = function() {\\n  this.count_ = 0;\\n  this.entries_ = {};\\n  this.oldest_ = null;\\n  this.newest_ = null;\\n  this.dispatchEvent(EventType.CLEAR);\\n};\\n\\n\\n/**\\n * @param {string} key Key.\\n * @return {boolean} Contains key.\\n */\\nLRUCache.prototype.containsKey = function(key) {\\n  return this.entries_.hasOwnProperty(key);\\n};\\n\\n\\n/**\\n * @param {function(this: S, T, string, module:ol/structs/LRUCache): ?} f The function\\n *     to call for every entry from the oldest to the newer. This function takes\\n *     3 arguments (the entry value, the entry key and the LRUCache object).\\n *     The return value is ignored.\\n * @param {S=} opt_this The object to use as `this` in `f`.\\n * @template S\\n */\\nLRUCache.prototype.forEach = function(f, opt_this) {\\n  let entry = this.oldest_;\\n  while (entry) {\\n    f.call(opt_this, entry.value_, entry.key_, this);\\n    entry = entry.newer;\\n  }\\n};\\n\\n\\n/**\\n * @param {string} key Key.\\n * @return {T} Value.\\n */\\nLRUCache.prototype.get = function(key) {\\n  const entry = this.entries_[key];\\n  assert(entry !== undefined,\\n    15); // Tried to get a value for a key that does not exist in the cache\\n  if (entry === this.newest_) {\\n    return entry.value_;\\n  } else if (entry === this.oldest_) {\\n    this.oldest_ = /** @type {module:ol/structs/LRUCache~Entry} */ (this.oldest_.newer);\\n    this.oldest_.older = null;\\n  } else {\\n    entry.newer.older = entry.older;\\n    entry.older.newer = entry.newer;\\n  }\\n  entry.newer = null;\\n  entry.older = this.newest_;\\n  this.newest_.newer = entry;\\n  this.newest_ = entry;\\n  return entry.value_;\\n};\\n\\n\\n/**\\n * Remove an entry from the cache.\\n * @param {string} key The entry key.\\n * @return {T} The removed entry.\\n */\\nLRUCache.prototype.remove = function(key) {\\n  const entry = this.entries_[key];\\n  assert(entry !== undefined, 15); // Tried to get a value for a key that does not exist in the cache\\n  if (entry === this.newest_) {\\n    this.newest_ = /** @type {module:ol/structs/LRUCache~Entry} */ (entry.older);\\n    if (this.newest_) {\\n      this.newest_.newer = null;\\n    }\\n  } else if (entry === this.oldest_) {\\n    this.oldest_ = /** @type {module:ol/structs/LRUCache~Entry} */ (entry.newer);\\n    if (this.oldest_) {\\n      this.oldest_.older = null;\\n    }\\n  } else {\\n    entry.newer.older = entry.older;\\n    entry.older.newer = entry.newer;\\n  }\\n  delete this.entries_[key];\\n  --this.count_;\\n  return entry.value_;\\n};\\n\\n\\n/**\\n * @return {number} Count.\\n */\\nLRUCache.prototype.getCount = function() {\\n  return this.count_;\\n};\\n\\n\\n/**\\n * @return {Array.<string>} Keys.\\n */\\nLRUCache.prototype.getKeys = function() {\\n  const keys = new Array(this.count_);\\n  let i = 0;\\n  let entry;\\n  for (entry = this.newest_; entry; entry = entry.older) {\\n    keys[i++] = entry.key_;\\n  }\\n  return keys;\\n};\\n\\n\\n/**\\n * @return {Array.<T>} Values.\\n */\\nLRUCache.prototype.getValues = function() {\\n  const values = new Array(this.count_);\\n  let i = 0;\\n  let entry;\\n  for (entry = this.newest_; entry; entry = entry.older) {\\n    values[i++] = entry.value_;\\n  }\\n  return values;\\n};\\n\\n\\n/**\\n * @return {T} Last value.\\n */\\nLRUCache.prototype.peekLast = function() {\\n  return this.oldest_.value_;\\n};\\n\\n\\n/**\\n * @return {string} Last key.\\n */\\nLRUCache.prototype.peekLastKey = function() {\\n  return this.oldest_.key_;\\n};\\n\\n\\n/**\\n * Get the key of the newest item in the cache.  Throws if the cache is empty.\\n * @return {string} The newest key.\\n */\\nLRUCache.prototype.peekFirstKey = function() {\\n  return this.newest_.key_;\\n};\\n\\n\\n/**\\n * @return {T} value Value.\\n */\\nLRUCache.prototype.pop = function() {\\n  const entry = this.oldest_;\\n  delete this.entries_[entry.key_];\\n  if (entry.newer) {\\n    entry.newer.older = null;\\n  }\\n  this.oldest_ = /** @type {module:ol/structs/LRUCache~Entry} */ (entry.newer);\\n  if (!this.oldest_) {\\n    this.newest_ = null;\\n  }\\n  --this.count_;\\n  return entry.value_;\\n};\\n\\n\\n/**\\n * @param {string} key Key.\\n * @param {T} value Value.\\n */\\nLRUCache.prototype.replace = function(key, value) {\\n  this.get(key);  // update `newest_`\\n  this.entries_[key].value_ = value;\\n};\\n\\n\\n/**\\n * @param {string} key Key.\\n * @param {T} value Value.\\n */\\nLRUCache.prototype.set = function(key, value) {\\n  assert(!(key in this.entries_),\\n    16); // Tried to set a value for a key that is used already\\n  const entry = /** @type {module:ol/structs/LRUCache~Entry} */ ({\\n    key_: key,\\n    newer: null,\\n    older: this.newest_,\\n    value_: value\\n  });\\n  if (!this.newest_) {\\n    this.oldest_ = entry;\\n  } else {\\n    this.newest_.newer = entry;\\n  }\\n  this.newest_ = entry;\\n  this.entries_[key] = entry;\\n  ++this.count_;\\n};\\n\\n\\n/**\\n * Set a maximum number of entries for the cache.\\n * @param {number} size Cache size.\\n * @api\\n */\\nLRUCache.prototype.setSize = function(size) {\\n  this.highWaterMark = size;\\n};\\n\\n\\n/**\\n * Prune the cache.\\n */\\nLRUCache.prototype.prune = function() {\\n  while (this.canExpireCache()) {\\n    this.pop();\\n  }\\n};\\nexport default LRUCache;\\n\",\"/**\\n * @module ol/render/canvas\\n */\\nimport {getFontFamilies} from '../css.js';\\nimport {createCanvasContext2D} from '../dom.js';\\nimport {clear} from '../obj.js';\\nimport LRUCache from '../structs/LRUCache.js';\\nimport {create as createTransform} from '../transform.js';\\n\\n\\n/**\\n * @typedef {Object} FillState\\n * @property {module:ol/colorlike~ColorLike} fillStyle\\n */\\n\\n\\n/**\\n * @typedef {Object} FillStrokeState\\n * @property {module:ol/colorlike~ColorLike} [currentFillStyle]\\n * @property {module:ol/colorlike~ColorLike} [currentStrokeStyle]\\n * @property {string} [currentLineCap]\\n * @property {Array.<number>} currentLineDash\\n * @property {number} [currentLineDashOffset]\\n * @property {string} [currentLineJoin]\\n * @property {number} [currentLineWidth]\\n * @property {number} [currentMiterLimit]\\n * @property {number} [lastStroke]\\n * @property {module:ol/colorlike~ColorLike} [fillStyle]\\n * @property {module:ol/colorlike~ColorLike} [strokeStyle]\\n * @property {string} [lineCap]\\n * @property {Array.<number>} lineDash\\n * @property {number} [lineDashOffset]\\n * @property {string} [lineJoin]\\n * @property {number} [lineWidth]\\n * @property {number} [miterLimit]\\n */\\n\\n\\n/**\\n * @typedef {Object} StrokeState\\n * @property {string} lineCap\\n * @property {Array.<number>} lineDash\\n * @property {number} lineDashOffset\\n * @property {string} lineJoin\\n * @property {number} lineWidth\\n * @property {number} miterLimit\\n * @property {module:ol/colorlike~ColorLike} strokeStyle\\n */\\n\\n\\n/**\\n * @typedef {Object} TextState\\n * @property {string} font\\n * @property {string} [textAlign]\\n * @property {string} textBaseline\\n */\\n\\n\\n/**\\n * Container for decluttered replay instructions that need to be rendered or\\n * omitted together, i.e. when styles render both an image and text, or for the\\n * characters that form text along lines. The basic elements of this array are\\n * `[minX, minY, maxX, maxY, count]`, where the first four entries are the\\n * rendered extent of the group in pixel space. `count` is the number of styles\\n * in the group, i.e. 2 when an image and a text are grouped, or 1 otherwise.\\n * In addition to these four elements, declutter instruction arrays (i.e. the\\n * arguments to {@link module:ol/render/canvas~drawImage} are appended to the array.\\n * @typedef {Array.<*>} DeclutterGroup\\n */\\n\\n\\n/**\\n * @const\\n * @type {string}\\n */\\nexport const defaultFont = '10px sans-serif';\\n\\n\\n/**\\n * @const\\n * @type {module:ol/color~Color}\\n */\\nexport const defaultFillStyle = [0, 0, 0, 1];\\n\\n\\n/**\\n * @const\\n * @type {string}\\n */\\nexport const defaultLineCap = 'round';\\n\\n\\n/**\\n * @const\\n * @type {Array.<number>}\\n */\\nexport const defaultLineDash = [];\\n\\n\\n/**\\n * @const\\n * @type {number}\\n */\\nexport const defaultLineDashOffset = 0;\\n\\n\\n/**\\n * @const\\n * @type {string}\\n */\\nexport const defaultLineJoin = 'round';\\n\\n\\n/**\\n * @const\\n * @type {number}\\n */\\nexport const defaultMiterLimit = 10;\\n\\n\\n/**\\n * @const\\n * @type {module:ol/color~Color}\\n */\\nexport const defaultStrokeStyle = [0, 0, 0, 1];\\n\\n\\n/**\\n * @const\\n * @type {string}\\n */\\nexport const defaultTextAlign = 'center';\\n\\n\\n/**\\n * @const\\n * @type {string}\\n */\\nexport const defaultTextBaseline = 'middle';\\n\\n\\n/**\\n * @const\\n * @type {Array.<number>}\\n */\\nexport const defaultPadding = [0, 0, 0, 0];\\n\\n\\n/**\\n * @const\\n * @type {number}\\n */\\nexport const defaultLineWidth = 1;\\n\\n\\n/**\\n * The label cache for text rendering. To change the default cache size of 2048\\n * entries, use {@link module:ol/structs/LRUCache#setSize}.\\n * @type {module:ol/structs/LRUCache.<HTMLCanvasElement>}\\n * @api\\n */\\nexport const labelCache = new LRUCache();\\n\\n\\n/**\\n * @type {!Object.<string, number>}\\n */\\nexport const checkedFonts = {};\\n\\n\\n/**\\n * @type {CanvasRenderingContext2D}\\n */\\nlet measureContext = null;\\n\\n\\n/**\\n * @type {!Object.<string, number>}\\n */\\nexport const textHeights = {};\\n\\n\\n/**\\n * Clears the label cache when a font becomes available.\\n * @param {string} fontSpec CSS font spec.\\n */\\nexport const checkFont = (function() {\\n  const retries = 60;\\n  const checked = checkedFonts;\\n  const size = '32px ';\\n  const referenceFonts = ['monospace', 'serif'];\\n  const len = referenceFonts.length;\\n  const text = 'wmytzilWMYTZIL@#/&?$%10\\\\uF013';\\n  let interval, referenceWidth;\\n\\n  function isAvailable(font) {\\n    const context = getMeasureContext();\\n    let available = true;\\n    for (let i = 0; i < len; ++i) {\\n      const referenceFont = referenceFonts[i];\\n      context.font = size + referenceFont;\\n      referenceWidth = context.measureText(text).width;\\n      if (font != referenceFont) {\\n        context.font = size + font + ',' + referenceFont;\\n        const width = context.measureText(text).width;\\n        // If width and referenceWidth are the same, then the fallback was used\\n        // instead of the font we wanted, so the font is not available.\\n        available = available && width != referenceWidth;\\n      }\\n    }\\n    return available;\\n  }\\n\\n  function check() {\\n    let done = true;\\n    for (const font in checked) {\\n      if (checked[font] < retries) {\\n        if (isAvailable(font)) {\\n          checked[font] = retries;\\n          clear(textHeights);\\n          // Make sure that loaded fonts are picked up by Safari\\n          measureContext = null;\\n          labelCache.clear();\\n        } else {\\n          ++checked[font];\\n          done = false;\\n        }\\n      }\\n    }\\n    if (done) {\\n      clearInterval(interval);\\n      interval = undefined;\\n    }\\n  }\\n\\n  return function(fontSpec) {\\n    const fontFamilies = getFontFamilies(fontSpec);\\n    if (!fontFamilies) {\\n      return;\\n    }\\n    for (let i = 0, ii = fontFamilies.length; i < ii; ++i) {\\n      const fontFamily = fontFamilies[i];\\n      if (!(fontFamily in checked)) {\\n        checked[fontFamily] = retries;\\n        if (!isAvailable(fontFamily)) {\\n          checked[fontFamily] = 0;\\n          if (interval === undefined) {\\n            interval = setInterval(check, 32);\\n          }\\n        }\\n      }\\n    }\\n  };\\n})();\\n\\n\\n/**\\n * @return {CanvasRenderingContext2D} Measure context.\\n */\\nfunction getMeasureContext() {\\n  if (!measureContext) {\\n    measureContext = createCanvasContext2D(1, 1);\\n  }\\n  return measureContext;\\n}\\n\\n\\n/**\\n * @param {string} font Font to use for measuring.\\n * @return {module:ol/size~Size} Measurement.\\n */\\nexport const measureTextHeight = (function() {\\n  let span;\\n  const heights = textHeights;\\n  return function(font) {\\n    let height = heights[font];\\n    if (height == undefined) {\\n      if (!span) {\\n        span = document.createElement('span');\\n        span.textContent = 'M';\\n        span.style.margin = span.style.padding = '0 !important';\\n        span.style.position = 'absolute !important';\\n        span.style.left = '-99999px !important';\\n      }\\n      span.style.font = font;\\n      document.body.appendChild(span);\\n      height = heights[font] = span.offsetHeight;\\n      document.body.removeChild(span);\\n    }\\n    return height;\\n  };\\n})();\\n\\n\\n/**\\n * @param {string} font Font.\\n * @param {string} text Text.\\n * @return {number} Width.\\n */\\nexport function measureTextWidth(font, text) {\\n  const measureContext = getMeasureContext();\\n  if (font != measureContext.font) {\\n    measureContext.font = font;\\n  }\\n  return measureContext.measureText(text).width;\\n}\\n\\n\\n/**\\n * @param {CanvasRenderingContext2D} context Context.\\n * @param {number} rotation Rotation.\\n * @param {number} offsetX X offset.\\n * @param {number} offsetY Y offset.\\n */\\nexport function rotateAtOffset(context, rotation, offsetX, offsetY) {\\n  if (rotation !== 0) {\\n    context.translate(offsetX, offsetY);\\n    context.rotate(rotation);\\n    context.translate(-offsetX, -offsetY);\\n  }\\n}\\n\\n\\nexport const resetTransform = createTransform();\\n\\n\\n/**\\n * @param {CanvasRenderingContext2D} context Context.\\n * @param {module:ol/transform~Transform|null} transform Transform.\\n * @param {number} opacity Opacity.\\n * @param {HTMLImageElement|HTMLCanvasElement|HTMLVideoElement} image Image.\\n * @param {number} originX Origin X.\\n * @param {number} originY Origin Y.\\n * @param {number} w Width.\\n * @param {number} h Height.\\n * @param {number} x X.\\n * @param {number} y Y.\\n * @param {number} scale Scale.\\n */\\nexport function drawImage(context,\\n  transform, opacity, image, originX, originY, w, h, x, y, scale) {\\n  let alpha;\\n  if (opacity != 1) {\\n    alpha = context.globalAlpha;\\n    context.globalAlpha = alpha * opacity;\\n  }\\n  if (transform) {\\n    context.setTransform.apply(context, transform);\\n  }\\n\\n  context.drawImage(image, originX, originY, w, h, x, y, w * scale, h * scale);\\n\\n  if (alpha) {\\n    context.globalAlpha = alpha;\\n  }\\n  if (transform) {\\n    context.setTransform.apply(context, resetTransform);\\n  }\\n}\\n\",\"/**\\n * @module ol/style/Image\\n */\\n\\n\\n/**\\n * @typedef {Object} Options\\n * @property {number} opacity\\n * @property {boolean} rotateWithView\\n * @property {number} rotation\\n * @property {number} scale\\n * @property {boolean} snapToPixel\\n */\\n\\n\\n/**\\n * @classdesc\\n * A base class used for creating subclasses and not instantiated in\\n * apps. Base class for {@link module:ol/style/Icon~Icon}, {@link module:ol/style/Circle~CircleStyle} and\\n * {@link module:ol/style/RegularShape~RegularShape}.\\n *\\n * @constructor\\n * @abstract\\n * @param {module:ol/style/Image~Options} options Options.\\n * @api\\n */\\nconst ImageStyle = function(options) {\\n\\n  /**\\n   * @private\\n   * @type {number}\\n   */\\n  this.opacity_ = options.opacity;\\n\\n  /**\\n   * @private\\n   * @type {boolean}\\n   */\\n  this.rotateWithView_ = options.rotateWithView;\\n\\n  /**\\n   * @private\\n   * @type {number}\\n   */\\n  this.rotation_ = options.rotation;\\n\\n  /**\\n   * @private\\n   * @type {number}\\n   */\\n  this.scale_ = options.scale;\\n\\n  /**\\n   * @private\\n   * @type {boolean}\\n   */\\n  this.snapToPixel_ = options.snapToPixel;\\n\\n};\\n\\n\\n/**\\n * Get the symbolizer opacity.\\n * @return {number} Opacity.\\n * @api\\n */\\nImageStyle.prototype.getOpacity = function() {\\n  return this.opacity_;\\n};\\n\\n\\n/**\\n * Determine whether the symbolizer rotates with the map.\\n * @return {boolean} Rotate with map.\\n * @api\\n */\\nImageStyle.prototype.getRotateWithView = function() {\\n  return this.rotateWithView_;\\n};\\n\\n\\n/**\\n * Get the symoblizer rotation.\\n * @return {number} Rotation.\\n * @api\\n */\\nImageStyle.prototype.getRotation = function() {\\n  return this.rotation_;\\n};\\n\\n\\n/**\\n * Get the symbolizer scale.\\n * @return {number} Scale.\\n * @api\\n */\\nImageStyle.prototype.getScale = function() {\\n  return this.scale_;\\n};\\n\\n\\n/**\\n * Determine whether the symbolizer should be snapped to a pixel.\\n * @return {boolean} The symbolizer should snap to a pixel.\\n * @api\\n */\\nImageStyle.prototype.getSnapToPixel = function() {\\n  return this.snapToPixel_;\\n};\\n\\n\\n/**\\n * Get the anchor point in pixels. The anchor determines the center point for the\\n * symbolizer.\\n * @abstract\\n * @return {Array.<number>} Anchor.\\n */\\nImageStyle.prototype.getAnchor = function() {};\\n\\n\\n/**\\n * Get the image element for the symbolizer.\\n * @abstract\\n * @param {number} pixelRatio Pixel ratio.\\n * @return {HTMLCanvasElement|HTMLVideoElement|Image} Image element.\\n */\\nImageStyle.prototype.getImage = function(pixelRatio) {};\\n\\n\\n/**\\n * @abstract\\n * @param {number} pixelRatio Pixel ratio.\\n * @return {HTMLCanvasElement|HTMLVideoElement|Image} Image element.\\n */\\nImageStyle.prototype.getHitDetectionImage = function(pixelRatio) {};\\n\\n\\n/**\\n * @abstract\\n * @return {module:ol/ImageState} Image state.\\n */\\nImageStyle.prototype.getImageState = function() {};\\n\\n\\n/**\\n * @abstract\\n * @return {module:ol/size~Size} Image size.\\n */\\nImageStyle.prototype.getImageSize = function() {};\\n\\n\\n/**\\n * @abstract\\n * @return {module:ol/size~Size} Size of the hit-detection image.\\n */\\nImageStyle.prototype.getHitDetectionImageSize = function() {};\\n\\n\\n/**\\n * Get the origin of the symbolizer.\\n * @abstract\\n * @return {Array.<number>} Origin.\\n */\\nImageStyle.prototype.getOrigin = function() {};\\n\\n\\n/**\\n * Get the size of the symbolizer (in pixels).\\n * @abstract\\n * @return {module:ol/size~Size} Size.\\n */\\nImageStyle.prototype.getSize = function() {};\\n\\n\\n/**\\n * Set the opacity.\\n *\\n * @param {number} opacity Opacity.\\n * @api\\n */\\nImageStyle.prototype.setOpacity = function(opacity) {\\n  this.opacity_ = opacity;\\n};\\n\\n\\n/**\\n * Set whether to rotate the style with the view.\\n *\\n * @param {boolean} rotateWithView Rotate with map.\\n * @api\\n */\\nImageStyle.prototype.setRotateWithView = function(rotateWithView) {\\n  this.rotateWithView_ = rotateWithView;\\n};\\n\\n\\n/**\\n * Set the rotation.\\n *\\n * @param {number} rotation Rotation.\\n * @api\\n */\\nImageStyle.prototype.setRotation = function(rotation) {\\n  this.rotation_ = rotation;\\n};\\n\\n\\n/**\\n * Set the scale.\\n *\\n * @param {number} scale Scale.\\n * @api\\n */\\nImageStyle.prototype.setScale = function(scale) {\\n  this.scale_ = scale;\\n};\\n\\n\\n/**\\n * Set whether to snap the image to the closest pixel.\\n *\\n * @param {boolean} snapToPixel Snap to pixel?\\n * @api\\n */\\nImageStyle.prototype.setSnapToPixel = function(snapToPixel) {\\n  this.snapToPixel_ = snapToPixel;\\n};\\n\\n\\n/**\\n * @abstract\\n * @param {function(this: T, module:ol/events/Event)} listener Listener function.\\n * @param {T} thisArg Value to use as `this` when executing `listener`.\\n * @return {module:ol/events~EventsKey|undefined} Listener key.\\n * @template T\\n */\\nImageStyle.prototype.listenImageChange = function(listener, thisArg) {};\\n\\n\\n/**\\n * Load not yet loaded URI.\\n * @abstract\\n */\\nImageStyle.prototype.load = function() {};\\n\\n\\n/**\\n * @abstract\\n * @param {function(this: T, module:ol/events/Event)} listener Listener function.\\n * @param {T} thisArg Value to use as `this` when executing `listener`.\\n * @template T\\n */\\nImageStyle.prototype.unlistenImageChange = function(listener, thisArg) {};\\nexport default ImageStyle;\\n\",\"/**\\n * @module ol/style/RegularShape\\n */\\nimport {inherits} from '../index.js';\\nimport {asColorLike} from '../colorlike.js';\\nimport {createCanvasContext2D} from '../dom.js';\\nimport {CANVAS_LINE_DASH} from '../has.js';\\nimport ImageState from '../ImageState.js';\\nimport {defaultStrokeStyle, defaultFillStyle, defaultLineCap, defaultLineWidth, defaultLineJoin, defaultMiterLimit} from '../render/canvas.js';\\nimport ImageStyle from '../style/Image.js';\\n\\n\\n/**\\n * Specify radius for regular polygons, or radius1 and radius2 for stars.\\n * @typedef {Object} Options\\n * @property {module:ol/style/Fill} [fill] Fill style.\\n * @property {number} points Number of points for stars and regular polygons. In case of a polygon, the number of points\\n * is the number of sides.\\n * @property {number} [radius] Radius of a regular polygon.\\n * @property {number} [radius1] Outer radius of a star.\\n * @property {number} [radius2] Inner radius of a star.\\n * @property {number} [angle=0] Shape's angle in radians. A value of 0 will have one of the shape's point facing up.\\n * @property {boolean} [snapToPixel=true] If `true` integral numbers of pixels are used as the X and Y pixel coordinate\\n * when drawing the shape in the output canvas. If `false` fractional numbers may be used. Using `true` allows for\\n * \\\"sharp\\\" rendering (no blur), while using `false` allows for \\\"accurate\\\" rendering. Note that accuracy is important if\\n * the shape's position is animated. Without it, the shape may jitter noticeably.\\n * @property {module:ol/style/Stroke} [stroke] Stroke style.\\n * @property {number} [rotation=0] Rotation in radians (positive rotation clockwise).\\n * @property {boolean} [rotateWithView=false] Whether to rotate the shape with the view.\\n * @property {module:ol/style/AtlasManager} [atlasManager] The atlas manager to use for this symbol. When\\n * using WebGL it is recommended to use an atlas manager to avoid texture switching. If an atlas manager is given, the\\n * symbol is added to an atlas. By default no atlas manager is used.\\n */\\n\\n\\n/**\\n * @typedef {Object} RenderOptions\\n * @property {module:ol/colorlike~ColorLike} [strokeStyle]\\n * @property {number} strokeWidth\\n * @property {number} size\\n * @property {string} lineCap\\n * @property {Array.<number>} lineDash\\n * @property {number} lineDashOffset\\n * @property {string} lineJoin\\n * @property {number} miterLimit\\n */\\n\\n\\n/**\\n * @classdesc\\n * Set regular shape style for vector features. The resulting shape will be\\n * a regular polygon when `radius` is provided, or a star when `radius1` and\\n * `radius2` are provided.\\n *\\n * @constructor\\n * @param {module:ol/style/RegularShape~Options} options Options.\\n * @extends {module:ol/style/Image}\\n * @api\\n */\\nconst RegularShape = function(options) {\\n  /**\\n   * @private\\n   * @type {Array.<string>}\\n   */\\n  this.checksums_ = null;\\n\\n  /**\\n   * @private\\n   * @type {HTMLCanvasElement}\\n   */\\n  this.canvas_ = null;\\n\\n  /**\\n   * @private\\n   * @type {HTMLCanvasElement}\\n   */\\n  this.hitDetectionCanvas_ = null;\\n\\n  /**\\n   * @private\\n   * @type {module:ol/style/Fill}\\n   */\\n  this.fill_ = options.fill !== undefined ? options.fill : null;\\n\\n  /**\\n   * @private\\n   * @type {Array.<number>}\\n   */\\n  this.origin_ = [0, 0];\\n\\n  /**\\n   * @private\\n   * @type {number}\\n   */\\n  this.points_ = options.points;\\n\\n  /**\\n   * @protected\\n   * @type {number}\\n   */\\n  this.radius_ = /** @type {number} */ (options.radius !== undefined ?\\n    options.radius : options.radius1);\\n\\n  /**\\n   * @private\\n   * @type {number|undefined}\\n   */\\n  this.radius2_ = options.radius2;\\n\\n  /**\\n   * @private\\n   * @type {number}\\n   */\\n  this.angle_ = options.angle !== undefined ? options.angle : 0;\\n\\n  /**\\n   * @private\\n   * @type {module:ol/style/Stroke}\\n   */\\n  this.stroke_ = options.stroke !== undefined ? options.stroke : null;\\n\\n  /**\\n   * @private\\n   * @type {Array.<number>}\\n   */\\n  this.anchor_ = null;\\n\\n  /**\\n   * @private\\n   * @type {module:ol/size~Size}\\n   */\\n  this.size_ = null;\\n\\n  /**\\n   * @private\\n   * @type {module:ol/size~Size}\\n   */\\n  this.imageSize_ = null;\\n\\n  /**\\n   * @private\\n   * @type {module:ol/size~Size}\\n   */\\n  this.hitDetectionImageSize_ = null;\\n\\n  /**\\n   * @protected\\n   * @type {module:ol/style/AtlasManager|undefined}\\n   */\\n  this.atlasManager_ = options.atlasManager;\\n\\n  this.render_(this.atlasManager_);\\n\\n  /**\\n   * @type {boolean}\\n   */\\n  const snapToPixel = options.snapToPixel !== undefined ?\\n    options.snapToPixel : true;\\n\\n  /**\\n   * @type {boolean}\\n   */\\n  const rotateWithView = options.rotateWithView !== undefined ?\\n    options.rotateWithView : false;\\n\\n  ImageStyle.call(this, {\\n    opacity: 1,\\n    rotateWithView: rotateWithView,\\n    rotation: options.rotation !== undefined ? options.rotation : 0,\\n    scale: 1,\\n    snapToPixel: snapToPixel\\n  });\\n};\\n\\ninherits(RegularShape, ImageStyle);\\n\\n\\n/**\\n * Clones the style. If an atlasmanager was provided to the original style it will be used in the cloned style, too.\\n * @return {module:ol/style/RegularShape} The cloned style.\\n * @api\\n */\\nRegularShape.prototype.clone = function() {\\n  const style = new RegularShape({\\n    fill: this.getFill() ? this.getFill().clone() : undefined,\\n    points: this.getPoints(),\\n    radius: this.getRadius(),\\n    radius2: this.getRadius2(),\\n    angle: this.getAngle(),\\n    snapToPixel: this.getSnapToPixel(),\\n    stroke: this.getStroke() ?  this.getStroke().clone() : undefined,\\n    rotation: this.getRotation(),\\n    rotateWithView: this.getRotateWithView(),\\n    atlasManager: this.atlasManager_\\n  });\\n  style.setOpacity(this.getOpacity());\\n  style.setScale(this.getScale());\\n  return style;\\n};\\n\\n\\n/**\\n * @inheritDoc\\n * @api\\n */\\nRegularShape.prototype.getAnchor = function() {\\n  return this.anchor_;\\n};\\n\\n\\n/**\\n * Get the angle used in generating the shape.\\n * @return {number} Shape's rotation in radians.\\n * @api\\n */\\nRegularShape.prototype.getAngle = function() {\\n  return this.angle_;\\n};\\n\\n\\n/**\\n * Get the fill style for the shape.\\n * @return {module:ol/style/Fill} Fill style.\\n * @api\\n */\\nRegularShape.prototype.getFill = function() {\\n  return this.fill_;\\n};\\n\\n\\n/**\\n * @inheritDoc\\n */\\nRegularShape.prototype.getHitDetectionImage = function(pixelRatio) {\\n  return this.hitDetectionCanvas_;\\n};\\n\\n\\n/**\\n * @inheritDoc\\n * @api\\n */\\nRegularShape.prototype.getImage = function(pixelRatio) {\\n  return this.canvas_;\\n};\\n\\n\\n/**\\n * @inheritDoc\\n */\\nRegularShape.prototype.getImageSize = function() {\\n  return this.imageSize_;\\n};\\n\\n\\n/**\\n * @inheritDoc\\n */\\nRegularShape.prototype.getHitDetectionImageSize = function() {\\n  return this.hitDetectionImageSize_;\\n};\\n\\n\\n/**\\n * @inheritDoc\\n */\\nRegularShape.prototype.getImageState = function() {\\n  return ImageState.LOADED;\\n};\\n\\n\\n/**\\n * @inheritDoc\\n * @api\\n */\\nRegularShape.prototype.getOrigin = function() {\\n  return this.origin_;\\n};\\n\\n\\n/**\\n * Get the number of points for generating the shape.\\n * @return {number} Number of points for stars and regular polygons.\\n * @api\\n */\\nRegularShape.prototype.getPoints = function() {\\n  return this.points_;\\n};\\n\\n\\n/**\\n * Get the (primary) radius for the shape.\\n * @return {number} Radius.\\n * @api\\n */\\nRegularShape.prototype.getRadius = function() {\\n  return this.radius_;\\n};\\n\\n\\n/**\\n * Get the secondary radius for the shape.\\n * @return {number|undefined} Radius2.\\n * @api\\n */\\nRegularShape.prototype.getRadius2 = function() {\\n  return this.radius2_;\\n};\\n\\n\\n/**\\n * @inheritDoc\\n * @api\\n */\\nRegularShape.prototype.getSize = function() {\\n  return this.size_;\\n};\\n\\n\\n/**\\n * Get the stroke style for the shape.\\n * @return {module:ol/style/Stroke} Stroke style.\\n * @api\\n */\\nRegularShape.prototype.getStroke = function() {\\n  return this.stroke_;\\n};\\n\\n\\n/**\\n * @inheritDoc\\n */\\nRegularShape.prototype.listenImageChange = function(listener, thisArg) {};\\n\\n\\n/**\\n * @inheritDoc\\n */\\nRegularShape.prototype.load = function() {};\\n\\n\\n/**\\n * @inheritDoc\\n */\\nRegularShape.prototype.unlistenImageChange = function(listener, thisArg) {};\\n\\n\\n/**\\n * @protected\\n * @param {module:ol/style/AtlasManager|undefined} atlasManager An atlas manager.\\n */\\nRegularShape.prototype.render_ = function(atlasManager) {\\n  let imageSize;\\n  let lineCap = '';\\n  let lineJoin = '';\\n  let miterLimit = 0;\\n  let lineDash = null;\\n  let lineDashOffset = 0;\\n  let strokeStyle;\\n  let strokeWidth = 0;\\n\\n  if (this.stroke_) {\\n    strokeStyle = this.stroke_.getColor();\\n    if (strokeStyle === null) {\\n      strokeStyle = defaultStrokeStyle;\\n    }\\n    strokeStyle = asColorLike(strokeStyle);\\n    strokeWidth = this.stroke_.getWidth();\\n    if (strokeWidth === undefined) {\\n      strokeWidth = defaultLineWidth;\\n    }\\n    lineDash = this.stroke_.getLineDash();\\n    lineDashOffset = this.stroke_.getLineDashOffset();\\n    if (!CANVAS_LINE_DASH) {\\n      lineDash = null;\\n      lineDashOffset = 0;\\n    }\\n    lineJoin = this.stroke_.getLineJoin();\\n    if (lineJoin === undefined) {\\n      lineJoin = defaultLineJoin;\\n    }\\n    lineCap = this.stroke_.getLineCap();\\n    if (lineCap === undefined) {\\n      lineCap = defaultLineCap;\\n    }\\n    miterLimit = this.stroke_.getMiterLimit();\\n    if (miterLimit === undefined) {\\n      miterLimit = defaultMiterLimit;\\n    }\\n  }\\n\\n  let size = 2 * (this.radius_ + strokeWidth) + 1;\\n\\n  /** @type {module:ol/style/RegularShape~RenderOptions} */\\n  const renderOptions = {\\n    strokeStyle: strokeStyle,\\n    strokeWidth: strokeWidth,\\n    size: size,\\n    lineCap: lineCap,\\n    lineDash: lineDash,\\n    lineDashOffset: lineDashOffset,\\n    lineJoin: lineJoin,\\n    miterLimit: miterLimit\\n  };\\n\\n  if (atlasManager === undefined) {\\n    // no atlas manager is used, create a new canvas\\n    const context = createCanvasContext2D(size, size);\\n    this.canvas_ = context.canvas;\\n\\n    // canvas.width and height are rounded to the closest integer\\n    size = this.canvas_.width;\\n    imageSize = size;\\n\\n    this.draw_(renderOptions, context, 0, 0);\\n\\n    this.createHitDetectionCanvas_(renderOptions);\\n  } else {\\n    // an atlas manager is used, add the symbol to an atlas\\n    size = Math.round(size);\\n\\n    const hasCustomHitDetectionImage = !this.fill_;\\n    let renderHitDetectionCallback;\\n    if (hasCustomHitDetectionImage) {\\n      // render the hit-detection image into a separate atlas image\\n      renderHitDetectionCallback =\\n          this.drawHitDetectionCanvas_.bind(this, renderOptions);\\n    }\\n\\n    const id = this.getChecksum();\\n    const info = atlasManager.add(\\n      id, size, size, this.draw_.bind(this, renderOptions),\\n      renderHitDetectionCallback);\\n\\n    this.canvas_ = info.image;\\n    this.origin_ = [info.offsetX, info.offsetY];\\n    imageSize = info.image.width;\\n\\n    if (hasCustomHitDetectionImage) {\\n      this.hitDetectionCanvas_ = info.hitImage;\\n      this.hitDetectionImageSize_ =\\n          [info.hitImage.width, info.hitImage.height];\\n    } else {\\n      this.hitDetectionCanvas_ = this.canvas_;\\n      this.hitDetectionImageSize_ = [imageSize, imageSize];\\n    }\\n  }\\n\\n  this.anchor_ = [size / 2, size / 2];\\n  this.size_ = [size, size];\\n  this.imageSize_ = [imageSize, imageSize];\\n};\\n\\n\\n/**\\n * @private\\n * @param {module:ol/style/RegularShape~RenderOptions} renderOptions Render options.\\n * @param {CanvasRenderingContext2D} context The rendering context.\\n * @param {number} x The origin for the symbol (x).\\n * @param {number} y The origin for the symbol (y).\\n */\\nRegularShape.prototype.draw_ = function(renderOptions, context, x, y) {\\n  let i, angle0, radiusC;\\n  // reset transform\\n  context.setTransform(1, 0, 0, 1, 0, 0);\\n\\n  // then move to (x, y)\\n  context.translate(x, y);\\n\\n  context.beginPath();\\n\\n  let points = this.points_;\\n  if (points === Infinity) {\\n    context.arc(\\n      renderOptions.size / 2, renderOptions.size / 2,\\n      this.radius_, 0, 2 * Math.PI, true);\\n  } else {\\n    const radius2 = (this.radius2_ !== undefined) ? this.radius2_\\n      : this.radius_;\\n    if (radius2 !== this.radius_) {\\n      points = 2 * points;\\n    }\\n    for (i = 0; i <= points; i++) {\\n      angle0 = i * 2 * Math.PI / points - Math.PI / 2 + this.angle_;\\n      radiusC = i % 2 === 0 ? this.radius_ : radius2;\\n      context.lineTo(renderOptions.size / 2 + radiusC * Math.cos(angle0),\\n        renderOptions.size / 2 + radiusC * Math.sin(angle0));\\n    }\\n  }\\n\\n\\n  if (this.fill_) {\\n    let color = this.fill_.getColor();\\n    if (color === null) {\\n      color = defaultFillStyle;\\n    }\\n    context.fillStyle = asColorLike(color);\\n    context.fill();\\n  }\\n  if (this.stroke_) {\\n    context.strokeStyle = renderOptions.strokeStyle;\\n    context.lineWidth = renderOptions.strokeWidth;\\n    if (renderOptions.lineDash) {\\n      context.setLineDash(renderOptions.lineDash);\\n      context.lineDashOffset = renderOptions.lineDashOffset;\\n    }\\n    context.lineCap = renderOptions.lineCap;\\n    context.lineJoin = renderOptions.lineJoin;\\n    context.miterLimit = renderOptions.miterLimit;\\n    context.stroke();\\n  }\\n  context.closePath();\\n};\\n\\n\\n/**\\n * @private\\n * @param {module:ol/style/RegularShape~RenderOptions} renderOptions Render options.\\n */\\nRegularShape.prototype.createHitDetectionCanvas_ = function(renderOptions) {\\n  this.hitDetectionImageSize_ = [renderOptions.size, renderOptions.size];\\n  if (this.fill_) {\\n    this.hitDetectionCanvas_ = this.canvas_;\\n    return;\\n  }\\n\\n  // if no fill style is set, create an extra hit-detection image with a\\n  // default fill style\\n  const context = createCanvasContext2D(renderOptions.size, renderOptions.size);\\n  this.hitDetectionCanvas_ = context.canvas;\\n\\n  this.drawHitDetectionCanvas_(renderOptions, context, 0, 0);\\n};\\n\\n\\n/**\\n * @private\\n * @param {module:ol/style/RegularShape~RenderOptions} renderOptions Render options.\\n * @param {CanvasRenderingContext2D} context The context.\\n * @param {number} x The origin for the symbol (x).\\n * @param {number} y The origin for the symbol (y).\\n */\\nRegularShape.prototype.drawHitDetectionCanvas_ = function(renderOptions, context, x, y) {\\n  // reset transform\\n  context.setTransform(1, 0, 0, 1, 0, 0);\\n\\n  // then move to (x, y)\\n  context.translate(x, y);\\n\\n  context.beginPath();\\n\\n  let points = this.points_;\\n  if (points === Infinity) {\\n    context.arc(\\n      renderOptions.size / 2, renderOptions.size / 2,\\n      this.radius_, 0, 2 * Math.PI, true);\\n  } else {\\n    const radius2 = (this.radius2_ !== undefined) ? this.radius2_\\n      : this.radius_;\\n    if (radius2 !== this.radius_) {\\n      points = 2 * points;\\n    }\\n    let i, radiusC, angle0;\\n    for (i = 0; i <= points; i++) {\\n      angle0 = i * 2 * Math.PI / points - Math.PI / 2 + this.angle_;\\n      radiusC = i % 2 === 0 ? this.radius_ : radius2;\\n      context.lineTo(renderOptions.size / 2 + radiusC * Math.cos(angle0),\\n        renderOptions.size / 2 + radiusC * Math.sin(angle0));\\n    }\\n  }\\n\\n  context.fillStyle = defaultFillStyle;\\n  context.fill();\\n  if (this.stroke_) {\\n    context.strokeStyle = renderOptions.strokeStyle;\\n    context.lineWidth = renderOptions.strokeWidth;\\n    if (renderOptions.lineDash) {\\n      context.setLineDash(renderOptions.lineDash);\\n      context.lineDashOffset = renderOptions.lineDashOffset;\\n    }\\n    context.stroke();\\n  }\\n  context.closePath();\\n};\\n\\n\\n/**\\n * @return {string} The checksum.\\n */\\nRegularShape.prototype.getChecksum = function() {\\n  const strokeChecksum = this.stroke_ ?\\n    this.stroke_.getChecksum() : '-';\\n  const fillChecksum = this.fill_ ?\\n    this.fill_.getChecksum() : '-';\\n\\n  const recalculate = !this.checksums_ ||\\n      (strokeChecksum != this.checksums_[1] ||\\n      fillChecksum != this.checksums_[2] ||\\n      this.radius_ != this.checksums_[3] ||\\n      this.radius2_ != this.checksums_[4] ||\\n      this.angle_ != this.checksums_[5] ||\\n      this.points_ != this.checksums_[6]);\\n\\n  if (recalculate) {\\n    const checksum = 'r' + strokeChecksum + fillChecksum +\\n        (this.radius_ !== undefined ? this.radius_.toString() : '-') +\\n        (this.radius2_ !== undefined ? this.radius2_.toString() : '-') +\\n        (this.angle_ !== undefined ? this.angle_.toString() : '-') +\\n        (this.points_ !== undefined ? this.points_.toString() : '-');\\n    this.checksums_ = [checksum, strokeChecksum, fillChecksum,\\n      this.radius_, this.radius2_, this.angle_, this.points_];\\n  }\\n\\n  return this.checksums_[0];\\n};\\nexport default RegularShape;\\n\",\"/**\\n * @module ol/style/Circle\\n */\\nimport {inherits} from '../index.js';\\nimport RegularShape from '../style/RegularShape.js';\\n\\n\\n/**\\n * @typedef {Object} Options\\n * @property {module:ol/style/Fill} [fill] Fill style.\\n * @property {number} radius Circle radius.\\n * @property {boolean} [snapToPixel=true] If `true` integral numbers of pixels are used as the X and Y pixel coordinate\\n * when drawing the circle in the output canvas. If `false` fractional numbers may be used. Using `true` allows for\\n * \\\"sharp\\\" rendering (no blur), while using `false` allows for \\\"accurate\\\" rendering. Note that accuracy is important if\\n * the circle's position is animated. Without it, the circle may jitter noticeably.\\n * @property {module:ol/style/Stroke} [stroke] Stroke style.\\n * @property {module:ol/style/AtlasManager} [atlasManager] The atlas manager to use for this circle.\\n * When using WebGL it is recommended to use an atlas manager to avoid texture switching. If an atlas manager is given,\\n * the circle is added to an atlas. By default no atlas manager is used.\\n */\\n\\n\\n/**\\n * @classdesc\\n * Set circle style for vector features.\\n *\\n * @constructor\\n * @param {module:ol/style/Circle~Options=} opt_options Options.\\n * @extends {module:ol/style/RegularShape}\\n * @api\\n */\\nconst CircleStyle = function(opt_options) {\\n\\n  const options = opt_options || {};\\n\\n  RegularShape.call(this, {\\n    points: Infinity,\\n    fill: options.fill,\\n    radius: options.radius,\\n    snapToPixel: options.snapToPixel,\\n    stroke: options.stroke,\\n    atlasManager: options.atlasManager\\n  });\\n\\n};\\n\\ninherits(CircleStyle, RegularShape);\\n\\n\\n/**\\n * Clones the style.  If an atlasmanager was provided to the original style it will be used in the cloned style, too.\\n * @return {module:ol/style/Circle} The cloned style.\\n * @override\\n * @api\\n */\\nCircleStyle.prototype.clone = function() {\\n  const style = new CircleStyle({\\n    fill: this.getFill() ? this.getFill().clone() : undefined,\\n    stroke: this.getStroke() ? this.getStroke().clone() : undefined,\\n    radius: this.getRadius(),\\n    snapToPixel: this.getSnapToPixel(),\\n    atlasManager: this.atlasManager_\\n  });\\n  style.setOpacity(this.getOpacity());\\n  style.setScale(this.getScale());\\n  return style;\\n};\\n\\n\\n/**\\n * Set the circle radius.\\n *\\n * @param {number} radius Circle radius.\\n * @api\\n */\\nCircleStyle.prototype.setRadius = function(radius) {\\n  this.radius_ = radius;\\n  this.render_(this.atlasManager_);\\n};\\nexport default CircleStyle;\\n\",\"/**\\n * @module ol/style/Fill\\n */\\nimport {getUid} from '../index.js';\\nimport {asString} from '../color.js';\\n\\n\\n/**\\n * @typedef {Object} Options\\n * @property {module:ol/color~Color|module:ol/colorlike~ColorLike} [color] A color, gradient or pattern.\\n * See {@link module:ol/color~Color} and {@link module:ol/colorlike~ColorLike} for possible formats.\\n * Default null; if null, the Canvas/renderer default black will be used.\\n */\\n\\n\\n/**\\n * @classdesc\\n * Set fill style for vector features.\\n *\\n * @constructor\\n * @param {module:ol/style/Fill~Options=} opt_options Options.\\n * @api\\n */\\nconst Fill = function(opt_options) {\\n\\n  const options = opt_options || {};\\n\\n  /**\\n   * @private\\n   * @type {module:ol/color~Color|module:ol/colorlike~ColorLike}\\n   */\\n  this.color_ = options.color !== undefined ? options.color : null;\\n\\n  /**\\n   * @private\\n   * @type {string|undefined}\\n   */\\n  this.checksum_ = undefined;\\n};\\n\\n\\n/**\\n * Clones the style. The color is not cloned if it is an {@link module:ol/colorlike~ColorLike}.\\n * @return {module:ol/style/Fill} The cloned style.\\n * @api\\n */\\nFill.prototype.clone = function() {\\n  const color = this.getColor();\\n  return new Fill({\\n    color: (color && color.slice) ? color.slice() : color || undefined\\n  });\\n};\\n\\n\\n/**\\n * Get the fill color.\\n * @return {module:ol/color~Color|module:ol/colorlike~ColorLike} Color.\\n * @api\\n */\\nFill.prototype.getColor = function() {\\n  return this.color_;\\n};\\n\\n\\n/**\\n * Set the color.\\n *\\n * @param {module:ol/color~Color|module:ol/colorlike~ColorLike} color Color.\\n * @api\\n */\\nFill.prototype.setColor = function(color) {\\n  this.color_ = color;\\n  this.checksum_ = undefined;\\n};\\n\\n\\n/**\\n * @return {string} The checksum.\\n */\\nFill.prototype.getChecksum = function() {\\n  if (this.checksum_ === undefined) {\\n    if (\\n      this.color_ instanceof CanvasPattern ||\\n        this.color_ instanceof CanvasGradient\\n    ) {\\n      this.checksum_ = getUid(this.color_).toString();\\n    } else {\\n      this.checksum_ = 'f' + (this.color_ ? asString(this.color_) : '-');\\n    }\\n  }\\n\\n  return this.checksum_;\\n};\\nexport default Fill;\\n\",\"/**\\n * @module ol/style/Stroke\\n */\\nimport {getUid} from '../index.js';\\n\\n\\n/**\\n * @typedef {Object} Options\\n * @property {module:ol/color~Color|module:ol/colorlike~ColorLike} [color] A color, gradient or pattern.\\n * See {@link module:ol/color~Color} and {@link module:ol/colorlike~ColorLike} for possible formats.\\n * Default null; if null, the Canvas/renderer default black will be used.\\n * @property {string} [lineCap='round'] Line cap style: `butt`, `round`, or `square`.\\n * @property {string} [lineJoin='round'] Line join style: `bevel`, `round`, or `miter`.\\n * @property {Array.<number>} [lineDash] Line dash pattern. Default is `undefined` (no dash).\\n * Please note that Internet Explorer 10 and lower do not support the `setLineDash` method on\\n * the `CanvasRenderingContext2D` and therefore this option will have no visual effect in these browsers.\\n * @property {number} [lineDashOffset=0] Line dash offset.\\n * @property {number} [miterLimit=10] Miter limit.\\n * @property {number} [width] Width.\\n */\\n\\n\\n/**\\n * @classdesc\\n * Set stroke style for vector features.\\n * Note that the defaults given are the Canvas defaults, which will be used if\\n * option is not defined. The `get` functions return whatever was entered in\\n * the options; they will not return the default.\\n *\\n * @constructor\\n * @param {module:ol/style/Stroke~Options=} opt_options Options.\\n * @api\\n */\\nconst Stroke = function(opt_options) {\\n\\n  const options = opt_options || {};\\n\\n  /**\\n   * @private\\n   * @type {module:ol/color~Color|module:ol/colorlike~ColorLike}\\n   */\\n  this.color_ = options.color !== undefined ? options.color : null;\\n\\n  /**\\n   * @private\\n   * @type {string|undefined}\\n   */\\n  this.lineCap_ = options.lineCap;\\n\\n  /**\\n   * @private\\n   * @type {Array.<number>}\\n   */\\n  this.lineDash_ = options.lineDash !== undefined ? options.lineDash : null;\\n\\n  /**\\n   * @private\\n   * @type {number|undefined}\\n   */\\n  this.lineDashOffset_ = options.lineDashOffset;\\n\\n  /**\\n   * @private\\n   * @type {string|undefined}\\n   */\\n  this.lineJoin_ = options.lineJoin;\\n\\n  /**\\n   * @private\\n   * @type {number|undefined}\\n   */\\n  this.miterLimit_ = options.miterLimit;\\n\\n  /**\\n   * @private\\n   * @type {number|undefined}\\n   */\\n  this.width_ = options.width;\\n\\n  /**\\n   * @private\\n   * @type {string|undefined}\\n   */\\n  this.checksum_ = undefined;\\n};\\n\\n\\n/**\\n * Clones the style.\\n * @return {module:ol/style/Stroke} The cloned style.\\n * @api\\n */\\nStroke.prototype.clone = function() {\\n  const color = this.getColor();\\n  return new Stroke({\\n    color: (color && color.slice) ? color.slice() : color || undefined,\\n    lineCap: this.getLineCap(),\\n    lineDash: this.getLineDash() ? this.getLineDash().slice() : undefined,\\n    lineDashOffset: this.getLineDashOffset(),\\n    lineJoin: this.getLineJoin(),\\n    miterLimit: this.getMiterLimit(),\\n    width: this.getWidth()\\n  });\\n};\\n\\n\\n/**\\n * Get the stroke color.\\n * @return {module:ol/color~Color|module:ol/colorlike~ColorLike} Color.\\n * @api\\n */\\nStroke.prototype.getColor = function() {\\n  return this.color_;\\n};\\n\\n\\n/**\\n * Get the line cap type for the stroke.\\n * @return {string|undefined} Line cap.\\n * @api\\n */\\nStroke.prototype.getLineCap = function() {\\n  return this.lineCap_;\\n};\\n\\n\\n/**\\n * Get the line dash style for the stroke.\\n * @return {Array.<number>} Line dash.\\n * @api\\n */\\nStroke.prototype.getLineDash = function() {\\n  return this.lineDash_;\\n};\\n\\n\\n/**\\n * Get the line dash offset for the stroke.\\n * @return {number|undefined} Line dash offset.\\n * @api\\n */\\nStroke.prototype.getLineDashOffset = function() {\\n  return this.lineDashOffset_;\\n};\\n\\n\\n/**\\n * Get the line join type for the stroke.\\n * @return {string|undefined} Line join.\\n * @api\\n */\\nStroke.prototype.getLineJoin = function() {\\n  return this.lineJoin_;\\n};\\n\\n\\n/**\\n * Get the miter limit for the stroke.\\n * @return {number|undefined} Miter limit.\\n * @api\\n */\\nStroke.prototype.getMiterLimit = function() {\\n  return this.miterLimit_;\\n};\\n\\n\\n/**\\n * Get the stroke width.\\n * @return {number|undefined} Width.\\n * @api\\n */\\nStroke.prototype.getWidth = function() {\\n  return this.width_;\\n};\\n\\n\\n/**\\n * Set the color.\\n *\\n * @param {module:ol/color~Color|module:ol/colorlike~ColorLike} color Color.\\n * @api\\n */\\nStroke.prototype.setColor = function(color) {\\n  this.color_ = color;\\n  this.checksum_ = undefined;\\n};\\n\\n\\n/**\\n * Set the line cap.\\n *\\n * @param {string|undefined} lineCap Line cap.\\n * @api\\n */\\nStroke.prototype.setLineCap = function(lineCap) {\\n  this.lineCap_ = lineCap;\\n  this.checksum_ = undefined;\\n};\\n\\n\\n/**\\n * Set the line dash.\\n *\\n * Please note that Internet Explorer 10 and lower [do not support][mdn] the\\n * `setLineDash` method on the `CanvasRenderingContext2D` and therefore this\\n * property will have no visual effect in these browsers.\\n *\\n * [mdn]: https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/setLineDash#Browser_compatibility\\n *\\n * @param {Array.<number>} lineDash Line dash.\\n * @api\\n */\\nStroke.prototype.setLineDash = function(lineDash) {\\n  this.lineDash_ = lineDash;\\n  this.checksum_ = undefined;\\n};\\n\\n\\n/**\\n * Set the line dash offset.\\n *\\n * @param {number|undefined} lineDashOffset Line dash offset.\\n * @api\\n */\\nStroke.prototype.setLineDashOffset = function(lineDashOffset) {\\n  this.lineDashOffset_ = lineDashOffset;\\n  this.checksum_ = undefined;\\n};\\n\\n\\n/**\\n * Set the line join.\\n *\\n * @param {string|undefined} lineJoin Line join.\\n * @api\\n */\\nStroke.prototype.setLineJoin = function(lineJoin) {\\n  this.lineJoin_ = lineJoin;\\n  this.checksum_ = undefined;\\n};\\n\\n\\n/**\\n * Set the miter limit.\\n *\\n * @param {number|undefined} miterLimit Miter limit.\\n * @api\\n */\\nStroke.prototype.setMiterLimit = function(miterLimit) {\\n  this.miterLimit_ = miterLimit;\\n  this.checksum_ = undefined;\\n};\\n\\n\\n/**\\n * Set the width.\\n *\\n * @param {number|undefined} width Width.\\n * @api\\n */\\nStroke.prototype.setWidth = function(width) {\\n  this.width_ = width;\\n  this.checksum_ = undefined;\\n};\\n\\n\\n/**\\n * @return {string} The checksum.\\n */\\nStroke.prototype.getChecksum = function() {\\n  if (this.checksum_ === undefined) {\\n    this.checksum_ = 's';\\n    if (this.color_) {\\n      if (typeof this.color_ === 'string') {\\n        this.checksum_ += this.color_;\\n      } else {\\n        this.checksum_ += getUid(this.color_).toString();\\n      }\\n    } else {\\n      this.checksum_ += '-';\\n    }\\n    this.checksum_ += ',' +\\n        (this.lineCap_ !== undefined ?\\n          this.lineCap_.toString() : '-') + ',' +\\n        (this.lineDash_ ?\\n          this.lineDash_.toString() : '-') + ',' +\\n        (this.lineDashOffset_ !== undefined ?\\n          this.lineDashOffset_ : '-') + ',' +\\n        (this.lineJoin_ !== undefined ?\\n          this.lineJoin_ : '-') + ',' +\\n        (this.miterLimit_ !== undefined ?\\n          this.miterLimit_.toString() : '-') + ',' +\\n        (this.width_ !== undefined ?\\n          this.width_.toString() : '-');\\n  }\\n\\n  return this.checksum_;\\n};\\nexport default Stroke;\\n\",\"/**\\n * @module ol/style/Style\\n */\\n\\n/**\\n * Feature styles.\\n *\\n * If no style is defined, the following default style is used:\\n * ```js\\n *  import {Fill, Stroke, Cirle, Style} from 'ol/style';\\n *\\n *  var fill = new Fill({\\n *    color: 'rgba(255,255,255,0.4)'\\n *  });\\n *  var stroke = new Stroke({\\n *    color: '#3399CC',\\n *    width: 1.25\\n *  });\\n *  var styles = [\\n *    new Style({\\n *      image: new Circle({\\n *        fill: fill,\\n *        stroke: stroke,\\n *        radius: 5\\n *      }),\\n *      fill: fill,\\n *      stroke: stroke\\n *    })\\n *  ];\\n * ```\\n *\\n * A separate editing style has the following defaults:\\n * ```js\\n *  import {Fill, Stroke, Cirle, Style} from 'ol/style';\\n *  import GeometryType from 'ol/geom/GeometryType';\\n *\\n *  var white = [255, 255, 255, 1];\\n *  var blue = [0, 153, 255, 1];\\n *  var width = 3;\\n *  styles[GeometryType.POLYGON] = [\\n *    new Style({\\n *      fill: new Fill({\\n *        color: [255, 255, 255, 0.5]\\n *      })\\n *    })\\n *  ];\\n *  styles[GeometryType.MULTI_POLYGON] =\\n *      styles[GeometryType.POLYGON];\\n *  styles[GeometryType.LINE_STRING] = [\\n *    new Style({\\n *      stroke: new Stroke({\\n *        color: white,\\n *        width: width + 2\\n *      })\\n *    }),\\n *    new Style({\\n *      stroke: new Stroke({\\n *        color: blue,\\n *        width: width\\n *      })\\n *    })\\n *  ];\\n *  styles[GeometryType.MULTI_LINE_STRING] =\\n *      styles[GeometryType.LINE_STRING];\\n *  styles[GeometryType.POINT] = [\\n *    new Style({\\n *      image: new Circle({\\n *        radius: width * 2,\\n *        fill: new Fill({\\n *          color: blue\\n *        }),\\n *        stroke: new Stroke({\\n *          color: white,\\n *          width: width / 2\\n *        })\\n *      }),\\n *      zIndex: Infinity\\n *    })\\n *  ];\\n *  styles[GeometryType.MULTI_POINT] =\\n *      styles[GeometryType.POINT];\\n *  styles[GEOMETRY_COLLECTION] =\\n *      styles[GeometryType.POLYGON].concat(\\n *          styles[GeometryType.POINT]\\n *      );\\n * ```\\n */\\nimport {assert} from '../asserts.js';\\nimport GeometryType from '../geom/GeometryType.js';\\nimport CircleStyle from '../style/Circle.js';\\nimport Fill from '../style/Fill.js';\\nimport Stroke from '../style/Stroke.js';\\n\\n\\n/**\\n * A function that takes an {@link module:ol/Feature} and a `{number}`\\n * representing the view's resolution. The function should return a\\n * {@link module:ol/style/Style} or an array of them. This way e.g. a\\n * vector layer can be styled.\\n *\\n * @typedef {function((module:ol/Feature|module:ol/render/Feature), number):\\n *     (module:ol/style/Style|Array.<module:ol/style/Style>)} StyleFunction\\n */\\n\\n\\n/**\\n * A function that takes an {@link module:ol/Feature} as argument and returns an\\n * {@link module:ol/geom/Geometry} that will be rendered and styled for the feature.\\n *\\n * @typedef {function((module:ol/Feature|module:ol/render/Feature)):\\n *     (module:ol/geom/Geometry|module:ol/render/Feature|undefined)} GeometryFunction\\n */\\n\\n\\n/**\\n * Custom renderer function. Takes two arguments:\\n *\\n * 1. The pixel coordinates of the geometry in GeoJSON notation.\\n * 2. The {@link module:ol/render~State} of the layer renderer.\\n *\\n * @typedef {function((module:ol/coordinate~Coordinate|Array<module:ol/coordinate~Coordinate>|Array.<Array.<module:ol/coordinate~Coordinate>>),module:ol/render~State)}\\n * RenderFunction\\n */\\n\\n\\n/**\\n * @typedef {Object} Options\\n * @property {string|module:ol/geom/Geometry|module:ol/style/Style~GeometryFunction} [geometry] Feature property or geometry\\n * or function returning a geometry to render for this style.\\n * @property {module:ol/style/Fill} [fill] Fill style.\\n * @property {module:ol/style/Image} [image] Image style.\\n * @property {module:ol/style/Style~RenderFunction} [renderer] Custom renderer. When configured, `fill`, `stroke` and `image` will be\\n * ignored, and the provided function will be called with each render frame for each geometry.\\n * @property {module:ol/style/Stroke} [stroke] Stroke style.\\n * @property {module:ol/style/Text} [text] Text style.\\n * @property {number} [zIndex] Z index.\\n */\\n\\n\\n/**\\n * @classdesc\\n * Container for vector feature rendering styles. Any changes made to the style\\n * or its children through `set*()` methods will not take effect until the\\n * feature or layer that uses the style is re-rendered.\\n *\\n * @constructor\\n * @struct\\n * @param {module:ol/style/Style~Options=} opt_options Style options.\\n * @api\\n */\\nconst Style = function(opt_options) {\\n\\n  const options = opt_options || {};\\n\\n  /**\\n   * @private\\n   * @type {string|module:ol/geom/Geometry|module:ol/style/Style~GeometryFunction}\\n   */\\n  this.geometry_ = null;\\n\\n  /**\\n   * @private\\n   * @type {!module:ol/style/Style~GeometryFunction}\\n   */\\n  this.geometryFunction_ = defaultGeometryFunction;\\n\\n  if (options.geometry !== undefined) {\\n    this.setGeometry(options.geometry);\\n  }\\n\\n  /**\\n   * @private\\n   * @type {module:ol/style/Fill}\\n   */\\n  this.fill_ = options.fill !== undefined ? options.fill : null;\\n\\n  /**\\n     * @private\\n     * @type {module:ol/style/Image}\\n     */\\n  this.image_ = options.image !== undefined ? options.image : null;\\n\\n  /**\\n   * @private\\n   * @type {module:ol/style/Style~RenderFunction|null}\\n   */\\n  this.renderer_ = options.renderer !== undefined ? options.renderer : null;\\n\\n  /**\\n   * @private\\n   * @type {module:ol/style/Stroke}\\n   */\\n  this.stroke_ = options.stroke !== undefined ? options.stroke : null;\\n\\n  /**\\n   * @private\\n   * @type {module:ol/style/Text}\\n   */\\n  this.text_ = options.text !== undefined ? options.text : null;\\n\\n  /**\\n   * @private\\n   * @type {number|undefined}\\n   */\\n  this.zIndex_ = options.zIndex;\\n\\n};\\n\\n\\n/**\\n * Clones the style.\\n * @return {module:ol/style/Style} The cloned style.\\n * @api\\n */\\nStyle.prototype.clone = function() {\\n  let geometry = this.getGeometry();\\n  if (geometry && geometry.clone) {\\n    geometry = geometry.clone();\\n  }\\n  return new Style({\\n    geometry: geometry,\\n    fill: this.getFill() ? this.getFill().clone() : undefined,\\n    image: this.getImage() ? this.getImage().clone() : undefined,\\n    stroke: this.getStroke() ? this.getStroke().clone() : undefined,\\n    text: this.getText() ? this.getText().clone() : undefined,\\n    zIndex: this.getZIndex()\\n  });\\n};\\n\\n\\n/**\\n * Get the custom renderer function that was configured with\\n * {@link #setRenderer} or the `renderer` constructor option.\\n * @return {module:ol/style/Style~RenderFunction|null} Custom renderer function.\\n * @api\\n */\\nStyle.prototype.getRenderer = function() {\\n  return this.renderer_;\\n};\\n\\n\\n/**\\n * Sets a custom renderer function for this style. When set, `fill`, `stroke`\\n * and `image` options of the style will be ignored.\\n * @param {module:ol/style/Style~RenderFunction|null} renderer Custom renderer function.\\n * @api\\n */\\nStyle.prototype.setRenderer = function(renderer) {\\n  this.renderer_ = renderer;\\n};\\n\\n\\n/**\\n * Get the geometry to be rendered.\\n * @return {string|module:ol/geom/Geometry|module:ol/style/Style~GeometryFunction}\\n * Feature property or geometry or function that returns the geometry that will\\n * be rendered with this style.\\n * @api\\n */\\nStyle.prototype.getGeometry = function() {\\n  return this.geometry_;\\n};\\n\\n\\n/**\\n * Get the function used to generate a geometry for rendering.\\n * @return {!module:ol/style/Style~GeometryFunction} Function that is called with a feature\\n * and returns the geometry to render instead of the feature's geometry.\\n * @api\\n */\\nStyle.prototype.getGeometryFunction = function() {\\n  return this.geometryFunction_;\\n};\\n\\n\\n/**\\n * Get the fill style.\\n * @return {module:ol/style/Fill} Fill style.\\n * @api\\n */\\nStyle.prototype.getFill = function() {\\n  return this.fill_;\\n};\\n\\n\\n/**\\n * Set the fill style.\\n * @param {module:ol/style/Fill} fill Fill style.\\n * @api\\n */\\nStyle.prototype.setFill = function(fill) {\\n  this.fill_ = fill;\\n};\\n\\n\\n/**\\n * Get the image style.\\n * @return {module:ol/style/Image} Image style.\\n * @api\\n */\\nStyle.prototype.getImage = function() {\\n  return this.image_;\\n};\\n\\n\\n/**\\n * Set the image style.\\n * @param {module:ol/style/Image} image Image style.\\n * @api\\n */\\nStyle.prototype.setImage = function(image) {\\n  this.image_ = image;\\n};\\n\\n\\n/**\\n * Get the stroke style.\\n * @return {module:ol/style/Stroke} Stroke style.\\n * @api\\n */\\nStyle.prototype.getStroke = function() {\\n  return this.stroke_;\\n};\\n\\n\\n/**\\n * Set the stroke style.\\n * @param {module:ol/style/Stroke} stroke Stroke style.\\n * @api\\n */\\nStyle.prototype.setStroke = function(stroke) {\\n  this.stroke_ = stroke;\\n};\\n\\n\\n/**\\n * Get the text style.\\n * @return {module:ol/style/Text} Text style.\\n * @api\\n */\\nStyle.prototype.getText = function() {\\n  return this.text_;\\n};\\n\\n\\n/**\\n * Set the text style.\\n * @param {module:ol/style/Text} text Text style.\\n * @api\\n */\\nStyle.prototype.setText = function(text) {\\n  this.text_ = text;\\n};\\n\\n\\n/**\\n * Get the z-index for the style.\\n * @return {number|undefined} ZIndex.\\n * @api\\n */\\nStyle.prototype.getZIndex = function() {\\n  return this.zIndex_;\\n};\\n\\n\\n/**\\n * Set a geometry that is rendered instead of the feature's geometry.\\n *\\n * @param {string|module:ol/geom/Geometry|module:ol/style/Style~GeometryFunction} geometry\\n *     Feature property or geometry or function returning a geometry to render\\n *     for this style.\\n * @api\\n */\\nStyle.prototype.setGeometry = function(geometry) {\\n  if (typeof geometry === 'function') {\\n    this.geometryFunction_ = geometry;\\n  } else if (typeof geometry === 'string') {\\n    this.geometryFunction_ = function(feature) {\\n      return (\\n        /** @type {module:ol/geom/Geometry} */ (feature.get(geometry))\\n      );\\n    };\\n  } else if (!geometry) {\\n    this.geometryFunction_ = defaultGeometryFunction;\\n  } else if (geometry !== undefined) {\\n    this.geometryFunction_ = function() {\\n      return (\\n        /** @type {module:ol/geom/Geometry} */ (geometry)\\n      );\\n    };\\n  }\\n  this.geometry_ = geometry;\\n};\\n\\n\\n/**\\n * Set the z-index.\\n *\\n * @param {number|undefined} zIndex ZIndex.\\n * @api\\n */\\nStyle.prototype.setZIndex = function(zIndex) {\\n  this.zIndex_ = zIndex;\\n};\\n\\n\\n/**\\n * Convert the provided object into a style function.  Functions passed through\\n * unchanged.  Arrays of module:ol/style/Style or single style objects wrapped in a\\n * new style function.\\n * @param {module:ol/style/Style~StyleFunction|Array.<module:ol/style/Style>|module:ol/style/Style} obj\\n *     A style function, a single style, or an array of styles.\\n * @return {module:ol/style/Style~StyleFunction} A style function.\\n */\\nexport function toFunction(obj) {\\n  let styleFunction;\\n\\n  if (typeof obj === 'function') {\\n    styleFunction = obj;\\n  } else {\\n    /**\\n     * @type {Array.<module:ol/style/Style>}\\n     */\\n    let styles;\\n    if (Array.isArray(obj)) {\\n      styles = obj;\\n    } else {\\n      assert(obj instanceof Style,\\n        41); // Expected an `module:ol/style/Style~Style` or an array of `module:ol/style/Style~Style`\\n      styles = [obj];\\n    }\\n    styleFunction = function() {\\n      return styles;\\n    };\\n  }\\n  return styleFunction;\\n}\\n\\n\\n/**\\n * @type {Array.<module:ol/style/Style>}\\n */\\nlet defaultStyles = null;\\n\\n\\n/**\\n * @param {module:ol/Feature|module:ol/render/Feature} feature Feature.\\n * @param {number} resolution Resolution.\\n * @return {Array.<module:ol/style/Style>} Style.\\n */\\nexport function createDefaultStyle(feature, resolution) {\\n  // We don't use an immediately-invoked function\\n  // and a closure so we don't get an error at script evaluation time in\\n  // browsers that do not support Canvas. (module:ol/style/Circle~CircleStyle does\\n  // canvas.getContext('2d') at construction time, which will cause an.error\\n  // in such browsers.)\\n  if (!defaultStyles) {\\n    const fill = new Fill({\\n      color: 'rgba(255,255,255,0.4)'\\n    });\\n    const stroke = new Stroke({\\n      color: '#3399CC',\\n      width: 1.25\\n    });\\n    defaultStyles = [\\n      new Style({\\n        image: new CircleStyle({\\n          fill: fill,\\n          stroke: stroke,\\n          radius: 5\\n        }),\\n        fill: fill,\\n        stroke: stroke\\n      })\\n    ];\\n  }\\n  return defaultStyles;\\n}\\n\\n\\n/**\\n * Default styles for editing features.\\n * @return {Object.<module:ol/geom/GeometryType, Array.<module:ol/style/Style>>} Styles\\n */\\nexport function createEditingStyle() {\\n  /** @type {Object.<module:ol/geom/GeometryType, Array.<module:ol/style/Style>>} */\\n  const styles = {};\\n  const white = [255, 255, 255, 1];\\n  const blue = [0, 153, 255, 1];\\n  const width = 3;\\n  styles[GeometryType.POLYGON] = [\\n    new Style({\\n      fill: new Fill({\\n        color: [255, 255, 255, 0.5]\\n      })\\n    })\\n  ];\\n  styles[GeometryType.MULTI_POLYGON] =\\n      styles[GeometryType.POLYGON];\\n\\n  styles[GeometryType.LINE_STRING] = [\\n    new Style({\\n      stroke: new Stroke({\\n        color: white,\\n        width: width + 2\\n      })\\n    }),\\n    new Style({\\n      stroke: new Stroke({\\n        color: blue,\\n        width: width\\n      })\\n    })\\n  ];\\n  styles[GeometryType.MULTI_LINE_STRING] =\\n      styles[GeometryType.LINE_STRING];\\n\\n  styles[GeometryType.CIRCLE] =\\n      styles[GeometryType.POLYGON].concat(\\n        styles[GeometryType.LINE_STRING]\\n      );\\n\\n\\n  styles[GeometryType.POINT] = [\\n    new Style({\\n      image: new CircleStyle({\\n        radius: width * 2,\\n        fill: new Fill({\\n          color: blue\\n        }),\\n        stroke: new Stroke({\\n          color: white,\\n          width: width / 2\\n        })\\n      }),\\n      zIndex: Infinity\\n    })\\n  ];\\n  styles[GeometryType.MULTI_POINT] =\\n      styles[GeometryType.POINT];\\n\\n  styles[GeometryType.GEOMETRY_COLLECTION] =\\n      styles[GeometryType.POLYGON].concat(\\n        styles[GeometryType.LINE_STRING],\\n        styles[GeometryType.POINT]\\n      );\\n\\n  return styles;\\n}\\n\\n\\n/**\\n * Function that is called with a feature and returns its default geometry.\\n * @param {module:ol/Feature|module:ol/render/Feature} feature Feature to get the geometry for.\\n * @return {module:ol/geom/Geometry|module:ol/render/Feature|undefined} Geometry to render.\\n */\\nfunction defaultGeometryFunction(feature) {\\n  return feature.getGeometry();\\n}\\n\\nexport default Style;\\n\",\"/**\\n * @module ol/Feature\\n */\\nimport {assert} from './asserts.js';\\nimport {listen, unlisten, unlistenByKey} from './events.js';\\nimport EventType from './events/EventType.js';\\nimport {inherits} from './index.js';\\nimport BaseObject, {getChangeEventType} from './Object.js';\\nimport Geometry from './geom/Geometry.js';\\nimport Style from './style/Style.js';\\n\\n/**\\n * @classdesc\\n * A vector object for geographic features with a geometry and other\\n * attribute properties, similar to the features in vector file formats like\\n * GeoJSON.\\n *\\n * Features can be styled individually with `setStyle`; otherwise they use the\\n * style of their vector layer.\\n *\\n * Note that attribute properties are set as {@link module:ol/Object} properties on\\n * the feature object, so they are observable, and have get/set accessors.\\n *\\n * Typically, a feature has a single geometry property. You can set the\\n * geometry using the `setGeometry` method and get it with `getGeometry`.\\n * It is possible to store more than one geometry on a feature using attribute\\n * properties. By default, the geometry used for rendering is identified by\\n * the property name `geometry`. If you want to use another geometry property\\n * for rendering, use the `setGeometryName` method to change the attribute\\n * property associated with the geometry for the feature.  For example:\\n *\\n * ```js\\n *\\n * import Feature from 'ol/Feature';\\n * import Polygon from 'ol/geom/Polygon';\\n * import Point from 'ol/geom/Point';\\n *\\n * var feature = new Feature({\\n *   geometry: new Polygon(polyCoords),\\n *   labelPoint: new Point(labelCoords),\\n *   name: 'My Polygon'\\n * });\\n *\\n * // get the polygon geometry\\n * var poly = feature.getGeometry();\\n *\\n * // Render the feature as a point using the coordinates from labelPoint\\n * feature.setGeometryName('labelPoint');\\n *\\n * // get the point geometry\\n * var point = feature.getGeometry();\\n * ```\\n *\\n * @constructor\\n * @extends {module:ol/Object}\\n * @param {module:ol/geom/Geometry|Object.<string, *>=} opt_geometryOrProperties\\n * You may pass a Geometry object directly, or an object literal containing\\n * properties. If you pass an object literal, you may include a Geometry\\n * associated with a `geometry` key.\\n * @api\\n */\\nconst Feature = function(opt_geometryOrProperties) {\\n\\n  BaseObject.call(this);\\n\\n  /**\\n   * @private\\n   * @type {number|string|undefined}\\n   */\\n  this.id_ = undefined;\\n\\n  /**\\n   * @type {string}\\n   * @private\\n   */\\n  this.geometryName_ = 'geometry';\\n\\n  /**\\n   * User provided style.\\n   * @private\\n   * @type {module:ol/style/Style|Array.<module:ol/style/Style>|module:ol/style/Style~StyleFunction}\\n   */\\n  this.style_ = null;\\n\\n  /**\\n   * @private\\n   * @type {module:ol/style/Style~StyleFunction|undefined}\\n   */\\n  this.styleFunction_ = undefined;\\n\\n  /**\\n   * @private\\n   * @type {?module:ol/events~EventsKey}\\n   */\\n  this.geometryChangeKey_ = null;\\n\\n  listen(\\n    this, getChangeEventType(this.geometryName_),\\n    this.handleGeometryChanged_, this);\\n\\n  if (opt_geometryOrProperties !== undefined) {\\n    if (opt_geometryOrProperties instanceof Geometry ||\\n        !opt_geometryOrProperties) {\\n      const geometry = opt_geometryOrProperties;\\n      this.setGeometry(geometry);\\n    } else {\\n      /** @type {Object.<string, *>} */\\n      const properties = opt_geometryOrProperties;\\n      this.setProperties(properties);\\n    }\\n  }\\n};\\n\\ninherits(Feature, BaseObject);\\n\\n\\n/**\\n * Clone this feature. If the original feature has a geometry it\\n * is also cloned. The feature id is not set in the clone.\\n * @return {module:ol/Feature} The clone.\\n * @api\\n */\\nFeature.prototype.clone = function() {\\n  const clone = new Feature(this.getProperties());\\n  clone.setGeometryName(this.getGeometryName());\\n  const geometry = this.getGeometry();\\n  if (geometry) {\\n    clone.setGeometry(geometry.clone());\\n  }\\n  const style = this.getStyle();\\n  if (style) {\\n    clone.setStyle(style);\\n  }\\n  return clone;\\n};\\n\\n\\n/**\\n * Get the feature's default geometry.  A feature may have any number of named\\n * geometries.  The \\\"default\\\" geometry (the one that is rendered by default) is\\n * set when calling {@link module:ol/Feature~Feature#setGeometry}.\\n * @return {module:ol/geom/Geometry|undefined} The default geometry for the feature.\\n * @api\\n * @observable\\n */\\nFeature.prototype.getGeometry = function() {\\n  return (\\n    /** @type {module:ol/geom/Geometry|undefined} */ (this.get(this.geometryName_))\\n  );\\n};\\n\\n\\n/**\\n * Get the feature identifier.  This is a stable identifier for the feature and\\n * is either set when reading data from a remote source or set explicitly by\\n * calling {@link module:ol/Feature~Feature#setId}.\\n * @return {number|string|undefined} Id.\\n * @api\\n */\\nFeature.prototype.getId = function() {\\n  return this.id_;\\n};\\n\\n\\n/**\\n * Get the name of the feature's default geometry.  By default, the default\\n * geometry is named `geometry`.\\n * @return {string} Get the property name associated with the default geometry\\n *     for this feature.\\n * @api\\n */\\nFeature.prototype.getGeometryName = function() {\\n  return this.geometryName_;\\n};\\n\\n\\n/**\\n * Get the feature's style. Will return what was provided to the\\n * {@link module:ol/Feature~Feature#setStyle} method.\\n * @return {module:ol/style/Style|Array.<module:ol/style/Style>|module:ol/style/Style~StyleFunction} The feature style.\\n * @api\\n */\\nFeature.prototype.getStyle = function() {\\n  return this.style_;\\n};\\n\\n\\n/**\\n * Get the feature's style function.\\n * @return {module:ol/style/Style~StyleFunction|undefined} Return a function\\n * representing the current style of this feature.\\n * @api\\n */\\nFeature.prototype.getStyleFunction = function() {\\n  return this.styleFunction_;\\n};\\n\\n\\n/**\\n * @private\\n */\\nFeature.prototype.handleGeometryChange_ = function() {\\n  this.changed();\\n};\\n\\n\\n/**\\n * @private\\n */\\nFeature.prototype.handleGeometryChanged_ = function() {\\n  if (this.geometryChangeKey_) {\\n    unlistenByKey(this.geometryChangeKey_);\\n    this.geometryChangeKey_ = null;\\n  }\\n  const geometry = this.getGeometry();\\n  if (geometry) {\\n    this.geometryChangeKey_ = listen(geometry,\\n      EventType.CHANGE, this.handleGeometryChange_, this);\\n  }\\n  this.changed();\\n};\\n\\n\\n/**\\n * Set the default geometry for the feature.  This will update the property\\n * with the name returned by {@link module:ol/Feature~Feature#getGeometryName}.\\n * @param {module:ol/geom/Geometry|undefined} geometry The new geometry.\\n * @api\\n * @observable\\n */\\nFeature.prototype.setGeometry = function(geometry) {\\n  this.set(this.geometryName_, geometry);\\n};\\n\\n\\n/**\\n * Set the style for the feature.  This can be a single style object, an array\\n * of styles, or a function that takes a resolution and returns an array of\\n * styles. If it is `null` the feature has no style (a `null` style).\\n * @param {module:ol/style/Style|Array.<module:ol/style/Style>|module:ol/style/Style~StyleFunction} style Style for this feature.\\n * @api\\n * @fires module:ol/events/Event~Event#event:change\\n */\\nFeature.prototype.setStyle = function(style) {\\n  this.style_ = style;\\n  this.styleFunction_ = !style ? undefined : createStyleFunction(style);\\n  this.changed();\\n};\\n\\n\\n/**\\n * Set the feature id.  The feature id is considered stable and may be used when\\n * requesting features or comparing identifiers returned from a remote source.\\n * The feature id can be used with the\\n * {@link module:ol/source/Vector~VectorSource#getFeatureById} method.\\n * @param {number|string|undefined} id The feature id.\\n * @api\\n * @fires module:ol/events/Event~Event#event:change\\n */\\nFeature.prototype.setId = function(id) {\\n  this.id_ = id;\\n  this.changed();\\n};\\n\\n\\n/**\\n * Set the property name to be used when getting the feature's default geometry.\\n * When calling {@link module:ol/Feature~Feature#getGeometry}, the value of the property with\\n * this name will be returned.\\n * @param {string} name The property name of the default geometry.\\n * @api\\n */\\nFeature.prototype.setGeometryName = function(name) {\\n  unlisten(\\n    this, getChangeEventType(this.geometryName_),\\n    this.handleGeometryChanged_, this);\\n  this.geometryName_ = name;\\n  listen(\\n    this, getChangeEventType(this.geometryName_),\\n    this.handleGeometryChanged_, this);\\n  this.handleGeometryChanged_();\\n};\\n\\n\\n/**\\n * Convert the provided object into a feature style function.  Functions passed\\n * through unchanged.  Arrays of module:ol/style/Style or single style objects wrapped\\n * in a new feature style function.\\n * @param {module:ol/style/Style~StyleFunction|!Array.<module:ol/style/Style>|!module:ol/style/Style} obj\\n *     A feature style function, a single style, or an array of styles.\\n * @return {module:ol/style/Style~StyleFunction} A style function.\\n */\\nexport function createStyleFunction(obj) {\\n  if (typeof obj === 'function') {\\n    return obj;\\n  } else {\\n    /**\\n     * @type {Array.<module:ol/style/Style>}\\n     */\\n    let styles;\\n    if (Array.isArray(obj)) {\\n      styles = obj;\\n    } else {\\n      assert(obj instanceof Style,\\n        41); // Expected an `module:ol/style/Style~Style` or an array of `module:ol/style/Style~Style`\\n      styles = [obj];\\n    }\\n    return function() {\\n      return styles;\\n    };\\n  }\\n}\\nexport default Feature;\\n\",\"/**\\n * @module ol/format/Feature\\n */\\nimport Geometry from '../geom/Geometry.js';\\nimport {assign} from '../obj.js';\\nimport {get as getProjection, equivalent as equivalentProjection, transformExtent} from '../proj.js';\\n\\n\\n/**\\n * @typedef {Object} ReadOptions\\n * @property {module:ol/proj~ProjectionLike} dataProjection Projection of the data we are reading.\\n * If not provided, the projection will be derived from the data (where possible) or\\n * the `defaultDataProjection` of the format is assigned (where set). If the projection\\n * can not be derived from the data and if no `defaultDataProjection` is set for a format,\\n * the features will not be reprojected.\\n * @property {module:ol/extent~Extent} extent Tile extent of the tile being read. This is only used and\\n * required for {@link module:ol/format/MVT}.\\n * @property {module:ol/proj~ProjectionLike} featureProjection Projection of the feature geometries\\n * created by the format reader. If not provided, features will be returned in the\\n * `dataProjection`.\\n */\\n\\n\\n/**\\n * @typedef {Object} WriteOptions\\n * @property {module:ol/proj~ProjectionLike} dataProjection Projection of the data we are writing.\\n * If not provided, the `defaultDataProjection` of the format is assigned (where set).\\n * If no `defaultDataProjection` is set for a format, the features will be returned\\n * in the `featureProjection`.\\n * @property {module:ol/proj~ProjectionLike} featureProjection Projection of the feature geometries\\n * that will be serialized by the format writer. If not provided, geometries are assumed\\n * to be in the `dataProjection` if that is set; in other words, they are not transformed.\\n * @property {boolean} [rightHanded] When writing geometries, follow the right-hand\\n * rule for linear ring orientation.  This means that polygons will have counter-clockwise\\n * exterior rings and clockwise interior rings.  By default, coordinates are serialized\\n * as they are provided at construction.  If `true`, the right-hand rule will\\n * be applied.  If `false`, the left-hand rule will be applied (clockwise for\\n * exterior and counter-clockwise for interior rings).  Note that not all\\n * formats support this.  The GeoJSON format does use this property when writing\\n * geometries.\\n * @property {number} [decimals] Maximum number of decimal places for coordinates.\\n * Coordinates are stored internally as floats, but floating-point arithmetic can create\\n * coordinates with a large number of decimal places, not generally wanted on output.\\n * Set a number here to round coordinates. Can also be used to ensure that\\n * coordinates read in can be written back out with the same number of decimals.\\n * Default is no rounding.\\n */\\n\\n\\n/**\\n * @classdesc\\n * Abstract base class; normally only used for creating subclasses and not\\n * instantiated in apps.\\n * Base class for feature formats.\\n * {module:ol/format/Feature~FeatureFormat} subclasses provide the ability to decode and encode\\n * {@link module:ol/Feature~Feature} objects from a variety of commonly used geospatial\\n * file formats.  See the documentation for each format for more details.\\n *\\n * @constructor\\n * @abstract\\n * @api\\n */\\nconst FeatureFormat = function() {\\n\\n  /**\\n   * @protected\\n   * @type {module:ol/proj/Projection}\\n   */\\n  this.defaultDataProjection = null;\\n\\n  /**\\n   * @protected\\n   * @type {module:ol/proj/Projection}\\n   */\\n  this.defaultFeatureProjection = null;\\n\\n};\\n\\n\\n/**\\n * Adds the data projection to the read options.\\n * @param {Document|Node|Object|string} source Source.\\n * @param {module:ol/format/Feature~ReadOptions=} opt_options Options.\\n * @return {module:ol/format/Feature~ReadOptions|undefined} Options.\\n * @protected\\n */\\nFeatureFormat.prototype.getReadOptions = function(source, opt_options) {\\n  let options;\\n  if (opt_options) {\\n    options = {\\n      dataProjection: opt_options.dataProjection ?\\n        opt_options.dataProjection : this.readProjection(source),\\n      featureProjection: opt_options.featureProjection\\n    };\\n  }\\n  return this.adaptOptions(options);\\n};\\n\\n\\n/**\\n * Sets the `defaultDataProjection` on the options, if no `dataProjection`\\n * is set.\\n * @param {module:ol/format/Feature~WriteOptions|module:ol/format/Feature~ReadOptions|undefined} options\\n *     Options.\\n * @protected\\n * @return {module:ol/format/Feature~WriteOptions|module:ol/format/Feature~ReadOptions|undefined}\\n *     Updated options.\\n */\\nFeatureFormat.prototype.adaptOptions = function(options) {\\n  return assign({\\n    dataProjection: this.defaultDataProjection,\\n    featureProjection: this.defaultFeatureProjection\\n  }, options);\\n};\\n\\n\\n/**\\n * Get the extent from the source of the last {@link readFeatures} call.\\n * @return {module:ol/extent~Extent} Tile extent.\\n */\\nFeatureFormat.prototype.getLastExtent = function() {\\n  return null;\\n};\\n\\n\\n/**\\n * @abstract\\n * @return {module:ol/format/FormatType} Format.\\n */\\nFeatureFormat.prototype.getType = function() {};\\n\\n\\n/**\\n * Read a single feature from a source.\\n *\\n * @abstract\\n * @param {Document|Node|Object|string} source Source.\\n * @param {module:ol/format/Feature~ReadOptions=} opt_options Read options.\\n * @return {module:ol/Feature} Feature.\\n */\\nFeatureFormat.prototype.readFeature = function(source, opt_options) {};\\n\\n\\n/**\\n * Read all features from a source.\\n *\\n * @abstract\\n * @param {Document|Node|ArrayBuffer|Object|string} source Source.\\n * @param {module:ol/format/Feature~ReadOptions=} opt_options Read options.\\n * @return {Array.<module:ol/Feature>} Features.\\n */\\nFeatureFormat.prototype.readFeatures = function(source, opt_options) {};\\n\\n\\n/**\\n * Read a single geometry from a source.\\n *\\n * @abstract\\n * @param {Document|Node|Object|string} source Source.\\n * @param {module:ol/format/Feature~ReadOptions=} opt_options Read options.\\n * @return {module:ol/geom/Geometry} Geometry.\\n */\\nFeatureFormat.prototype.readGeometry = function(source, opt_options) {};\\n\\n\\n/**\\n * Read the projection from a source.\\n *\\n * @abstract\\n * @param {Document|Node|Object|string} source Source.\\n * @return {module:ol/proj/Projection} Projection.\\n */\\nFeatureFormat.prototype.readProjection = function(source) {};\\n\\n\\n/**\\n * Encode a feature in this format.\\n *\\n * @abstract\\n * @param {module:ol/Feature} feature Feature.\\n * @param {module:ol/format/Feature~WriteOptions=} opt_options Write options.\\n * @return {string} Result.\\n */\\nFeatureFormat.prototype.writeFeature = function(feature, opt_options) {};\\n\\n\\n/**\\n * Encode an array of features in this format.\\n *\\n * @abstract\\n * @param {Array.<module:ol/Feature>} features Features.\\n * @param {module:ol/format/Feature~WriteOptions=} opt_options Write options.\\n * @return {string} Result.\\n */\\nFeatureFormat.prototype.writeFeatures = function(features, opt_options) {};\\n\\n\\n/**\\n * Write a single geometry in this format.\\n *\\n * @abstract\\n * @param {module:ol/geom/Geometry} geometry Geometry.\\n * @param {module:ol/format/Feature~WriteOptions=} opt_options Write options.\\n * @return {string} Result.\\n */\\nFeatureFormat.prototype.writeGeometry = function(geometry, opt_options) {};\\n\\nexport default FeatureFormat;\\n\\n/**\\n * @param {module:ol/geom/Geometry|module:ol/extent~Extent} geometry Geometry.\\n * @param {boolean} write Set to true for writing, false for reading.\\n * @param {(module:ol/format/Feature~WriteOptions|module:ol/format/Feature~ReadOptions)=} opt_options\\n *     Options.\\n * @return {module:ol/geom/Geometry|module:ol/extent~Extent} Transformed geometry.\\n */\\nexport function transformWithOptions(geometry, write, opt_options) {\\n  const featureProjection = opt_options ?\\n    getProjection(opt_options.featureProjection) : null;\\n  const dataProjection = opt_options ?\\n    getProjection(opt_options.dataProjection) : null;\\n  /**\\n   * @type {module:ol/geom/Geometry|module:ol/extent~Extent}\\n   */\\n  let transformed;\\n  if (featureProjection && dataProjection &&\\n      !equivalentProjection(featureProjection, dataProjection)) {\\n    if (geometry instanceof Geometry) {\\n      transformed = (write ? geometry.clone() : geometry).transform(\\n        write ? featureProjection : dataProjection,\\n        write ? dataProjection : featureProjection);\\n    } else {\\n      // FIXME this is necessary because GML treats extents\\n      // as geometries\\n      transformed = transformExtent(\\n        geometry,\\n        dataProjection,\\n        featureProjection);\\n    }\\n  } else {\\n    transformed = geometry;\\n  }\\n  if (write && opt_options && opt_options.decimals !== undefined) {\\n    const power = Math.pow(10, opt_options.decimals);\\n    // if decimals option on write, round each coordinate appropriately\\n    /**\\n     * @param {Array.<number>} coordinates Coordinates.\\n     * @return {Array.<number>} Transformed coordinates.\\n     */\\n    const transform = function(coordinates) {\\n      for (let i = 0, ii = coordinates.length; i < ii; ++i) {\\n        coordinates[i] = Math.round(coordinates[i] * power) / power;\\n      }\\n      return coordinates;\\n    };\\n    if (transformed === geometry) {\\n      transformed = transformed.clone();\\n    }\\n    transformed.applyTransform(transform);\\n  }\\n  return transformed;\\n}\\n\",\"/**\\n * @module ol/format/FormatType\\n */\\n\\n/**\\n * @enum {string}\\n */\\nexport default {\\n  ARRAY_BUFFER: 'arraybuffer',\\n  JSON: 'json',\\n  TEXT: 'text',\\n  XML: 'xml'\\n};\\n\",\"/**\\n * @module ol/format/JSONFeature\\n */\\nimport {inherits} from '../index.js';\\nimport FeatureFormat from '../format/Feature.js';\\nimport FormatType from '../format/FormatType.js';\\n\\n/**\\n * @classdesc\\n * Abstract base class; normally only used for creating subclasses and not\\n * instantiated in apps.\\n * Base class for JSON feature formats.\\n *\\n * @constructor\\n * @abstract\\n * @extends {module:ol/format/Feature}\\n */\\nconst JSONFeature = function() {\\n  FeatureFormat.call(this);\\n};\\n\\ninherits(JSONFeature, FeatureFormat);\\n\\n\\n/**\\n * @param {Document|Node|Object|string} source Source.\\n * @return {Object} Object.\\n */\\nfunction getObject(source) {\\n  if (typeof source === 'string') {\\n    const object = JSON.parse(source);\\n    return object ? /** @type {Object} */ (object) : null;\\n  } else if (source !== null) {\\n    return source;\\n  } else {\\n    return null;\\n  }\\n}\\n\\n\\n/**\\n * @inheritDoc\\n */\\nJSONFeature.prototype.getType = function() {\\n  return FormatType.JSON;\\n};\\n\\n\\n/**\\n * @inheritDoc\\n */\\nJSONFeature.prototype.readFeature = function(source, opt_options) {\\n  return this.readFeatureFromObject(\\n    getObject(source), this.getReadOptions(source, opt_options));\\n};\\n\\n\\n/**\\n * @inheritDoc\\n */\\nJSONFeature.prototype.readFeatures = function(source, opt_options) {\\n  return this.readFeaturesFromObject(\\n    getObject(source), this.getReadOptions(source, opt_options));\\n};\\n\\n\\n/**\\n * @abstract\\n * @param {Object} object Object.\\n * @param {module:ol/format/Feature~ReadOptions=} opt_options Read options.\\n * @protected\\n * @return {module:ol/Feature} Feature.\\n */\\nJSONFeature.prototype.readFeatureFromObject = function(object, opt_options) {};\\n\\n\\n/**\\n * @abstract\\n * @param {Object} object Object.\\n * @param {module:ol/format/Feature~ReadOptions=} opt_options Read options.\\n * @protected\\n * @return {Array.<module:ol/Feature>} Features.\\n */\\nJSONFeature.prototype.readFeaturesFromObject = function(object, opt_options) {};\\n\\n\\n/**\\n * @inheritDoc\\n */\\nJSONFeature.prototype.readGeometry = function(source, opt_options) {\\n  return this.readGeometryFromObject(\\n    getObject(source), this.getReadOptions(source, opt_options));\\n};\\n\\n\\n/**\\n * @abstract\\n * @param {Object} object Object.\\n * @param {module:ol/format/Feature~ReadOptions=} opt_options Read options.\\n * @protected\\n * @return {module:ol/geom/Geometry} Geometry.\\n */\\nJSONFeature.prototype.readGeometryFromObject = function(object, opt_options) {};\\n\\n\\n/**\\n * @inheritDoc\\n */\\nJSONFeature.prototype.readProjection = function(source) {\\n  return this.readProjectionFromObject(getObject(source));\\n};\\n\\n\\n/**\\n * @abstract\\n * @param {Object} object Object.\\n * @protected\\n * @return {module:ol/proj/Projection} Projection.\\n */\\nJSONFeature.prototype.readProjectionFromObject = function(object) {};\\n\\n\\n/**\\n * @inheritDoc\\n */\\nJSONFeature.prototype.writeFeature = function(feature, opt_options) {\\n  return JSON.stringify(this.writeFeatureObject(feature, opt_options));\\n};\\n\\n\\n/**\\n * @abstract\\n * @param {module:ol/Feature} feature Feature.\\n * @param {module:ol/format/Feature~WriteOptions=} opt_options Write options.\\n * @return {Object} Object.\\n */\\nJSONFeature.prototype.writeFeatureObject = function(feature, opt_options) {};\\n\\n\\n/**\\n * @inheritDoc\\n */\\nJSONFeature.prototype.writeFeatures = function(features, opt_options) {\\n  return JSON.stringify(this.writeFeaturesObject(features, opt_options));\\n};\\n\\n\\n/**\\n * @abstract\\n * @param {Array.<module:ol/Feature>} features Features.\\n * @param {module:ol/format/Feature~WriteOptions=} opt_options Write options.\\n * @return {Object} Object.\\n */\\nJSONFeature.prototype.writeFeaturesObject = function(features, opt_options) {};\\n\\n\\n/**\\n * @inheritDoc\\n */\\nJSONFeature.prototype.writeGeometry = function(geometry, opt_options) {\\n  return JSON.stringify(this.writeGeometryObject(geometry, opt_options));\\n};\\n\\n\\n/**\\n * @abstract\\n * @param {module:ol/geom/Geometry} geometry Geometry.\\n * @param {module:ol/format/Feature~WriteOptions=} opt_options Write options.\\n * @return {Object} Object.\\n */\\nJSONFeature.prototype.writeGeometryObject = function(geometry, opt_options) {};\\nexport default JSONFeature;\\n\",\"/**\\n * @module ol/geom/GeometryCollection\\n */\\nimport {inherits} from '../index.js';\\nimport {listen, unlisten} from '../events.js';\\nimport EventType from '../events/EventType.js';\\nimport {createOrUpdateEmpty, closestSquaredDistanceXY, extend, getCenter} from '../extent.js';\\nimport Geometry from '../geom/Geometry.js';\\nimport GeometryType from '../geom/GeometryType.js';\\nimport {clear} from '../obj.js';\\n\\n/**\\n * @classdesc\\n * An array of {@link module:ol/geom/Geometry} objects.\\n *\\n * @constructor\\n * @extends {module:ol/geom/Geometry}\\n * @param {Array.<module:ol/geom/Geometry>=} opt_geometries Geometries.\\n * @api\\n */\\nconst GeometryCollection = function(opt_geometries) {\\n\\n  Geometry.call(this);\\n\\n  /**\\n   * @private\\n   * @type {Array.<module:ol/geom/Geometry>}\\n   */\\n  this.geometries_ = opt_geometries ? opt_geometries : null;\\n\\n  this.listenGeometriesChange_();\\n};\\n\\ninherits(GeometryCollection, Geometry);\\n\\n\\n/**\\n * @param {Array.<module:ol/geom/Geometry>} geometries Geometries.\\n * @return {Array.<module:ol/geom/Geometry>} Cloned geometries.\\n */\\nfunction cloneGeometries(geometries) {\\n  const clonedGeometries = [];\\n  for (let i = 0, ii = geometries.length; i < ii; ++i) {\\n    clonedGeometries.push(geometries[i].clone());\\n  }\\n  return clonedGeometries;\\n}\\n\\n\\n/**\\n * @private\\n */\\nGeometryCollection.prototype.unlistenGeometriesChange_ = function() {\\n  if (!this.geometries_) {\\n    return;\\n  }\\n  for (let i = 0, ii = this.geometries_.length; i < ii; ++i) {\\n    unlisten(\\n      this.geometries_[i], EventType.CHANGE,\\n      this.changed, this);\\n  }\\n};\\n\\n\\n/**\\n * @private\\n */\\nGeometryCollection.prototype.listenGeometriesChange_ = function() {\\n  if (!this.geometries_) {\\n    return;\\n  }\\n  for (let i = 0, ii = this.geometries_.length; i < ii; ++i) {\\n    listen(\\n      this.geometries_[i], EventType.CHANGE,\\n      this.changed, this);\\n  }\\n};\\n\\n\\n/**\\n * Make a complete copy of the geometry.\\n * @return {!module:ol/geom/GeometryCollection} Clone.\\n * @override\\n * @api\\n */\\nGeometryCollection.prototype.clone = function() {\\n  const geometryCollection = new GeometryCollection(null);\\n  geometryCollection.setGeometries(this.geometries_);\\n  return geometryCollection;\\n};\\n\\n\\n/**\\n * @inheritDoc\\n */\\nGeometryCollection.prototype.closestPointXY = function(x, y, closestPoint, minSquaredDistance) {\\n  if (minSquaredDistance < closestSquaredDistanceXY(this.getExtent(), x, y)) {\\n    return minSquaredDistance;\\n  }\\n  const geometries = this.geometries_;\\n  for (let i = 0, ii = geometries.length; i < ii; ++i) {\\n    minSquaredDistance = geometries[i].closestPointXY(\\n      x, y, closestPoint, minSquaredDistance);\\n  }\\n  return minSquaredDistance;\\n};\\n\\n\\n/**\\n * @inheritDoc\\n */\\nGeometryCollection.prototype.containsXY = function(x, y) {\\n  const geometries = this.geometries_;\\n  for (let i = 0, ii = geometries.length; i < ii; ++i) {\\n    if (geometries[i].containsXY(x, y)) {\\n      return true;\\n    }\\n  }\\n  return false;\\n};\\n\\n\\n/**\\n * @inheritDoc\\n */\\nGeometryCollection.prototype.computeExtent = function(extent) {\\n  createOrUpdateEmpty(extent);\\n  const geometries = this.geometries_;\\n  for (let i = 0, ii = geometries.length; i < ii; ++i) {\\n    extend(extent, geometries[i].getExtent());\\n  }\\n  return extent;\\n};\\n\\n\\n/**\\n * Return the geometries that make up this geometry collection.\\n * @return {Array.<module:ol/geom/Geometry>} Geometries.\\n * @api\\n */\\nGeometryCollection.prototype.getGeometries = function() {\\n  return cloneGeometries(this.geometries_);\\n};\\n\\n\\n/**\\n * @return {Array.<module:ol/geom/Geometry>} Geometries.\\n */\\nGeometryCollection.prototype.getGeometriesArray = function() {\\n  return this.geometries_;\\n};\\n\\n\\n/**\\n * @inheritDoc\\n */\\nGeometryCollection.prototype.getSimplifiedGeometry = function(squaredTolerance) {\\n  if (this.simplifiedGeometryRevision != this.getRevision()) {\\n    clear(this.simplifiedGeometryCache);\\n    this.simplifiedGeometryMaxMinSquaredTolerance = 0;\\n    this.simplifiedGeometryRevision = this.getRevision();\\n  }\\n  if (squaredTolerance < 0 ||\\n      (this.simplifiedGeometryMaxMinSquaredTolerance !== 0 &&\\n       squaredTolerance < this.simplifiedGeometryMaxMinSquaredTolerance)) {\\n    return this;\\n  }\\n  const key = squaredTolerance.toString();\\n  if (this.simplifiedGeometryCache.hasOwnProperty(key)) {\\n    return this.simplifiedGeometryCache[key];\\n  } else {\\n    const simplifiedGeometries = [];\\n    const geometries = this.geometries_;\\n    let simplified = false;\\n    for (let i = 0, ii = geometries.length; i < ii; ++i) {\\n      const geometry = geometries[i];\\n      const simplifiedGeometry = geometry.getSimplifiedGeometry(squaredTolerance);\\n      simplifiedGeometries.push(simplifiedGeometry);\\n      if (simplifiedGeometry !== geometry) {\\n        simplified = true;\\n      }\\n    }\\n    if (simplified) {\\n      const simplifiedGeometryCollection = new GeometryCollection(null);\\n      simplifiedGeometryCollection.setGeometriesArray(simplifiedGeometries);\\n      this.simplifiedGeometryCache[key] = simplifiedGeometryCollection;\\n      return simplifiedGeometryCollection;\\n    } else {\\n      this.simplifiedGeometryMaxMinSquaredTolerance = squaredTolerance;\\n      return this;\\n    }\\n  }\\n};\\n\\n\\n/**\\n * @inheritDoc\\n * @api\\n */\\nGeometryCollection.prototype.getType = function() {\\n  return GeometryType.GEOMETRY_COLLECTION;\\n};\\n\\n\\n/**\\n * @inheritDoc\\n * @api\\n */\\nGeometryCollection.prototype.intersectsExtent = function(extent) {\\n  const geometries = this.geometries_;\\n  for (let i = 0, ii = geometries.length; i < ii; ++i) {\\n    if (geometries[i].intersectsExtent(extent)) {\\n      return true;\\n    }\\n  }\\n  return false;\\n};\\n\\n\\n/**\\n * @return {boolean} Is empty.\\n */\\nGeometryCollection.prototype.isEmpty = function() {\\n  return this.geometries_.length === 0;\\n};\\n\\n\\n/**\\n * @inheritDoc\\n * @api\\n */\\nGeometryCollection.prototype.rotate = function(angle, anchor) {\\n  const geometries = this.geometries_;\\n  for (let i = 0, ii = geometries.length; i < ii; ++i) {\\n    geometries[i].rotate(angle, anchor);\\n  }\\n  this.changed();\\n};\\n\\n\\n/**\\n * @inheritDoc\\n * @api\\n */\\nGeometryCollection.prototype.scale = function(sx, opt_sy, opt_anchor) {\\n  let anchor = opt_anchor;\\n  if (!anchor) {\\n    anchor = getCenter(this.getExtent());\\n  }\\n  const geometries = this.geometries_;\\n  for (let i = 0, ii = geometries.length; i < ii; ++i) {\\n    geometries[i].scale(sx, opt_sy, anchor);\\n  }\\n  this.changed();\\n};\\n\\n\\n/**\\n * Set the geometries that make up this geometry collection.\\n * @param {Array.<module:ol/geom/Geometry>} geometries Geometries.\\n * @api\\n */\\nGeometryCollection.prototype.setGeometries = function(geometries) {\\n  this.setGeometriesArray(cloneGeometries(geometries));\\n};\\n\\n\\n/**\\n * @param {Array.<module:ol/geom/Geometry>} geometries Geometries.\\n */\\nGeometryCollection.prototype.setGeometriesArray = function(geometries) {\\n  this.unlistenGeometriesChange_();\\n  this.geometries_ = geometries;\\n  this.listenGeometriesChange_();\\n  this.changed();\\n};\\n\\n\\n/**\\n * @inheritDoc\\n * @api\\n */\\nGeometryCollection.prototype.applyTransform = function(transformFn) {\\n  const geometries = this.geometries_;\\n  for (let i = 0, ii = geometries.length; i < ii; ++i) {\\n    geometries[i].applyTransform(transformFn);\\n  }\\n  this.changed();\\n};\\n\\n\\n/**\\n * Translate the geometry.\\n * @param {number} deltaX Delta X.\\n * @param {number} deltaY Delta Y.\\n * @override\\n * @api\\n */\\nGeometryCollection.prototype.translate = function(deltaX, deltaY) {\\n  const geometries = this.geometries_;\\n  for (let i = 0, ii = geometries.length; i < ii; ++i) {\\n    geometries[i].translate(deltaX, deltaY);\\n  }\\n  this.changed();\\n};\\n\\n\\n/**\\n * @inheritDoc\\n */\\nGeometryCollection.prototype.disposeInternal = function() {\\n  this.unlistenGeometriesChange_();\\n  Geometry.prototype.disposeInternal.call(this);\\n};\\nexport default GeometryCollection;\\n\",\"/**\\n * @module ol/array\\n */\\n\\n\\n/**\\n * Performs a binary search on the provided sorted list and returns the index of the item if found. If it can't be found it'll return -1.\\n * https://github.com/darkskyapp/binary-search\\n *\\n * @param {Array.<*>} haystack Items to search through.\\n * @param {*} needle The item to look for.\\n * @param {Function=} opt_comparator Comparator function.\\n * @return {number} The index of the item if found, -1 if not.\\n */\\nexport function binarySearch(haystack, needle, opt_comparator) {\\n  let mid, cmp;\\n  const comparator = opt_comparator || numberSafeCompareFunction;\\n  let low = 0;\\n  let high = haystack.length;\\n  let found = false;\\n\\n  while (low < high) {\\n    /* Note that \\\"(low + high) >>> 1\\\" may overflow, and results in a typecast\\n     * to double (which gives the wrong results). */\\n    mid = low + (high - low >> 1);\\n    cmp = +comparator(haystack[mid], needle);\\n\\n    if (cmp < 0.0) { /* Too low. */\\n      low  = mid + 1;\\n\\n    } else { /* Key found or too high */\\n      high = mid;\\n      found = !cmp;\\n    }\\n  }\\n\\n  /* Key not found. */\\n  return found ? low : ~low;\\n}\\n\\n\\n/**\\n * Compare function for array sort that is safe for numbers.\\n * @param {*} a The first object to be compared.\\n * @param {*} b The second object to be compared.\\n * @return {number} A negative number, zero, or a positive number as the first\\n *     argument is less than, equal to, or greater than the second.\\n */\\nexport function numberSafeCompareFunction(a, b) {\\n  return a > b ? 1 : a < b ? -1 : 0;\\n}\\n\\n\\n/**\\n * Whether the array contains the given object.\\n * @param {Array.<*>} arr The array to test for the presence of the element.\\n * @param {*} obj The object for which to test.\\n * @return {boolean} The object is in the array.\\n */\\nexport function includes(arr, obj) {\\n  return arr.indexOf(obj) >= 0;\\n}\\n\\n\\n/**\\n * @param {Array.<number>} arr Array.\\n * @param {number} target Target.\\n * @param {number} direction 0 means return the nearest, > 0\\n *    means return the largest nearest, < 0 means return the\\n *    smallest nearest.\\n * @return {number} Index.\\n */\\nexport function linearFindNearest(arr, target, direction) {\\n  const n = arr.length;\\n  if (arr[0] <= target) {\\n    return 0;\\n  } else if (target <= arr[n - 1]) {\\n    return n - 1;\\n  } else {\\n    let i;\\n    if (direction > 0) {\\n      for (i = 1; i < n; ++i) {\\n        if (arr[i] < target) {\\n          return i - 1;\\n        }\\n      }\\n    } else if (direction < 0) {\\n      for (i = 1; i < n; ++i) {\\n        if (arr[i] <= target) {\\n          return i;\\n        }\\n      }\\n    } else {\\n      for (i = 1; i < n; ++i) {\\n        if (arr[i] == target) {\\n          return i;\\n        } else if (arr[i] < target) {\\n          if (arr[i - 1] - target < target - arr[i]) {\\n            return i - 1;\\n          } else {\\n            return i;\\n          }\\n        }\\n      }\\n    }\\n    return n - 1;\\n  }\\n}\\n\\n\\n/**\\n * @param {Array.<*>} arr Array.\\n * @param {number} begin Begin index.\\n * @param {number} end End index.\\n */\\nexport function reverseSubArray(arr, begin, end) {\\n  while (begin < end) {\\n    const tmp = arr[begin];\\n    arr[begin] = arr[end];\\n    arr[end] = tmp;\\n    ++begin;\\n    --end;\\n  }\\n}\\n\\n\\n/**\\n * @param {Array.<VALUE>} arr The array to modify.\\n * @param {!Array.<VALUE>|VALUE} data The elements or arrays of elements to add to arr.\\n * @template VALUE\\n */\\nexport function extend(arr, data) {\\n  const extension = Array.isArray(data) ? data : [data];\\n  const length = extension.length;\\n  for (let i = 0; i < length; i++) {\\n    arr[arr.length] = extension[i];\\n  }\\n}\\n\\n\\n/**\\n * @param {Array.<VALUE>} arr The array to modify.\\n * @param {VALUE} obj The element to remove.\\n * @template VALUE\\n * @return {boolean} If the element was removed.\\n */\\nexport function remove(arr, obj) {\\n  const i = arr.indexOf(obj);\\n  const found = i > -1;\\n  if (found) {\\n    arr.splice(i, 1);\\n  }\\n  return found;\\n}\\n\\n\\n/**\\n * @param {Array.<VALUE>} arr The array to search in.\\n * @param {function(VALUE, number, ?) : boolean} func The function to compare.\\n * @template VALUE\\n * @return {VALUE|null} The element found or null.\\n */\\nexport function find(arr, func) {\\n  const length = arr.length >>> 0;\\n  let value;\\n\\n  for (let i = 0; i < length; i++) {\\n    value = arr[i];\\n    if (func(value, i, arr)) {\\n      return value;\\n    }\\n  }\\n  return null;\\n}\\n\\n\\n/**\\n * @param {Array|Uint8ClampedArray} arr1 The first array to compare.\\n * @param {Array|Uint8ClampedArray} arr2 The second array to compare.\\n * @return {boolean} Whether the two arrays are equal.\\n */\\nexport function equals(arr1, arr2) {\\n  const len1 = arr1.length;\\n  if (len1 !== arr2.length) {\\n    return false;\\n  }\\n  for (let i = 0; i < len1; i++) {\\n    if (arr1[i] !== arr2[i]) {\\n      return false;\\n    }\\n  }\\n  return true;\\n}\\n\\n\\n/**\\n * @param {Array.<*>} arr The array to sort (modifies original).\\n * @param {Function} compareFnc Comparison function.\\n */\\nexport function stableSort(arr, compareFnc) {\\n  const length = arr.length;\\n  const tmp = Array(arr.length);\\n  let i;\\n  for (i = 0; i < length; i++) {\\n    tmp[i] = {index: i, value: arr[i]};\\n  }\\n  tmp.sort(function(a, b) {\\n    return compareFnc(a.value, b.value) || a.index - b.index;\\n  });\\n  for (i = 0; i < arr.length; i++) {\\n    arr[i] = tmp[i].value;\\n  }\\n}\\n\\n\\n/**\\n * @param {Array.<*>} arr The array to search in.\\n * @param {Function} func Comparison function.\\n * @return {number} Return index.\\n */\\nexport function findIndex(arr, func) {\\n  let index;\\n  const found = !arr.every(function(el, idx) {\\n    index = idx;\\n    return !func(el, idx, arr);\\n  });\\n  return found ? index : -1;\\n}\\n\\n\\n/**\\n * @param {Array.<*>} arr The array to test.\\n * @param {Function=} opt_func Comparison function.\\n * @param {boolean=} opt_strict Strictly sorted (default false).\\n * @return {boolean} Return index.\\n */\\nexport function isSorted(arr, opt_func, opt_strict) {\\n  const compare = opt_func || numberSafeCompareFunction;\\n  return arr.every(function(currentVal, index) {\\n    if (index === 0) {\\n      return true;\\n    }\\n    const res = compare(arr[index - 1], currentVal);\\n    return !(res > 0 || opt_strict && res === 0);\\n  });\\n}\\n\",\"/**\\n * @module ol/geom/GeometryLayout\\n */\\n\\n/**\\n * The coordinate layout for geometries, indicating whether a 3rd or 4th z ('Z')\\n * or measure ('M') coordinate is available. Supported values are `'XY'`,\\n * `'XYZ'`, `'XYM'`, `'XYZM'`.\\n * @enum {string}\\n */\\nexport default {\\n  XY: 'XY',\\n  XYZ: 'XYZ',\\n  XYM: 'XYM',\\n  XYZM: 'XYZM'\\n};\\n\",\"/**\\n * @module ol/geom/SimpleGeometry\\n */\\nimport {inherits} from '../index.js';\\nimport {FALSE} from '../functions.js';\\nimport {createOrUpdateFromFlatCoordinates, getCenter} from '../extent.js';\\nimport Geometry from '../geom/Geometry.js';\\nimport GeometryLayout from '../geom/GeometryLayout.js';\\nimport {rotate, scale, translate, transform2D} from '../geom/flat/transform.js';\\nimport {clear} from '../obj.js';\\n\\n/**\\n * @classdesc\\n * Abstract base class; only used for creating subclasses; do not instantiate\\n * in apps, as cannot be rendered.\\n *\\n * @constructor\\n * @abstract\\n * @extends {module:ol/geom/Geometry}\\n * @api\\n */\\nconst SimpleGeometry = function() {\\n\\n  Geometry.call(this);\\n\\n  /**\\n   * @protected\\n   * @type {module:ol/geom/GeometryLayout}\\n   */\\n  this.layout = GeometryLayout.XY;\\n\\n  /**\\n   * @protected\\n   * @type {number}\\n   */\\n  this.stride = 2;\\n\\n  /**\\n   * @protected\\n   * @type {Array.<number>}\\n   */\\n  this.flatCoordinates = null;\\n\\n};\\n\\ninherits(SimpleGeometry, Geometry);\\n\\n\\n/**\\n * @param {number} stride Stride.\\n * @return {module:ol/geom/GeometryLayout} layout Layout.\\n */\\nfunction getLayoutForStride(stride) {\\n  let layout;\\n  if (stride == 2) {\\n    layout = GeometryLayout.XY;\\n  } else if (stride == 3) {\\n    layout = GeometryLayout.XYZ;\\n  } else if (stride == 4) {\\n    layout = GeometryLayout.XYZM;\\n  }\\n  return (\\n    /** @type {module:ol/geom/GeometryLayout} */ (layout)\\n  );\\n}\\n\\n\\n/**\\n * @param {module:ol/geom/GeometryLayout} layout Layout.\\n * @return {number} Stride.\\n */\\nexport function getStrideForLayout(layout) {\\n  let stride;\\n  if (layout == GeometryLayout.XY) {\\n    stride = 2;\\n  } else if (layout == GeometryLayout.XYZ || layout == GeometryLayout.XYM) {\\n    stride = 3;\\n  } else if (layout == GeometryLayout.XYZM) {\\n    stride = 4;\\n  }\\n  return /** @type {number} */ (stride);\\n}\\n\\n\\n/**\\n * @inheritDoc\\n */\\nSimpleGeometry.prototype.containsXY = FALSE;\\n\\n\\n/**\\n * @inheritDoc\\n */\\nSimpleGeometry.prototype.computeExtent = function(extent) {\\n  return createOrUpdateFromFlatCoordinates(this.flatCoordinates,\\n    0, this.flatCoordinates.length, this.stride, extent);\\n};\\n\\n\\n/**\\n * @abstract\\n * @return {Array} Coordinates.\\n */\\nSimpleGeometry.prototype.getCoordinates = function() {};\\n\\n\\n/**\\n * Return the first coordinate of the geometry.\\n * @return {module:ol/coordinate~Coordinate} First coordinate.\\n * @api\\n */\\nSimpleGeometry.prototype.getFirstCoordinate = function() {\\n  return this.flatCoordinates.slice(0, this.stride);\\n};\\n\\n\\n/**\\n * @return {Array.<number>} Flat coordinates.\\n */\\nSimpleGeometry.prototype.getFlatCoordinates = function() {\\n  return this.flatCoordinates;\\n};\\n\\n\\n/**\\n * Return the last coordinate of the geometry.\\n * @return {module:ol/coordinate~Coordinate} Last point.\\n * @api\\n */\\nSimpleGeometry.prototype.getLastCoordinate = function() {\\n  return this.flatCoordinates.slice(this.flatCoordinates.length - this.stride);\\n};\\n\\n\\n/**\\n * Return the {@link module:ol/geom/GeometryLayout~GeometryLayout layout} of the geometry.\\n * @return {module:ol/geom/GeometryLayout} Layout.\\n * @api\\n */\\nSimpleGeometry.prototype.getLayout = function() {\\n  return this.layout;\\n};\\n\\n\\n/**\\n * @inheritDoc\\n */\\nSimpleGeometry.prototype.getSimplifiedGeometry = function(squaredTolerance) {\\n  if (this.simplifiedGeometryRevision != this.getRevision()) {\\n    clear(this.simplifiedGeometryCache);\\n    this.simplifiedGeometryMaxMinSquaredTolerance = 0;\\n    this.simplifiedGeometryRevision = this.getRevision();\\n  }\\n  // If squaredTolerance is negative or if we know that simplification will not\\n  // have any effect then just return this.\\n  if (squaredTolerance < 0 ||\\n      (this.simplifiedGeometryMaxMinSquaredTolerance !== 0 &&\\n       squaredTolerance <= this.simplifiedGeometryMaxMinSquaredTolerance)) {\\n    return this;\\n  }\\n  const key = squaredTolerance.toString();\\n  if (this.simplifiedGeometryCache.hasOwnProperty(key)) {\\n    return this.simplifiedGeometryCache[key];\\n  } else {\\n    const simplifiedGeometry =\\n        this.getSimplifiedGeometryInternal(squaredTolerance);\\n    const simplifiedFlatCoordinates = simplifiedGeometry.getFlatCoordinates();\\n    if (simplifiedFlatCoordinates.length < this.flatCoordinates.length) {\\n      this.simplifiedGeometryCache[key] = simplifiedGeometry;\\n      return simplifiedGeometry;\\n    } else {\\n      // Simplification did not actually remove any coordinates.  We now know\\n      // that any calls to getSimplifiedGeometry with a squaredTolerance less\\n      // than or equal to the current squaredTolerance will also not have any\\n      // effect.  This allows us to short circuit simplification (saving CPU\\n      // cycles) and prevents the cache of simplified geometries from filling\\n      // up with useless identical copies of this geometry (saving memory).\\n      this.simplifiedGeometryMaxMinSquaredTolerance = squaredTolerance;\\n      return this;\\n    }\\n  }\\n};\\n\\n\\n/**\\n * @param {number} squaredTolerance Squared tolerance.\\n * @return {module:ol/geom/SimpleGeometry} Simplified geometry.\\n * @protected\\n */\\nSimpleGeometry.prototype.getSimplifiedGeometryInternal = function(squaredTolerance) {\\n  return this;\\n};\\n\\n\\n/**\\n * @return {number} Stride.\\n */\\nSimpleGeometry.prototype.getStride = function() {\\n  return this.stride;\\n};\\n\\n\\n/**\\n * @param {module:ol/geom/GeometryLayout} layout Layout.\\n * @param {Array.<number>} flatCoordinates Flat coordinates.\\n * @protected\\n */\\nSimpleGeometry.prototype.setFlatCoordinatesInternal = function(layout, flatCoordinates) {\\n  this.stride = getStrideForLayout(layout);\\n  this.layout = layout;\\n  this.flatCoordinates = flatCoordinates;\\n};\\n\\n\\n/**\\n * @abstract\\n * @param {Array} coordinates Coordinates.\\n * @param {module:ol/geom/GeometryLayout=} opt_layout Layout.\\n */\\nSimpleGeometry.prototype.setCoordinates = function(coordinates, opt_layout) {};\\n\\n\\n/**\\n * @param {module:ol/geom/GeometryLayout|undefined} layout Layout.\\n * @param {Array} coordinates Coordinates.\\n * @param {number} nesting Nesting.\\n * @protected\\n */\\nSimpleGeometry.prototype.setLayout = function(layout, coordinates, nesting) {\\n  /** @type {number} */\\n  let stride;\\n  if (layout) {\\n    stride = getStrideForLayout(layout);\\n  } else {\\n    for (let i = 0; i < nesting; ++i) {\\n      if (coordinates.length === 0) {\\n        this.layout = GeometryLayout.XY;\\n        this.stride = 2;\\n        return;\\n      } else {\\n        coordinates = /** @type {Array} */ (coordinates[0]);\\n      }\\n    }\\n    stride = coordinates.length;\\n    layout = getLayoutForStride(stride);\\n  }\\n  this.layout = layout;\\n  this.stride = stride;\\n};\\n\\n\\n/**\\n * @inheritDoc\\n * @api\\n */\\nSimpleGeometry.prototype.applyTransform = function(transformFn) {\\n  if (this.flatCoordinates) {\\n    transformFn(this.flatCoordinates, this.flatCoordinates, this.stride);\\n    this.changed();\\n  }\\n};\\n\\n\\n/**\\n * @inheritDoc\\n * @api\\n */\\nSimpleGeometry.prototype.rotate = function(angle, anchor) {\\n  const flatCoordinates = this.getFlatCoordinates();\\n  if (flatCoordinates) {\\n    const stride = this.getStride();\\n    rotate(\\n      flatCoordinates, 0, flatCoordinates.length,\\n      stride, angle, anchor, flatCoordinates);\\n    this.changed();\\n  }\\n};\\n\\n\\n/**\\n * @inheritDoc\\n * @api\\n */\\nSimpleGeometry.prototype.scale = function(sx, opt_sy, opt_anchor) {\\n  let sy = opt_sy;\\n  if (sy === undefined) {\\n    sy = sx;\\n  }\\n  let anchor = opt_anchor;\\n  if (!anchor) {\\n    anchor = getCenter(this.getExtent());\\n  }\\n  const flatCoordinates = this.getFlatCoordinates();\\n  if (flatCoordinates) {\\n    const stride = this.getStride();\\n    scale(\\n      flatCoordinates, 0, flatCoordinates.length,\\n      stride, sx, sy, anchor, flatCoordinates);\\n    this.changed();\\n  }\\n};\\n\\n\\n/**\\n * @inheritDoc\\n * @api\\n */\\nSimpleGeometry.prototype.translate = function(deltaX, deltaY) {\\n  const flatCoordinates = this.getFlatCoordinates();\\n  if (flatCoordinates) {\\n    const stride = this.getStride();\\n    translate(\\n      flatCoordinates, 0, flatCoordinates.length, stride,\\n      deltaX, deltaY, flatCoordinates);\\n    this.changed();\\n  }\\n};\\n\\n\\n/**\\n * @param {module:ol/geom/SimpleGeometry} simpleGeometry Simple geometry.\\n * @param {module:ol/transform~Transform} transform Transform.\\n * @param {Array.<number>=} opt_dest Destination.\\n * @return {Array.<number>} Transformed flat coordinates.\\n */\\nexport function transformGeom2D(simpleGeometry, transform, opt_dest) {\\n  const flatCoordinates = simpleGeometry.getFlatCoordinates();\\n  if (!flatCoordinates) {\\n    return null;\\n  } else {\\n    const stride = simpleGeometry.getStride();\\n    return transform2D(\\n      flatCoordinates, 0, flatCoordinates.length, stride,\\n      transform, opt_dest);\\n  }\\n}\\n\\nexport default SimpleGeometry;\\n\",\"/**\\n * @module ol/geom/flat/closest\\n */\\nimport {lerp, squaredDistance as squaredDx} from '../../math.js';\\n\\n\\n/**\\n * Returns the point on the 2D line segment flatCoordinates[offset1] to\\n * flatCoordinates[offset2] that is closest to the point (x, y).  Extra\\n * dimensions are linearly interpolated.\\n * @param {Array.<number>} flatCoordinates Flat coordinates.\\n * @param {number} offset1 Offset 1.\\n * @param {number} offset2 Offset 2.\\n * @param {number} stride Stride.\\n * @param {number} x X.\\n * @param {number} y Y.\\n * @param {Array.<number>} closestPoint Closest point.\\n */\\nfunction assignClosest(flatCoordinates, offset1, offset2, stride, x, y, closestPoint) {\\n  const x1 = flatCoordinates[offset1];\\n  const y1 = flatCoordinates[offset1 + 1];\\n  const dx = flatCoordinates[offset2] - x1;\\n  const dy = flatCoordinates[offset2 + 1] - y1;\\n  let offset;\\n  if (dx === 0 && dy === 0) {\\n    offset = offset1;\\n  } else {\\n    const t = ((x - x1) * dx + (y - y1) * dy) / (dx * dx + dy * dy);\\n    if (t > 1) {\\n      offset = offset2;\\n    } else if (t > 0) {\\n      for (let i = 0; i < stride; ++i) {\\n        closestPoint[i] = lerp(flatCoordinates[offset1 + i],\\n          flatCoordinates[offset2 + i], t);\\n      }\\n      closestPoint.length = stride;\\n      return;\\n    } else {\\n      offset = offset1;\\n    }\\n  }\\n  for (let i = 0; i < stride; ++i) {\\n    closestPoint[i] = flatCoordinates[offset + i];\\n  }\\n  closestPoint.length = stride;\\n}\\n\\n\\n/**\\n * Return the squared of the largest distance between any pair of consecutive\\n * coordinates.\\n * @param {Array.<number>} flatCoordinates Flat coordinates.\\n * @param {number} offset Offset.\\n * @param {number} end End.\\n * @param {number} stride Stride.\\n * @param {number} max Max squared delta.\\n * @return {number} Max squared delta.\\n */\\nexport function maxSquaredDelta(flatCoordinates, offset, end, stride, max) {\\n  let x1 = flatCoordinates[offset];\\n  let y1 = flatCoordinates[offset + 1];\\n  for (offset += stride; offset < end; offset += stride) {\\n    const x2 = flatCoordinates[offset];\\n    const y2 = flatCoordinates[offset + 1];\\n    const squaredDelta = squaredDx(x1, y1, x2, y2);\\n    if (squaredDelta > max) {\\n      max = squaredDelta;\\n    }\\n    x1 = x2;\\n    y1 = y2;\\n  }\\n  return max;\\n}\\n\\n\\n/**\\n * @param {Array.<number>} flatCoordinates Flat coordinates.\\n * @param {number} offset Offset.\\n * @param {Array.<number>} ends Ends.\\n * @param {number} stride Stride.\\n * @param {number} max Max squared delta.\\n * @return {number} Max squared delta.\\n */\\nexport function arrayMaxSquaredDelta(flatCoordinates, offset, ends, stride, max) {\\n  for (let i = 0, ii = ends.length; i < ii; ++i) {\\n    const end = ends[i];\\n    max = maxSquaredDelta(\\n      flatCoordinates, offset, end, stride, max);\\n    offset = end;\\n  }\\n  return max;\\n}\\n\\n\\n/**\\n * @param {Array.<number>} flatCoordinates Flat coordinates.\\n * @param {number} offset Offset.\\n * @param {Array.<Array.<number>>} endss Endss.\\n * @param {number} stride Stride.\\n * @param {number} max Max squared delta.\\n * @return {number} Max squared delta.\\n */\\nexport function multiArrayMaxSquaredDelta(flatCoordinates, offset, endss, stride, max) {\\n  for (let i = 0, ii = endss.length; i < ii; ++i) {\\n    const ends = endss[i];\\n    max = arrayMaxSquaredDelta(\\n      flatCoordinates, offset, ends, stride, max);\\n    offset = ends[ends.length - 1];\\n  }\\n  return max;\\n}\\n\\n\\n/**\\n * @param {Array.<number>} flatCoordinates Flat coordinates.\\n * @param {number} offset Offset.\\n * @param {number} end End.\\n * @param {number} stride Stride.\\n * @param {number} maxDelta Max delta.\\n * @param {boolean} isRing Is ring.\\n * @param {number} x X.\\n * @param {number} y Y.\\n * @param {Array.<number>} closestPoint Closest point.\\n * @param {number} minSquaredDistance Minimum squared distance.\\n * @param {Array.<number>=} opt_tmpPoint Temporary point object.\\n * @return {number} Minimum squared distance.\\n */\\nexport function assignClosestPoint(flatCoordinates, offset, end,\\n  stride, maxDelta, isRing, x, y, closestPoint, minSquaredDistance,\\n  opt_tmpPoint) {\\n  if (offset == end) {\\n    return minSquaredDistance;\\n  }\\n  let i, squaredDistance;\\n  if (maxDelta === 0) {\\n    // All points are identical, so just test the first point.\\n    squaredDistance = squaredDx(\\n      x, y, flatCoordinates[offset], flatCoordinates[offset + 1]);\\n    if (squaredDistance < minSquaredDistance) {\\n      for (i = 0; i < stride; ++i) {\\n        closestPoint[i] = flatCoordinates[offset + i];\\n      }\\n      closestPoint.length = stride;\\n      return squaredDistance;\\n    } else {\\n      return minSquaredDistance;\\n    }\\n  }\\n  const tmpPoint = opt_tmpPoint ? opt_tmpPoint : [NaN, NaN];\\n  let index = offset + stride;\\n  while (index < end) {\\n    assignClosest(\\n      flatCoordinates, index - stride, index, stride, x, y, tmpPoint);\\n    squaredDistance = squaredDx(x, y, tmpPoint[0], tmpPoint[1]);\\n    if (squaredDistance < minSquaredDistance) {\\n      minSquaredDistance = squaredDistance;\\n      for (i = 0; i < stride; ++i) {\\n        closestPoint[i] = tmpPoint[i];\\n      }\\n      closestPoint.length = stride;\\n      index += stride;\\n    } else {\\n      // Skip ahead multiple points, because we know that all the skipped\\n      // points cannot be any closer than the closest point we have found so\\n      // far.  We know this because we know how close the current point is, how\\n      // close the closest point we have found so far is, and the maximum\\n      // distance between consecutive points.  For example, if we're currently\\n      // at distance 10, the best we've found so far is 3, and that the maximum\\n      // distance between consecutive points is 2, then we'll need to skip at\\n      // least (10 - 3) / 2 == 3 (rounded down) points to have any chance of\\n      // finding a closer point.  We use Math.max(..., 1) to ensure that we\\n      // always advance at least one point, to avoid an infinite loop.\\n      index += stride * Math.max(\\n        ((Math.sqrt(squaredDistance) -\\n            Math.sqrt(minSquaredDistance)) / maxDelta) | 0, 1);\\n    }\\n  }\\n  if (isRing) {\\n    // Check the closing segment.\\n    assignClosest(\\n      flatCoordinates, end - stride, offset, stride, x, y, tmpPoint);\\n    squaredDistance = squaredDx(x, y, tmpPoint[0], tmpPoint[1]);\\n    if (squaredDistance < minSquaredDistance) {\\n      minSquaredDistance = squaredDistance;\\n      for (i = 0; i < stride; ++i) {\\n        closestPoint[i] = tmpPoint[i];\\n      }\\n      closestPoint.length = stride;\\n    }\\n  }\\n  return minSquaredDistance;\\n}\\n\\n\\n/**\\n * @param {Array.<number>} flatCoordinates Flat coordinates.\\n * @param {number} offset Offset.\\n * @param {Array.<number>} ends Ends.\\n * @param {number} stride Stride.\\n * @param {number} maxDelta Max delta.\\n * @param {boolean} isRing Is ring.\\n * @param {number} x X.\\n * @param {number} y Y.\\n * @param {Array.<number>} closestPoint Closest point.\\n * @param {number} minSquaredDistance Minimum squared distance.\\n * @param {Array.<number>=} opt_tmpPoint Temporary point object.\\n * @return {number} Minimum squared distance.\\n */\\nexport function assignClosestArrayPoint(flatCoordinates, offset, ends,\\n  stride, maxDelta, isRing, x, y, closestPoint, minSquaredDistance,\\n  opt_tmpPoint) {\\n  const tmpPoint = opt_tmpPoint ? opt_tmpPoint : [NaN, NaN];\\n  for (let i = 0, ii = ends.length; i < ii; ++i) {\\n    const end = ends[i];\\n    minSquaredDistance = assignClosestPoint(\\n      flatCoordinates, offset, end, stride,\\n      maxDelta, isRing, x, y, closestPoint, minSquaredDistance, tmpPoint);\\n    offset = end;\\n  }\\n  return minSquaredDistance;\\n}\\n\\n\\n/**\\n * @param {Array.<number>} flatCoordinates Flat coordinates.\\n * @param {number} offset Offset.\\n * @param {Array.<Array.<number>>} endss Endss.\\n * @param {number} stride Stride.\\n * @param {number} maxDelta Max delta.\\n * @param {boolean} isRing Is ring.\\n * @param {number} x X.\\n * @param {number} y Y.\\n * @param {Array.<number>} closestPoint Closest point.\\n * @param {number} minSquaredDistance Minimum squared distance.\\n * @param {Array.<number>=} opt_tmpPoint Temporary point object.\\n * @return {number} Minimum squared distance.\\n */\\nexport function assignClosestMultiArrayPoint(flatCoordinates, offset,\\n  endss, stride, maxDelta, isRing, x, y, closestPoint, minSquaredDistance,\\n  opt_tmpPoint) {\\n  const tmpPoint = opt_tmpPoint ? opt_tmpPoint : [NaN, NaN];\\n  for (let i = 0, ii = endss.length; i < ii; ++i) {\\n    const ends = endss[i];\\n    minSquaredDistance = assignClosestArrayPoint(\\n      flatCoordinates, offset, ends, stride,\\n      maxDelta, isRing, x, y, closestPoint, minSquaredDistance, tmpPoint);\\n    offset = ends[ends.length - 1];\\n  }\\n  return minSquaredDistance;\\n}\\n\",\"/**\\n * @module ol/geom/flat/deflate\\n */\\n\\n\\n/**\\n * @param {Array.<number>} flatCoordinates Flat coordinates.\\n * @param {number} offset Offset.\\n * @param {module:ol/coordinate~Coordinate} coordinate Coordinate.\\n * @param {number} stride Stride.\\n * @return {number} offset Offset.\\n */\\nexport function deflateCoordinate(flatCoordinates, offset, coordinate, stride) {\\n  for (let i = 0, ii = coordinate.length; i < ii; ++i) {\\n    flatCoordinates[offset++] = coordinate[i];\\n  }\\n  return offset;\\n}\\n\\n\\n/**\\n * @param {Array.<number>} flatCoordinates Flat coordinates.\\n * @param {number} offset Offset.\\n * @param {Array.<module:ol/coordinate~Coordinate>} coordinates Coordinates.\\n * @param {number} stride Stride.\\n * @return {number} offset Offset.\\n */\\nexport function deflateCoordinates(flatCoordinates, offset, coordinates, stride) {\\n  for (let i = 0, ii = coordinates.length; i < ii; ++i) {\\n    const coordinate = coordinates[i];\\n    for (let j = 0; j < stride; ++j) {\\n      flatCoordinates[offset++] = coordinate[j];\\n    }\\n  }\\n  return offset;\\n}\\n\\n\\n/**\\n * @param {Array.<number>} flatCoordinates Flat coordinates.\\n * @param {number} offset Offset.\\n * @param {Array.<Array.<module:ol/coordinate~Coordinate>>} coordinatess Coordinatess.\\n * @param {number} stride Stride.\\n * @param {Array.<number>=} opt_ends Ends.\\n * @return {Array.<number>} Ends.\\n */\\nexport function deflateCoordinatesArray(flatCoordinates, offset, coordinatess, stride, opt_ends) {\\n  const ends = opt_ends ? opt_ends : [];\\n  let i = 0;\\n  for (let j = 0, jj = coordinatess.length; j < jj; ++j) {\\n    const end = deflateCoordinates(\\n      flatCoordinates, offset, coordinatess[j], stride);\\n    ends[i++] = end;\\n    offset = end;\\n  }\\n  ends.length = i;\\n  return ends;\\n}\\n\\n\\n/**\\n * @param {Array.<number>} flatCoordinates Flat coordinates.\\n * @param {number} offset Offset.\\n * @param {Array.<Array.<Array.<module:ol/coordinate~Coordinate>>>} coordinatesss Coordinatesss.\\n * @param {number} stride Stride.\\n * @param {Array.<Array.<number>>=} opt_endss Endss.\\n * @return {Array.<Array.<number>>} Endss.\\n */\\nexport function deflateMultiCoordinatesArray(flatCoordinates, offset, coordinatesss, stride, opt_endss) {\\n  const endss = opt_endss ? opt_endss : [];\\n  let i = 0;\\n  for (let j = 0, jj = coordinatesss.length; j < jj; ++j) {\\n    const ends = deflateCoordinatesArray(\\n      flatCoordinates, offset, coordinatesss[j], stride, endss[i]);\\n    endss[i++] = ends;\\n    offset = ends[ends.length - 1];\\n  }\\n  endss.length = i;\\n  return endss;\\n}\\n\",\"/**\\n * @module ol/geom/flat/inflate\\n */\\n\\n\\n/**\\n * @param {Array.<number>} flatCoordinates Flat coordinates.\\n * @param {number} offset Offset.\\n * @param {number} end End.\\n * @param {number} stride Stride.\\n * @param {Array.<module:ol/coordinate~Coordinate>=} opt_coordinates Coordinates.\\n * @return {Array.<module:ol/coordinate~Coordinate>} Coordinates.\\n */\\nexport function inflateCoordinates(flatCoordinates, offset, end, stride, opt_coordinates) {\\n  const coordinates = opt_coordinates !== undefined ? opt_coordinates : [];\\n  let i = 0;\\n  for (let j = offset; j < end; j += stride) {\\n    coordinates[i++] = flatCoordinates.slice(j, j + stride);\\n  }\\n  coordinates.length = i;\\n  return coordinates;\\n}\\n\\n\\n/**\\n * @param {Array.<number>} flatCoordinates Flat coordinates.\\n * @param {number} offset Offset.\\n * @param {Array.<number>} ends Ends.\\n * @param {number} stride Stride.\\n * @param {Array.<Array.<module:ol/coordinate~Coordinate>>=} opt_coordinatess Coordinatess.\\n * @return {Array.<Array.<module:ol/coordinate~Coordinate>>} Coordinatess.\\n */\\nexport function inflateCoordinatesArray(flatCoordinates, offset, ends, stride, opt_coordinatess) {\\n  const coordinatess = opt_coordinatess !== undefined ? opt_coordinatess : [];\\n  let i = 0;\\n  for (let j = 0, jj = ends.length; j < jj; ++j) {\\n    const end = ends[j];\\n    coordinatess[i++] = inflateCoordinates(\\n      flatCoordinates, offset, end, stride, coordinatess[i]);\\n    offset = end;\\n  }\\n  coordinatess.length = i;\\n  return coordinatess;\\n}\\n\\n\\n/**\\n * @param {Array.<number>} flatCoordinates Flat coordinates.\\n * @param {number} offset Offset.\\n * @param {Array.<Array.<number>>} endss Endss.\\n * @param {number} stride Stride.\\n * @param {Array.<Array.<Array.<module:ol/coordinate~Coordinate>>>=} opt_coordinatesss\\n *     Coordinatesss.\\n * @return {Array.<Array.<Array.<module:ol/coordinate~Coordinate>>>} Coordinatesss.\\n */\\nexport function inflateMultiCoordinatesArray(flatCoordinates, offset, endss, stride, opt_coordinatesss) {\\n  const coordinatesss = opt_coordinatesss !== undefined ? opt_coordinatesss : [];\\n  let i = 0;\\n  for (let j = 0, jj = endss.length; j < jj; ++j) {\\n    const ends = endss[j];\\n    coordinatesss[i++] = inflateCoordinatesArray(\\n      flatCoordinates, offset, ends, stride, coordinatesss[i]);\\n    offset = ends[ends.length - 1];\\n  }\\n  coordinatesss.length = i;\\n  return coordinatesss;\\n}\\n\",\"/**\\n * @module ol/geom/flat/interpolate\\n */\\nimport {binarySearch} from '../../array.js';\\nimport {lerp} from '../../math.js';\\n\\n\\n/**\\n * @param {Array.<number>} flatCoordinates Flat coordinates.\\n * @param {number} offset Offset.\\n * @param {number} end End.\\n * @param {number} stride Stride.\\n * @param {number} fraction Fraction.\\n * @param {Array.<number>=} opt_dest Destination.\\n * @return {Array.<number>} Destination.\\n */\\nexport function interpolatePoint(flatCoordinates, offset, end, stride, fraction, opt_dest) {\\n  let pointX = NaN;\\n  let pointY = NaN;\\n  const n = (end - offset) / stride;\\n  if (n === 1) {\\n    pointX = flatCoordinates[offset];\\n    pointY = flatCoordinates[offset + 1];\\n  } else if (n == 2) {\\n    pointX = (1 - fraction) * flatCoordinates[offset] +\\n        fraction * flatCoordinates[offset + stride];\\n    pointY = (1 - fraction) * flatCoordinates[offset + 1] +\\n        fraction * flatCoordinates[offset + stride + 1];\\n  } else if (n !== 0) {\\n    let x1 = flatCoordinates[offset];\\n    let y1 = flatCoordinates[offset + 1];\\n    let length = 0;\\n    const cumulativeLengths = [0];\\n    for (let i = offset + stride; i < end; i += stride) {\\n      const x2 = flatCoordinates[i];\\n      const y2 = flatCoordinates[i + 1];\\n      length += Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));\\n      cumulativeLengths.push(length);\\n      x1 = x2;\\n      y1 = y2;\\n    }\\n    const target = fraction * length;\\n    const index = binarySearch(cumulativeLengths, target);\\n    if (index < 0) {\\n      const t = (target - cumulativeLengths[-index - 2]) /\\n          (cumulativeLengths[-index - 1] - cumulativeLengths[-index - 2]);\\n      const o = offset + (-index - 2) * stride;\\n      pointX = lerp(\\n        flatCoordinates[o], flatCoordinates[o + stride], t);\\n      pointY = lerp(\\n        flatCoordinates[o + 1], flatCoordinates[o + stride + 1], t);\\n    } else {\\n      pointX = flatCoordinates[offset + index * stride];\\n      pointY = flatCoordinates[offset + index * stride + 1];\\n    }\\n  }\\n  if (opt_dest) {\\n    opt_dest[0] = pointX;\\n    opt_dest[1] = pointY;\\n    return opt_dest;\\n  } else {\\n    return [pointX, pointY];\\n  }\\n}\\n\\n\\n/**\\n * @param {Array.<number>} flatCoordinates Flat coordinates.\\n * @param {number} offset Offset.\\n * @param {number} end End.\\n * @param {number} stride Stride.\\n * @param {number} m M.\\n * @param {boolean} extrapolate Extrapolate.\\n * @return {module:ol/coordinate~Coordinate} Coordinate.\\n */\\nexport function lineStringCoordinateAtM(flatCoordinates, offset, end, stride, m, extrapolate) {\\n  if (end == offset) {\\n    return null;\\n  }\\n  let coordinate;\\n  if (m < flatCoordinates[offset + stride - 1]) {\\n    if (extrapolate) {\\n      coordinate = flatCoordinates.slice(offset, offset + stride);\\n      coordinate[stride - 1] = m;\\n      return coordinate;\\n    } else {\\n      return null;\\n    }\\n  } else if (flatCoordinates[end - 1] < m) {\\n    if (extrapolate) {\\n      coordinate = flatCoordinates.slice(end - stride, end);\\n      coordinate[stride - 1] = m;\\n      return coordinate;\\n    } else {\\n      return null;\\n    }\\n  }\\n  // FIXME use O(1) search\\n  if (m == flatCoordinates[offset + stride - 1]) {\\n    return flatCoordinates.slice(offset, offset + stride);\\n  }\\n  let lo = offset / stride;\\n  let hi = end / stride;\\n  while (lo < hi) {\\n    const mid = (lo + hi) >> 1;\\n    if (m < flatCoordinates[(mid + 1) * stride - 1]) {\\n      hi = mid;\\n    } else {\\n      lo = mid + 1;\\n    }\\n  }\\n  const m0 = flatCoordinates[lo * stride - 1];\\n  if (m == m0) {\\n    return flatCoordinates.slice((lo - 1) * stride, (lo - 1) * stride + stride);\\n  }\\n  const m1 = flatCoordinates[(lo + 1) * stride - 1];\\n  const t = (m - m0) / (m1 - m0);\\n  coordinate = [];\\n  for (let i = 0; i < stride - 1; ++i) {\\n    coordinate.push(lerp(flatCoordinates[(lo - 1) * stride + i],\\n      flatCoordinates[lo * stride + i], t));\\n  }\\n  coordinate.push(m);\\n  return coordinate;\\n}\\n\\n\\n/**\\n * @param {Array.<number>} flatCoordinates Flat coordinates.\\n * @param {number} offset Offset.\\n * @param {Array.<number>} ends Ends.\\n * @param {number} stride Stride.\\n * @param {number} m M.\\n * @param {boolean} extrapolate Extrapolate.\\n * @param {boolean} interpolate Interpolate.\\n * @return {module:ol/coordinate~Coordinate} Coordinate.\\n */\\nexport function lineStringsCoordinateAtM(\\n  flatCoordinates, offset, ends, stride, m, extrapolate, interpolate) {\\n  if (interpolate) {\\n    return lineStringCoordinateAtM(\\n      flatCoordinates, offset, ends[ends.length - 1], stride, m, extrapolate);\\n  }\\n  let coordinate;\\n  if (m < flatCoordinates[stride - 1]) {\\n    if (extrapolate) {\\n      coordinate = flatCoordinates.slice(0, stride);\\n      coordinate[stride - 1] = m;\\n      return coordinate;\\n    } else {\\n      return null;\\n    }\\n  }\\n  if (flatCoordinates[flatCoordinates.length - 1] < m) {\\n    if (extrapolate) {\\n      coordinate = flatCoordinates.slice(flatCoordinates.length - stride);\\n      coordinate[stride - 1] = m;\\n      return coordinate;\\n    } else {\\n      return null;\\n    }\\n  }\\n  for (let i = 0, ii = ends.length; i < ii; ++i) {\\n    const end = ends[i];\\n    if (offset == end) {\\n      continue;\\n    }\\n    if (m < flatCoordinates[offset + stride - 1]) {\\n      return null;\\n    } else if (m <= flatCoordinates[end - 1]) {\\n      return lineStringCoordinateAtM(\\n        flatCoordinates, offset, end, stride, m, false);\\n    }\\n    offset = end;\\n  }\\n  return null;\\n}\\n\",\"/**\\n * @module ol/geom/flat/contains\\n */\\nimport {forEachCorner} from '../../extent.js';\\n\\n\\n/**\\n * @param {Array.<number>} flatCoordinates Flat coordinates.\\n * @param {number} offset Offset.\\n * @param {number} end End.\\n * @param {number} stride Stride.\\n * @param {module:ol/extent~Extent} extent Extent.\\n * @return {boolean} Contains extent.\\n */\\nexport function linearRingContainsExtent(flatCoordinates, offset, end, stride, extent) {\\n  const outside = forEachCorner(extent,\\n    /**\\n     * @param {module:ol/coordinate~Coordinate} coordinate Coordinate.\\n     * @return {boolean} Contains (x, y).\\n     */\\n    function(coordinate) {\\n      return !linearRingContainsXY(flatCoordinates, offset, end, stride, coordinate[0], coordinate[1]);\\n    });\\n  return !outside;\\n}\\n\\n\\n/**\\n * @param {Array.<number>} flatCoordinates Flat coordinates.\\n * @param {number} offset Offset.\\n * @param {number} end End.\\n * @param {number} stride Stride.\\n * @param {number} x X.\\n * @param {number} y Y.\\n * @return {boolean} Contains (x, y).\\n */\\nexport function linearRingContainsXY(flatCoordinates, offset, end, stride, x, y) {\\n  // http://geomalgorithms.com/a03-_inclusion.html\\n  // Copyright 2000 softSurfer, 2012 Dan Sunday\\n  // This code may be freely used and modified for any purpose\\n  // providing that this copyright notice is included with it.\\n  // SoftSurfer makes no warranty for this code, and cannot be held\\n  // liable for any real or imagined damage resulting from its use.\\n  // Users of this code must verify correctness for their application.\\n  let wn = 0;\\n  let x1 = flatCoordinates[end - stride];\\n  let y1 = flatCoordinates[end - stride + 1];\\n  for (; offset < end; offset += stride) {\\n    const x2 = flatCoordinates[offset];\\n    const y2 = flatCoordinates[offset + 1];\\n    if (y1 <= y) {\\n      if (y2 > y && ((x2 - x1) * (y - y1)) - ((x - x1) * (y2 - y1)) > 0) {\\n        wn++;\\n      }\\n    } else if (y2 <= y && ((x2 - x1) * (y - y1)) - ((x - x1) * (y2 - y1)) < 0) {\\n      wn--;\\n    }\\n    x1 = x2;\\n    y1 = y2;\\n  }\\n  return wn !== 0;\\n}\\n\\n\\n/**\\n * @param {Array.<number>} flatCoordinates Flat coordinates.\\n * @param {number} offset Offset.\\n * @param {Array.<number>} ends Ends.\\n * @param {number} stride Stride.\\n * @param {number} x X.\\n * @param {number} y Y.\\n * @return {boolean} Contains (x, y).\\n */\\nexport function linearRingsContainsXY(flatCoordinates, offset, ends, stride, x, y) {\\n  if (ends.length === 0) {\\n    return false;\\n  }\\n  if (!linearRingContainsXY(flatCoordinates, offset, ends[0], stride, x, y)) {\\n    return false;\\n  }\\n  for (let i = 1, ii = ends.length; i < ii; ++i) {\\n    if (linearRingContainsXY(flatCoordinates, ends[i - 1], ends[i], stride, x, y)) {\\n      return false;\\n    }\\n  }\\n  return true;\\n}\\n\\n\\n/**\\n * @param {Array.<number>} flatCoordinates Flat coordinates.\\n * @param {number} offset Offset.\\n * @param {Array.<Array.<number>>} endss Endss.\\n * @param {number} stride Stride.\\n * @param {number} x X.\\n * @param {number} y Y.\\n * @return {boolean} Contains (x, y).\\n */\\nexport function linearRingssContainsXY(flatCoordinates, offset, endss, stride, x, y) {\\n  if (endss.length === 0) {\\n    return false;\\n  }\\n  for (let i = 0, ii = endss.length; i < ii; ++i) {\\n    const ends = endss[i];\\n    if (linearRingsContainsXY(flatCoordinates, offset, ends, stride, x, y)) {\\n      return true;\\n    }\\n    offset = ends[ends.length - 1];\\n  }\\n  return false;\\n}\\n\",\"/**\\n * @module ol/geom/flat/segments\\n */\\n\\n\\n/**\\n * This function calls `callback` for each segment of the flat coordinates\\n * array. If the callback returns a truthy value the function returns that\\n * value immediately. Otherwise the function returns `false`.\\n * @param {Array.<number>} flatCoordinates Flat coordinates.\\n * @param {number} offset Offset.\\n * @param {number} end End.\\n * @param {number} stride Stride.\\n * @param {function(this: S, module:ol/coordinate~Coordinate, module:ol/coordinate~Coordinate): T} callback Function\\n *     called for each segment.\\n * @param {S=} opt_this The object to be used as the value of 'this'\\n *     within callback.\\n * @return {T|boolean} Value.\\n * @template T,S\\n */\\nexport function forEach(flatCoordinates, offset, end, stride, callback, opt_this) {\\n  const point1 = [flatCoordinates[offset], flatCoordinates[offset + 1]];\\n  const point2 = [];\\n  let ret;\\n  for (; (offset + stride) < end; offset += stride) {\\n    point2[0] = flatCoordinates[offset + stride];\\n    point2[1] = flatCoordinates[offset + stride + 1];\\n    ret = callback.call(opt_this, point1, point2);\\n    if (ret) {\\n      return ret;\\n    }\\n    point1[0] = point2[0];\\n    point1[1] = point2[1];\\n  }\\n  return false;\\n}\\n\",\"/**\\n * @module ol/geom/flat/intersectsextent\\n */\\nimport {containsExtent, createEmpty, extendFlatCoordinates, intersects, intersectsSegment} from '../../extent.js';\\nimport {linearRingContainsXY, linearRingContainsExtent} from '../flat/contains.js';\\nimport {forEach as forEachSegment} from '../flat/segments.js';\\n\\n\\n/**\\n * @param {Array.<number>} flatCoordinates Flat coordinates.\\n * @param {number} offset Offset.\\n * @param {number} end End.\\n * @param {number} stride Stride.\\n * @param {module:ol/extent~Extent} extent Extent.\\n * @return {boolean} True if the geometry and the extent intersect.\\n */\\nexport function intersectsLineString(flatCoordinates, offset, end, stride, extent) {\\n  const coordinatesExtent = extendFlatCoordinates(\\n    createEmpty(), flatCoordinates, offset, end, stride);\\n  if (!intersects(extent, coordinatesExtent)) {\\n    return false;\\n  }\\n  if (containsExtent(extent, coordinatesExtent)) {\\n    return true;\\n  }\\n  if (coordinatesExtent[0] >= extent[0] &&\\n      coordinatesExtent[2] <= extent[2]) {\\n    return true;\\n  }\\n  if (coordinatesExtent[1] >= extent[1] &&\\n      coordinatesExtent[3] <= extent[3]) {\\n    return true;\\n  }\\n  return forEachSegment(flatCoordinates, offset, end, stride,\\n    /**\\n     * @param {module:ol/coordinate~Coordinate} point1 Start point.\\n     * @param {module:ol/coordinate~Coordinate} point2 End point.\\n     * @return {boolean} `true` if the segment and the extent intersect,\\n     *     `false` otherwise.\\n     */\\n    function(point1, point2) {\\n      return intersectsSegment(extent, point1, point2);\\n    });\\n}\\n\\n\\n/**\\n * @param {Array.<number>} flatCoordinates Flat coordinates.\\n * @param {number} offset Offset.\\n * @param {Array.<number>} ends Ends.\\n * @param {number} stride Stride.\\n * @param {module:ol/extent~Extent} extent Extent.\\n * @return {boolean} True if the geometry and the extent intersect.\\n */\\nexport function intersectsLineStringArray(flatCoordinates, offset, ends, stride, extent) {\\n  for (let i = 0, ii = ends.length; i < ii; ++i) {\\n    if (intersectsLineString(\\n      flatCoordinates, offset, ends[i], stride, extent)) {\\n      return true;\\n    }\\n    offset = ends[i];\\n  }\\n  return false;\\n}\\n\\n\\n/**\\n * @param {Array.<number>} flatCoordinates Flat coordinates.\\n * @param {number} offset Offset.\\n * @param {number} end End.\\n * @param {number} stride Stride.\\n * @param {module:ol/extent~Extent} extent Extent.\\n * @return {boolean} True if the geometry and the extent intersect.\\n */\\nexport function intersectsLinearRing(flatCoordinates, offset, end, stride, extent) {\\n  if (intersectsLineString(\\n    flatCoordinates, offset, end, stride, extent)) {\\n    return true;\\n  }\\n  if (linearRingContainsXY(flatCoordinates, offset, end, stride, extent[0], extent[1])) {\\n    return true;\\n  }\\n  if (linearRingContainsXY(flatCoordinates, offset, end, stride, extent[0], extent[3])) {\\n    return true;\\n  }\\n  if (linearRingContainsXY(flatCoordinates, offset, end, stride, extent[2], extent[1])) {\\n    return true;\\n  }\\n  if (linearRingContainsXY(flatCoordinates, offset, end, stride, extent[2], extent[3])) {\\n    return true;\\n  }\\n  return false;\\n}\\n\\n\\n/**\\n * @param {Array.<number>} flatCoordinates Flat coordinates.\\n * @param {number} offset Offset.\\n * @param {Array.<number>} ends Ends.\\n * @param {number} stride Stride.\\n * @param {module:ol/extent~Extent} extent Extent.\\n * @return {boolean} True if the geometry and the extent intersect.\\n */\\nexport function intersectsLinearRingArray(flatCoordinates, offset, ends, stride, extent) {\\n  if (!intersectsLinearRing(\\n    flatCoordinates, offset, ends[0], stride, extent)) {\\n    return false;\\n  }\\n  if (ends.length === 1) {\\n    return true;\\n  }\\n  for (let i = 1, ii = ends.length; i < ii; ++i) {\\n    if (linearRingContainsExtent(flatCoordinates, ends[i - 1], ends[i], stride, extent)) {\\n      return false;\\n    }\\n  }\\n  return true;\\n}\\n\\n\\n/**\\n * @param {Array.<number>} flatCoordinates Flat coordinates.\\n * @param {number} offset Offset.\\n * @param {Array.<Array.<number>>} endss Endss.\\n * @param {number} stride Stride.\\n * @param {module:ol/extent~Extent} extent Extent.\\n * @return {boolean} True if the geometry and the extent intersect.\\n */\\nexport function intersectsLinearRingMultiArray(flatCoordinates, offset, endss, stride, extent) {\\n  for (let i = 0, ii = endss.length; i < ii; ++i) {\\n    const ends = endss[i];\\n    if (intersectsLinearRingArray(\\n      flatCoordinates, offset, ends, stride, extent)) {\\n      return true;\\n    }\\n    offset = ends[ends.length - 1];\\n  }\\n  return false;\\n}\\n\",\"/**\\n * @module ol/geom/flat/length\\n */\\n\\n\\n/**\\n * @param {Array.<number>} flatCoordinates Flat coordinates.\\n * @param {number} offset Offset.\\n * @param {number} end End.\\n * @param {number} stride Stride.\\n * @return {number} Length.\\n */\\nexport function lineStringLength(flatCoordinates, offset, end, stride) {\\n  let x1 = flatCoordinates[offset];\\n  let y1 = flatCoordinates[offset + 1];\\n  let length = 0;\\n  for (let i = offset + stride; i < end; i += stride) {\\n    const x2 = flatCoordinates[i];\\n    const y2 = flatCoordinates[i + 1];\\n    length += Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));\\n    x1 = x2;\\n    y1 = y2;\\n  }\\n  return length;\\n}\\n\\n\\n/**\\n * @param {Array.<number>} flatCoordinates Flat coordinates.\\n * @param {number} offset Offset.\\n * @param {number} end End.\\n * @param {number} stride Stride.\\n * @return {number} Perimeter.\\n */\\nexport function linearRingLength(flatCoordinates, offset, end, stride) {\\n  let perimeter = lineStringLength(flatCoordinates, offset, end, stride);\\n  const dx = flatCoordinates[end - stride] - flatCoordinates[offset];\\n  const dy = flatCoordinates[end - stride + 1] - flatCoordinates[offset + 1];\\n  perimeter += Math.sqrt(dx * dx + dy * dy);\\n  return perimeter;\\n}\\n\",\"/**\\n * @module ol/geom/flat/simplify\\n */\\n// Based on simplify-js https://github.com/mourner/simplify-js\\n// Copyright (c) 2012, Vladimir Agafonkin\\n// All rights reserved.\\n//\\n// Redistribution and use in source and binary forms, with or without\\n// modification, are permitted provided that the following conditions are met:\\n//\\n//    1. Redistributions of source code must retain the above copyright notice,\\n//       this list of conditions and the following disclaimer.\\n//\\n//    2. Redistributions in binary form must reproduce the above copyright\\n//       notice, this list of conditions and the following disclaimer in the\\n//       documentation and/or other materials provided with the distribution.\\n//\\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \\\"AS IS\\\"\\n// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\\n// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\\n// ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\\n// LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\\n// CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\\n// SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\\n// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\\n// CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\\n// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\\n// POSSIBILITY OF SUCH DAMAGE.\\n\\nimport {squaredSegmentDistance, squaredDistance} from '../../math.js';\\n\\n\\n/**\\n * @param {Array.<number>} flatCoordinates Flat coordinates.\\n * @param {number} offset Offset.\\n * @param {number} end End.\\n * @param {number} stride Stride.\\n * @param {number} squaredTolerance Squared tolerance.\\n * @param {boolean} highQuality Highest quality.\\n * @param {Array.<number>=} opt_simplifiedFlatCoordinates Simplified flat\\n *     coordinates.\\n * @return {Array.<number>} Simplified line string.\\n */\\nexport function simplifyLineString(flatCoordinates, offset, end,\\n  stride, squaredTolerance, highQuality, opt_simplifiedFlatCoordinates) {\\n  const simplifiedFlatCoordinates = opt_simplifiedFlatCoordinates !== undefined ?\\n    opt_simplifiedFlatCoordinates : [];\\n  if (!highQuality) {\\n    end = radialDistance(flatCoordinates, offset, end,\\n      stride, squaredTolerance,\\n      simplifiedFlatCoordinates, 0);\\n    flatCoordinates = simplifiedFlatCoordinates;\\n    offset = 0;\\n    stride = 2;\\n  }\\n  simplifiedFlatCoordinates.length = douglasPeucker(\\n    flatCoordinates, offset, end, stride, squaredTolerance,\\n    simplifiedFlatCoordinates, 0);\\n  return simplifiedFlatCoordinates;\\n}\\n\\n\\n/**\\n * @param {Array.<number>} flatCoordinates Flat coordinates.\\n * @param {number} offset Offset.\\n * @param {number} end End.\\n * @param {number} stride Stride.\\n * @param {number} squaredTolerance Squared tolerance.\\n * @param {Array.<number>} simplifiedFlatCoordinates Simplified flat\\n *     coordinates.\\n * @param {number} simplifiedOffset Simplified offset.\\n * @return {number} Simplified offset.\\n */\\nexport function douglasPeucker(flatCoordinates, offset, end,\\n  stride, squaredTolerance, simplifiedFlatCoordinates, simplifiedOffset) {\\n  const n = (end - offset) / stride;\\n  if (n < 3) {\\n    for (; offset < end; offset += stride) {\\n      simplifiedFlatCoordinates[simplifiedOffset++] =\\n          flatCoordinates[offset];\\n      simplifiedFlatCoordinates[simplifiedOffset++] =\\n          flatCoordinates[offset + 1];\\n    }\\n    return simplifiedOffset;\\n  }\\n  /** @type {Array.<number>} */\\n  const markers = new Array(n);\\n  markers[0] = 1;\\n  markers[n - 1] = 1;\\n  /** @type {Array.<number>} */\\n  const stack = [offset, end - stride];\\n  let index = 0;\\n  while (stack.length > 0) {\\n    const last = stack.pop();\\n    const first = stack.pop();\\n    let maxSquaredDistance = 0;\\n    const x1 = flatCoordinates[first];\\n    const y1 = flatCoordinates[first + 1];\\n    const x2 = flatCoordinates[last];\\n    const y2 = flatCoordinates[last + 1];\\n    for (let i = first + stride; i < last; i += stride) {\\n      const x = flatCoordinates[i];\\n      const y = flatCoordinates[i + 1];\\n      const squaredDistance = squaredSegmentDistance(\\n        x, y, x1, y1, x2, y2);\\n      if (squaredDistance > maxSquaredDistance) {\\n        index = i;\\n        maxSquaredDistance = squaredDistance;\\n      }\\n    }\\n    if (maxSquaredDistance > squaredTolerance) {\\n      markers[(index - offset) / stride] = 1;\\n      if (first + stride < index) {\\n        stack.push(first, index);\\n      }\\n      if (index + stride < last) {\\n        stack.push(index, last);\\n      }\\n    }\\n  }\\n  for (let i = 0; i < n; ++i) {\\n    if (markers[i]) {\\n      simplifiedFlatCoordinates[simplifiedOffset++] =\\n          flatCoordinates[offset + i * stride];\\n      simplifiedFlatCoordinates[simplifiedOffset++] =\\n          flatCoordinates[offset + i * stride + 1];\\n    }\\n  }\\n  return simplifiedOffset;\\n}\\n\\n\\n/**\\n * @param {Array.<number>} flatCoordinates Flat coordinates.\\n * @param {number} offset Offset.\\n * @param {Array.<number>} ends Ends.\\n * @param {number} stride Stride.\\n * @param {number} squaredTolerance Squared tolerance.\\n * @param {Array.<number>} simplifiedFlatCoordinates Simplified flat\\n *     coordinates.\\n * @param {number} simplifiedOffset Simplified offset.\\n * @param {Array.<number>} simplifiedEnds Simplified ends.\\n * @return {number} Simplified offset.\\n */\\nexport function douglasPeuckerArray(flatCoordinates, offset,\\n  ends, stride, squaredTolerance, simplifiedFlatCoordinates,\\n  simplifiedOffset, simplifiedEnds) {\\n  for (let i = 0, ii = ends.length; i < ii; ++i) {\\n    const end = ends[i];\\n    simplifiedOffset = douglasPeucker(\\n      flatCoordinates, offset, end, stride, squaredTolerance,\\n      simplifiedFlatCoordinates, simplifiedOffset);\\n    simplifiedEnds.push(simplifiedOffset);\\n    offset = end;\\n  }\\n  return simplifiedOffset;\\n}\\n\\n\\n/**\\n * @param {Array.<number>} flatCoordinates Flat coordinates.\\n * @param {number} offset Offset.\\n * @param {Array.<Array.<number>>} endss Endss.\\n * @param {number} stride Stride.\\n * @param {number} squaredTolerance Squared tolerance.\\n * @param {Array.<number>} simplifiedFlatCoordinates Simplified flat\\n *     coordinates.\\n * @param {number} simplifiedOffset Simplified offset.\\n * @param {Array.<Array.<number>>} simplifiedEndss Simplified endss.\\n * @return {number} Simplified offset.\\n */\\nexport function douglasPeuckerMultiArray(\\n  flatCoordinates, offset, endss, stride, squaredTolerance,\\n  simplifiedFlatCoordinates, simplifiedOffset, simplifiedEndss) {\\n  for (let i = 0, ii = endss.length; i < ii; ++i) {\\n    const ends = endss[i];\\n    const simplifiedEnds = [];\\n    simplifiedOffset = douglasPeuckerArray(\\n      flatCoordinates, offset, ends, stride, squaredTolerance,\\n      simplifiedFlatCoordinates, simplifiedOffset, simplifiedEnds);\\n    simplifiedEndss.push(simplifiedEnds);\\n    offset = ends[ends.length - 1];\\n  }\\n  return simplifiedOffset;\\n}\\n\\n\\n/**\\n * @param {Array.<number>} flatCoordinates Flat coordinates.\\n * @param {number} offset Offset.\\n * @param {number} end End.\\n * @param {number} stride Stride.\\n * @param {number} squaredTolerance Squared tolerance.\\n * @param {Array.<number>} simplifiedFlatCoordinates Simplified flat\\n *     coordinates.\\n * @param {number} simplifiedOffset Simplified offset.\\n * @return {number} Simplified offset.\\n */\\nexport function radialDistance(flatCoordinates, offset, end,\\n  stride, squaredTolerance, simplifiedFlatCoordinates, simplifiedOffset) {\\n  if (end <= offset + stride) {\\n    // zero or one point, no simplification possible, so copy and return\\n    for (; offset < end; offset += stride) {\\n      simplifiedFlatCoordinates[simplifiedOffset++] = flatCoordinates[offset];\\n      simplifiedFlatCoordinates[simplifiedOffset++] =\\n          flatCoordinates[offset + 1];\\n    }\\n    return simplifiedOffset;\\n  }\\n  let x1 = flatCoordinates[offset];\\n  let y1 = flatCoordinates[offset + 1];\\n  // copy first point\\n  simplifiedFlatCoordinates[simplifiedOffset++] = x1;\\n  simplifiedFlatCoordinates[simplifiedOffset++] = y1;\\n  let x2 = x1;\\n  let y2 = y1;\\n  for (offset += stride; offset < end; offset += stride) {\\n    x2 = flatCoordinates[offset];\\n    y2 = flatCoordinates[offset + 1];\\n    if (squaredDistance(x1, y1, x2, y2) > squaredTolerance) {\\n      // copy point at offset\\n      simplifiedFlatCoordinates[simplifiedOffset++] = x2;\\n      simplifiedFlatCoordinates[simplifiedOffset++] = y2;\\n      x1 = x2;\\n      y1 = y2;\\n    }\\n  }\\n  if (x2 != x1 || y2 != y1) {\\n    // copy last point\\n    simplifiedFlatCoordinates[simplifiedOffset++] = x2;\\n    simplifiedFlatCoordinates[simplifiedOffset++] = y2;\\n  }\\n  return simplifiedOffset;\\n}\\n\\n\\n/**\\n * @param {number} value Value.\\n * @param {number} tolerance Tolerance.\\n * @return {number} Rounded value.\\n */\\nexport function snap(value, tolerance) {\\n  return tolerance * Math.round(value / tolerance);\\n}\\n\\n\\n/**\\n * Simplifies a line string using an algorithm designed by Tim Schaub.\\n * Coordinates are snapped to the nearest value in a virtual grid and\\n * consecutive duplicate coordinates are discarded.  This effectively preserves\\n * topology as the simplification of any subsection of a line string is\\n * independent of the rest of the line string.  This means that, for examples,\\n * the common edge between two polygons will be simplified to the same line\\n * string independently in both polygons.  This implementation uses a single\\n * pass over the coordinates and eliminates intermediate collinear points.\\n * @param {Array.<number>} flatCoordinates Flat coordinates.\\n * @param {number} offset Offset.\\n * @param {number} end End.\\n * @param {number} stride Stride.\\n * @param {number} tolerance Tolerance.\\n * @param {Array.<number>} simplifiedFlatCoordinates Simplified flat\\n *     coordinates.\\n * @param {number} simplifiedOffset Simplified offset.\\n * @return {number} Simplified offset.\\n */\\nexport function quantize(flatCoordinates, offset, end, stride,\\n  tolerance, simplifiedFlatCoordinates, simplifiedOffset) {\\n  // do nothing if the line is empty\\n  if (offset == end) {\\n    return simplifiedOffset;\\n  }\\n  // snap the first coordinate (P1)\\n  let x1 = snap(flatCoordinates[offset], tolerance);\\n  let y1 = snap(flatCoordinates[offset + 1], tolerance);\\n  offset += stride;\\n  // add the first coordinate to the output\\n  simplifiedFlatCoordinates[simplifiedOffset++] = x1;\\n  simplifiedFlatCoordinates[simplifiedOffset++] = y1;\\n  // find the next coordinate that does not snap to the same value as the first\\n  // coordinate (P2)\\n  let x2, y2;\\n  do {\\n    x2 = snap(flatCoordinates[offset], tolerance);\\n    y2 = snap(flatCoordinates[offset + 1], tolerance);\\n    offset += stride;\\n    if (offset == end) {\\n      // all coordinates snap to the same value, the line collapses to a point\\n      // push the last snapped value anyway to ensure that the output contains\\n      // at least two points\\n      // FIXME should we really return at least two points anyway?\\n      simplifiedFlatCoordinates[simplifiedOffset++] = x2;\\n      simplifiedFlatCoordinates[simplifiedOffset++] = y2;\\n      return simplifiedOffset;\\n    }\\n  } while (x2 == x1 && y2 == y1);\\n  while (offset < end) {\\n    // snap the next coordinate (P3)\\n    const x3 = snap(flatCoordinates[offset], tolerance);\\n    const y3 = snap(flatCoordinates[offset + 1], tolerance);\\n    offset += stride;\\n    // skip P3 if it is equal to P2\\n    if (x3 == x2 && y3 == y2) {\\n      continue;\\n    }\\n    // calculate the delta between P1 and P2\\n    const dx1 = x2 - x1;\\n    const dy1 = y2 - y1;\\n    // calculate the delta between P3 and P1\\n    const dx2 = x3 - x1;\\n    const dy2 = y3 - y1;\\n    // if P1, P2, and P3 are colinear and P3 is further from P1 than P2 is from\\n    // P1 in the same direction then P2 is on the straight line between P1 and\\n    // P3\\n    if ((dx1 * dy2 == dy1 * dx2) &&\\n        ((dx1 < 0 && dx2 < dx1) || dx1 == dx2 || (dx1 > 0 && dx2 > dx1)) &&\\n        ((dy1 < 0 && dy2 < dy1) || dy1 == dy2 || (dy1 > 0 && dy2 > dy1))) {\\n      // discard P2 and set P2 = P3\\n      x2 = x3;\\n      y2 = y3;\\n      continue;\\n    }\\n    // either P1, P2, and P3 are not colinear, or they are colinear but P3 is\\n    // between P3 and P1 or on the opposite half of the line to P2.  add P2,\\n    // and continue with P1 = P2 and P2 = P3\\n    simplifiedFlatCoordinates[simplifiedOffset++] = x2;\\n    simplifiedFlatCoordinates[simplifiedOffset++] = y2;\\n    x1 = x2;\\n    y1 = y2;\\n    x2 = x3;\\n    y2 = y3;\\n  }\\n  // add the last point (P2)\\n  simplifiedFlatCoordinates[simplifiedOffset++] = x2;\\n  simplifiedFlatCoordinates[simplifiedOffset++] = y2;\\n  return simplifiedOffset;\\n}\\n\\n\\n/**\\n * @param {Array.<number>} flatCoordinates Flat coordinates.\\n * @param {number} offset Offset.\\n * @param {Array.<number>} ends Ends.\\n * @param {number} stride Stride.\\n * @param {number} tolerance Tolerance.\\n * @param {Array.<number>} simplifiedFlatCoordinates Simplified flat\\n *     coordinates.\\n * @param {number} simplifiedOffset Simplified offset.\\n * @param {Array.<number>} simplifiedEnds Simplified ends.\\n * @return {number} Simplified offset.\\n */\\nexport function quantizeArray(\\n  flatCoordinates, offset, ends, stride,\\n  tolerance,\\n  simplifiedFlatCoordinates, simplifiedOffset, simplifiedEnds) {\\n  for (let i = 0, ii = ends.length; i < ii; ++i) {\\n    const end = ends[i];\\n    simplifiedOffset = quantize(\\n      flatCoordinates, offset, end, stride,\\n      tolerance,\\n      simplifiedFlatCoordinates, simplifiedOffset);\\n    simplifiedEnds.push(simplifiedOffset);\\n    offset = end;\\n  }\\n  return simplifiedOffset;\\n}\\n\\n\\n/**\\n * @param {Array.<number>} flatCoordinates Flat coordinates.\\n * @param {number} offset Offset.\\n * @param {Array.<Array.<number>>} endss Endss.\\n * @param {number} stride Stride.\\n * @param {number} tolerance Tolerance.\\n * @param {Array.<number>} simplifiedFlatCoordinates Simplified flat\\n *     coordinates.\\n * @param {number} simplifiedOffset Simplified offset.\\n * @param {Array.<Array.<number>>} simplifiedEndss Simplified endss.\\n * @return {number} Simplified offset.\\n */\\nexport function quantizeMultiArray(\\n  flatCoordinates, offset, endss, stride,\\n  tolerance,\\n  simplifiedFlatCoordinates, simplifiedOffset, simplifiedEndss) {\\n  for (let i = 0, ii = endss.length; i < ii; ++i) {\\n    const ends = endss[i];\\n    const simplifiedEnds = [];\\n    simplifiedOffset = quantizeArray(\\n      flatCoordinates, offset, ends, stride,\\n      tolerance,\\n      simplifiedFlatCoordinates, simplifiedOffset, simplifiedEnds);\\n    simplifiedEndss.push(simplifiedEnds);\\n    offset = ends[ends.length - 1];\\n  }\\n  return simplifiedOffset;\\n}\\n\",\"/**\\n * @module ol/geom/LineString\\n */\\nimport {inherits} from '../index.js';\\nimport {extend} from '../array.js';\\nimport {closestSquaredDistanceXY} from '../extent.js';\\nimport GeometryLayout from '../geom/GeometryLayout.js';\\nimport GeometryType from '../geom/GeometryType.js';\\nimport SimpleGeometry from '../geom/SimpleGeometry.js';\\nimport {assignClosestPoint, maxSquaredDelta} from '../geom/flat/closest.js';\\nimport {deflateCoordinates} from '../geom/flat/deflate.js';\\nimport {inflateCoordinates} from '../geom/flat/inflate.js';\\nimport {interpolatePoint, lineStringCoordinateAtM} from '../geom/flat/interpolate.js';\\nimport {intersectsLineString} from '../geom/flat/intersectsextent.js';\\nimport {lineStringLength} from '../geom/flat/length.js';\\nimport {forEach as forEachSegment} from '../geom/flat/segments.js';\\nimport {douglasPeucker} from '../geom/flat/simplify.js';\\n\\n/**\\n * @classdesc\\n * Linestring geometry.\\n *\\n * @constructor\\n * @extends {module:ol/geom/SimpleGeometry}\\n * @param {Array.<module:ol/coordinate~Coordinate>} coordinates Coordinates.\\n * @param {module:ol/geom/GeometryLayout=} opt_layout Layout.\\n * @api\\n */\\nconst LineString = function(coordinates, opt_layout) {\\n\\n  SimpleGeometry.call(this);\\n\\n  /**\\n   * @private\\n   * @type {module:ol/coordinate~Coordinate}\\n   */\\n  this.flatMidpoint_ = null;\\n\\n  /**\\n   * @private\\n   * @type {number}\\n   */\\n  this.flatMidpointRevision_ = -1;\\n\\n  /**\\n   * @private\\n   * @type {number}\\n   */\\n  this.maxDelta_ = -1;\\n\\n  /**\\n   * @private\\n   * @type {number}\\n   */\\n  this.maxDeltaRevision_ = -1;\\n\\n  this.setCoordinates(coordinates, opt_layout);\\n\\n};\\n\\ninherits(LineString, SimpleGeometry);\\n\\n\\n/**\\n * Append the passed coordinate to the coordinates of the linestring.\\n * @param {module:ol/coordinate~Coordinate} coordinate Coordinate.\\n * @api\\n */\\nLineString.prototype.appendCoordinate = function(coordinate) {\\n  if (!this.flatCoordinates) {\\n    this.flatCoordinates = coordinate.slice();\\n  } else {\\n    extend(this.flatCoordinates, coordinate);\\n  }\\n  this.changed();\\n};\\n\\n\\n/**\\n * Make a complete copy of the geometry.\\n * @return {!module:ol/geom/LineString} Clone.\\n * @override\\n * @api\\n */\\nLineString.prototype.clone = function() {\\n  const lineString = new LineString(null);\\n  lineString.setFlatCoordinates(this.layout, this.flatCoordinates.slice());\\n  return lineString;\\n};\\n\\n\\n/**\\n * @inheritDoc\\n */\\nLineString.prototype.closestPointXY = function(x, y, closestPoint, minSquaredDistance) {\\n  if (minSquaredDistance < closestSquaredDistanceXY(this.getExtent(), x, y)) {\\n    return minSquaredDistance;\\n  }\\n  if (this.maxDeltaRevision_ != this.getRevision()) {\\n    this.maxDelta_ = Math.sqrt(maxSquaredDelta(\\n      this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, 0));\\n    this.maxDeltaRevision_ = this.getRevision();\\n  }\\n  return assignClosestPoint(\\n    this.flatCoordinates, 0, this.flatCoordinates.length, this.stride,\\n    this.maxDelta_, false, x, y, closestPoint, minSquaredDistance);\\n};\\n\\n\\n/**\\n * Iterate over each segment, calling the provided callback.\\n * If the callback returns a truthy value the function returns that\\n * value immediately. Otherwise the function returns `false`.\\n *\\n * @param {function(this: S, module:ol/coordinate~Coordinate, module:ol/coordinate~Coordinate): T} callback Function\\n *     called for each segment.\\n * @return {T|boolean} Value.\\n * @template T,S\\n * @api\\n */\\nLineString.prototype.forEachSegment = function(callback) {\\n  return forEachSegment(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, callback);\\n};\\n\\n\\n/**\\n * Returns the coordinate at `m` using linear interpolation, or `null` if no\\n * such coordinate exists.\\n *\\n * `opt_extrapolate` controls extrapolation beyond the range of Ms in the\\n * MultiLineString. If `opt_extrapolate` is `true` then Ms less than the first\\n * M will return the first coordinate and Ms greater than the last M will\\n * return the last coordinate.\\n *\\n * @param {number} m M.\\n * @param {boolean=} opt_extrapolate Extrapolate. Default is `false`.\\n * @return {module:ol/coordinate~Coordinate} Coordinate.\\n * @api\\n */\\nLineString.prototype.getCoordinateAtM = function(m, opt_extrapolate) {\\n  if (this.layout != GeometryLayout.XYM &&\\n      this.layout != GeometryLayout.XYZM) {\\n    return null;\\n  }\\n  const extrapolate = opt_extrapolate !== undefined ? opt_extrapolate : false;\\n  return lineStringCoordinateAtM(this.flatCoordinates, 0,\\n    this.flatCoordinates.length, this.stride, m, extrapolate);\\n};\\n\\n\\n/**\\n * Return the coordinates of the linestring.\\n * @return {Array.<module:ol/coordinate~Coordinate>} Coordinates.\\n * @override\\n * @api\\n */\\nLineString.prototype.getCoordinates = function() {\\n  return inflateCoordinates(\\n    this.flatCoordinates, 0, this.flatCoordinates.length, this.stride);\\n};\\n\\n\\n/**\\n * Return the coordinate at the provided fraction along the linestring.\\n * The `fraction` is a number between 0 and 1, where 0 is the start of the\\n * linestring and 1 is the end.\\n * @param {number} fraction Fraction.\\n * @param {module:ol/coordinate~Coordinate=} opt_dest Optional coordinate whose values will\\n *     be modified. If not provided, a new coordinate will be returned.\\n * @return {module:ol/coordinate~Coordinate} Coordinate of the interpolated point.\\n * @api\\n */\\nLineString.prototype.getCoordinateAt = function(fraction, opt_dest) {\\n  return interpolatePoint(\\n    this.flatCoordinates, 0, this.flatCoordinates.length, this.stride,\\n    fraction, opt_dest);\\n};\\n\\n\\n/**\\n * Return the length of the linestring on projected plane.\\n * @return {number} Length (on projected plane).\\n * @api\\n */\\nLineString.prototype.getLength = function() {\\n  return lineStringLength(\\n    this.flatCoordinates, 0, this.flatCoordinates.length, this.stride);\\n};\\n\\n\\n/**\\n * @return {Array.<number>} Flat midpoint.\\n */\\nLineString.prototype.getFlatMidpoint = function() {\\n  if (this.flatMidpointRevision_ != this.getRevision()) {\\n    this.flatMidpoint_ = this.getCoordinateAt(0.5, this.flatMidpoint_);\\n    this.flatMidpointRevision_ = this.getRevision();\\n  }\\n  return this.flatMidpoint_;\\n};\\n\\n\\n/**\\n * @inheritDoc\\n */\\nLineString.prototype.getSimplifiedGeometryInternal = function(squaredTolerance) {\\n  const simplifiedFlatCoordinates = [];\\n  simplifiedFlatCoordinates.length = douglasPeucker(\\n    this.flatCoordinates, 0, this.flatCoordinates.length, this.stride,\\n    squaredTolerance, simplifiedFlatCoordinates, 0);\\n  const simplifiedLineString = new LineString(null);\\n  simplifiedLineString.setFlatCoordinates(\\n    GeometryLayout.XY, simplifiedFlatCoordinates);\\n  return simplifiedLineString;\\n};\\n\\n\\n/**\\n * @inheritDoc\\n * @api\\n */\\nLineString.prototype.getType = function() {\\n  return GeometryType.LINE_STRING;\\n};\\n\\n\\n/**\\n * @inheritDoc\\n * @api\\n */\\nLineString.prototype.intersectsExtent = function(extent) {\\n  return intersectsLineString(\\n    this.flatCoordinates, 0, this.flatCoordinates.length, this.stride,\\n    extent);\\n};\\n\\n\\n/**\\n * Set the coordinates of the linestring.\\n * @param {Array.<module:ol/coordinate~Coordinate>} coordinates Coordinates.\\n * @param {module:ol/geom/GeometryLayout=} opt_layout Layout.\\n * @override\\n * @api\\n */\\nLineString.prototype.setCoordinates = function(coordinates, opt_layout) {\\n  if (!coordinates) {\\n    this.setFlatCoordinates(GeometryLayout.XY, null);\\n  } else {\\n    this.setLayout(opt_layout, coordinates, 1);\\n    if (!this.flatCoordinates) {\\n      this.flatCoordinates = [];\\n    }\\n    this.flatCoordinates.length = deflateCoordinates(\\n      this.flatCoordinates, 0, coordinates, this.stride);\\n    this.changed();\\n  }\\n};\\n\\n\\n/**\\n * @param {module:ol/geom/GeometryLayout} layout Layout.\\n * @param {Array.<number>} flatCoordinates Flat coordinates.\\n */\\nLineString.prototype.setFlatCoordinates = function(layout, flatCoordinates) {\\n  this.setFlatCoordinatesInternal(layout, flatCoordinates);\\n  this.changed();\\n};\\nexport default LineString;\\n\",\"/**\\n * @module ol/geom/MultiLineString\\n */\\nimport {inherits} from '../index.js';\\nimport {extend} from '../array.js';\\nimport {closestSquaredDistanceXY} from '../extent.js';\\nimport GeometryLayout from '../geom/GeometryLayout.js';\\nimport GeometryType from '../geom/GeometryType.js';\\nimport LineString from '../geom/LineString.js';\\nimport SimpleGeometry from '../geom/SimpleGeometry.js';\\nimport {assignClosestArrayPoint, arrayMaxSquaredDelta} from '../geom/flat/closest.js';\\nimport {deflateCoordinatesArray} from '../geom/flat/deflate.js';\\nimport {inflateCoordinatesArray} from '../geom/flat/inflate.js';\\nimport {interpolatePoint, lineStringsCoordinateAtM} from '../geom/flat/interpolate.js';\\nimport {intersectsLineStringArray} from '../geom/flat/intersectsextent.js';\\nimport {douglasPeuckerArray} from '../geom/flat/simplify.js';\\n\\n/**\\n * @classdesc\\n * Multi-linestring geometry.\\n *\\n * @constructor\\n * @extends {module:ol/geom/SimpleGeometry}\\n * @param {Array.<Array.<module:ol/coordinate~Coordinate>>} coordinates Coordinates.\\n * @param {module:ol/geom/GeometryLayout=} opt_layout Layout.\\n * @api\\n */\\nconst MultiLineString = function(coordinates, opt_layout) {\\n\\n  SimpleGeometry.call(this);\\n\\n  /**\\n   * @type {Array.<number>}\\n   * @private\\n   */\\n  this.ends_ = [];\\n\\n  /**\\n   * @private\\n   * @type {number}\\n   */\\n  this.maxDelta_ = -1;\\n\\n  /**\\n   * @private\\n   * @type {number}\\n   */\\n  this.maxDeltaRevision_ = -1;\\n\\n  this.setCoordinates(coordinates, opt_layout);\\n\\n};\\n\\ninherits(MultiLineString, SimpleGeometry);\\n\\n\\n/**\\n * Append the passed linestring to the multilinestring.\\n * @param {module:ol/geom/LineString} lineString LineString.\\n * @api\\n */\\nMultiLineString.prototype.appendLineString = function(lineString) {\\n  if (!this.flatCoordinates) {\\n    this.flatCoordinates = lineString.getFlatCoordinates().slice();\\n  } else {\\n    extend(this.flatCoordinates, lineString.getFlatCoordinates().slice());\\n  }\\n  this.ends_.push(this.flatCoordinates.length);\\n  this.changed();\\n};\\n\\n\\n/**\\n * Make a complete copy of the geometry.\\n * @return {!module:ol/geom/MultiLineString} Clone.\\n * @override\\n * @api\\n */\\nMultiLineString.prototype.clone = function() {\\n  const multiLineString = new MultiLineString(null);\\n  multiLineString.setFlatCoordinates(\\n    this.layout, this.flatCoordinates.slice(), this.ends_.slice());\\n  return multiLineString;\\n};\\n\\n\\n/**\\n * @inheritDoc\\n */\\nMultiLineString.prototype.closestPointXY = function(x, y, closestPoint, minSquaredDistance) {\\n  if (minSquaredDistance < closestSquaredDistanceXY(this.getExtent(), x, y)) {\\n    return minSquaredDistance;\\n  }\\n  if (this.maxDeltaRevision_ != this.getRevision()) {\\n    this.maxDelta_ = Math.sqrt(arrayMaxSquaredDelta(\\n      this.flatCoordinates, 0, this.ends_, this.stride, 0));\\n    this.maxDeltaRevision_ = this.getRevision();\\n  }\\n  return assignClosestArrayPoint(\\n    this.flatCoordinates, 0, this.ends_, this.stride,\\n    this.maxDelta_, false, x, y, closestPoint, minSquaredDistance);\\n};\\n\\n\\n/**\\n * Returns the coordinate at `m` using linear interpolation, or `null` if no\\n * such coordinate exists.\\n *\\n * `opt_extrapolate` controls extrapolation beyond the range of Ms in the\\n * MultiLineString. If `opt_extrapolate` is `true` then Ms less than the first\\n * M will return the first coordinate and Ms greater than the last M will\\n * return the last coordinate.\\n *\\n * `opt_interpolate` controls interpolation between consecutive LineStrings\\n * within the MultiLineString. If `opt_interpolate` is `true` the coordinates\\n * will be linearly interpolated between the last coordinate of one LineString\\n * and the first coordinate of the next LineString.  If `opt_interpolate` is\\n * `false` then the function will return `null` for Ms falling between\\n * LineStrings.\\n *\\n * @param {number} m M.\\n * @param {boolean=} opt_extrapolate Extrapolate. Default is `false`.\\n * @param {boolean=} opt_interpolate Interpolate. Default is `false`.\\n * @return {module:ol/coordinate~Coordinate} Coordinate.\\n * @api\\n */\\nMultiLineString.prototype.getCoordinateAtM = function(m, opt_extrapolate, opt_interpolate) {\\n  if ((this.layout != GeometryLayout.XYM &&\\n       this.layout != GeometryLayout.XYZM) ||\\n      this.flatCoordinates.length === 0) {\\n    return null;\\n  }\\n  const extrapolate = opt_extrapolate !== undefined ? opt_extrapolate : false;\\n  const interpolate = opt_interpolate !== undefined ? opt_interpolate : false;\\n  return lineStringsCoordinateAtM(this.flatCoordinates, 0,\\n    this.ends_, this.stride, m, extrapolate, interpolate);\\n};\\n\\n\\n/**\\n * Return the coordinates of the multilinestring.\\n * @return {Array.<Array.<module:ol/coordinate~Coordinate>>} Coordinates.\\n * @override\\n * @api\\n */\\nMultiLineString.prototype.getCoordinates = function() {\\n  return inflateCoordinatesArray(\\n    this.flatCoordinates, 0, this.ends_, this.stride);\\n};\\n\\n\\n/**\\n * @return {Array.<number>} Ends.\\n */\\nMultiLineString.prototype.getEnds = function() {\\n  return this.ends_;\\n};\\n\\n\\n/**\\n * Return the linestring at the specified index.\\n * @param {number} index Index.\\n * @return {module:ol/geom/LineString} LineString.\\n * @api\\n */\\nMultiLineString.prototype.getLineString = function(index) {\\n  if (index < 0 || this.ends_.length <= index) {\\n    return null;\\n  }\\n  const lineString = new LineString(null);\\n  lineString.setFlatCoordinates(this.layout, this.flatCoordinates.slice(\\n    index === 0 ? 0 : this.ends_[index - 1], this.ends_[index]));\\n  return lineString;\\n};\\n\\n\\n/**\\n * Return the linestrings of this multilinestring.\\n * @return {Array.<module:ol/geom/LineString>} LineStrings.\\n * @api\\n */\\nMultiLineString.prototype.getLineStrings = function() {\\n  const flatCoordinates = this.flatCoordinates;\\n  const ends = this.ends_;\\n  const layout = this.layout;\\n  /** @type {Array.<module:ol/geom/LineString>} */\\n  const lineStrings = [];\\n  let offset = 0;\\n  for (let i = 0, ii = ends.length; i < ii; ++i) {\\n    const end = ends[i];\\n    const lineString = new LineString(null);\\n    lineString.setFlatCoordinates(layout, flatCoordinates.slice(offset, end));\\n    lineStrings.push(lineString);\\n    offset = end;\\n  }\\n  return lineStrings;\\n};\\n\\n\\n/**\\n * @return {Array.<number>} Flat midpoints.\\n */\\nMultiLineString.prototype.getFlatMidpoints = function() {\\n  const midpoints = [];\\n  const flatCoordinates = this.flatCoordinates;\\n  let offset = 0;\\n  const ends = this.ends_;\\n  const stride = this.stride;\\n  for (let i = 0, ii = ends.length; i < ii; ++i) {\\n    const end = ends[i];\\n    const midpoint = interpolatePoint(\\n      flatCoordinates, offset, end, stride, 0.5);\\n    extend(midpoints, midpoint);\\n    offset = end;\\n  }\\n  return midpoints;\\n};\\n\\n\\n/**\\n * @inheritDoc\\n */\\nMultiLineString.prototype.getSimplifiedGeometryInternal = function(squaredTolerance) {\\n  const simplifiedFlatCoordinates = [];\\n  const simplifiedEnds = [];\\n  simplifiedFlatCoordinates.length = douglasPeuckerArray(\\n    this.flatCoordinates, 0, this.ends_, this.stride, squaredTolerance,\\n    simplifiedFlatCoordinates, 0, simplifiedEnds);\\n  const simplifiedMultiLineString = new MultiLineString(null);\\n  simplifiedMultiLineString.setFlatCoordinates(\\n    GeometryLayout.XY, simplifiedFlatCoordinates, simplifiedEnds);\\n  return simplifiedMultiLineString;\\n};\\n\\n\\n/**\\n * @inheritDoc\\n * @api\\n */\\nMultiLineString.prototype.getType = function() {\\n  return GeometryType.MULTI_LINE_STRING;\\n};\\n\\n\\n/**\\n * @inheritDoc\\n * @api\\n */\\nMultiLineString.prototype.intersectsExtent = function(extent) {\\n  return intersectsLineStringArray(\\n    this.flatCoordinates, 0, this.ends_, this.stride, extent);\\n};\\n\\n\\n/**\\n * Set the coordinates of the multilinestring.\\n * @param {Array.<Array.<module:ol/coordinate~Coordinate>>} coordinates Coordinates.\\n * @param {module:ol/geom/GeometryLayout=} opt_layout Layout.\\n * @override\\n * @api\\n */\\nMultiLineString.prototype.setCoordinates = function(coordinates, opt_layout) {\\n  if (!coordinates) {\\n    this.setFlatCoordinates(GeometryLayout.XY, null, this.ends_);\\n  } else {\\n    this.setLayout(opt_layout, coordinates, 2);\\n    if (!this.flatCoordinates) {\\n      this.flatCoordinates = [];\\n    }\\n    const ends = deflateCoordinatesArray(\\n      this.flatCoordinates, 0, coordinates, this.stride, this.ends_);\\n    this.flatCoordinates.length = ends.length === 0 ? 0 : ends[ends.length - 1];\\n    this.changed();\\n  }\\n};\\n\\n\\n/**\\n * @param {module:ol/geom/GeometryLayout} layout Layout.\\n * @param {Array.<number>} flatCoordinates Flat coordinates.\\n * @param {Array.<number>} ends Ends.\\n */\\nMultiLineString.prototype.setFlatCoordinates = function(layout, flatCoordinates, ends) {\\n  this.setFlatCoordinatesInternal(layout, flatCoordinates);\\n  this.ends_ = ends;\\n  this.changed();\\n};\\n\\n\\n/**\\n * @param {Array.<module:ol/geom/LineString>} lineStrings LineStrings.\\n */\\nMultiLineString.prototype.setLineStrings = function(lineStrings) {\\n  let layout = this.getLayout();\\n  const flatCoordinates = [];\\n  const ends = [];\\n  for (let i = 0, ii = lineStrings.length; i < ii; ++i) {\\n    const lineString = lineStrings[i];\\n    if (i === 0) {\\n      layout = lineString.getLayout();\\n    }\\n    extend(flatCoordinates, lineString.getFlatCoordinates());\\n    ends.push(flatCoordinates.length);\\n  }\\n  this.setFlatCoordinates(layout, flatCoordinates, ends);\\n};\\nexport default MultiLineString;\\n\",\"/**\\n * @module ol/geom/Point\\n */\\nimport {inherits} from '../index.js';\\nimport {createOrUpdateFromCoordinate, containsXY} from '../extent.js';\\nimport GeometryLayout from '../geom/GeometryLayout.js';\\nimport GeometryType from '../geom/GeometryType.js';\\nimport SimpleGeometry from '../geom/SimpleGeometry.js';\\nimport {deflateCoordinate} from '../geom/flat/deflate.js';\\nimport {squaredDistance as squaredDx} from '../math.js';\\n\\n/**\\n * @classdesc\\n * Point geometry.\\n *\\n * @constructor\\n * @extends {module:ol/geom/SimpleGeometry}\\n * @param {module:ol/coordinate~Coordinate} coordinates Coordinates.\\n * @param {module:ol/geom/GeometryLayout=} opt_layout Layout.\\n * @api\\n */\\nconst Point = function(coordinates, opt_layout) {\\n  SimpleGeometry.call(this);\\n  this.setCoordinates(coordinates, opt_layout);\\n};\\n\\ninherits(Point, SimpleGeometry);\\n\\n\\n/**\\n * Make a complete copy of the geometry.\\n * @return {!module:ol/geom/Point} Clone.\\n * @override\\n * @api\\n */\\nPoint.prototype.clone = function() {\\n  const point = new Point(null);\\n  point.setFlatCoordinates(this.layout, this.flatCoordinates.slice());\\n  return point;\\n};\\n\\n\\n/**\\n * @inheritDoc\\n */\\nPoint.prototype.closestPointXY = function(x, y, closestPoint, minSquaredDistance) {\\n  const flatCoordinates = this.flatCoordinates;\\n  const squaredDistance = squaredDx(x, y, flatCoordinates[0], flatCoordinates[1]);\\n  if (squaredDistance < minSquaredDistance) {\\n    const stride = this.stride;\\n    for (let i = 0; i < stride; ++i) {\\n      closestPoint[i] = flatCoordinates[i];\\n    }\\n    closestPoint.length = stride;\\n    return squaredDistance;\\n  } else {\\n    return minSquaredDistance;\\n  }\\n};\\n\\n\\n/**\\n * Return the coordinate of the point.\\n * @return {module:ol/coordinate~Coordinate} Coordinates.\\n * @override\\n * @api\\n */\\nPoint.prototype.getCoordinates = function() {\\n  return !this.flatCoordinates ? [] : this.flatCoordinates.slice();\\n};\\n\\n\\n/**\\n * @inheritDoc\\n */\\nPoint.prototype.computeExtent = function(extent) {\\n  return createOrUpdateFromCoordinate(this.flatCoordinates, extent);\\n};\\n\\n\\n/**\\n * @inheritDoc\\n * @api\\n */\\nPoint.prototype.getType = function() {\\n  return GeometryType.POINT;\\n};\\n\\n\\n/**\\n * @inheritDoc\\n * @api\\n */\\nPoint.prototype.intersectsExtent = function(extent) {\\n  return containsXY(extent, this.flatCoordinates[0], this.flatCoordinates[1]);\\n};\\n\\n\\n/**\\n * @inheritDoc\\n * @api\\n */\\nPoint.prototype.setCoordinates = function(coordinates, opt_layout) {\\n  if (!coordinates) {\\n    this.setFlatCoordinates(GeometryLayout.XY, null);\\n  } else {\\n    this.setLayout(opt_layout, coordinates, 0);\\n    if (!this.flatCoordinates) {\\n      this.flatCoordinates = [];\\n    }\\n    this.flatCoordinates.length = deflateCoordinate(\\n      this.flatCoordinates, 0, coordinates, this.stride);\\n    this.changed();\\n  }\\n};\\n\\n\\n/**\\n * @param {module:ol/geom/GeometryLayout} layout Layout.\\n * @param {Array.<number>} flatCoordinates Flat coordinates.\\n */\\nPoint.prototype.setFlatCoordinates = function(layout, flatCoordinates) {\\n  this.setFlatCoordinatesInternal(layout, flatCoordinates);\\n  this.changed();\\n};\\nexport default Point;\\n\",\"/**\\n * @module ol/geom/MultiPoint\\n */\\nimport {inherits} from '../index.js';\\nimport {extend} from '../array.js';\\nimport {closestSquaredDistanceXY, containsXY} from '../extent.js';\\nimport GeometryLayout from '../geom/GeometryLayout.js';\\nimport GeometryType from '../geom/GeometryType.js';\\nimport Point from '../geom/Point.js';\\nimport SimpleGeometry from '../geom/SimpleGeometry.js';\\nimport {deflateCoordinates} from '../geom/flat/deflate.js';\\nimport {inflateCoordinates} from '../geom/flat/inflate.js';\\nimport {squaredDistance as squaredDx} from '../math.js';\\n\\n/**\\n * @classdesc\\n * Multi-point geometry.\\n *\\n * @constructor\\n * @extends {module:ol/geom/SimpleGeometry}\\n * @param {Array.<module:ol/coordinate~Coordinate>} coordinates Coordinates.\\n * @param {module:ol/geom/GeometryLayout=} opt_layout Layout.\\n * @api\\n */\\nconst MultiPoint = function(coordinates, opt_layout) {\\n  SimpleGeometry.call(this);\\n  this.setCoordinates(coordinates, opt_layout);\\n};\\n\\ninherits(MultiPoint, SimpleGeometry);\\n\\n\\n/**\\n * Append the passed point to this multipoint.\\n * @param {module:ol/geom/Point} point Point.\\n * @api\\n */\\nMultiPoint.prototype.appendPoint = function(point) {\\n  if (!this.flatCoordinates) {\\n    this.flatCoordinates = point.getFlatCoordinates().slice();\\n  } else {\\n    extend(this.flatCoordinates, point.getFlatCoordinates());\\n  }\\n  this.changed();\\n};\\n\\n\\n/**\\n * Make a complete copy of the geometry.\\n * @return {!module:ol/geom/MultiPoint} Clone.\\n * @override\\n * @api\\n */\\nMultiPoint.prototype.clone = function() {\\n  const multiPoint = new MultiPoint(null);\\n  multiPoint.setFlatCoordinates(this.layout, this.flatCoordinates.slice());\\n  return multiPoint;\\n};\\n\\n\\n/**\\n * @inheritDoc\\n */\\nMultiPoint.prototype.closestPointXY = function(x, y, closestPoint, minSquaredDistance) {\\n  if (minSquaredDistance < closestSquaredDistanceXY(this.getExtent(), x, y)) {\\n    return minSquaredDistance;\\n  }\\n  const flatCoordinates = this.flatCoordinates;\\n  const stride = this.stride;\\n  for (let i = 0, ii = flatCoordinates.length; i < ii; i += stride) {\\n    const squaredDistance = squaredDx(\\n      x, y, flatCoordinates[i], flatCoordinates[i + 1]);\\n    if (squaredDistance < minSquaredDistance) {\\n      minSquaredDistance = squaredDistance;\\n      for (let j = 0; j < stride; ++j) {\\n        closestPoint[j] = flatCoordinates[i + j];\\n      }\\n      closestPoint.length = stride;\\n    }\\n  }\\n  return minSquaredDistance;\\n};\\n\\n\\n/**\\n * Return the coordinates of the multipoint.\\n * @return {Array.<module:ol/coordinate~Coordinate>} Coordinates.\\n * @override\\n * @api\\n */\\nMultiPoint.prototype.getCoordinates = function() {\\n  return inflateCoordinates(\\n    this.flatCoordinates, 0, this.flatCoordinates.length, this.stride);\\n};\\n\\n\\n/**\\n * Return the point at the specified index.\\n * @param {number} index Index.\\n * @return {module:ol/geom/Point} Point.\\n * @api\\n */\\nMultiPoint.prototype.getPoint = function(index) {\\n  const n = !this.flatCoordinates ? 0 : this.flatCoordinates.length / this.stride;\\n  if (index < 0 || n <= index) {\\n    return null;\\n  }\\n  const point = new Point(null);\\n  point.setFlatCoordinates(this.layout, this.flatCoordinates.slice(\\n    index * this.stride, (index + 1) * this.stride));\\n  return point;\\n};\\n\\n\\n/**\\n * Return the points of this multipoint.\\n * @return {Array.<module:ol/geom/Point>} Points.\\n * @api\\n */\\nMultiPoint.prototype.getPoints = function() {\\n  const flatCoordinates = this.flatCoordinates;\\n  const layout = this.layout;\\n  const stride = this.stride;\\n  /** @type {Array.<module:ol/geom/Point>} */\\n  const points = [];\\n  for (let i = 0, ii = flatCoordinates.length; i < ii; i += stride) {\\n    const point = new Point(null);\\n    point.setFlatCoordinates(layout, flatCoordinates.slice(i, i + stride));\\n    points.push(point);\\n  }\\n  return points;\\n};\\n\\n\\n/**\\n * @inheritDoc\\n * @api\\n */\\nMultiPoint.prototype.getType = function() {\\n  return GeometryType.MULTI_POINT;\\n};\\n\\n\\n/**\\n * @inheritDoc\\n * @api\\n */\\nMultiPoint.prototype.intersectsExtent = function(extent) {\\n  const flatCoordinates = this.flatCoordinates;\\n  const stride = this.stride;\\n  for (let i = 0, ii = flatCoordinates.length; i < ii; i += stride) {\\n    const x = flatCoordinates[i];\\n    const y = flatCoordinates[i + 1];\\n    if (containsXY(extent, x, y)) {\\n      return true;\\n    }\\n  }\\n  return false;\\n};\\n\\n\\n/**\\n * Set the coordinates of the multipoint.\\n * @param {Array.<module:ol/coordinate~Coordinate>} coordinates Coordinates.\\n * @param {module:ol/geom/GeometryLayout=} opt_layout Layout.\\n * @override\\n * @api\\n */\\nMultiPoint.prototype.setCoordinates = function(coordinates, opt_layout) {\\n  if (!coordinates) {\\n    this.setFlatCoordinates(GeometryLayout.XY, null);\\n  } else {\\n    this.setLayout(opt_layout, coordinates, 1);\\n    if (!this.flatCoordinates) {\\n      this.flatCoordinates = [];\\n    }\\n    this.flatCoordinates.length = deflateCoordinates(\\n      this.flatCoordinates, 0, coordinates, this.stride);\\n    this.changed();\\n  }\\n};\\n\\n\\n/**\\n * @param {module:ol/geom/GeometryLayout} layout Layout.\\n * @param {Array.<number>} flatCoordinates Flat coordinates.\\n */\\nMultiPoint.prototype.setFlatCoordinates = function(layout, flatCoordinates) {\\n  this.setFlatCoordinatesInternal(layout, flatCoordinates);\\n  this.changed();\\n};\\nexport default MultiPoint;\\n\",\"/**\\n * @module ol/geom/flat/area\\n */\\n\\n\\n/**\\n * @param {Array.<number>} flatCoordinates Flat coordinates.\\n * @param {number} offset Offset.\\n * @param {number} end End.\\n * @param {number} stride Stride.\\n * @return {number} Area.\\n */\\nexport function linearRing(flatCoordinates, offset, end, stride) {\\n  let twiceArea = 0;\\n  let x1 = flatCoordinates[end - stride];\\n  let y1 = flatCoordinates[end - stride + 1];\\n  for (; offset < end; offset += stride) {\\n    const x2 = flatCoordinates[offset];\\n    const y2 = flatCoordinates[offset + 1];\\n    twiceArea += y1 * x2 - x1 * y2;\\n    x1 = x2;\\n    y1 = y2;\\n  }\\n  return twiceArea / 2;\\n}\\n\\n\\n/**\\n * @param {Array.<number>} flatCoordinates Flat coordinates.\\n * @param {number} offset Offset.\\n * @param {Array.<number>} ends Ends.\\n * @param {number} stride Stride.\\n * @return {number} Area.\\n */\\nexport function linearRings(flatCoordinates, offset, ends, stride) {\\n  let area = 0;\\n  for (let i = 0, ii = ends.length; i < ii; ++i) {\\n    const end = ends[i];\\n    area += linearRing(flatCoordinates, offset, end, stride);\\n    offset = end;\\n  }\\n  return area;\\n}\\n\\n\\n/**\\n * @param {Array.<number>} flatCoordinates Flat coordinates.\\n * @param {number} offset Offset.\\n * @param {Array.<Array.<number>>} endss Endss.\\n * @param {number} stride Stride.\\n * @return {number} Area.\\n */\\nexport function linearRingss(flatCoordinates, offset, endss, stride) {\\n  let area = 0;\\n  for (let i = 0, ii = endss.length; i < ii; ++i) {\\n    const ends = endss[i];\\n    area += linearRings(flatCoordinates, offset, ends, stride);\\n    offset = ends[ends.length - 1];\\n  }\\n  return area;\\n}\\n\",\"/**\\n * @module ol/geom/LinearRing\\n */\\nimport {inherits} from '../index.js';\\nimport {closestSquaredDistanceXY} from '../extent.js';\\nimport GeometryLayout from '../geom/GeometryLayout.js';\\nimport GeometryType from '../geom/GeometryType.js';\\nimport SimpleGeometry from '../geom/SimpleGeometry.js';\\nimport {linearRing as linearRingArea} from '../geom/flat/area.js';\\nimport {assignClosestPoint, maxSquaredDelta} from '../geom/flat/closest.js';\\nimport {deflateCoordinates} from '../geom/flat/deflate.js';\\nimport {inflateCoordinates} from '../geom/flat/inflate.js';\\nimport {douglasPeucker} from '../geom/flat/simplify.js';\\n\\n/**\\n * @classdesc\\n * Linear ring geometry. Only used as part of polygon; cannot be rendered\\n * on its own.\\n *\\n * @constructor\\n * @extends {module:ol/geom/SimpleGeometry}\\n * @param {Array.<module:ol/coordinate~Coordinate>} coordinates Coordinates.\\n * @param {module:ol/geom/GeometryLayout=} opt_layout Layout.\\n * @api\\n */\\nconst LinearRing = function(coordinates, opt_layout) {\\n\\n  SimpleGeometry.call(this);\\n\\n  /**\\n   * @private\\n   * @type {number}\\n   */\\n  this.maxDelta_ = -1;\\n\\n  /**\\n   * @private\\n   * @type {number}\\n   */\\n  this.maxDeltaRevision_ = -1;\\n\\n  this.setCoordinates(coordinates, opt_layout);\\n\\n};\\n\\ninherits(LinearRing, SimpleGeometry);\\n\\n\\n/**\\n * Make a complete copy of the geometry.\\n * @return {!module:ol/geom/LinearRing} Clone.\\n * @override\\n * @api\\n */\\nLinearRing.prototype.clone = function() {\\n  const linearRing = new LinearRing(null);\\n  linearRing.setFlatCoordinates(this.layout, this.flatCoordinates.slice());\\n  return linearRing;\\n};\\n\\n\\n/**\\n * @inheritDoc\\n */\\nLinearRing.prototype.closestPointXY = function(x, y, closestPoint, minSquaredDistance) {\\n  if (minSquaredDistance < closestSquaredDistanceXY(this.getExtent(), x, y)) {\\n    return minSquaredDistance;\\n  }\\n  if (this.maxDeltaRevision_ != this.getRevision()) {\\n    this.maxDelta_ = Math.sqrt(maxSquaredDelta(\\n      this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, 0));\\n    this.maxDeltaRevision_ = this.getRevision();\\n  }\\n  return assignClosestPoint(\\n    this.flatCoordinates, 0, this.flatCoordinates.length, this.stride,\\n    this.maxDelta_, true, x, y, closestPoint, minSquaredDistance);\\n};\\n\\n\\n/**\\n * Return the area of the linear ring on projected plane.\\n * @return {number} Area (on projected plane).\\n * @api\\n */\\nLinearRing.prototype.getArea = function() {\\n  return linearRingArea(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride);\\n};\\n\\n\\n/**\\n * Return the coordinates of the linear ring.\\n * @return {Array.<module:ol/coordinate~Coordinate>} Coordinates.\\n * @override\\n * @api\\n */\\nLinearRing.prototype.getCoordinates = function() {\\n  return inflateCoordinates(\\n    this.flatCoordinates, 0, this.flatCoordinates.length, this.stride);\\n};\\n\\n\\n/**\\n * @inheritDoc\\n */\\nLinearRing.prototype.getSimplifiedGeometryInternal = function(squaredTolerance) {\\n  const simplifiedFlatCoordinates = [];\\n  simplifiedFlatCoordinates.length = douglasPeucker(\\n    this.flatCoordinates, 0, this.flatCoordinates.length, this.stride,\\n    squaredTolerance, simplifiedFlatCoordinates, 0);\\n  const simplifiedLinearRing = new LinearRing(null);\\n  simplifiedLinearRing.setFlatCoordinates(\\n    GeometryLayout.XY, simplifiedFlatCoordinates);\\n  return simplifiedLinearRing;\\n};\\n\\n\\n/**\\n * @inheritDoc\\n * @api\\n */\\nLinearRing.prototype.getType = function() {\\n  return GeometryType.LINEAR_RING;\\n};\\n\\n\\n/**\\n * @inheritDoc\\n */\\nLinearRing.prototype.intersectsExtent = function(extent) {};\\n\\n\\n/**\\n * Set the coordinates of the linear ring.\\n * @param {Array.<module:ol/coordinate~Coordinate>} coordinates Coordinates.\\n * @param {module:ol/geom/GeometryLayout=} opt_layout Layout.\\n * @override\\n * @api\\n */\\nLinearRing.prototype.setCoordinates = function(coordinates, opt_layout) {\\n  if (!coordinates) {\\n    this.setFlatCoordinates(GeometryLayout.XY, null);\\n  } else {\\n    this.setLayout(opt_layout, coordinates, 1);\\n    if (!this.flatCoordinates) {\\n      this.flatCoordinates = [];\\n    }\\n    this.flatCoordinates.length = deflateCoordinates(\\n      this.flatCoordinates, 0, coordinates, this.stride);\\n    this.changed();\\n  }\\n};\\n\\n\\n/**\\n * @param {module:ol/geom/GeometryLayout} layout Layout.\\n * @param {Array.<number>} flatCoordinates Flat coordinates.\\n */\\nLinearRing.prototype.setFlatCoordinates = function(layout, flatCoordinates) {\\n  this.setFlatCoordinatesInternal(layout, flatCoordinates);\\n  this.changed();\\n};\\nexport default LinearRing;\\n\",\"/**\\n * @module ol/geom/flat/interiorpoint\\n */\\nimport {numberSafeCompareFunction} from '../../array.js';\\nimport {linearRingsContainsXY} from '../flat/contains.js';\\n\\n\\n/**\\n * Calculates a point that is likely to lie in the interior of the linear rings.\\n * Inspired by JTS's com.vividsolutions.jts.geom.Geometry#getInteriorPoint.\\n * @param {Array.<number>} flatCoordinates Flat coordinates.\\n * @param {number} offset Offset.\\n * @param {Array.<number>} ends Ends.\\n * @param {number} stride Stride.\\n * @param {Array.<number>} flatCenters Flat centers.\\n * @param {number} flatCentersOffset Flat center offset.\\n * @param {Array.<number>=} opt_dest Destination.\\n * @return {Array.<number>} Destination point as XYM coordinate, where M is the\\n * length of the horizontal intersection that the point belongs to.\\n */\\nexport function getInteriorPointOfArray(flatCoordinates, offset,\\n  ends, stride, flatCenters, flatCentersOffset, opt_dest) {\\n  let i, ii, x, x1, x2, y1, y2;\\n  const y = flatCenters[flatCentersOffset + 1];\\n  /** @type {Array.<number>} */\\n  const intersections = [];\\n  // Calculate intersections with the horizontal line\\n  for (let r = 0, rr = ends.length; r < rr; ++r) {\\n    const end = ends[r];\\n    x1 = flatCoordinates[end - stride];\\n    y1 = flatCoordinates[end - stride + 1];\\n    for (i = offset; i < end; i += stride) {\\n      x2 = flatCoordinates[i];\\n      y2 = flatCoordinates[i + 1];\\n      if ((y <= y1 && y2 <= y) || (y1 <= y && y <= y2)) {\\n        x = (y - y1) / (y2 - y1) * (x2 - x1) + x1;\\n        intersections.push(x);\\n      }\\n      x1 = x2;\\n      y1 = y2;\\n    }\\n  }\\n  // Find the longest segment of the horizontal line that has its center point\\n  // inside the linear ring.\\n  let pointX = NaN;\\n  let maxSegmentLength = -Infinity;\\n  intersections.sort(numberSafeCompareFunction);\\n  x1 = intersections[0];\\n  for (i = 1, ii = intersections.length; i < ii; ++i) {\\n    x2 = intersections[i];\\n    const segmentLength = Math.abs(x2 - x1);\\n    if (segmentLength > maxSegmentLength) {\\n      x = (x1 + x2) / 2;\\n      if (linearRingsContainsXY(flatCoordinates, offset, ends, stride, x, y)) {\\n        pointX = x;\\n        maxSegmentLength = segmentLength;\\n      }\\n    }\\n    x1 = x2;\\n  }\\n  if (isNaN(pointX)) {\\n    // There is no horizontal line that has its center point inside the linear\\n    // ring.  Use the center of the the linear ring's extent.\\n    pointX = flatCenters[flatCentersOffset];\\n  }\\n  if (opt_dest) {\\n    opt_dest.push(pointX, y, maxSegmentLength);\\n    return opt_dest;\\n  } else {\\n    return [pointX, y, maxSegmentLength];\\n  }\\n}\\n\\n\\n/**\\n * @param {Array.<number>} flatCoordinates Flat coordinates.\\n * @param {number} offset Offset.\\n * @param {Array.<Array.<number>>} endss Endss.\\n * @param {number} stride Stride.\\n * @param {Array.<number>} flatCenters Flat centers.\\n * @return {Array.<number>} Interior points as XYM coordinates, where M is the\\n * length of the horizontal intersection that the point belongs to.\\n */\\nexport function getInteriorPointsOfMultiArray(flatCoordinates, offset, endss, stride, flatCenters) {\\n  let interiorPoints = [];\\n  for (let i = 0, ii = endss.length; i < ii; ++i) {\\n    const ends = endss[i];\\n    interiorPoints = getInteriorPointOfArray(flatCoordinates,\\n      offset, ends, stride, flatCenters, 2 * i, interiorPoints);\\n    offset = ends[ends.length - 1];\\n  }\\n  return interiorPoints;\\n}\\n\",\"/**\\n * @module ol/geom/flat/reverse\\n */\\n\\n\\n/**\\n * @param {Array.<number>} flatCoordinates Flat coordinates.\\n * @param {number} offset Offset.\\n * @param {number} end End.\\n * @param {number} stride Stride.\\n */\\nexport function coordinates(flatCoordinates, offset, end, stride) {\\n  while (offset < end - stride) {\\n    for (let i = 0; i < stride; ++i) {\\n      const tmp = flatCoordinates[offset + i];\\n      flatCoordinates[offset + i] = flatCoordinates[end - stride + i];\\n      flatCoordinates[end - stride + i] = tmp;\\n    }\\n    offset += stride;\\n    end -= stride;\\n  }\\n}\\n\",\"/**\\n * @module ol/geom/flat/orient\\n */\\nimport {coordinates as reverseCoordinates} from '../flat/reverse.js';\\n\\n\\n/**\\n * @param {Array.<number>} flatCoordinates Flat coordinates.\\n * @param {number} offset Offset.\\n * @param {number} end End.\\n * @param {number} stride Stride.\\n * @return {boolean} Is clockwise.\\n */\\nexport function linearRingIsClockwise(flatCoordinates, offset, end, stride) {\\n  // http://tinyurl.com/clockwise-method\\n  // https://github.com/OSGeo/gdal/blob/trunk/gdal/ogr/ogrlinearring.cpp\\n  let edge = 0;\\n  let x1 = flatCoordinates[end - stride];\\n  let y1 = flatCoordinates[end - stride + 1];\\n  for (; offset < end; offset += stride) {\\n    const x2 = flatCoordinates[offset];\\n    const y2 = flatCoordinates[offset + 1];\\n    edge += (x2 - x1) * (y2 + y1);\\n    x1 = x2;\\n    y1 = y2;\\n  }\\n  return edge > 0;\\n}\\n\\n\\n/**\\n * Determines if linear rings are oriented.  By default, left-hand orientation\\n * is tested (first ring must be clockwise, remaining rings counter-clockwise).\\n * To test for right-hand orientation, use the `opt_right` argument.\\n *\\n * @param {Array.<number>} flatCoordinates Flat coordinates.\\n * @param {number} offset Offset.\\n * @param {Array.<number>} ends Array of end indexes.\\n * @param {number} stride Stride.\\n * @param {boolean=} opt_right Test for right-hand orientation\\n *     (counter-clockwise exterior ring and clockwise interior rings).\\n * @return {boolean} Rings are correctly oriented.\\n */\\nexport function linearRingIsOriented(flatCoordinates, offset, ends, stride, opt_right) {\\n  const right = opt_right !== undefined ? opt_right : false;\\n  for (let i = 0, ii = ends.length; i < ii; ++i) {\\n    const end = ends[i];\\n    const isClockwise = linearRingIsClockwise(\\n      flatCoordinates, offset, end, stride);\\n    if (i === 0) {\\n      if ((right && isClockwise) || (!right && !isClockwise)) {\\n        return false;\\n      }\\n    } else {\\n      if ((right && !isClockwise) || (!right && isClockwise)) {\\n        return false;\\n      }\\n    }\\n    offset = end;\\n  }\\n  return true;\\n}\\n\\n\\n/**\\n * Determines if linear rings are oriented.  By default, left-hand orientation\\n * is tested (first ring must be clockwise, remaining rings counter-clockwise).\\n * To test for right-hand orientation, use the `opt_right` argument.\\n *\\n * @param {Array.<number>} flatCoordinates Flat coordinates.\\n * @param {number} offset Offset.\\n * @param {Array.<Array.<number>>} endss Array of array of end indexes.\\n * @param {number} stride Stride.\\n * @param {boolean=} opt_right Test for right-hand orientation\\n *     (counter-clockwise exterior ring and clockwise interior rings).\\n * @return {boolean} Rings are correctly oriented.\\n */\\nexport function linearRingsAreOriented(flatCoordinates, offset, endss, stride, opt_right) {\\n  for (let i = 0, ii = endss.length; i < ii; ++i) {\\n    if (!linearRingIsOriented(\\n      flatCoordinates, offset, endss[i], stride, opt_right)) {\\n      return false;\\n    }\\n  }\\n  return true;\\n}\\n\\n\\n/**\\n * Orient coordinates in a flat array of linear rings.  By default, rings\\n * are oriented following the left-hand rule (clockwise for exterior and\\n * counter-clockwise for interior rings).  To orient according to the\\n * right-hand rule, use the `opt_right` argument.\\n *\\n * @param {Array.<number>} flatCoordinates Flat coordinates.\\n * @param {number} offset Offset.\\n * @param {Array.<number>} ends Ends.\\n * @param {number} stride Stride.\\n * @param {boolean=} opt_right Follow the right-hand rule for orientation.\\n * @return {number} End.\\n */\\nexport function orientLinearRings(flatCoordinates, offset, ends, stride, opt_right) {\\n  const right = opt_right !== undefined ? opt_right : false;\\n  for (let i = 0, ii = ends.length; i < ii; ++i) {\\n    const end = ends[i];\\n    const isClockwise = linearRingIsClockwise(\\n      flatCoordinates, offset, end, stride);\\n    const reverse = i === 0 ?\\n      (right && isClockwise) || (!right && !isClockwise) :\\n      (right && !isClockwise) || (!right && isClockwise);\\n    if (reverse) {\\n      reverseCoordinates(flatCoordinates, offset, end, stride);\\n    }\\n    offset = end;\\n  }\\n  return offset;\\n}\\n\\n\\n/**\\n * Orient coordinates in a flat array of linear rings.  By default, rings\\n * are oriented following the left-hand rule (clockwise for exterior and\\n * counter-clockwise for interior rings).  To orient according to the\\n * right-hand rule, use the `opt_right` argument.\\n *\\n * @param {Array.<number>} flatCoordinates Flat coordinates.\\n * @param {number} offset Offset.\\n * @param {Array.<Array.<number>>} endss Array of array of end indexes.\\n * @param {number} stride Stride.\\n * @param {boolean=} opt_right Follow the right-hand rule for orientation.\\n * @return {number} End.\\n */\\nexport function orientLinearRingsArray(flatCoordinates, offset, endss, stride, opt_right) {\\n  for (let i = 0, ii = endss.length; i < ii; ++i) {\\n    offset = orientLinearRings(\\n      flatCoordinates, offset, endss[i], stride, opt_right);\\n  }\\n  return offset;\\n}\\n\",\"/**\\n * @module ol/geom/Polygon\\n */\\nimport {inherits} from '../index.js';\\nimport {extend} from '../array.js';\\nimport {closestSquaredDistanceXY, getCenter} from '../extent.js';\\nimport GeometryLayout from '../geom/GeometryLayout.js';\\nimport GeometryType from '../geom/GeometryType.js';\\nimport LinearRing from '../geom/LinearRing.js';\\nimport Point from '../geom/Point.js';\\nimport SimpleGeometry from '../geom/SimpleGeometry.js';\\nimport {offset as sphereOffset} from '../sphere.js';\\nimport {linearRings as linearRingsArea} from '../geom/flat/area.js';\\nimport {assignClosestArrayPoint, arrayMaxSquaredDelta} from '../geom/flat/closest.js';\\nimport {linearRingsContainsXY} from '../geom/flat/contains.js';\\nimport {deflateCoordinatesArray} from '../geom/flat/deflate.js';\\nimport {inflateCoordinatesArray} from '../geom/flat/inflate.js';\\nimport {getInteriorPointOfArray} from '../geom/flat/interiorpoint.js';\\nimport {intersectsLinearRingArray} from '../geom/flat/intersectsextent.js';\\nimport {linearRingIsOriented, orientLinearRings} from '../geom/flat/orient.js';\\nimport {quantizeArray} from '../geom/flat/simplify.js';\\nimport {modulo} from '../math.js';\\n\\n/**\\n * @classdesc\\n * Polygon geometry.\\n *\\n * @constructor\\n * @extends {module:ol/geom/SimpleGeometry}\\n * @param {Array.<Array.<module:ol/coordinate~Coordinate>>} coordinates Array of linear\\n *     rings that define the polygon. The first linear ring of the array\\n *     defines the outer-boundary or surface of the polygon. Each subsequent\\n *     linear ring defines a hole in the surface of the polygon. A linear ring\\n *     is an array of vertices' coordinates where the first coordinate and the\\n *     last are equivalent.\\n * @param {module:ol/geom/GeometryLayout=} opt_layout Layout.\\n * @api\\n */\\nconst Polygon = function(coordinates, opt_layout) {\\n\\n  SimpleGeometry.call(this);\\n\\n  /**\\n   * @type {Array.<number>}\\n   * @private\\n   */\\n  this.ends_ = [];\\n\\n  /**\\n   * @private\\n   * @type {number}\\n   */\\n  this.flatInteriorPointRevision_ = -1;\\n\\n  /**\\n   * @private\\n   * @type {module:ol/coordinate~Coordinate}\\n   */\\n  this.flatInteriorPoint_ = null;\\n\\n  /**\\n   * @private\\n   * @type {number}\\n   */\\n  this.maxDelta_ = -1;\\n\\n  /**\\n   * @private\\n   * @type {number}\\n   */\\n  this.maxDeltaRevision_ = -1;\\n\\n  /**\\n   * @private\\n   * @type {number}\\n   */\\n  this.orientedRevision_ = -1;\\n\\n  /**\\n   * @private\\n   * @type {Array.<number>}\\n   */\\n  this.orientedFlatCoordinates_ = null;\\n\\n  this.setCoordinates(coordinates, opt_layout);\\n\\n};\\n\\ninherits(Polygon, SimpleGeometry);\\n\\n\\n/**\\n * Append the passed linear ring to this polygon.\\n * @param {module:ol/geom/LinearRing} linearRing Linear ring.\\n * @api\\n */\\nPolygon.prototype.appendLinearRing = function(linearRing) {\\n  if (!this.flatCoordinates) {\\n    this.flatCoordinates = linearRing.getFlatCoordinates().slice();\\n  } else {\\n    extend(this.flatCoordinates, linearRing.getFlatCoordinates());\\n  }\\n  this.ends_.push(this.flatCoordinates.length);\\n  this.changed();\\n};\\n\\n\\n/**\\n * Make a complete copy of the geometry.\\n * @return {!module:ol/geom/Polygon} Clone.\\n * @override\\n * @api\\n */\\nPolygon.prototype.clone = function() {\\n  const polygon = new Polygon(null);\\n  polygon.setFlatCoordinates(\\n    this.layout, this.flatCoordinates.slice(), this.ends_.slice());\\n  return polygon;\\n};\\n\\n\\n/**\\n * @inheritDoc\\n */\\nPolygon.prototype.closestPointXY = function(x, y, closestPoint, minSquaredDistance) {\\n  if (minSquaredDistance < closestSquaredDistanceXY(this.getExtent(), x, y)) {\\n    return minSquaredDistance;\\n  }\\n  if (this.maxDeltaRevision_ != this.getRevision()) {\\n    this.maxDelta_ = Math.sqrt(arrayMaxSquaredDelta(\\n      this.flatCoordinates, 0, this.ends_, this.stride, 0));\\n    this.maxDeltaRevision_ = this.getRevision();\\n  }\\n  return assignClosestArrayPoint(\\n    this.flatCoordinates, 0, this.ends_, this.stride,\\n    this.maxDelta_, true, x, y, closestPoint, minSquaredDistance);\\n};\\n\\n\\n/**\\n * @inheritDoc\\n */\\nPolygon.prototype.containsXY = function(x, y) {\\n  return linearRingsContainsXY(this.getOrientedFlatCoordinates(), 0, this.ends_, this.stride, x, y);\\n};\\n\\n\\n/**\\n * Return the area of the polygon on projected plane.\\n * @return {number} Area (on projected plane).\\n * @api\\n */\\nPolygon.prototype.getArea = function() {\\n  return linearRingsArea(this.getOrientedFlatCoordinates(), 0, this.ends_, this.stride);\\n};\\n\\n\\n/**\\n * Get the coordinate array for this geometry.  This array has the structure\\n * of a GeoJSON coordinate array for polygons.\\n *\\n * @param {boolean=} opt_right Orient coordinates according to the right-hand\\n *     rule (counter-clockwise for exterior and clockwise for interior rings).\\n *     If `false`, coordinates will be oriented according to the left-hand rule\\n *     (clockwise for exterior and counter-clockwise for interior rings).\\n *     By default, coordinate orientation will depend on how the geometry was\\n *     constructed.\\n * @return {Array.<Array.<module:ol/coordinate~Coordinate>>} Coordinates.\\n * @override\\n * @api\\n */\\nPolygon.prototype.getCoordinates = function(opt_right) {\\n  let flatCoordinates;\\n  if (opt_right !== undefined) {\\n    flatCoordinates = this.getOrientedFlatCoordinates().slice();\\n    orientLinearRings(\\n      flatCoordinates, 0, this.ends_, this.stride, opt_right);\\n  } else {\\n    flatCoordinates = this.flatCoordinates;\\n  }\\n\\n  return inflateCoordinatesArray(\\n    flatCoordinates, 0, this.ends_, this.stride);\\n};\\n\\n\\n/**\\n * @return {Array.<number>} Ends.\\n */\\nPolygon.prototype.getEnds = function() {\\n  return this.ends_;\\n};\\n\\n\\n/**\\n * @return {Array.<number>} Interior point.\\n */\\nPolygon.prototype.getFlatInteriorPoint = function() {\\n  if (this.flatInteriorPointRevision_ != this.getRevision()) {\\n    const flatCenter = getCenter(this.getExtent());\\n    this.flatInteriorPoint_ = getInteriorPointOfArray(\\n      this.getOrientedFlatCoordinates(), 0, this.ends_, this.stride,\\n      flatCenter, 0);\\n    this.flatInteriorPointRevision_ = this.getRevision();\\n  }\\n  return this.flatInteriorPoint_;\\n};\\n\\n\\n/**\\n * Return an interior point of the polygon.\\n * @return {module:ol/geom/Point} Interior point as XYM coordinate, where M is the\\n * length of the horizontal intersection that the point belongs to.\\n * @api\\n */\\nPolygon.prototype.getInteriorPoint = function() {\\n  return new Point(this.getFlatInteriorPoint(), GeometryLayout.XYM);\\n};\\n\\n\\n/**\\n * Return the number of rings of the polygon,  this includes the exterior\\n * ring and any interior rings.\\n *\\n * @return {number} Number of rings.\\n * @api\\n */\\nPolygon.prototype.getLinearRingCount = function() {\\n  return this.ends_.length;\\n};\\n\\n\\n/**\\n * Return the Nth linear ring of the polygon geometry. Return `null` if the\\n * given index is out of range.\\n * The exterior linear ring is available at index `0` and the interior rings\\n * at index `1` and beyond.\\n *\\n * @param {number} index Index.\\n * @return {module:ol/geom/LinearRing} Linear ring.\\n * @api\\n */\\nPolygon.prototype.getLinearRing = function(index) {\\n  if (index < 0 || this.ends_.length <= index) {\\n    return null;\\n  }\\n  const linearRing = new LinearRing(null);\\n  linearRing.setFlatCoordinates(this.layout, this.flatCoordinates.slice(\\n    index === 0 ? 0 : this.ends_[index - 1], this.ends_[index]));\\n  return linearRing;\\n};\\n\\n\\n/**\\n * Return the linear rings of the polygon.\\n * @return {Array.<module:ol/geom/LinearRing>} Linear rings.\\n * @api\\n */\\nPolygon.prototype.getLinearRings = function() {\\n  const layout = this.layout;\\n  const flatCoordinates = this.flatCoordinates;\\n  const ends = this.ends_;\\n  const linearRings = [];\\n  let offset = 0;\\n  for (let i = 0, ii = ends.length; i < ii; ++i) {\\n    const end = ends[i];\\n    const linearRing = new LinearRing(null);\\n    linearRing.setFlatCoordinates(layout, flatCoordinates.slice(offset, end));\\n    linearRings.push(linearRing);\\n    offset = end;\\n  }\\n  return linearRings;\\n};\\n\\n\\n/**\\n * @return {Array.<number>} Oriented flat coordinates.\\n */\\nPolygon.prototype.getOrientedFlatCoordinates = function() {\\n  if (this.orientedRevision_ != this.getRevision()) {\\n    const flatCoordinates = this.flatCoordinates;\\n    if (linearRingIsOriented(\\n      flatCoordinates, 0, this.ends_, this.stride)) {\\n      this.orientedFlatCoordinates_ = flatCoordinates;\\n    } else {\\n      this.orientedFlatCoordinates_ = flatCoordinates.slice();\\n      this.orientedFlatCoordinates_.length =\\n          orientLinearRings(\\n            this.orientedFlatCoordinates_, 0, this.ends_, this.stride);\\n    }\\n    this.orientedRevision_ = this.getRevision();\\n  }\\n  return this.orientedFlatCoordinates_;\\n};\\n\\n\\n/**\\n * @inheritDoc\\n */\\nPolygon.prototype.getSimplifiedGeometryInternal = function(squaredTolerance) {\\n  const simplifiedFlatCoordinates = [];\\n  const simplifiedEnds = [];\\n  simplifiedFlatCoordinates.length = quantizeArray(\\n    this.flatCoordinates, 0, this.ends_, this.stride,\\n    Math.sqrt(squaredTolerance),\\n    simplifiedFlatCoordinates, 0, simplifiedEnds);\\n  const simplifiedPolygon = new Polygon(null);\\n  simplifiedPolygon.setFlatCoordinates(\\n    GeometryLayout.XY, simplifiedFlatCoordinates, simplifiedEnds);\\n  return simplifiedPolygon;\\n};\\n\\n\\n/**\\n * @inheritDoc\\n * @api\\n */\\nPolygon.prototype.getType = function() {\\n  return GeometryType.POLYGON;\\n};\\n\\n\\n/**\\n * @inheritDoc\\n * @api\\n */\\nPolygon.prototype.intersectsExtent = function(extent) {\\n  return intersectsLinearRingArray(\\n    this.getOrientedFlatCoordinates(), 0, this.ends_, this.stride, extent);\\n};\\n\\n\\n/**\\n * Set the coordinates of the polygon.\\n * @param {Array.<Array.<module:ol/coordinate~Coordinate>>} coordinates Coordinates.\\n * @param {module:ol/geom/GeometryLayout=} opt_layout Layout.\\n * @override\\n * @api\\n */\\nPolygon.prototype.setCoordinates = function(coordinates, opt_layout) {\\n  if (!coordinates) {\\n    this.setFlatCoordinates(GeometryLayout.XY, null, this.ends_);\\n  } else {\\n    this.setLayout(opt_layout, coordinates, 2);\\n    if (!this.flatCoordinates) {\\n      this.flatCoordinates = [];\\n    }\\n    const ends = deflateCoordinatesArray(\\n      this.flatCoordinates, 0, coordinates, this.stride, this.ends_);\\n    this.flatCoordinates.length = ends.length === 0 ? 0 : ends[ends.length - 1];\\n    this.changed();\\n  }\\n};\\n\\n\\n/**\\n * @param {module:ol/geom/GeometryLayout} layout Layout.\\n * @param {Array.<number>} flatCoordinates Flat coordinates.\\n * @param {Array.<number>} ends Ends.\\n */\\nPolygon.prototype.setFlatCoordinates = function(layout, flatCoordinates, ends) {\\n  this.setFlatCoordinatesInternal(layout, flatCoordinates);\\n  this.ends_ = ends;\\n  this.changed();\\n};\\n\\nexport default Polygon;\\n\\n\\n/**\\n * Create an approximation of a circle on the surface of a sphere.\\n * @param {module:ol/coordinate~Coordinate} center Center (`[lon, lat]` in degrees).\\n * @param {number} radius The great-circle distance from the center to\\n *     the polygon vertices.\\n * @param {number=} opt_n Optional number of vertices for the resulting\\n *     polygon. Default is `32`.\\n * @param {number=} opt_sphereRadius Optional radius for the sphere (defaults to\\n *     the Earth's mean radius using the WGS84 ellipsoid).\\n * @return {module:ol/geom/Polygon} The \\\"circular\\\" polygon.\\n * @api\\n */\\nexport function circular(center, radius, opt_n, opt_sphereRadius) {\\n  const n = opt_n ? opt_n : 32;\\n  /** @type {Array.<number>} */\\n  const flatCoordinates = [];\\n  for (let i = 0; i < n; ++i) {\\n    extend(flatCoordinates, sphereOffset(center, radius, 2 * Math.PI * i / n, opt_sphereRadius));\\n  }\\n  flatCoordinates.push(flatCoordinates[0], flatCoordinates[1]);\\n  const polygon = new Polygon(null);\\n  polygon.setFlatCoordinates(GeometryLayout.XY, flatCoordinates, [flatCoordinates.length]);\\n  return polygon;\\n}\\n\\n\\n/**\\n * Create a polygon from an extent. The layout used is `XY`.\\n * @param {module:ol/extent~Extent} extent The extent.\\n * @return {module:ol/geom/Polygon} The polygon.\\n * @api\\n */\\nexport function fromExtent(extent) {\\n  const minX = extent[0];\\n  const minY = extent[1];\\n  const maxX = extent[2];\\n  const maxY = extent[3];\\n  const flatCoordinates =\\n      [minX, minY, minX, maxY, maxX, maxY, maxX, minY, minX, minY];\\n  const polygon = new Polygon(null);\\n  polygon.setFlatCoordinates(\\n    GeometryLayout.XY, flatCoordinates, [flatCoordinates.length]);\\n  return polygon;\\n}\\n\\n\\n/**\\n * Create a regular polygon from a circle.\\n * @param {module:ol/geom/Circle} circle Circle geometry.\\n * @param {number=} opt_sides Number of sides of the polygon. Default is 32.\\n * @param {number=} opt_angle Start angle for the first vertex of the polygon in\\n *     radians. Default is 0.\\n * @return {module:ol/geom/Polygon} Polygon geometry.\\n * @api\\n */\\nexport function fromCircle(circle, opt_sides, opt_angle) {\\n  const sides = opt_sides ? opt_sides : 32;\\n  const stride = circle.getStride();\\n  const layout = circle.getLayout();\\n  const polygon = new Polygon(null, layout);\\n  const arrayLength = stride * (sides + 1);\\n  const flatCoordinates = new Array(arrayLength);\\n  for (let i = 0; i < arrayLength; i++) {\\n    flatCoordinates[i] = 0;\\n  }\\n  const ends = [flatCoordinates.length];\\n  polygon.setFlatCoordinates(layout, flatCoordinates, ends);\\n  makeRegular(polygon, circle.getCenter(), circle.getRadius(), opt_angle);\\n  return polygon;\\n}\\n\\n\\n/**\\n * Modify the coordinates of a polygon to make it a regular polygon.\\n * @param {module:ol/geom/Polygon} polygon Polygon geometry.\\n * @param {module:ol/coordinate~Coordinate} center Center of the regular polygon.\\n * @param {number} radius Radius of the regular polygon.\\n * @param {number=} opt_angle Start angle for the first vertex of the polygon in\\n *     radians. Default is 0.\\n */\\nexport function makeRegular(polygon, center, radius, opt_angle) {\\n  const flatCoordinates = polygon.getFlatCoordinates();\\n  const layout = polygon.getLayout();\\n  const stride = polygon.getStride();\\n  const ends = polygon.getEnds();\\n  const sides = flatCoordinates.length / stride - 1;\\n  const startAngle = opt_angle ? opt_angle : 0;\\n  for (let i = 0; i <= sides; ++i) {\\n    const offset = i * stride;\\n    const angle = startAngle + (modulo(i, sides) * 2 * Math.PI / sides);\\n    flatCoordinates[offset] = center[0] + (radius * Math.cos(angle));\\n    flatCoordinates[offset + 1] = center[1] + (radius * Math.sin(angle));\\n  }\\n  polygon.setFlatCoordinates(layout, flatCoordinates, ends);\\n}\\n\",\"/**\\n * @module ol/geom/MultiPolygon\\n */\\nimport {inherits} from '../index.js';\\nimport {extend} from '../array.js';\\nimport {closestSquaredDistanceXY} from '../extent.js';\\nimport GeometryLayout from '../geom/GeometryLayout.js';\\nimport GeometryType from '../geom/GeometryType.js';\\nimport MultiPoint from '../geom/MultiPoint.js';\\nimport Polygon from '../geom/Polygon.js';\\nimport SimpleGeometry from '../geom/SimpleGeometry.js';\\nimport {linearRingss as linearRingssArea} from '../geom/flat/area.js';\\nimport {linearRingss as linearRingssCenter} from '../geom/flat/center.js';\\nimport {assignClosestMultiArrayPoint, multiArrayMaxSquaredDelta} from '../geom/flat/closest.js';\\nimport {linearRingssContainsXY} from '../geom/flat/contains.js';\\nimport {deflateMultiCoordinatesArray} from '../geom/flat/deflate.js';\\nimport {inflateMultiCoordinatesArray} from '../geom/flat/inflate.js';\\nimport {getInteriorPointsOfMultiArray} from '../geom/flat/interiorpoint.js';\\nimport {intersectsLinearRingMultiArray} from '../geom/flat/intersectsextent.js';\\nimport {linearRingsAreOriented, orientLinearRingsArray} from '../geom/flat/orient.js';\\nimport {quantizeMultiArray} from '../geom/flat/simplify.js';\\n\\n/**\\n * @classdesc\\n * Multi-polygon geometry.\\n *\\n * @constructor\\n * @extends {module:ol/geom/SimpleGeometry}\\n * @param {Array.<Array.<Array.<module:ol/coordinate~Coordinate>>>} coordinates Coordinates.\\n * @param {module:ol/geom/GeometryLayout=} opt_layout Layout.\\n * @api\\n */\\nconst MultiPolygon = function(coordinates, opt_layout) {\\n\\n  SimpleGeometry.call(this);\\n\\n  /**\\n   * @type {Array.<Array.<number>>}\\n   * @private\\n   */\\n  this.endss_ = [];\\n\\n  /**\\n   * @private\\n   * @type {number}\\n   */\\n  this.flatInteriorPointsRevision_ = -1;\\n\\n  /**\\n   * @private\\n   * @type {Array.<number>}\\n   */\\n  this.flatInteriorPoints_ = null;\\n\\n  /**\\n   * @private\\n   * @type {number}\\n   */\\n  this.maxDelta_ = -1;\\n\\n  /**\\n   * @private\\n   * @type {number}\\n   */\\n  this.maxDeltaRevision_ = -1;\\n\\n  /**\\n   * @private\\n   * @type {number}\\n   */\\n  this.orientedRevision_ = -1;\\n\\n  /**\\n   * @private\\n   * @type {Array.<number>}\\n   */\\n  this.orientedFlatCoordinates_ = null;\\n\\n  this.setCoordinates(coordinates, opt_layout);\\n\\n};\\n\\ninherits(MultiPolygon, SimpleGeometry);\\n\\n\\n/**\\n * Append the passed polygon to this multipolygon.\\n * @param {module:ol/geom/Polygon} polygon Polygon.\\n * @api\\n */\\nMultiPolygon.prototype.appendPolygon = function(polygon) {\\n  /** @type {Array.<number>} */\\n  let ends;\\n  if (!this.flatCoordinates) {\\n    this.flatCoordinates = polygon.getFlatCoordinates().slice();\\n    ends = polygon.getEnds().slice();\\n    this.endss_.push();\\n  } else {\\n    const offset = this.flatCoordinates.length;\\n    extend(this.flatCoordinates, polygon.getFlatCoordinates());\\n    ends = polygon.getEnds().slice();\\n    for (let i = 0, ii = ends.length; i < ii; ++i) {\\n      ends[i] += offset;\\n    }\\n  }\\n  this.endss_.push(ends);\\n  this.changed();\\n};\\n\\n\\n/**\\n * Make a complete copy of the geometry.\\n * @return {!module:ol/geom/MultiPolygon} Clone.\\n * @override\\n * @api\\n */\\nMultiPolygon.prototype.clone = function() {\\n  const multiPolygon = new MultiPolygon(null);\\n\\n  const len = this.endss_.length;\\n  const newEndss = new Array(len);\\n  for (let i = 0; i < len; ++i) {\\n    newEndss[i] = this.endss_[i].slice();\\n  }\\n\\n  multiPolygon.setFlatCoordinates(\\n    this.layout, this.flatCoordinates.slice(), newEndss);\\n  return multiPolygon;\\n};\\n\\n\\n/**\\n * @inheritDoc\\n */\\nMultiPolygon.prototype.closestPointXY = function(x, y, closestPoint, minSquaredDistance) {\\n  if (minSquaredDistance < closestSquaredDistanceXY(this.getExtent(), x, y)) {\\n    return minSquaredDistance;\\n  }\\n  if (this.maxDeltaRevision_ != this.getRevision()) {\\n    this.maxDelta_ = Math.sqrt(multiArrayMaxSquaredDelta(\\n      this.flatCoordinates, 0, this.endss_, this.stride, 0));\\n    this.maxDeltaRevision_ = this.getRevision();\\n  }\\n  return assignClosestMultiArrayPoint(\\n    this.getOrientedFlatCoordinates(), 0, this.endss_, this.stride,\\n    this.maxDelta_, true, x, y, closestPoint, minSquaredDistance);\\n};\\n\\n\\n/**\\n * @inheritDoc\\n */\\nMultiPolygon.prototype.containsXY = function(x, y) {\\n  return linearRingssContainsXY(this.getOrientedFlatCoordinates(), 0, this.endss_, this.stride, x, y);\\n};\\n\\n\\n/**\\n * Return the area of the multipolygon on projected plane.\\n * @return {number} Area (on projected plane).\\n * @api\\n */\\nMultiPolygon.prototype.getArea = function() {\\n  return linearRingssArea(this.getOrientedFlatCoordinates(), 0, this.endss_, this.stride);\\n};\\n\\n\\n/**\\n * Get the coordinate array for this geometry.  This array has the structure\\n * of a GeoJSON coordinate array for multi-polygons.\\n *\\n * @param {boolean=} opt_right Orient coordinates according to the right-hand\\n *     rule (counter-clockwise for exterior and clockwise for interior rings).\\n *     If `false`, coordinates will be oriented according to the left-hand rule\\n *     (clockwise for exterior and counter-clockwise for interior rings).\\n *     By default, coordinate orientation will depend on how the geometry was\\n *     constructed.\\n * @return {Array.<Array.<Array.<module:ol/coordinate~Coordinate>>>} Coordinates.\\n * @override\\n * @api\\n */\\nMultiPolygon.prototype.getCoordinates = function(opt_right) {\\n  let flatCoordinates;\\n  if (opt_right !== undefined) {\\n    flatCoordinates = this.getOrientedFlatCoordinates().slice();\\n    orientLinearRingsArray(\\n      flatCoordinates, 0, this.endss_, this.stride, opt_right);\\n  } else {\\n    flatCoordinates = this.flatCoordinates;\\n  }\\n\\n  return inflateMultiCoordinatesArray(\\n    flatCoordinates, 0, this.endss_, this.stride);\\n};\\n\\n\\n/**\\n * @return {Array.<Array.<number>>} Endss.\\n */\\nMultiPolygon.prototype.getEndss = function() {\\n  return this.endss_;\\n};\\n\\n\\n/**\\n * @return {Array.<number>} Flat interior points.\\n */\\nMultiPolygon.prototype.getFlatInteriorPoints = function() {\\n  if (this.flatInteriorPointsRevision_ != this.getRevision()) {\\n    const flatCenters = linearRingssCenter(\\n      this.flatCoordinates, 0, this.endss_, this.stride);\\n    this.flatInteriorPoints_ = getInteriorPointsOfMultiArray(\\n      this.getOrientedFlatCoordinates(), 0, this.endss_, this.stride,\\n      flatCenters);\\n    this.flatInteriorPointsRevision_ = this.getRevision();\\n  }\\n  return this.flatInteriorPoints_;\\n};\\n\\n\\n/**\\n * Return the interior points as {@link module:ol/geom/MultiPoint multipoint}.\\n * @return {module:ol/geom/MultiPoint} Interior points as XYM coordinates, where M is\\n * the length of the horizontal intersection that the point belongs to.\\n * @api\\n */\\nMultiPolygon.prototype.getInteriorPoints = function() {\\n  const interiorPoints = new MultiPoint(null);\\n  interiorPoints.setFlatCoordinates(GeometryLayout.XYM,\\n    this.getFlatInteriorPoints().slice());\\n  return interiorPoints;\\n};\\n\\n\\n/**\\n * @return {Array.<number>} Oriented flat coordinates.\\n */\\nMultiPolygon.prototype.getOrientedFlatCoordinates = function() {\\n  if (this.orientedRevision_ != this.getRevision()) {\\n    const flatCoordinates = this.flatCoordinates;\\n    if (linearRingsAreOriented(\\n      flatCoordinates, 0, this.endss_, this.stride)) {\\n      this.orientedFlatCoordinates_ = flatCoordinates;\\n    } else {\\n      this.orientedFlatCoordinates_ = flatCoordinates.slice();\\n      this.orientedFlatCoordinates_.length =\\n          orientLinearRingsArray(\\n            this.orientedFlatCoordinates_, 0, this.endss_, this.stride);\\n    }\\n    this.orientedRevision_ = this.getRevision();\\n  }\\n  return this.orientedFlatCoordinates_;\\n};\\n\\n\\n/**\\n * @inheritDoc\\n */\\nMultiPolygon.prototype.getSimplifiedGeometryInternal = function(squaredTolerance) {\\n  const simplifiedFlatCoordinates = [];\\n  const simplifiedEndss = [];\\n  simplifiedFlatCoordinates.length = quantizeMultiArray(\\n    this.flatCoordinates, 0, this.endss_, this.stride,\\n    Math.sqrt(squaredTolerance),\\n    simplifiedFlatCoordinates, 0, simplifiedEndss);\\n  const simplifiedMultiPolygon = new MultiPolygon(null);\\n  simplifiedMultiPolygon.setFlatCoordinates(\\n    GeometryLayout.XY, simplifiedFlatCoordinates, simplifiedEndss);\\n  return simplifiedMultiPolygon;\\n};\\n\\n\\n/**\\n * Return the polygon at the specified index.\\n * @param {number} index Index.\\n * @return {module:ol/geom/Polygon} Polygon.\\n * @api\\n */\\nMultiPolygon.prototype.getPolygon = function(index) {\\n  if (index < 0 || this.endss_.length <= index) {\\n    return null;\\n  }\\n  let offset;\\n  if (index === 0) {\\n    offset = 0;\\n  } else {\\n    const prevEnds = this.endss_[index - 1];\\n    offset = prevEnds[prevEnds.length - 1];\\n  }\\n  const ends = this.endss_[index].slice();\\n  const end = ends[ends.length - 1];\\n  if (offset !== 0) {\\n    for (let i = 0, ii = ends.length; i < ii; ++i) {\\n      ends[i] -= offset;\\n    }\\n  }\\n  const polygon = new Polygon(null);\\n  polygon.setFlatCoordinates(\\n    this.layout, this.flatCoordinates.slice(offset, end), ends);\\n  return polygon;\\n};\\n\\n\\n/**\\n * Return the polygons of this multipolygon.\\n * @return {Array.<module:ol/geom/Polygon>} Polygons.\\n * @api\\n */\\nMultiPolygon.prototype.getPolygons = function() {\\n  const layout = this.layout;\\n  const flatCoordinates = this.flatCoordinates;\\n  const endss = this.endss_;\\n  const polygons = [];\\n  let offset = 0;\\n  for (let i = 0, ii = endss.length; i < ii; ++i) {\\n    const ends = endss[i].slice();\\n    const end = ends[ends.length - 1];\\n    if (offset !== 0) {\\n      for (let j = 0, jj = ends.length; j < jj; ++j) {\\n        ends[j] -= offset;\\n      }\\n    }\\n    const polygon = new Polygon(null);\\n    polygon.setFlatCoordinates(\\n      layout, flatCoordinates.slice(offset, end), ends);\\n    polygons.push(polygon);\\n    offset = end;\\n  }\\n  return polygons;\\n};\\n\\n\\n/**\\n * @inheritDoc\\n * @api\\n */\\nMultiPolygon.prototype.getType = function() {\\n  return GeometryType.MULTI_POLYGON;\\n};\\n\\n\\n/**\\n * @inheritDoc\\n * @api\\n */\\nMultiPolygon.prototype.intersectsExtent = function(extent) {\\n  return intersectsLinearRingMultiArray(\\n    this.getOrientedFlatCoordinates(), 0, this.endss_, this.stride, extent);\\n};\\n\\n\\n/**\\n * Set the coordinates of the multipolygon.\\n * @param {Array.<Array.<Array.<module:ol/coordinate~Coordinate>>>} coordinates Coordinates.\\n * @param {module:ol/geom/GeometryLayout=} opt_layout Layout.\\n * @override\\n * @api\\n */\\nMultiPolygon.prototype.setCoordinates = function(coordinates, opt_layout) {\\n  if (!coordinates) {\\n    this.setFlatCoordinates(GeometryLayout.XY, null, this.endss_);\\n  } else {\\n    this.setLayout(opt_layout, coordinates, 3);\\n    if (!this.flatCoordinates) {\\n      this.flatCoordinates = [];\\n    }\\n    const endss = deflateMultiCoordinatesArray(\\n      this.flatCoordinates, 0, coordinates, this.stride, this.endss_);\\n    if (endss.length === 0) {\\n      this.flatCoordinates.length = 0;\\n    } else {\\n      const lastEnds = endss[endss.length - 1];\\n      this.flatCoordinates.length = lastEnds.length === 0 ?\\n        0 : lastEnds[lastEnds.length - 1];\\n    }\\n    this.changed();\\n  }\\n};\\n\\n\\n/**\\n * @param {module:ol/geom/GeometryLayout} layout Layout.\\n * @param {Array.<number>} flatCoordinates Flat coordinates.\\n * @param {Array.<Array.<number>>} endss Endss.\\n */\\nMultiPolygon.prototype.setFlatCoordinates = function(layout, flatCoordinates, endss) {\\n  this.setFlatCoordinatesInternal(layout, flatCoordinates);\\n  this.endss_ = endss;\\n  this.changed();\\n};\\n\\n\\n/**\\n * @param {Array.<module:ol/geom/Polygon>} polygons Polygons.\\n */\\nMultiPolygon.prototype.setPolygons = function(polygons) {\\n  let layout = this.getLayout();\\n  const flatCoordinates = [];\\n  const endss = [];\\n  for (let i = 0, ii = polygons.length; i < ii; ++i) {\\n    const polygon = polygons[i];\\n    if (i === 0) {\\n      layout = polygon.getLayout();\\n    }\\n    const offset = flatCoordinates.length;\\n    const ends = polygon.getEnds();\\n    for (let j = 0, jj = ends.length; j < jj; ++j) {\\n      ends[j] += offset;\\n    }\\n    extend(flatCoordinates, polygon.getFlatCoordinates());\\n    endss.push(ends);\\n  }\\n  this.setFlatCoordinates(layout, flatCoordinates, endss);\\n};\\n\\nexport default MultiPolygon;\\n\",\"/**\\n * @module ol/geom/flat/center\\n */\\nimport {createEmpty, createOrUpdateFromFlatCoordinates} from '../../extent.js';\\n\\n\\n/**\\n * @param {Array.<number>} flatCoordinates Flat coordinates.\\n * @param {number} offset Offset.\\n * @param {Array.<Array.<number>>} endss Endss.\\n * @param {number} stride Stride.\\n * @return {Array.<number>} Flat centers.\\n */\\nexport function linearRingss(flatCoordinates, offset, endss, stride) {\\n  const flatCenters = [];\\n  let extent = createEmpty();\\n  for (let i = 0, ii = endss.length; i < ii; ++i) {\\n    const ends = endss[i];\\n    extent = createOrUpdateFromFlatCoordinates(flatCoordinates, offset, ends[0], stride);\\n    flatCenters.push((extent[0] + extent[2]) / 2, (extent[1] + extent[3]) / 2);\\n    offset = ends[ends.length - 1];\\n  }\\n  return flatCenters;\\n}\\n\",\"/**\\n * @module ol/format/GeoJSON\\n */\\n// TODO: serialize dataProjection as crs member when writing\\n// see https://github.com/openlayers/openlayers/issues/2078\\n\\nimport {inherits} from '../index.js';\\nimport {assert} from '../asserts.js';\\nimport Feature from '../Feature.js';\\nimport {transformWithOptions} from '../format/Feature.js';\\nimport JSONFeature from '../format/JSONFeature.js';\\nimport GeometryCollection from '../geom/GeometryCollection.js';\\nimport LineString from '../geom/LineString.js';\\nimport MultiLineString from '../geom/MultiLineString.js';\\nimport MultiPoint from '../geom/MultiPoint.js';\\nimport MultiPolygon from '../geom/MultiPolygon.js';\\nimport Point from '../geom/Point.js';\\nimport Polygon from '../geom/Polygon.js';\\nimport {assign, isEmpty} from '../obj.js';\\nimport {get as getProjection} from '../proj.js';\\n\\n\\n/**\\n * @typedef {Object} Options\\n * @property {module:ol/proj~ProjectionLike} [defaultDataProjection='EPSG:4326'] Default data projection.\\n * @property {module:ol/proj~ProjectionLike} [featureProjection] Projection for features read or\\n * written by the format.  Options passed to read or write methods will take precedence.\\n * @property {string} [geometryName] Geometry name to use when creating features.\\n * @property {boolean} [extractGeometryName=false] Certain GeoJSON providers include\\n * the geometry_name field in the feature GeoJSON. If set to `true` the GeoJSON reader\\n * will look for that field to set the geometry name. If both this field is set to `true`\\n * and a `geometryName` is provided, the `geometryName` will take precedence.\\n */\\n\\n\\n/**\\n * @classdesc\\n * Feature format for reading and writing data in the GeoJSON format.\\n *\\n * @constructor\\n * @extends {module:ol/format/JSONFeature}\\n * @param {module:ol/format/GeoJSON~Options=} opt_options Options.\\n * @api\\n */\\nconst GeoJSON = function(opt_options) {\\n\\n  const options = opt_options ? opt_options : {};\\n\\n  JSONFeature.call(this);\\n\\n  /**\\n   * @inheritDoc\\n   */\\n  this.defaultDataProjection = getProjection(\\n    options.defaultDataProjection ?\\n      options.defaultDataProjection : 'EPSG:4326');\\n\\n\\n  if (options.featureProjection) {\\n    this.defaultFeatureProjection = getProjection(options.featureProjection);\\n  }\\n\\n  /**\\n   * Name of the geometry attribute for features.\\n   * @type {string|undefined}\\n   * @private\\n   */\\n  this.geometryName_ = options.geometryName;\\n\\n  /**\\n   * Look for the geometry name in the feature GeoJSON\\n   * @type {boolean|undefined}\\n   * @private\\n   */\\n  this.extractGeometryName_ = options.extractGeometryName;\\n\\n};\\n\\ninherits(GeoJSON, JSONFeature);\\n\\n\\n/**\\n * @const\\n * @type {Object.<string, function(GeoJSONObject): module:ol/geom/Geometry>}\\n */\\nconst GEOMETRY_READERS = {\\n  'Point': readPointGeometry,\\n  'LineString': readLineStringGeometry,\\n  'Polygon': readPolygonGeometry,\\n  'MultiPoint': readMultiPointGeometry,\\n  'MultiLineString': readMultiLineStringGeometry,\\n  'MultiPolygon': readMultiPolygonGeometry,\\n  'GeometryCollection': readGeometryCollectionGeometry\\n};\\n\\n\\n/**\\n * @const\\n * @type {Object.<string, function(module:ol/geom/Geometry, module:ol/format/Feature~WriteOptions=): (GeoJSONGeometry|GeoJSONGeometryCollection)>}\\n */\\nconst GEOMETRY_WRITERS = {\\n  'Point': writePointGeometry,\\n  'LineString': writeLineStringGeometry,\\n  'Polygon': writePolygonGeometry,\\n  'MultiPoint': writeMultiPointGeometry,\\n  'MultiLineString': writeMultiLineStringGeometry,\\n  'MultiPolygon': writeMultiPolygonGeometry,\\n  'GeometryCollection': writeGeometryCollectionGeometry,\\n  'Circle': writeEmptyGeometryCollectionGeometry\\n};\\n\\n\\n/**\\n * @param {GeoJSONGeometry|GeoJSONGeometryCollection} object Object.\\n * @param {module:ol/format/Feature~ReadOptions=} opt_options Read options.\\n * @return {module:ol/geom/Geometry} Geometry.\\n */\\nfunction readGeometry(object, opt_options) {\\n  if (!object) {\\n    return null;\\n  }\\n  const geometryReader = GEOMETRY_READERS[object.type];\\n  return (\\n    /** @type {module:ol/geom/Geometry} */ (transformWithOptions(geometryReader(object), false, opt_options))\\n  );\\n}\\n\\n\\n/**\\n * @param {GeoJSONGeometryCollection} object Object.\\n * @param {module:ol/format/Feature~ReadOptions=} opt_options Read options.\\n * @return {module:ol/geom/GeometryCollection} Geometry collection.\\n */\\nfunction readGeometryCollectionGeometry(object, opt_options) {\\n  const geometries = object.geometries.map(\\n    /**\\n     * @param {GeoJSONGeometry} geometry Geometry.\\n     * @return {module:ol/geom/Geometry} geometry Geometry.\\n     */\\n    function(geometry) {\\n      return readGeometry(geometry, opt_options);\\n    });\\n  return new GeometryCollection(geometries);\\n}\\n\\n\\n/**\\n * @param {GeoJSONGeometry} object Object.\\n * @return {module:ol/geom/Point} Point.\\n */\\nfunction readPointGeometry(object) {\\n  return new Point(object.coordinates);\\n}\\n\\n\\n/**\\n * @param {GeoJSONGeometry} object Object.\\n * @return {module:ol/geom/LineString} LineString.\\n */\\nfunction readLineStringGeometry(object) {\\n  return new LineString(object.coordinates);\\n}\\n\\n\\n/**\\n * @param {GeoJSONGeometry} object Object.\\n * @return {module:ol/geom/MultiLineString} MultiLineString.\\n */\\nfunction readMultiLineStringGeometry(object) {\\n  return new MultiLineString(object.coordinates);\\n}\\n\\n\\n/**\\n * @param {GeoJSONGeometry} object Object.\\n * @return {module:ol/geom/MultiPoint} MultiPoint.\\n */\\nfunction readMultiPointGeometry(object) {\\n  return new MultiPoint(object.coordinates);\\n}\\n\\n\\n/**\\n * @param {GeoJSONGeometry} object Object.\\n * @return {module:ol/geom/MultiPolygon} MultiPolygon.\\n */\\nfunction readMultiPolygonGeometry(object) {\\n  return new MultiPolygon(object.coordinates);\\n}\\n\\n\\n/**\\n * @param {GeoJSONGeometry} object Object.\\n * @return {module:ol/geom/Polygon} Polygon.\\n */\\nfunction readPolygonGeometry(object) {\\n  return new Polygon(object.coordinates);\\n}\\n\\n\\n/**\\n * @param {module:ol/geom/Geometry} geometry Geometry.\\n * @param {module:ol/format/Feature~WriteOptions=} opt_options Write options.\\n * @return {GeoJSONGeometry|GeoJSONGeometryCollection} GeoJSON geometry.\\n */\\nfunction writeGeometry(geometry, opt_options) {\\n  const geometryWriter = GEOMETRY_WRITERS[geometry.getType()];\\n  return geometryWriter(/** @type {module:ol/geom/Geometry} */ (\\n    transformWithOptions(geometry, true, opt_options)), opt_options);\\n}\\n\\n\\n/**\\n * @param {module:ol/geom/Geometry} geometry Geometry.\\n * @return {GeoJSONGeometryCollection} Empty GeoJSON geometry collection.\\n */\\nfunction writeEmptyGeometryCollectionGeometry(geometry) {\\n  return /** @type {GeoJSONGeometryCollection} */ ({\\n    type: 'GeometryCollection',\\n    geometries: []\\n  });\\n}\\n\\n\\n/**\\n * @param {module:ol/geom/GeometryCollection} geometry Geometry.\\n * @param {module:ol/format/Feature~WriteOptions=} opt_options Write options.\\n * @return {GeoJSONGeometryCollection} GeoJSON geometry collection.\\n */\\nfunction writeGeometryCollectionGeometry(geometry, opt_options) {\\n  const geometries = geometry.getGeometriesArray().map(function(geometry) {\\n    const options = assign({}, opt_options);\\n    delete options.featureProjection;\\n    return writeGeometry(geometry, options);\\n  });\\n  return /** @type {GeoJSONGeometryCollection} */ ({\\n    type: 'GeometryCollection',\\n    geometries: geometries\\n  });\\n}\\n\\n\\n/**\\n * @param {module:ol/geom/LineString} geometry Geometry.\\n * @param {module:ol/format/Feature~WriteOptions=} opt_options Write options.\\n * @return {GeoJSONGeometry} GeoJSON geometry.\\n */\\nfunction writeLineStringGeometry(geometry, opt_options) {\\n  return /** @type {GeoJSONGeometry} */ ({\\n    type: 'LineString',\\n    coordinates: geometry.getCoordinates()\\n  });\\n}\\n\\n\\n/**\\n * @param {module:ol/geom/MultiLineString} geometry Geometry.\\n * @param {module:ol/format/Feature~WriteOptions=} opt_options Write options.\\n * @return {GeoJSONGeometry} GeoJSON geometry.\\n */\\nfunction writeMultiLineStringGeometry(geometry, opt_options) {\\n  return /** @type {GeoJSONGeometry} */ ({\\n    type: 'MultiLineString',\\n    coordinates: geometry.getCoordinates()\\n  });\\n}\\n\\n\\n/**\\n * @param {module:ol/geom/MultiPoint} geometry Geometry.\\n * @param {module:ol/format/Feature~WriteOptions=} opt_options Write options.\\n * @return {GeoJSONGeometry} GeoJSON geometry.\\n */\\nfunction writeMultiPointGeometry(geometry, opt_options) {\\n  return /** @type {GeoJSONGeometry} */ ({\\n    type: 'MultiPoint',\\n    coordinates: geometry.getCoordinates()\\n  });\\n}\\n\\n\\n/**\\n * @param {module:ol/geom/MultiPolygon} geometry Geometry.\\n * @param {module:ol/format/Feature~WriteOptions=} opt_options Write options.\\n * @return {GeoJSONGeometry} GeoJSON geometry.\\n */\\nfunction writeMultiPolygonGeometry(geometry, opt_options) {\\n  let right;\\n  if (opt_options) {\\n    right = opt_options.rightHanded;\\n  }\\n  return /** @type {GeoJSONGeometry} */ ({\\n    type: 'MultiPolygon',\\n    coordinates: geometry.getCoordinates(right)\\n  });\\n}\\n\\n\\n/**\\n * @param {module:ol/geom/Point} geometry Geometry.\\n * @param {module:ol/format/Feature~WriteOptions=} opt_options Write options.\\n * @return {GeoJSONGeometry} GeoJSON geometry.\\n */\\nfunction writePointGeometry(geometry, opt_options) {\\n  return /** @type {GeoJSONGeometry} */ ({\\n    type: 'Point',\\n    coordinates: geometry.getCoordinates()\\n  });\\n}\\n\\n\\n/**\\n * @param {module:ol/geom/Polygon} geometry Geometry.\\n * @param {module:ol/format/Feature~WriteOptions=} opt_options Write options.\\n * @return {GeoJSONGeometry} GeoJSON geometry.\\n */\\nfunction writePolygonGeometry(geometry, opt_options) {\\n  let right;\\n  if (opt_options) {\\n    right = opt_options.rightHanded;\\n  }\\n  return /** @type {GeoJSONGeometry} */ ({\\n    type: 'Polygon',\\n    coordinates: geometry.getCoordinates(right)\\n  });\\n}\\n\\n\\n/**\\n * Read a feature from a GeoJSON Feature source.  Only works for Feature or\\n * geometry types.  Use {@link module:ol/format/GeoJSON#readFeatures} to read\\n * FeatureCollection source. If feature at source has an id, it will be used\\n * as Feature id by calling {@link module:ol/Feature#setId} internally.\\n *\\n * @function\\n * @param {Document|Node|Object|string} source Source.\\n * @param {module:ol/format/Feature~ReadOptions=} opt_options Read options.\\n * @return {module:ol/Feature} Feature.\\n * @api\\n */\\nGeoJSON.prototype.readFeature;\\n\\n\\n/**\\n * Read all features from a GeoJSON source.  Works for all GeoJSON types.\\n * If the source includes only geometries, features will be created with those\\n * geometries.\\n *\\n * @function\\n * @param {Document|Node|Object|string} source Source.\\n * @param {module:ol/format/Feature~ReadOptions=} opt_options Read options.\\n * @return {Array.<module:ol/Feature>} Features.\\n * @api\\n */\\nGeoJSON.prototype.readFeatures;\\n\\n\\n/**\\n * @inheritDoc\\n */\\nGeoJSON.prototype.readFeatureFromObject = function(object, opt_options) {\\n  /**\\n   * @type {GeoJSONFeature}\\n   */\\n  let geoJSONFeature = null;\\n  if (object.type === 'Feature') {\\n    geoJSONFeature = /** @type {GeoJSONFeature} */ (object);\\n  } else {\\n    geoJSONFeature = /** @type {GeoJSONFeature} */ ({\\n      type: 'Feature',\\n      geometry: /** @type {GeoJSONGeometry|GeoJSONGeometryCollection} */ (object)\\n    });\\n  }\\n\\n  const geometry = readGeometry(geoJSONFeature.geometry, opt_options);\\n  const feature = new Feature();\\n  if (this.geometryName_) {\\n    feature.setGeometryName(this.geometryName_);\\n  } else if (this.extractGeometryName_ && geoJSONFeature.geometry_name !== undefined) {\\n    feature.setGeometryName(geoJSONFeature.geometry_name);\\n  }\\n  feature.setGeometry(geometry);\\n  if (geoJSONFeature.id !== undefined) {\\n    feature.setId(geoJSONFeature.id);\\n  }\\n  if (geoJSONFeature.properties) {\\n    feature.setProperties(geoJSONFeature.properties);\\n  }\\n  return feature;\\n};\\n\\n\\n/**\\n * @inheritDoc\\n */\\nGeoJSON.prototype.readFeaturesFromObject = function(object, opt_options) {\\n  const geoJSONObject = /** @type {GeoJSONObject} */ (object);\\n  /** @type {Array.<module:ol/Feature>} */\\n  let features = null;\\n  if (geoJSONObject.type === 'FeatureCollection') {\\n    const geoJSONFeatureCollection = /** @type {GeoJSONFeatureCollection} */ (object);\\n    features = [];\\n    const geoJSONFeatures = geoJSONFeatureCollection.features;\\n    for (let i = 0, ii = geoJSONFeatures.length; i < ii; ++i) {\\n      features.push(this.readFeatureFromObject(geoJSONFeatures[i], opt_options));\\n    }\\n  } else {\\n    features = [this.readFeatureFromObject(object, opt_options)];\\n  }\\n  return features;\\n};\\n\\n\\n/**\\n * Read a geometry from a GeoJSON source.\\n *\\n * @function\\n * @param {Document|Node|Object|string} source Source.\\n * @param {module:ol/format/Feature~ReadOptions=} opt_options Read options.\\n * @return {module:ol/geom/Geometry} Geometry.\\n * @api\\n */\\nGeoJSON.prototype.readGeometry;\\n\\n\\n/**\\n * @inheritDoc\\n */\\nGeoJSON.prototype.readGeometryFromObject = function(object, opt_options) {\\n  return readGeometry(/** @type {GeoJSONGeometry} */ (object), opt_options);\\n};\\n\\n\\n/**\\n * Read the projection from a GeoJSON source.\\n *\\n * @function\\n * @param {Document|Node|Object|string} source Source.\\n * @return {module:ol/proj/Projection} Projection.\\n * @api\\n */\\nGeoJSON.prototype.readProjection;\\n\\n\\n/**\\n * @inheritDoc\\n */\\nGeoJSON.prototype.readProjectionFromObject = function(object) {\\n  const geoJSONObject = /** @type {GeoJSONObject} */ (object);\\n  const crs = geoJSONObject.crs;\\n  let projection;\\n  if (crs) {\\n    if (crs.type == 'name') {\\n      projection = getProjection(crs.properties.name);\\n    } else {\\n      assert(false, 36); // Unknown SRS type\\n    }\\n  } else {\\n    projection = this.defaultDataProjection;\\n  }\\n  return (\\n    /** @type {module:ol/proj/Projection} */ (projection)\\n  );\\n};\\n\\n\\n/**\\n * Encode a feature as a GeoJSON Feature string.\\n *\\n * @function\\n * @param {module:ol/Feature} feature Feature.\\n * @param {module:ol/format/Feature~WriteOptions=} opt_options Write options.\\n * @return {string} GeoJSON.\\n * @override\\n * @api\\n */\\nGeoJSON.prototype.writeFeature;\\n\\n\\n/**\\n * Encode a feature as a GeoJSON Feature object.\\n *\\n * @param {module:ol/Feature} feature Feature.\\n * @param {module:ol/format/Feature~WriteOptions=} opt_options Write options.\\n * @return {GeoJSONFeature} Object.\\n * @override\\n * @api\\n */\\nGeoJSON.prototype.writeFeatureObject = function(feature, opt_options) {\\n  opt_options = this.adaptOptions(opt_options);\\n\\n  const object = /** @type {GeoJSONFeature} */ ({\\n    'type': 'Feature'\\n  });\\n  const id = feature.getId();\\n  if (id !== undefined) {\\n    object.id = id;\\n  }\\n  const geometry = feature.getGeometry();\\n  if (geometry) {\\n    object.geometry = writeGeometry(geometry, opt_options);\\n  } else {\\n    object.geometry = null;\\n  }\\n  const properties = feature.getProperties();\\n  delete properties[feature.getGeometryName()];\\n  if (!isEmpty(properties)) {\\n    object.properties = properties;\\n  } else {\\n    object.properties = null;\\n  }\\n  return object;\\n};\\n\\n\\n/**\\n * Encode an array of features as GeoJSON.\\n *\\n * @function\\n * @param {Array.<module:ol/Feature>} features Features.\\n * @param {module:ol/format/Feature~WriteOptions=} opt_options Write options.\\n * @return {string} GeoJSON.\\n * @api\\n */\\nGeoJSON.prototype.writeFeatures;\\n\\n\\n/**\\n * Encode an array of features as a GeoJSON object.\\n *\\n * @param {Array.<module:ol/Feature>} features Features.\\n * @param {module:ol/format/Feature~WriteOptions=} opt_options Write options.\\n * @return {GeoJSONFeatureCollection} GeoJSON Object.\\n * @override\\n * @api\\n */\\nGeoJSON.prototype.writeFeaturesObject = function(features, opt_options) {\\n  opt_options = this.adaptOptions(opt_options);\\n  const objects = [];\\n  for (let i = 0, ii = features.length; i < ii; ++i) {\\n    objects.push(this.writeFeatureObject(features[i], opt_options));\\n  }\\n  return /** @type {GeoJSONFeatureCollection} */ ({\\n    type: 'FeatureCollection',\\n    features: objects\\n  });\\n};\\n\\n\\n/**\\n * Encode a geometry as a GeoJSON string.\\n *\\n * @function\\n * @param {module:ol/geom/Geometry} geometry Geometry.\\n * @param {module:ol/format/Feature~WriteOptions=} opt_options Write options.\\n * @return {string} GeoJSON.\\n * @api\\n */\\nGeoJSON.prototype.writeGeometry;\\n\\n\\n/**\\n * Encode a geometry as a GeoJSON object.\\n *\\n * @param {module:ol/geom/Geometry} geometry Geometry.\\n * @param {module:ol/format/Feature~WriteOptions=} opt_options Write options.\\n * @return {GeoJSONGeometry|GeoJSONGeometryCollection} Object.\\n * @override\\n * @api\\n */\\nGeoJSON.prototype.writeGeometryObject = function(geometry, opt_options) {\\n  return writeGeometry(geometry, this.adaptOptions(opt_options));\\n};\\nexport default GeoJSON;\\n\",\"/**\\n * @module ol/CollectionEventType\\n */\\n\\n/**\\n * @enum {string}\\n */\\nexport default {\\n  /**\\n   * Triggered when an item is added to the collection.\\n   * @event module:ol/Collection~CollectionEvent#add\\n   * @api\\n   */\\n  ADD: 'add',\\n  /**\\n   * Triggered when an item is removed from the collection.\\n   * @event module:ol/Collection~CollectionEvent#remove\\n   * @api\\n   */\\n  REMOVE: 'remove'\\n};\\n\",\"/**\\n * @module ol/Collection\\n */\\nimport {inherits} from './index.js';\\nimport AssertionError from './AssertionError.js';\\nimport CollectionEventType from './CollectionEventType.js';\\nimport BaseObject from './Object.js';\\nimport Event from './events/Event.js';\\n\\n\\n/**\\n * @enum {string}\\n * @private\\n */\\nconst Property = {\\n  LENGTH: 'length'\\n};\\n\\n\\n/**\\n * @classdesc\\n * Events emitted by {@link module:ol/Collection~Collection} instances are instances of this\\n * type.\\n *\\n * @constructor\\n * @extends {module:ol/events/Event}\\n * @param {module:ol/CollectionEventType} type Type.\\n * @param {*=} opt_element Element.\\n */\\nexport const CollectionEvent = function(type, opt_element) {\\n\\n  Event.call(this, type);\\n\\n  /**\\n   * The element that is added to or removed from the collection.\\n   * @type {*}\\n   * @api\\n   */\\n  this.element = opt_element;\\n\\n};\\n\\ninherits(CollectionEvent, Event);\\n\\n\\n/**\\n * @typedef {Object} Options\\n * @property {boolean} [unique=false] Disallow the same item from being added to\\n * the collection twice.\\n */\\n\\n/**\\n * @classdesc\\n * An expanded version of standard JS Array, adding convenience methods for\\n * manipulation. Add and remove changes to the Collection trigger a Collection\\n * event. Note that this does not cover changes to the objects _within_ the\\n * Collection; they trigger events on the appropriate object, not on the\\n * Collection as a whole.\\n *\\n * @constructor\\n * @extends {module:ol/Object}\\n * @fires module:ol/Collection~CollectionEvent\\n * @param {Array.<T>=} opt_array Array.\\n * @param {module:ol/Collection~Options=} opt_options Collection options.\\n * @template T\\n * @api\\n */\\nconst Collection = function(opt_array, opt_options) {\\n\\n  BaseObject.call(this);\\n\\n  const options = opt_options || {};\\n\\n  /**\\n   * @private\\n   * @type {boolean}\\n   */\\n  this.unique_ = !!options.unique;\\n\\n  /**\\n   * @private\\n   * @type {!Array.<T>}\\n   */\\n  this.array_ = opt_array ? opt_array : [];\\n\\n  if (this.unique_) {\\n    for (let i = 0, ii = this.array_.length; i < ii; ++i) {\\n      this.assertUnique_(this.array_[i], i);\\n    }\\n  }\\n\\n  this.updateLength_();\\n\\n};\\n\\ninherits(Collection, BaseObject);\\n\\n\\n/**\\n * Remove all elements from the collection.\\n * @api\\n */\\nCollection.prototype.clear = function() {\\n  while (this.getLength() > 0) {\\n    this.pop();\\n  }\\n};\\n\\n\\n/**\\n * Add elements to the collection.  This pushes each item in the provided array\\n * to the end of the collection.\\n * @param {!Array.<T>} arr Array.\\n * @return {module:ol/Collection.<T>} This collection.\\n * @api\\n */\\nCollection.prototype.extend = function(arr) {\\n  for (let i = 0, ii = arr.length; i < ii; ++i) {\\n    this.push(arr[i]);\\n  }\\n  return this;\\n};\\n\\n\\n/**\\n * Iterate over each element, calling the provided callback.\\n * @param {function(T, number, Array.<T>): *} f The function to call\\n *     for every element. This function takes 3 arguments (the element, the\\n *     index and the array). The return value is ignored.\\n * @api\\n */\\nCollection.prototype.forEach = function(f) {\\n  const array = this.array_;\\n  for (let i = 0, ii = array.length; i < ii; ++i) {\\n    f(array[i], i, array);\\n  }\\n};\\n\\n\\n/**\\n * Get a reference to the underlying Array object. Warning: if the array\\n * is mutated, no events will be dispatched by the collection, and the\\n * collection's \\\"length\\\" property won't be in sync with the actual length\\n * of the array.\\n * @return {!Array.<T>} Array.\\n * @api\\n */\\nCollection.prototype.getArray = function() {\\n  return this.array_;\\n};\\n\\n\\n/**\\n * Get the element at the provided index.\\n * @param {number} index Index.\\n * @return {T} Element.\\n * @api\\n */\\nCollection.prototype.item = function(index) {\\n  return this.array_[index];\\n};\\n\\n\\n/**\\n * Get the length of this collection.\\n * @return {number} The length of the array.\\n * @observable\\n * @api\\n */\\nCollection.prototype.getLength = function() {\\n  return /** @type {number} */ (this.get(Property.LENGTH));\\n};\\n\\n\\n/**\\n * Insert an element at the provided index.\\n * @param {number} index Index.\\n * @param {T} elem Element.\\n * @api\\n */\\nCollection.prototype.insertAt = function(index, elem) {\\n  if (this.unique_) {\\n    this.assertUnique_(elem);\\n  }\\n  this.array_.splice(index, 0, elem);\\n  this.updateLength_();\\n  this.dispatchEvent(\\n    new CollectionEvent(CollectionEventType.ADD, elem));\\n};\\n\\n\\n/**\\n * Remove the last element of the collection and return it.\\n * Return `undefined` if the collection is empty.\\n * @return {T|undefined} Element.\\n * @api\\n */\\nCollection.prototype.pop = function() {\\n  return this.removeAt(this.getLength() - 1);\\n};\\n\\n\\n/**\\n * Insert the provided element at the end of the collection.\\n * @param {T} elem Element.\\n * @return {number} New length of the collection.\\n * @api\\n */\\nCollection.prototype.push = function(elem) {\\n  if (this.unique_) {\\n    this.assertUnique_(elem);\\n  }\\n  const n = this.getLength();\\n  this.insertAt(n, elem);\\n  return this.getLength();\\n};\\n\\n\\n/**\\n * Remove the first occurrence of an element from the collection.\\n * @param {T} elem Element.\\n * @return {T|undefined} The removed element or undefined if none found.\\n * @api\\n */\\nCollection.prototype.remove = function(elem) {\\n  const arr = this.array_;\\n  for (let i = 0, ii = arr.length; i < ii; ++i) {\\n    if (arr[i] === elem) {\\n      return this.removeAt(i);\\n    }\\n  }\\n  return undefined;\\n};\\n\\n\\n/**\\n * Remove the element at the provided index and return it.\\n * Return `undefined` if the collection does not contain this index.\\n * @param {number} index Index.\\n * @return {T|undefined} Value.\\n * @api\\n */\\nCollection.prototype.removeAt = function(index) {\\n  const prev = this.array_[index];\\n  this.array_.splice(index, 1);\\n  this.updateLength_();\\n  this.dispatchEvent(new CollectionEvent(CollectionEventType.REMOVE, prev));\\n  return prev;\\n};\\n\\n\\n/**\\n * Set the element at the provided index.\\n * @param {number} index Index.\\n * @param {T} elem Element.\\n * @api\\n */\\nCollection.prototype.setAt = function(index, elem) {\\n  const n = this.getLength();\\n  if (index < n) {\\n    if (this.unique_) {\\n      this.assertUnique_(elem, index);\\n    }\\n    const prev = this.array_[index];\\n    this.array_[index] = elem;\\n    this.dispatchEvent(\\n      new CollectionEvent(CollectionEventType.REMOVE, prev));\\n    this.dispatchEvent(\\n      new CollectionEvent(CollectionEventType.ADD, elem));\\n  } else {\\n    for (let j = n; j < index; ++j) {\\n      this.insertAt(j, undefined);\\n    }\\n    this.insertAt(index, elem);\\n  }\\n};\\n\\n\\n/**\\n * @private\\n */\\nCollection.prototype.updateLength_ = function() {\\n  this.set(Property.LENGTH, this.array_.length);\\n};\\n\\n\\n/**\\n * @private\\n * @param {T} elem Element.\\n * @param {number=} opt_except Optional index to ignore.\\n */\\nCollection.prototype.assertUnique_ = function(elem, opt_except) {\\n  for (let i = 0, ii = this.array_.length; i < ii; ++i) {\\n    if (this.array_[i] === elem && i !== opt_except) {\\n      throw new AssertionError(58);\\n    }\\n  }\\n};\\n\\nexport default Collection;\\n\",\"/**\\n * @module ol/MapEvent\\n */\\nimport {inherits} from './index.js';\\nimport Event from './events/Event.js';\\n\\n/**\\n * @classdesc\\n * Events emitted as map events are instances of this type.\\n * See {@link module:ol/Map~Map} for which events trigger a map event.\\n *\\n * @constructor\\n * @extends {module:ol/events/Event}\\n * @param {string} type Event type.\\n * @param {module:ol/PluggableMap} map Map.\\n * @param {?module:ol/PluggableMap~FrameState=} opt_frameState Frame state.\\n */\\nconst MapEvent = function(type, map, opt_frameState) {\\n\\n  Event.call(this, type);\\n\\n  /**\\n   * The map where the event occurred.\\n   * @type {module:ol/PluggableMap}\\n   * @api\\n   */\\n  this.map = map;\\n\\n  /**\\n   * The frame state at the time of the event.\\n   * @type {?module:ol/PluggableMap~FrameState}\\n   * @api\\n   */\\n  this.frameState = opt_frameState !== undefined ? opt_frameState : null;\\n\\n};\\n\\ninherits(MapEvent, Event);\\nexport default MapEvent;\\n\",\"/**\\n * @module ol/MapBrowserEvent\\n */\\nimport {inherits} from './index.js';\\nimport MapEvent from './MapEvent.js';\\n\\n/**\\n * @classdesc\\n * Events emitted as map browser events are instances of this type.\\n * See {@link module:ol/Map~Map} for which events trigger a map browser event.\\n *\\n * @constructor\\n * @extends {module:ol/MapEvent}\\n * @param {string} type Event type.\\n * @param {module:ol/PluggableMap} map Map.\\n * @param {Event} browserEvent Browser event.\\n * @param {boolean=} opt_dragging Is the map currently being dragged?\\n * @param {?module:ol/PluggableMap~FrameState=} opt_frameState Frame state.\\n */\\nconst MapBrowserEvent = function(type, map, browserEvent, opt_dragging, opt_frameState) {\\n\\n  MapEvent.call(this, type, map, opt_frameState);\\n\\n  /**\\n   * The original browser event.\\n   * @const\\n   * @type {Event}\\n   * @api\\n   */\\n  this.originalEvent = browserEvent;\\n\\n  /**\\n   * The map pixel relative to the viewport corresponding to the original browser event.\\n   * @type {module:ol~Pixel}\\n   * @api\\n   */\\n  this.pixel = map.getEventPixel(browserEvent);\\n\\n  /**\\n   * The coordinate in view projection corresponding to the original browser event.\\n   * @type {module:ol/coordinate~Coordinate}\\n   * @api\\n   */\\n  this.coordinate = map.getCoordinateFromPixel(this.pixel);\\n\\n  /**\\n   * Indicates if the map is currently being dragged. Only set for\\n   * `POINTERDRAG` and `POINTERMOVE` events. Default is `false`.\\n   *\\n   * @type {boolean}\\n   * @api\\n   */\\n  this.dragging = opt_dragging !== undefined ? opt_dragging : false;\\n\\n};\\n\\ninherits(MapBrowserEvent, MapEvent);\\n\\n\\n/**\\n * Prevents the default browser action.\\n * @see https://developer.mozilla.org/en-US/docs/Web/API/event.preventDefault\\n * @override\\n * @api\\n */\\nMapBrowserEvent.prototype.preventDefault = function() {\\n  MapEvent.prototype.preventDefault.call(this);\\n  this.originalEvent.preventDefault();\\n};\\n\\n\\n/**\\n * Prevents further propagation of the current event.\\n * @see https://developer.mozilla.org/en-US/docs/Web/API/event.stopPropagation\\n * @override\\n * @api\\n */\\nMapBrowserEvent.prototype.stopPropagation = function() {\\n  MapEvent.prototype.stopPropagation.call(this);\\n  this.originalEvent.stopPropagation();\\n};\\nexport default MapBrowserEvent;\\n\",\"/**\\n * @module ol/MapBrowserEventType\\n */\\nimport EventType from './events/EventType.js';\\n\\n/**\\n * Constants for event names.\\n * @enum {string}\\n */\\nexport default {\\n\\n  /**\\n   * A true single click with no dragging and no double click. Note that this\\n   * event is delayed by 250 ms to ensure that it is not a double click.\\n   * @event module:ol/MapBrowserEvent~MapBrowserEvent#singleclick\\n   * @api\\n   */\\n  SINGLECLICK: 'singleclick',\\n\\n  /**\\n   * A click with no dragging. A double click will fire two of this.\\n   * @event module:ol/MapBrowserEvent~MapBrowserEvent#click\\n   * @api\\n   */\\n  CLICK: EventType.CLICK,\\n\\n  /**\\n   * A true double click, with no dragging.\\n   * @event module:ol/MapBrowserEvent~MapBrowserEvent#dblclick\\n   * @api\\n   */\\n  DBLCLICK: EventType.DBLCLICK,\\n\\n  /**\\n   * Triggered when a pointer is dragged.\\n   * @event module:ol/MapBrowserEvent~MapBrowserEvent#pointerdrag\\n   * @api\\n   */\\n  POINTERDRAG: 'pointerdrag',\\n\\n  /**\\n   * Triggered when a pointer is moved. Note that on touch devices this is\\n   * triggered when the map is panned, so is not the same as mousemove.\\n   * @event module:ol/MapBrowserEvent~MapBrowserEvent#pointermove\\n   * @api\\n   */\\n  POINTERMOVE: 'pointermove',\\n\\n  POINTERDOWN: 'pointerdown',\\n  POINTERUP: 'pointerup',\\n  POINTEROVER: 'pointerover',\\n  POINTEROUT: 'pointerout',\\n  POINTERENTER: 'pointerenter',\\n  POINTERLEAVE: 'pointerleave',\\n  POINTERCANCEL: 'pointercancel'\\n};\\n\",\"/**\\n * @module ol/MapBrowserPointerEvent\\n */\\nimport {inherits} from './index.js';\\nimport MapBrowserEvent from './MapBrowserEvent.js';\\n\\n/**\\n * @constructor\\n * @extends {module:ol/MapBrowserEvent}\\n * @param {string} type Event type.\\n * @param {module:ol/PluggableMap} map Map.\\n * @param {module:ol/pointer/PointerEvent} pointerEvent Pointer\\n * event.\\n * @param {boolean=} opt_dragging Is the map currently being dragged?\\n * @param {?module:ol/PluggableMap~FrameState=} opt_frameState Frame state.\\n */\\nconst MapBrowserPointerEvent = function(type, map, pointerEvent, opt_dragging,\\n  opt_frameState) {\\n\\n  MapBrowserEvent.call(this, type, map, pointerEvent.originalEvent, opt_dragging,\\n    opt_frameState);\\n\\n  /**\\n   * @const\\n   * @type {module:ol/pointer/PointerEvent}\\n   */\\n  this.pointerEvent = pointerEvent;\\n\\n};\\n\\ninherits(MapBrowserPointerEvent, MapBrowserEvent);\\nexport default MapBrowserPointerEvent;\\n\",\"/**\\n * @module ol/pointer/EventType\\n */\\n\\n/**\\n * Constants for event names.\\n * @enum {string}\\n */\\nexport default {\\n  POINTERMOVE: 'pointermove',\\n  POINTERDOWN: 'pointerdown',\\n  POINTERUP: 'pointerup',\\n  POINTEROVER: 'pointerover',\\n  POINTEROUT: 'pointerout',\\n  POINTERENTER: 'pointerenter',\\n  POINTERLEAVE: 'pointerleave',\\n  POINTERCANCEL: 'pointercancel'\\n};\\n\",\"/**\\n * @module ol/pointer/EventSource\\n */\\n/**\\n * @param {module:ol/pointer/PointerEventHandler} dispatcher Event handler.\\n * @param {!Object.<string, function(Event)>} mapping Event mapping.\\n * @constructor\\n */\\nconst EventSource = function(dispatcher, mapping) {\\n  /**\\n   * @type {module:ol/pointer/PointerEventHandler}\\n   */\\n  this.dispatcher = dispatcher;\\n\\n  /**\\n   * @private\\n   * @const\\n   * @type {!Object.<string, function(Event)>}\\n   */\\n  this.mapping_ = mapping;\\n};\\n\\n\\n/**\\n * List of events supported by this source.\\n * @return {Array.<string>} Event names\\n */\\nEventSource.prototype.getEvents = function() {\\n  return Object.keys(this.mapping_);\\n};\\n\\n\\n/**\\n * Returns the handler that should handle a given event type.\\n * @param {string} eventType The event type.\\n * @return {function(Event)} Handler\\n */\\nEventSource.prototype.getHandlerForEvent = function(eventType) {\\n  return this.mapping_[eventType];\\n};\\nexport default EventSource;\\n\",\"/**\\n * @module ol/pointer/MouseSource\\n */\\n// Based on https://github.com/Polymer/PointerEvents\\n\\n// Copyright (c) 2013 The Polymer Authors. All rights reserved.\\n//\\n// Redistribution and use in source and binary forms, with or without\\n// modification, are permitted provided that the following conditions are\\n// met:\\n//\\n// * Redistributions of source code must retain the above copyright\\n// notice, this list of conditions and the following disclaimer.\\n// * Redistributions in binary form must reproduce the above\\n// copyright notice, this list of conditions and the following disclaimer\\n// in the documentation and/or other materials provided with the\\n// distribution.\\n// * Neither the name of Google Inc. nor the names of its\\n// contributors may be used to endorse or promote products derived from\\n// this software without specific prior written permission.\\n//\\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\\n// \\\"AS IS\\\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\\n// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\\n// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\\n// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\\n// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\\n// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\\n// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\\n// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\\n// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\\n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\\n\\nimport {inherits} from '../index.js';\\nimport EventSource from '../pointer/EventSource.js';\\n\\n/**\\n * @param {module:ol/pointer/PointerEventHandler} dispatcher Event handler.\\n * @constructor\\n * @extends {module:ol/pointer/EventSource}\\n */\\nconst MouseSource = function(dispatcher) {\\n  const mapping = {\\n    'mousedown': this.mousedown,\\n    'mousemove': this.mousemove,\\n    'mouseup': this.mouseup,\\n    'mouseover': this.mouseover,\\n    'mouseout': this.mouseout\\n  };\\n  EventSource.call(this, dispatcher, mapping);\\n\\n  /**\\n   * @const\\n   * @type {!Object.<string, Event|Object>}\\n   */\\n  this.pointerMap = dispatcher.pointerMap;\\n\\n  /**\\n   * @const\\n   * @type {Array.<module:ol~Pixel>}\\n   */\\n  this.lastTouches = [];\\n};\\n\\ninherits(MouseSource, EventSource);\\n\\n\\n/**\\n * @type {number}\\n */\\nexport const POINTER_ID = 1;\\n\\n\\n/**\\n * @type {string}\\n */\\nexport const POINTER_TYPE = 'mouse';\\n\\n\\n/**\\n * Radius around touchend that swallows mouse events.\\n *\\n * @type {number}\\n */\\nconst DEDUP_DIST = 25;\\n\\n\\n/**\\n * Detect if a mouse event was simulated from a touch by\\n * checking if previously there was a touch event at the\\n * same position.\\n *\\n * FIXME - Known problem with the native Android browser on\\n * Samsung GT-I9100 (Android 4.1.2):\\n * In case the page is scrolled, this function does not work\\n * correctly when a canvas is used (WebGL or canvas renderer).\\n * Mouse listeners on canvas elements (for this browser), create\\n * two mouse events: One 'good' and one 'bad' one (on other browsers or\\n * when a div is used, there is only one event). For the 'bad' one,\\n * clientX/clientY and also pageX/pageY are wrong when the page\\n * is scrolled. Because of that, this function can not detect if\\n * the events were simulated from a touch event. As result, a\\n * pointer event at a wrong position is dispatched, which confuses\\n * the map interactions.\\n * It is unclear, how one can get the correct position for the event\\n * or detect that the positions are invalid.\\n *\\n * @private\\n * @param {Event} inEvent The in event.\\n * @return {boolean} True, if the event was generated by a touch.\\n */\\nMouseSource.prototype.isEventSimulatedFromTouch_ = function(inEvent) {\\n  const lts = this.lastTouches;\\n  const x = inEvent.clientX;\\n  const y = inEvent.clientY;\\n  for (let i = 0, l = lts.length, t; i < l && (t = lts[i]); i++) {\\n    // simulated mouse events will be swallowed near a primary touchend\\n    const dx = Math.abs(x - t[0]);\\n    const dy = Math.abs(y - t[1]);\\n    if (dx <= DEDUP_DIST && dy <= DEDUP_DIST) {\\n      return true;\\n    }\\n  }\\n  return false;\\n};\\n\\n\\n/**\\n * Creates a copy of the original event that will be used\\n * for the fake pointer event.\\n *\\n * @param {Event} inEvent The in event.\\n * @param {module:ol/pointer/PointerEventHandler} dispatcher Event handler.\\n * @return {Object} The copied event.\\n */\\nfunction prepareEvent(inEvent, dispatcher) {\\n  const e = dispatcher.cloneEvent(inEvent, inEvent);\\n\\n  // forward mouse preventDefault\\n  const pd = e.preventDefault;\\n  e.preventDefault = function() {\\n    inEvent.preventDefault();\\n    pd();\\n  };\\n\\n  e.pointerId = POINTER_ID;\\n  e.isPrimary = true;\\n  e.pointerType = POINTER_TYPE;\\n\\n  return e;\\n}\\n\\n\\n/**\\n * Handler for `mousedown`.\\n *\\n * @param {Event} inEvent The in event.\\n */\\nMouseSource.prototype.mousedown = function(inEvent) {\\n  if (!this.isEventSimulatedFromTouch_(inEvent)) {\\n    // TODO(dfreedman) workaround for some elements not sending mouseup\\n    // http://crbug/149091\\n    if (POINTER_ID.toString() in this.pointerMap) {\\n      this.cancel(inEvent);\\n    }\\n    const e = prepareEvent(inEvent, this.dispatcher);\\n    this.pointerMap[POINTER_ID.toString()] = inEvent;\\n    this.dispatcher.down(e, inEvent);\\n  }\\n};\\n\\n\\n/**\\n * Handler for `mousemove`.\\n *\\n * @param {Event} inEvent The in event.\\n */\\nMouseSource.prototype.mousemove = function(inEvent) {\\n  if (!this.isEventSimulatedFromTouch_(inEvent)) {\\n    const e = prepareEvent(inEvent, this.dispatcher);\\n    this.dispatcher.move(e, inEvent);\\n  }\\n};\\n\\n\\n/**\\n * Handler for `mouseup`.\\n *\\n * @param {Event} inEvent The in event.\\n */\\nMouseSource.prototype.mouseup = function(inEvent) {\\n  if (!this.isEventSimulatedFromTouch_(inEvent)) {\\n    const p = this.pointerMap[POINTER_ID.toString()];\\n\\n    if (p && p.button === inEvent.button) {\\n      const e = prepareEvent(inEvent, this.dispatcher);\\n      this.dispatcher.up(e, inEvent);\\n      this.cleanupMouse();\\n    }\\n  }\\n};\\n\\n\\n/**\\n * Handler for `mouseover`.\\n *\\n * @param {Event} inEvent The in event.\\n */\\nMouseSource.prototype.mouseover = function(inEvent) {\\n  if (!this.isEventSimulatedFromTouch_(inEvent)) {\\n    const e = prepareEvent(inEvent, this.dispatcher);\\n    this.dispatcher.enterOver(e, inEvent);\\n  }\\n};\\n\\n\\n/**\\n * Handler for `mouseout`.\\n *\\n * @param {Event} inEvent The in event.\\n */\\nMouseSource.prototype.mouseout = function(inEvent) {\\n  if (!this.isEventSimulatedFromTouch_(inEvent)) {\\n    const e = prepareEvent(inEvent, this.dispatcher);\\n    this.dispatcher.leaveOut(e, inEvent);\\n  }\\n};\\n\\n\\n/**\\n * Dispatches a `pointercancel` event.\\n *\\n * @param {Event} inEvent The in event.\\n */\\nMouseSource.prototype.cancel = function(inEvent) {\\n  const e = prepareEvent(inEvent, this.dispatcher);\\n  this.dispatcher.cancel(e, inEvent);\\n  this.cleanupMouse();\\n};\\n\\n\\n/**\\n * Remove the mouse from the list of active pointers.\\n */\\nMouseSource.prototype.cleanupMouse = function() {\\n  delete this.pointerMap[POINTER_ID.toString()];\\n};\\nexport default MouseSource;\\n\",\"/**\\n * @module ol/pointer/MsSource\\n */\\n// Based on https://github.com/Polymer/PointerEvents\\n\\n// Copyright (c) 2013 The Polymer Authors. All rights reserved.\\n//\\n// Redistribution and use in source and binary forms, with or without\\n// modification, are permitted provided that the following conditions are\\n// met:\\n//\\n// * Redistributions of source code must retain the above copyright\\n// notice, this list of conditions and the following disclaimer.\\n// * Redistributions in binary form must reproduce the above\\n// copyright notice, this list of conditions and the following disclaimer\\n// in the documentation and/or other materials provided with the\\n// distribution.\\n// * Neither the name of Google Inc. nor the names of its\\n// contributors may be used to endorse or promote products derived from\\n// this software without specific prior written permission.\\n//\\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\\n// \\\"AS IS\\\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\\n// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\\n// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\\n// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\\n// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\\n// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\\n// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\\n// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\\n// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\\n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\\n\\nimport {inherits} from '../index.js';\\nimport EventSource from '../pointer/EventSource.js';\\n\\n/**\\n * @param {module:ol/pointer/PointerEventHandler} dispatcher Event handler.\\n * @constructor\\n * @extends {module:ol/pointer/EventSource}\\n */\\nconst MsSource = function(dispatcher) {\\n  const mapping = {\\n    'MSPointerDown': this.msPointerDown,\\n    'MSPointerMove': this.msPointerMove,\\n    'MSPointerUp': this.msPointerUp,\\n    'MSPointerOut': this.msPointerOut,\\n    'MSPointerOver': this.msPointerOver,\\n    'MSPointerCancel': this.msPointerCancel,\\n    'MSGotPointerCapture': this.msGotPointerCapture,\\n    'MSLostPointerCapture': this.msLostPointerCapture\\n  };\\n  EventSource.call(this, dispatcher, mapping);\\n\\n  /**\\n   * @const\\n   * @type {!Object.<string, MSPointerEvent|Object>}\\n   */\\n  this.pointerMap = dispatcher.pointerMap;\\n};\\n\\ninherits(MsSource, EventSource);\\n\\n/**\\n * @const\\n * @type {Array.<string>}\\n */\\nconst POINTER_TYPES = [\\n  '',\\n  'unavailable',\\n  'touch',\\n  'pen',\\n  'mouse'\\n];\\n\\n\\n/**\\n * Creates a copy of the original event that will be used\\n * for the fake pointer event.\\n *\\n * @private\\n * @param {MSPointerEvent} inEvent The in event.\\n * @return {Object} The copied event.\\n */\\nMsSource.prototype.prepareEvent_ = function(inEvent) {\\n  let e = inEvent;\\n  if (typeof inEvent.pointerType === 'number') {\\n    e = this.dispatcher.cloneEvent(inEvent, inEvent);\\n    e.pointerType = POINTER_TYPES[inEvent.pointerType];\\n  }\\n\\n  return e;\\n};\\n\\n\\n/**\\n * Remove this pointer from the list of active pointers.\\n * @param {number} pointerId Pointer identifier.\\n */\\nMsSource.prototype.cleanup = function(pointerId) {\\n  delete this.pointerMap[pointerId.toString()];\\n};\\n\\n\\n/**\\n * Handler for `msPointerDown`.\\n *\\n * @param {MSPointerEvent} inEvent The in event.\\n */\\nMsSource.prototype.msPointerDown = function(inEvent) {\\n  this.pointerMap[inEvent.pointerId.toString()] = inEvent;\\n  const e = this.prepareEvent_(inEvent);\\n  this.dispatcher.down(e, inEvent);\\n};\\n\\n\\n/**\\n * Handler for `msPointerMove`.\\n *\\n * @param {MSPointerEvent} inEvent The in event.\\n */\\nMsSource.prototype.msPointerMove = function(inEvent) {\\n  const e = this.prepareEvent_(inEvent);\\n  this.dispatcher.move(e, inEvent);\\n};\\n\\n\\n/**\\n * Handler for `msPointerUp`.\\n *\\n * @param {MSPointerEvent} inEvent The in event.\\n */\\nMsSource.prototype.msPointerUp = function(inEvent) {\\n  const e = this.prepareEvent_(inEvent);\\n  this.dispatcher.up(e, inEvent);\\n  this.cleanup(inEvent.pointerId);\\n};\\n\\n\\n/**\\n * Handler for `msPointerOut`.\\n *\\n * @param {MSPointerEvent} inEvent The in event.\\n */\\nMsSource.prototype.msPointerOut = function(inEvent) {\\n  const e = this.prepareEvent_(inEvent);\\n  this.dispatcher.leaveOut(e, inEvent);\\n};\\n\\n\\n/**\\n * Handler for `msPointerOver`.\\n *\\n * @param {MSPointerEvent} inEvent The in event.\\n */\\nMsSource.prototype.msPointerOver = function(inEvent) {\\n  const e = this.prepareEvent_(inEvent);\\n  this.dispatcher.enterOver(e, inEvent);\\n};\\n\\n\\n/**\\n * Handler for `msPointerCancel`.\\n *\\n * @param {MSPointerEvent} inEvent The in event.\\n */\\nMsSource.prototype.msPointerCancel = function(inEvent) {\\n  const e = this.prepareEvent_(inEvent);\\n  this.dispatcher.cancel(e, inEvent);\\n  this.cleanup(inEvent.pointerId);\\n};\\n\\n\\n/**\\n * Handler for `msLostPointerCapture`.\\n *\\n * @param {MSPointerEvent} inEvent The in event.\\n */\\nMsSource.prototype.msLostPointerCapture = function(inEvent) {\\n  const e = this.dispatcher.makeEvent('lostpointercapture', inEvent, inEvent);\\n  this.dispatcher.dispatchEvent(e);\\n};\\n\\n\\n/**\\n * Handler for `msGotPointerCapture`.\\n *\\n * @param {MSPointerEvent} inEvent The in event.\\n */\\nMsSource.prototype.msGotPointerCapture = function(inEvent) {\\n  const e = this.dispatcher.makeEvent('gotpointercapture', inEvent, inEvent);\\n  this.dispatcher.dispatchEvent(e);\\n};\\nexport default MsSource;\\n\",\"/**\\n * @module ol/pointer/NativeSource\\n */\\n// Based on https://github.com/Polymer/PointerEvents\\n\\n// Copyright (c) 2013 The Polymer Authors. All rights reserved.\\n//\\n// Redistribution and use in source and binary forms, with or without\\n// modification, are permitted provided that the following conditions are\\n// met:\\n//\\n// * Redistributions of source code must retain the above copyright\\n// notice, this list of conditions and the following disclaimer.\\n// * Redistributions in binary form must reproduce the above\\n// copyright notice, this list of conditions and the following disclaimer\\n// in the documentation and/or other materials provided with the\\n// distribution.\\n// * Neither the name of Google Inc. nor the names of its\\n// contributors may be used to endorse or promote products derived from\\n// this software without specific prior written permission.\\n//\\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\\n// \\\"AS IS\\\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\\n// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\\n// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\\n// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\\n// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\\n// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\\n// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\\n// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\\n// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\\n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\\n\\nimport {inherits} from '../index.js';\\nimport EventSource from '../pointer/EventSource.js';\\n\\n/**\\n * @param {module:ol/pointer/PointerEventHandler} dispatcher Event handler.\\n * @constructor\\n * @extends {module:ol/pointer/EventSource}\\n */\\nconst NativeSource = function(dispatcher) {\\n  const mapping = {\\n    'pointerdown': this.pointerDown,\\n    'pointermove': this.pointerMove,\\n    'pointerup': this.pointerUp,\\n    'pointerout': this.pointerOut,\\n    'pointerover': this.pointerOver,\\n    'pointercancel': this.pointerCancel,\\n    'gotpointercapture': this.gotPointerCapture,\\n    'lostpointercapture': this.lostPointerCapture\\n  };\\n  EventSource.call(this, dispatcher, mapping);\\n};\\n\\ninherits(NativeSource, EventSource);\\n\\n\\n/**\\n * Handler for `pointerdown`.\\n *\\n * @param {Event} inEvent The in event.\\n */\\nNativeSource.prototype.pointerDown = function(inEvent) {\\n  this.dispatcher.fireNativeEvent(inEvent);\\n};\\n\\n\\n/**\\n * Handler for `pointermove`.\\n *\\n * @param {Event} inEvent The in event.\\n */\\nNativeSource.prototype.pointerMove = function(inEvent) {\\n  this.dispatcher.fireNativeEvent(inEvent);\\n};\\n\\n\\n/**\\n * Handler for `pointerup`.\\n *\\n * @param {Event} inEvent The in event.\\n */\\nNativeSource.prototype.pointerUp = function(inEvent) {\\n  this.dispatcher.fireNativeEvent(inEvent);\\n};\\n\\n\\n/**\\n * Handler for `pointerout`.\\n *\\n * @param {Event} inEvent The in event.\\n */\\nNativeSource.prototype.pointerOut = function(inEvent) {\\n  this.dispatcher.fireNativeEvent(inEvent);\\n};\\n\\n\\n/**\\n * Handler for `pointerover`.\\n *\\n * @param {Event} inEvent The in event.\\n */\\nNativeSource.prototype.pointerOver = function(inEvent) {\\n  this.dispatcher.fireNativeEvent(inEvent);\\n};\\n\\n\\n/**\\n * Handler for `pointercancel`.\\n *\\n * @param {Event} inEvent The in event.\\n */\\nNativeSource.prototype.pointerCancel = function(inEvent) {\\n  this.dispatcher.fireNativeEvent(inEvent);\\n};\\n\\n\\n/**\\n * Handler for `lostpointercapture`.\\n *\\n * @param {Event} inEvent The in event.\\n */\\nNativeSource.prototype.lostPointerCapture = function(inEvent) {\\n  this.dispatcher.fireNativeEvent(inEvent);\\n};\\n\\n\\n/**\\n * Handler for `gotpointercapture`.\\n *\\n * @param {Event} inEvent The in event.\\n */\\nNativeSource.prototype.gotPointerCapture = function(inEvent) {\\n  this.dispatcher.fireNativeEvent(inEvent);\\n};\\nexport default NativeSource;\\n\",\"/**\\n * @module ol/pointer/PointerEvent\\n */\\n// Based on https://github.com/Polymer/PointerEvents\\n\\n// Copyright (c) 2013 The Polymer Authors. All rights reserved.\\n//\\n// Redistribution and use in source and binary forms, with or without\\n// modification, are permitted provided that the following conditions are\\n// met:\\n//\\n// * Redistributions of source code must retain the above copyright\\n// notice, this list of conditions and the following disclaimer.\\n// * Redistributions in binary form must reproduce the above\\n// copyright notice, this list of conditions and the following disclaimer\\n// in the documentation and/or other materials provided with the\\n// distribution.\\n// * Neither the name of Google Inc. nor the names of its\\n// contributors may be used to endorse or promote products derived from\\n// this software without specific prior written permission.\\n//\\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\\n// \\\"AS IS\\\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\\n// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\\n// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\\n// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\\n// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\\n// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\\n// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\\n// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\\n// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\\n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\\n\\nimport {inherits} from '../index.js';\\nimport Event from '../events/Event.js';\\n\\n/**\\n * A class for pointer events.\\n *\\n * This class is used as an abstraction for mouse events,\\n * touch events and even native pointer events.\\n *\\n * @constructor\\n * @extends {module:ol/events/Event}\\n * @param {string} type The type of the event to create.\\n * @param {Event} originalEvent The event.\\n * @param {Object.<string, ?>=} opt_eventDict An optional dictionary of\\n *    initial event properties.\\n */\\nconst PointerEvent = function(type, originalEvent, opt_eventDict) {\\n  Event.call(this, type);\\n\\n  /**\\n   * @const\\n   * @type {Event}\\n   */\\n  this.originalEvent = originalEvent;\\n\\n  const eventDict = opt_eventDict ? opt_eventDict : {};\\n\\n  /**\\n   * @type {number}\\n   */\\n  this.buttons = this.getButtons_(eventDict);\\n\\n  /**\\n   * @type {number}\\n   */\\n  this.pressure = this.getPressure_(eventDict, this.buttons);\\n\\n  // MouseEvent related properties\\n\\n  /**\\n   * @type {boolean}\\n   */\\n  this.bubbles = 'bubbles' in eventDict ? eventDict['bubbles'] : false;\\n\\n  /**\\n   * @type {boolean}\\n   */\\n  this.cancelable = 'cancelable' in eventDict ? eventDict['cancelable'] : false;\\n\\n  /**\\n   * @type {Object}\\n   */\\n  this.view = 'view' in eventDict ? eventDict['view'] : null;\\n\\n  /**\\n   * @type {number}\\n   */\\n  this.detail = 'detail' in eventDict ? eventDict['detail'] : null;\\n\\n  /**\\n   * @type {number}\\n   */\\n  this.screenX = 'screenX' in eventDict ? eventDict['screenX'] : 0;\\n\\n  /**\\n   * @type {number}\\n   */\\n  this.screenY = 'screenY' in eventDict ? eventDict['screenY'] : 0;\\n\\n  /**\\n   * @type {number}\\n   */\\n  this.clientX = 'clientX' in eventDict ? eventDict['clientX'] : 0;\\n\\n  /**\\n   * @type {number}\\n   */\\n  this.clientY = 'clientY' in eventDict ? eventDict['clientY'] : 0;\\n\\n  /**\\n   * @type {boolean}\\n   */\\n  this.ctrlKey = 'ctrlKey' in eventDict ? eventDict['ctrlKey'] : false;\\n\\n  /**\\n   * @type {boolean}\\n   */\\n  this.altKey = 'altKey' in eventDict ? eventDict['altKey'] : false;\\n\\n  /**\\n   * @type {boolean}\\n   */\\n  this.shiftKey = 'shiftKey' in eventDict ? eventDict['shiftKey'] : false;\\n\\n  /**\\n   * @type {boolean}\\n   */\\n  this.metaKey = 'metaKey' in eventDict ? eventDict['metaKey'] : false;\\n\\n  /**\\n   * @type {number}\\n   */\\n  this.button = 'button' in eventDict ? eventDict['button'] : 0;\\n\\n  /**\\n   * @type {Node}\\n   */\\n  this.relatedTarget = 'relatedTarget' in eventDict ?\\n    eventDict['relatedTarget'] : null;\\n\\n  // PointerEvent related properties\\n\\n  /**\\n   * @const\\n   * @type {number}\\n   */\\n  this.pointerId = 'pointerId' in eventDict ? eventDict['pointerId'] : 0;\\n\\n  /**\\n   * @type {number}\\n   */\\n  this.width = 'width' in eventDict ? eventDict['width'] : 0;\\n\\n  /**\\n   * @type {number}\\n   */\\n  this.height = 'height' in eventDict ? eventDict['height'] : 0;\\n\\n  /**\\n   * @type {number}\\n   */\\n  this.tiltX = 'tiltX' in eventDict ? eventDict['tiltX'] : 0;\\n\\n  /**\\n   * @type {number}\\n   */\\n  this.tiltY = 'tiltY' in eventDict ? eventDict['tiltY'] : 0;\\n\\n  /**\\n   * @type {string}\\n   */\\n  this.pointerType = 'pointerType' in eventDict ? eventDict['pointerType'] : '';\\n\\n  /**\\n   * @type {number}\\n   */\\n  this.hwTimestamp = 'hwTimestamp' in eventDict ? eventDict['hwTimestamp'] : 0;\\n\\n  /**\\n   * @type {boolean}\\n   */\\n  this.isPrimary = 'isPrimary' in eventDict ? eventDict['isPrimary'] : false;\\n\\n  // keep the semantics of preventDefault\\n  if (originalEvent.preventDefault) {\\n    this.preventDefault = function() {\\n      originalEvent.preventDefault();\\n    };\\n  }\\n};\\n\\ninherits(PointerEvent, Event);\\n\\n\\n/**\\n * Is the `buttons` property supported?\\n * @type {boolean}\\n */\\nlet HAS_BUTTONS = false;\\n\\n\\n/**\\n * @private\\n * @param {Object.<string, ?>} eventDict The event dictionary.\\n * @return {number} Button indicator.\\n */\\nPointerEvent.prototype.getButtons_ = function(eventDict) {\\n  // According to the w3c spec,\\n  // http://www.w3.org/TR/DOM-Level-3-Events/#events-MouseEvent-button\\n  // MouseEvent.button == 0 can mean either no mouse button depressed, or the\\n  // left mouse button depressed.\\n  //\\n  // As of now, the only way to distinguish between the two states of\\n  // MouseEvent.button is by using the deprecated MouseEvent.which property, as\\n  // this maps mouse buttons to positive integers > 0, and uses 0 to mean that\\n  // no mouse button is held.\\n  //\\n  // MouseEvent.which is derived from MouseEvent.button at MouseEvent creation,\\n  // but initMouseEvent does not expose an argument with which to set\\n  // MouseEvent.which. Calling initMouseEvent with a buttonArg of 0 will set\\n  // MouseEvent.button == 0 and MouseEvent.which == 1, breaking the expectations\\n  // of app developers.\\n  //\\n  // The only way to propagate the correct state of MouseEvent.which and\\n  // MouseEvent.button to a new MouseEvent.button == 0 and MouseEvent.which == 0\\n  // is to call initMouseEvent with a buttonArg value of -1.\\n  //\\n  // This is fixed with DOM Level 4's use of buttons\\n  let buttons;\\n  if (eventDict.buttons || HAS_BUTTONS) {\\n    buttons = eventDict.buttons;\\n  } else {\\n    switch (eventDict.which) {\\n      case 1: buttons = 1; break;\\n      case 2: buttons = 4; break;\\n      case 3: buttons = 2; break;\\n      default: buttons = 0;\\n    }\\n  }\\n  return buttons;\\n};\\n\\n\\n/**\\n * @private\\n * @param {Object.<string, ?>} eventDict The event dictionary.\\n * @param {number} buttons Button indicator.\\n * @return {number} The pressure.\\n */\\nPointerEvent.prototype.getPressure_ = function(eventDict, buttons) {\\n  // Spec requires that pointers without pressure specified use 0.5 for down\\n  // state and 0 for up state.\\n  let pressure = 0;\\n  if (eventDict.pressure) {\\n    pressure = eventDict.pressure;\\n  } else {\\n    pressure = buttons ? 0.5 : 0;\\n  }\\n  return pressure;\\n};\\n\\n\\n/**\\n * Checks if the `buttons` property is supported.\\n */\\n(function() {\\n  try {\\n    const ev = new MouseEvent('click', {buttons: 1});\\n    HAS_BUTTONS = ev.buttons === 1;\\n  } catch (e) {\\n    // pass\\n  }\\n})();\\nexport default PointerEvent;\\n\",\"/**\\n * @module ol/pointer/TouchSource\\n */\\n// Based on https://github.com/Polymer/PointerEvents\\n\\n// Copyright (c) 2013 The Polymer Authors. All rights reserved.\\n//\\n// Redistribution and use in source and binary forms, with or without\\n// modification, are permitted provided that the following conditions are\\n// met:\\n//\\n// * Redistributions of source code must retain the above copyright\\n// notice, this list of conditions and the following disclaimer.\\n// * Redistributions in binary form must reproduce the above\\n// copyright notice, this list of conditions and the following disclaimer\\n// in the documentation and/or other materials provided with the\\n// distribution.\\n// * Neither the name of Google Inc. nor the names of its\\n// contributors may be used to endorse or promote products derived from\\n// this software without specific prior written permission.\\n//\\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\\n// \\\"AS IS\\\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\\n// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\\n// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\\n// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\\n// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\\n// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\\n// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\\n// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\\n// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\\n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\\n\\nimport {inherits} from '../index.js';\\nimport {remove} from '../array.js';\\nimport EventSource from '../pointer/EventSource.js';\\nimport {POINTER_ID} from '../pointer/MouseSource.js';\\n\\n\\n/**\\n * @constructor\\n * @param {module:ol/pointer/PointerEventHandler} dispatcher The event handler.\\n * @param {module:ol/pointer/MouseSource} mouseSource Mouse source.\\n * @extends {module:ol/pointer/EventSource}\\n */\\nconst TouchSource = function(dispatcher, mouseSource) {\\n  const mapping = {\\n    'touchstart': this.touchstart,\\n    'touchmove': this.touchmove,\\n    'touchend': this.touchend,\\n    'touchcancel': this.touchcancel\\n  };\\n  EventSource.call(this, dispatcher, mapping);\\n\\n  /**\\n   * @const\\n   * @type {!Object.<string, Event|Object>}\\n   */\\n  this.pointerMap = dispatcher.pointerMap;\\n\\n  /**\\n   * @const\\n   * @type {module:ol/pointer/MouseSource}\\n   */\\n  this.mouseSource = mouseSource;\\n\\n  /**\\n   * @private\\n   * @type {number|undefined}\\n   */\\n  this.firstTouchId_ = undefined;\\n\\n  /**\\n   * @private\\n   * @type {number}\\n   */\\n  this.clickCount_ = 0;\\n\\n  /**\\n   * @private\\n   * @type {number|undefined}\\n   */\\n  this.resetId_ = undefined;\\n\\n  /**\\n   * Mouse event timeout: This should be long enough to\\n   * ignore compat mouse events made by touch.\\n   * @private\\n   * @type {number}\\n   */\\n  this.dedupTimeout_ = 2500;\\n};\\n\\ninherits(TouchSource, EventSource);\\n\\n\\n/**\\n * @type {number}\\n */\\nconst CLICK_COUNT_TIMEOUT = 200;\\n\\n\\n/**\\n * @type {string}\\n */\\nconst POINTER_TYPE = 'touch';\\n\\n/**\\n * @private\\n * @param {Touch} inTouch The in touch.\\n * @return {boolean} True, if this is the primary touch.\\n */\\nTouchSource.prototype.isPrimaryTouch_ = function(inTouch) {\\n  return this.firstTouchId_ === inTouch.identifier;\\n};\\n\\n\\n/**\\n * Set primary touch if there are no pointers, or the only pointer is the mouse.\\n * @param {Touch} inTouch The in touch.\\n * @private\\n */\\nTouchSource.prototype.setPrimaryTouch_ = function(inTouch) {\\n  const count = Object.keys(this.pointerMap).length;\\n  if (count === 0 || (count === 1 && POINTER_ID.toString() in this.pointerMap)) {\\n    this.firstTouchId_ = inTouch.identifier;\\n    this.cancelResetClickCount_();\\n  }\\n};\\n\\n\\n/**\\n * @private\\n * @param {Object} inPointer The in pointer object.\\n */\\nTouchSource.prototype.removePrimaryPointer_ = function(inPointer) {\\n  if (inPointer.isPrimary) {\\n    this.firstTouchId_ = undefined;\\n    this.resetClickCount_();\\n  }\\n};\\n\\n\\n/**\\n * @private\\n */\\nTouchSource.prototype.resetClickCount_ = function() {\\n  this.resetId_ = setTimeout(\\n    this.resetClickCountHandler_.bind(this),\\n    CLICK_COUNT_TIMEOUT);\\n};\\n\\n\\n/**\\n * @private\\n */\\nTouchSource.prototype.resetClickCountHandler_ = function() {\\n  this.clickCount_ = 0;\\n  this.resetId_ = undefined;\\n};\\n\\n\\n/**\\n * @private\\n */\\nTouchSource.prototype.cancelResetClickCount_ = function() {\\n  if (this.resetId_ !== undefined) {\\n    clearTimeout(this.resetId_);\\n  }\\n};\\n\\n\\n/**\\n * @private\\n * @param {Event} browserEvent Browser event\\n * @param {Touch} inTouch Touch event\\n * @return {Object} A pointer object.\\n */\\nTouchSource.prototype.touchToPointer_ = function(browserEvent, inTouch) {\\n  const e = this.dispatcher.cloneEvent(browserEvent, inTouch);\\n  // Spec specifies that pointerId 1 is reserved for Mouse.\\n  // Touch identifiers can start at 0.\\n  // Add 2 to the touch identifier for compatibility.\\n  e.pointerId = inTouch.identifier + 2;\\n  // TODO: check if this is necessary?\\n  //e.target = findTarget(e);\\n  e.bubbles = true;\\n  e.cancelable = true;\\n  e.detail = this.clickCount_;\\n  e.button = 0;\\n  e.buttons = 1;\\n  e.width = inTouch.webkitRadiusX || inTouch.radiusX || 0;\\n  e.height = inTouch.webkitRadiusY || inTouch.radiusY || 0;\\n  e.pressure = inTouch.webkitForce || inTouch.force || 0.5;\\n  e.isPrimary = this.isPrimaryTouch_(inTouch);\\n  e.pointerType = POINTER_TYPE;\\n\\n  // make sure that the properties that are different for\\n  // each `Touch` object are not copied from the BrowserEvent object\\n  e.clientX = inTouch.clientX;\\n  e.clientY = inTouch.clientY;\\n  e.screenX = inTouch.screenX;\\n  e.screenY = inTouch.screenY;\\n\\n  return e;\\n};\\n\\n\\n/**\\n * @private\\n * @param {Event} inEvent Touch event\\n * @param {function(Event, Object)} inFunction In function.\\n */\\nTouchSource.prototype.processTouches_ = function(inEvent, inFunction) {\\n  const touches = Array.prototype.slice.call(inEvent.changedTouches);\\n  const count = touches.length;\\n  function preventDefault() {\\n    inEvent.preventDefault();\\n  }\\n  for (let i = 0; i < count; ++i) {\\n    const pointer = this.touchToPointer_(inEvent, touches[i]);\\n    // forward touch preventDefaults\\n    pointer.preventDefault = preventDefault;\\n    inFunction.call(this, inEvent, pointer);\\n  }\\n};\\n\\n\\n/**\\n * @private\\n * @param {TouchList} touchList The touch list.\\n * @param {number} searchId Search identifier.\\n * @return {boolean} True, if the `Touch` with the given id is in the list.\\n */\\nTouchSource.prototype.findTouch_ = function(touchList, searchId) {\\n  const l = touchList.length;\\n  for (let i = 0; i < l; i++) {\\n    const touch = touchList[i];\\n    if (touch.identifier === searchId) {\\n      return true;\\n    }\\n  }\\n  return false;\\n};\\n\\n\\n/**\\n * In some instances, a touchstart can happen without a touchend. This\\n * leaves the pointermap in a broken state.\\n * Therefore, on every touchstart, we remove the touches that did not fire a\\n * touchend event.\\n * To keep state globally consistent, we fire a pointercancel for\\n * this \\\"abandoned\\\" touch\\n *\\n * @private\\n * @param {Event} inEvent The in event.\\n */\\nTouchSource.prototype.vacuumTouches_ = function(inEvent) {\\n  const touchList = inEvent.touches;\\n  // pointerMap.getCount() should be < touchList.length here,\\n  // as the touchstart has not been processed yet.\\n  const keys = Object.keys(this.pointerMap);\\n  const count = keys.length;\\n  if (count >= touchList.length) {\\n    const d = [];\\n    for (let i = 0; i < count; ++i) {\\n      const key = keys[i];\\n      const value = this.pointerMap[key];\\n      // Never remove pointerId == 1, which is mouse.\\n      // Touch identifiers are 2 smaller than their pointerId, which is the\\n      // index in pointermap.\\n      if (key != POINTER_ID && !this.findTouch_(touchList, key - 2)) {\\n        d.push(value.out);\\n      }\\n    }\\n    for (let i = 0; i < d.length; ++i) {\\n      this.cancelOut_(inEvent, d[i]);\\n    }\\n  }\\n};\\n\\n\\n/**\\n * Handler for `touchstart`, triggers `pointerover`,\\n * `pointerenter` and `pointerdown` events.\\n *\\n * @param {Event} inEvent The in event.\\n */\\nTouchSource.prototype.touchstart = function(inEvent) {\\n  this.vacuumTouches_(inEvent);\\n  this.setPrimaryTouch_(inEvent.changedTouches[0]);\\n  this.dedupSynthMouse_(inEvent);\\n  this.clickCount_++;\\n  this.processTouches_(inEvent, this.overDown_);\\n};\\n\\n\\n/**\\n * @private\\n * @param {Event} browserEvent The event.\\n * @param {Object} inPointer The in pointer object.\\n */\\nTouchSource.prototype.overDown_ = function(browserEvent, inPointer) {\\n  this.pointerMap[inPointer.pointerId] = {\\n    target: inPointer.target,\\n    out: inPointer,\\n    outTarget: inPointer.target\\n  };\\n  this.dispatcher.over(inPointer, browserEvent);\\n  this.dispatcher.enter(inPointer, browserEvent);\\n  this.dispatcher.down(inPointer, browserEvent);\\n};\\n\\n\\n/**\\n * Handler for `touchmove`.\\n *\\n * @param {Event} inEvent The in event.\\n */\\nTouchSource.prototype.touchmove = function(inEvent) {\\n  inEvent.preventDefault();\\n  this.processTouches_(inEvent, this.moveOverOut_);\\n};\\n\\n\\n/**\\n * @private\\n * @param {Event} browserEvent The event.\\n * @param {Object} inPointer The in pointer.\\n */\\nTouchSource.prototype.moveOverOut_ = function(browserEvent, inPointer) {\\n  const event = inPointer;\\n  const pointer = this.pointerMap[event.pointerId];\\n  // a finger drifted off the screen, ignore it\\n  if (!pointer) {\\n    return;\\n  }\\n  const outEvent = pointer.out;\\n  const outTarget = pointer.outTarget;\\n  this.dispatcher.move(event, browserEvent);\\n  if (outEvent && outTarget !== event.target) {\\n    outEvent.relatedTarget = event.target;\\n    event.relatedTarget = outTarget;\\n    // recover from retargeting by shadow\\n    outEvent.target = outTarget;\\n    if (event.target) {\\n      this.dispatcher.leaveOut(outEvent, browserEvent);\\n      this.dispatcher.enterOver(event, browserEvent);\\n    } else {\\n      // clean up case when finger leaves the screen\\n      event.target = outTarget;\\n      event.relatedTarget = null;\\n      this.cancelOut_(browserEvent, event);\\n    }\\n  }\\n  pointer.out = event;\\n  pointer.outTarget = event.target;\\n};\\n\\n\\n/**\\n * Handler for `touchend`, triggers `pointerup`,\\n * `pointerout` and `pointerleave` events.\\n *\\n * @param {Event} inEvent The event.\\n */\\nTouchSource.prototype.touchend = function(inEvent) {\\n  this.dedupSynthMouse_(inEvent);\\n  this.processTouches_(inEvent, this.upOut_);\\n};\\n\\n\\n/**\\n * @private\\n * @param {Event} browserEvent An event.\\n * @param {Object} inPointer The inPointer object.\\n */\\nTouchSource.prototype.upOut_ = function(browserEvent, inPointer) {\\n  this.dispatcher.up(inPointer, browserEvent);\\n  this.dispatcher.out(inPointer, browserEvent);\\n  this.dispatcher.leave(inPointer, browserEvent);\\n  this.cleanUpPointer_(inPointer);\\n};\\n\\n\\n/**\\n * Handler for `touchcancel`, triggers `pointercancel`,\\n * `pointerout` and `pointerleave` events.\\n *\\n * @param {Event} inEvent The in event.\\n */\\nTouchSource.prototype.touchcancel = function(inEvent) {\\n  this.processTouches_(inEvent, this.cancelOut_);\\n};\\n\\n\\n/**\\n * @private\\n * @param {Event} browserEvent The event.\\n * @param {Object} inPointer The in pointer.\\n */\\nTouchSource.prototype.cancelOut_ = function(browserEvent, inPointer) {\\n  this.dispatcher.cancel(inPointer, browserEvent);\\n  this.dispatcher.out(inPointer, browserEvent);\\n  this.dispatcher.leave(inPointer, browserEvent);\\n  this.cleanUpPointer_(inPointer);\\n};\\n\\n\\n/**\\n * @private\\n * @param {Object} inPointer The inPointer object.\\n */\\nTouchSource.prototype.cleanUpPointer_ = function(inPointer) {\\n  delete this.pointerMap[inPointer.pointerId];\\n  this.removePrimaryPointer_(inPointer);\\n};\\n\\n\\n/**\\n * Prevent synth mouse events from creating pointer events.\\n *\\n * @private\\n * @param {Event} inEvent The in event.\\n */\\nTouchSource.prototype.dedupSynthMouse_ = function(inEvent) {\\n  const lts = this.mouseSource.lastTouches;\\n  const t = inEvent.changedTouches[0];\\n  // only the primary finger will synth mouse events\\n  if (this.isPrimaryTouch_(t)) {\\n    // remember x/y of last touch\\n    const lt = [t.clientX, t.clientY];\\n    lts.push(lt);\\n\\n    setTimeout(function() {\\n      // remove touch after timeout\\n      remove(lts, lt);\\n    }, this.dedupTimeout_);\\n  }\\n};\\nexport default TouchSource;\\n\",\"/**\\n * @module ol/pointer/PointerEventHandler\\n */\\n// Based on https://github.com/Polymer/PointerEvents\\n\\n// Copyright (c) 2013 The Polymer Authors. All rights reserved.\\n//\\n// Redistribution and use in source and binary forms, with or without\\n// modification, are permitted provided that the following conditions are\\n// met:\\n//\\n// * Redistributions of source code must retain the above copyright\\n// notice, this list of conditions and the following disclaimer.\\n// * Redistributions in binary form must reproduce the above\\n// copyright notice, this list of conditions and the following disclaimer\\n// in the documentation and/or other materials provided with the\\n// distribution.\\n// * Neither the name of Google Inc. nor the names of its\\n// contributors may be used to endorse or promote products derived from\\n// this software without specific prior written permission.\\n//\\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\\n// \\\"AS IS\\\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\\n// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\\n// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\\n// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\\n// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\\n// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\\n// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\\n// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\\n// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\\n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\\n\\nimport {inherits} from '../index.js';\\nimport {listen, unlisten} from '../events.js';\\nimport EventTarget from '../events/EventTarget.js';\\nimport {POINTER, MSPOINTER, TOUCH} from '../has.js';\\nimport PointerEventType from '../pointer/EventType.js';\\nimport MouseSource from '../pointer/MouseSource.js';\\nimport MsSource from '../pointer/MsSource.js';\\nimport NativeSource from '../pointer/NativeSource.js';\\nimport PointerEvent from '../pointer/PointerEvent.js';\\nimport TouchSource from '../pointer/TouchSource.js';\\n\\n/**\\n * @constructor\\n * @extends {module:ol/events/EventTarget}\\n * @param {Element|HTMLDocument} element Viewport element.\\n */\\nconst PointerEventHandler = function(element) {\\n  EventTarget.call(this);\\n\\n  /**\\n   * @const\\n   * @private\\n   * @type {Element|HTMLDocument}\\n   */\\n  this.element_ = element;\\n\\n  /**\\n   * @const\\n   * @type {!Object.<string, Event|Object>}\\n   */\\n  this.pointerMap = {};\\n\\n  /**\\n   * @type {Object.<string, function(Event)>}\\n   * @private\\n   */\\n  this.eventMap_ = {};\\n\\n  /**\\n   * @type {Array.<module:ol/pointer/EventSource>}\\n   * @private\\n   */\\n  this.eventSourceList_ = [];\\n\\n  this.registerSources();\\n};\\n\\ninherits(PointerEventHandler, EventTarget);\\n\\n/**\\n * Properties to copy when cloning an event, with default values.\\n * @type {Array.<Array>}\\n */\\nconst CLONE_PROPS = [\\n  // MouseEvent\\n  ['bubbles', false],\\n  ['cancelable', false],\\n  ['view', null],\\n  ['detail', null],\\n  ['screenX', 0],\\n  ['screenY', 0],\\n  ['clientX', 0],\\n  ['clientY', 0],\\n  ['ctrlKey', false],\\n  ['altKey', false],\\n  ['shiftKey', false],\\n  ['metaKey', false],\\n  ['button', 0],\\n  ['relatedTarget', null],\\n  // DOM Level 3\\n  ['buttons', 0],\\n  // PointerEvent\\n  ['pointerId', 0],\\n  ['width', 0],\\n  ['height', 0],\\n  ['pressure', 0],\\n  ['tiltX', 0],\\n  ['tiltY', 0],\\n  ['pointerType', ''],\\n  ['hwTimestamp', 0],\\n  ['isPrimary', false],\\n  // event instance\\n  ['type', ''],\\n  ['target', null],\\n  ['currentTarget', null],\\n  ['which', 0]\\n];\\n\\n\\n/**\\n * Set up the event sources (mouse, touch and native pointers)\\n * that generate pointer events.\\n */\\nPointerEventHandler.prototype.registerSources = function() {\\n  if (POINTER) {\\n    this.registerSource('native', new NativeSource(this));\\n  } else if (MSPOINTER) {\\n    this.registerSource('ms', new MsSource(this));\\n  } else {\\n    const mouseSource = new MouseSource(this);\\n    this.registerSource('mouse', mouseSource);\\n\\n    if (TOUCH) {\\n      this.registerSource('touch', new TouchSource(this, mouseSource));\\n    }\\n  }\\n\\n  // register events on the viewport element\\n  this.register_();\\n};\\n\\n\\n/**\\n * Add a new event source that will generate pointer events.\\n *\\n * @param {string} name A name for the event source\\n * @param {module:ol/pointer/EventSource} source The source event.\\n */\\nPointerEventHandler.prototype.registerSource = function(name, source) {\\n  const s = source;\\n  const newEvents = s.getEvents();\\n\\n  if (newEvents) {\\n    newEvents.forEach(function(e) {\\n      const handler = s.getHandlerForEvent(e);\\n\\n      if (handler) {\\n        this.eventMap_[e] = handler.bind(s);\\n      }\\n    }.bind(this));\\n    this.eventSourceList_.push(s);\\n  }\\n};\\n\\n\\n/**\\n * Set up the events for all registered event sources.\\n * @private\\n */\\nPointerEventHandler.prototype.register_ = function() {\\n  const l = this.eventSourceList_.length;\\n  for (let i = 0; i < l; i++) {\\n    const eventSource = this.eventSourceList_[i];\\n    this.addEvents_(eventSource.getEvents());\\n  }\\n};\\n\\n\\n/**\\n * Remove all registered events.\\n * @private\\n */\\nPointerEventHandler.prototype.unregister_ = function() {\\n  const l = this.eventSourceList_.length;\\n  for (let i = 0; i < l; i++) {\\n    const eventSource = this.eventSourceList_[i];\\n    this.removeEvents_(eventSource.getEvents());\\n  }\\n};\\n\\n\\n/**\\n * Calls the right handler for a new event.\\n * @private\\n * @param {Event} inEvent Browser event.\\n */\\nPointerEventHandler.prototype.eventHandler_ = function(inEvent) {\\n  const type = inEvent.type;\\n  const handler = this.eventMap_[type];\\n  if (handler) {\\n    handler(inEvent);\\n  }\\n};\\n\\n\\n/**\\n * Setup listeners for the given events.\\n * @private\\n * @param {Array.<string>} events List of events.\\n */\\nPointerEventHandler.prototype.addEvents_ = function(events) {\\n  events.forEach(function(eventName) {\\n    listen(this.element_, eventName, this.eventHandler_, this);\\n  }.bind(this));\\n};\\n\\n\\n/**\\n * Unregister listeners for the given events.\\n * @private\\n * @param {Array.<string>} events List of events.\\n */\\nPointerEventHandler.prototype.removeEvents_ = function(events) {\\n  events.forEach(function(e) {\\n    unlisten(this.element_, e, this.eventHandler_, this);\\n  }.bind(this));\\n};\\n\\n\\n/**\\n * Returns a snapshot of inEvent, with writable properties.\\n *\\n * @param {Event} event Browser event.\\n * @param {Event|Touch} inEvent An event that contains\\n *    properties to copy.\\n * @return {Object} An object containing shallow copies of\\n *    `inEvent`'s properties.\\n */\\nPointerEventHandler.prototype.cloneEvent = function(event, inEvent) {\\n  const eventCopy = {};\\n  for (let i = 0, ii = CLONE_PROPS.length; i < ii; i++) {\\n    const p = CLONE_PROPS[i][0];\\n    eventCopy[p] = event[p] || inEvent[p] || CLONE_PROPS[i][1];\\n  }\\n\\n  return eventCopy;\\n};\\n\\n\\n// EVENTS\\n\\n\\n/**\\n * Triggers a 'pointerdown' event.\\n * @param {Object} data Pointer event data.\\n * @param {Event} event The event.\\n */\\nPointerEventHandler.prototype.down = function(data, event) {\\n  this.fireEvent(PointerEventType.POINTERDOWN, data, event);\\n};\\n\\n\\n/**\\n * Triggers a 'pointermove' event.\\n * @param {Object} data Pointer event data.\\n * @param {Event} event The event.\\n */\\nPointerEventHandler.prototype.move = function(data, event) {\\n  this.fireEvent(PointerEventType.POINTERMOVE, data, event);\\n};\\n\\n\\n/**\\n * Triggers a 'pointerup' event.\\n * @param {Object} data Pointer event data.\\n * @param {Event} event The event.\\n */\\nPointerEventHandler.prototype.up = function(data, event) {\\n  this.fireEvent(PointerEventType.POINTERUP, data, event);\\n};\\n\\n\\n/**\\n * Triggers a 'pointerenter' event.\\n * @param {Object} data Pointer event data.\\n * @param {Event} event The event.\\n */\\nPointerEventHandler.prototype.enter = function(data, event) {\\n  data.bubbles = false;\\n  this.fireEvent(PointerEventType.POINTERENTER, data, event);\\n};\\n\\n\\n/**\\n * Triggers a 'pointerleave' event.\\n * @param {Object} data Pointer event data.\\n * @param {Event} event The event.\\n */\\nPointerEventHandler.prototype.leave = function(data, event) {\\n  data.bubbles = false;\\n  this.fireEvent(PointerEventType.POINTERLEAVE, data, event);\\n};\\n\\n\\n/**\\n * Triggers a 'pointerover' event.\\n * @param {Object} data Pointer event data.\\n * @param {Event} event The event.\\n */\\nPointerEventHandler.prototype.over = function(data, event) {\\n  data.bubbles = true;\\n  this.fireEvent(PointerEventType.POINTEROVER, data, event);\\n};\\n\\n\\n/**\\n * Triggers a 'pointerout' event.\\n * @param {Object} data Pointer event data.\\n * @param {Event} event The event.\\n */\\nPointerEventHandler.prototype.out = function(data, event) {\\n  data.bubbles = true;\\n  this.fireEvent(PointerEventType.POINTEROUT, data, event);\\n};\\n\\n\\n/**\\n * Triggers a 'pointercancel' event.\\n * @param {Object} data Pointer event data.\\n * @param {Event} event The event.\\n */\\nPointerEventHandler.prototype.cancel = function(data, event) {\\n  this.fireEvent(PointerEventType.POINTERCANCEL, data, event);\\n};\\n\\n\\n/**\\n * Triggers a combination of 'pointerout' and 'pointerleave' events.\\n * @param {Object} data Pointer event data.\\n * @param {Event} event The event.\\n */\\nPointerEventHandler.prototype.leaveOut = function(data, event) {\\n  this.out(data, event);\\n  if (!this.contains_(data.target, data.relatedTarget)) {\\n    this.leave(data, event);\\n  }\\n};\\n\\n\\n/**\\n * Triggers a combination of 'pointerover' and 'pointerevents' events.\\n * @param {Object} data Pointer event data.\\n * @param {Event} event The event.\\n */\\nPointerEventHandler.prototype.enterOver = function(data, event) {\\n  this.over(data, event);\\n  if (!this.contains_(data.target, data.relatedTarget)) {\\n    this.enter(data, event);\\n  }\\n};\\n\\n\\n/**\\n * @private\\n * @param {Element} container The container element.\\n * @param {Element} contained The contained element.\\n * @return {boolean} Returns true if the container element\\n *   contains the other element.\\n */\\nPointerEventHandler.prototype.contains_ = function(container, contained) {\\n  if (!container || !contained) {\\n    return false;\\n  }\\n  return container.contains(contained);\\n};\\n\\n\\n// EVENT CREATION AND TRACKING\\n/**\\n * Creates a new Event of type `inType`, based on the information in\\n * `data`.\\n *\\n * @param {string} inType A string representing the type of event to create.\\n * @param {Object} data Pointer event data.\\n * @param {Event} event The event.\\n * @return {module:ol/pointer/PointerEvent} A PointerEvent of type `inType`.\\n */\\nPointerEventHandler.prototype.makeEvent = function(inType, data, event) {\\n  return new PointerEvent(inType, event, data);\\n};\\n\\n\\n/**\\n * Make and dispatch an event in one call.\\n * @param {string} inType A string representing the type of event.\\n * @param {Object} data Pointer event data.\\n * @param {Event} event The event.\\n */\\nPointerEventHandler.prototype.fireEvent = function(inType, data, event) {\\n  const e = this.makeEvent(inType, data, event);\\n  this.dispatchEvent(e);\\n};\\n\\n\\n/**\\n * Creates a pointer event from a native pointer event\\n * and dispatches this event.\\n * @param {Event} event A platform event with a target.\\n */\\nPointerEventHandler.prototype.fireNativeEvent = function(event) {\\n  const e = this.makeEvent(event.type, event, event);\\n  this.dispatchEvent(e);\\n};\\n\\n\\n/**\\n * Wrap a native mouse event into a pointer event.\\n * This proxy method is required for the legacy IE support.\\n * @param {string} eventType The pointer event type.\\n * @param {Event} event The event.\\n * @return {module:ol/pointer/PointerEvent} The wrapped event.\\n */\\nPointerEventHandler.prototype.wrapMouseEvent = function(eventType, event) {\\n  const pointerEvent = this.makeEvent(\\n    eventType, MouseSource.prepareEvent(event, this), event);\\n  return pointerEvent;\\n};\\n\\n\\n/**\\n * @inheritDoc\\n */\\nPointerEventHandler.prototype.disposeInternal = function() {\\n  this.unregister_();\\n  EventTarget.prototype.disposeInternal.call(this);\\n};\\n\\n\\nexport default PointerEventHandler;\\n\",\"/**\\n * @module ol/MapBrowserEventHandler\\n */\\nimport {inherits} from './index.js';\\nimport {DEVICE_PIXEL_RATIO} from './has.js';\\nimport MapBrowserEventType from './MapBrowserEventType.js';\\nimport MapBrowserPointerEvent from './MapBrowserPointerEvent.js';\\nimport {listen, unlistenByKey} from './events.js';\\nimport EventTarget from './events/EventTarget.js';\\nimport PointerEventType from './pointer/EventType.js';\\nimport PointerEventHandler from './pointer/PointerEventHandler.js';\\n\\n/**\\n * @param {module:ol/PluggableMap} map The map with the viewport to\\n * listen to events on.\\n * @param {number=} moveTolerance The minimal distance the pointer must travel\\n * to trigger a move.\\n * @constructor\\n * @extends {module:ol/events/EventTarget}\\n */\\nconst MapBrowserEventHandler = function(map, moveTolerance) {\\n\\n  EventTarget.call(this);\\n\\n  /**\\n   * This is the element that we will listen to the real events on.\\n   * @type {module:ol/PluggableMap}\\n   * @private\\n   */\\n  this.map_ = map;\\n\\n  /**\\n   * @type {number}\\n   * @private\\n   */\\n  this.clickTimeoutId_ = 0;\\n\\n  /**\\n   * @type {boolean}\\n   * @private\\n   */\\n  this.dragging_ = false;\\n\\n  /**\\n   * @type {!Array.<module:ol/events~EventsKey>}\\n   * @private\\n   */\\n  this.dragListenerKeys_ = [];\\n\\n  /**\\n   * @type {number}\\n   * @private\\n   */\\n  this.moveTolerance_ = moveTolerance ?\\n    moveTolerance * DEVICE_PIXEL_RATIO : DEVICE_PIXEL_RATIO;\\n\\n  /**\\n   * The most recent \\\"down\\\" type event (or null if none have occurred).\\n   * Set on pointerdown.\\n   * @type {module:ol/pointer/PointerEvent}\\n   * @private\\n   */\\n  this.down_ = null;\\n\\n  const element = this.map_.getViewport();\\n\\n  /**\\n   * @type {number}\\n   * @private\\n   */\\n  this.activePointers_ = 0;\\n\\n  /**\\n   * @type {!Object.<number, boolean>}\\n   * @private\\n   */\\n  this.trackedTouches_ = {};\\n\\n  /**\\n   * Event handler which generates pointer events for\\n   * the viewport element.\\n   *\\n   * @type {module:ol/pointer/PointerEventHandler}\\n   * @private\\n   */\\n  this.pointerEventHandler_ = new PointerEventHandler(element);\\n\\n  /**\\n   * Event handler which generates pointer events for\\n   * the document (used when dragging).\\n   *\\n   * @type {module:ol/pointer/PointerEventHandler}\\n   * @private\\n   */\\n  this.documentPointerEventHandler_ = null;\\n\\n  /**\\n   * @type {?module:ol/events~EventsKey}\\n   * @private\\n   */\\n  this.pointerdownListenerKey_ = listen(this.pointerEventHandler_,\\n    PointerEventType.POINTERDOWN,\\n    this.handlePointerDown_, this);\\n\\n  /**\\n   * @type {?module:ol/events~EventsKey}\\n   * @private\\n   */\\n  this.relayedListenerKey_ = listen(this.pointerEventHandler_,\\n    PointerEventType.POINTERMOVE,\\n    this.relayEvent_, this);\\n\\n};\\n\\ninherits(MapBrowserEventHandler, EventTarget);\\n\\n\\n/**\\n * @param {module:ol/pointer/PointerEvent} pointerEvent Pointer\\n * event.\\n * @private\\n */\\nMapBrowserEventHandler.prototype.emulateClick_ = function(pointerEvent) {\\n  let newEvent = new MapBrowserPointerEvent(\\n    MapBrowserEventType.CLICK, this.map_, pointerEvent);\\n  this.dispatchEvent(newEvent);\\n  if (this.clickTimeoutId_ !== 0) {\\n    // double-click\\n    clearTimeout(this.clickTimeoutId_);\\n    this.clickTimeoutId_ = 0;\\n    newEvent = new MapBrowserPointerEvent(\\n      MapBrowserEventType.DBLCLICK, this.map_, pointerEvent);\\n    this.dispatchEvent(newEvent);\\n  } else {\\n    // click\\n    this.clickTimeoutId_ = setTimeout(function() {\\n      this.clickTimeoutId_ = 0;\\n      const newEvent = new MapBrowserPointerEvent(\\n        MapBrowserEventType.SINGLECLICK, this.map_, pointerEvent);\\n      this.dispatchEvent(newEvent);\\n    }.bind(this), 250);\\n  }\\n};\\n\\n\\n/**\\n * Keeps track on how many pointers are currently active.\\n *\\n * @param {module:ol/pointer/PointerEvent} pointerEvent Pointer\\n * event.\\n * @private\\n */\\nMapBrowserEventHandler.prototype.updateActivePointers_ = function(pointerEvent) {\\n  const event = pointerEvent;\\n\\n  if (event.type == MapBrowserEventType.POINTERUP ||\\n      event.type == MapBrowserEventType.POINTERCANCEL) {\\n    delete this.trackedTouches_[event.pointerId];\\n  } else if (event.type == MapBrowserEventType.POINTERDOWN) {\\n    this.trackedTouches_[event.pointerId] = true;\\n  }\\n  this.activePointers_ = Object.keys(this.trackedTouches_).length;\\n};\\n\\n\\n/**\\n * @param {module:ol/pointer/PointerEvent} pointerEvent Pointer\\n * event.\\n * @private\\n */\\nMapBrowserEventHandler.prototype.handlePointerUp_ = function(pointerEvent) {\\n  this.updateActivePointers_(pointerEvent);\\n  const newEvent = new MapBrowserPointerEvent(\\n    MapBrowserEventType.POINTERUP, this.map_, pointerEvent);\\n  this.dispatchEvent(newEvent);\\n\\n  // We emulate click events on left mouse button click, touch contact, and pen\\n  // contact. isMouseActionButton returns true in these cases (evt.button is set\\n  // to 0).\\n  // See http://www.w3.org/TR/pointerevents/#button-states\\n  // We only fire click, singleclick, and doubleclick if nobody has called\\n  // event.stopPropagation() or event.preventDefault().\\n  if (!newEvent.propagationStopped && !this.dragging_ && this.isMouseActionButton_(pointerEvent)) {\\n    this.emulateClick_(this.down_);\\n  }\\n\\n  if (this.activePointers_ === 0) {\\n    this.dragListenerKeys_.forEach(unlistenByKey);\\n    this.dragListenerKeys_.length = 0;\\n    this.dragging_ = false;\\n    this.down_ = null;\\n    this.documentPointerEventHandler_.dispose();\\n    this.documentPointerEventHandler_ = null;\\n  }\\n};\\n\\n\\n/**\\n * @param {module:ol/pointer/PointerEvent} pointerEvent Pointer\\n * event.\\n * @return {boolean} If the left mouse button was pressed.\\n * @private\\n */\\nMapBrowserEventHandler.prototype.isMouseActionButton_ = function(pointerEvent) {\\n  return pointerEvent.button === 0;\\n};\\n\\n\\n/**\\n * @param {module:ol/pointer/PointerEvent} pointerEvent Pointer\\n * event.\\n * @private\\n */\\nMapBrowserEventHandler.prototype.handlePointerDown_ = function(pointerEvent) {\\n  this.updateActivePointers_(pointerEvent);\\n  const newEvent = new MapBrowserPointerEvent(\\n    MapBrowserEventType.POINTERDOWN, this.map_, pointerEvent);\\n  this.dispatchEvent(newEvent);\\n\\n  this.down_ = pointerEvent;\\n\\n  if (this.dragListenerKeys_.length === 0) {\\n    /* Set up a pointer event handler on the `document`,\\n     * which is required when the pointer is moved outside\\n     * the viewport when dragging.\\n     */\\n    this.documentPointerEventHandler_ =\\n        new PointerEventHandler(document);\\n\\n    this.dragListenerKeys_.push(\\n      listen(this.documentPointerEventHandler_,\\n        MapBrowserEventType.POINTERMOVE,\\n        this.handlePointerMove_, this),\\n      listen(this.documentPointerEventHandler_,\\n        MapBrowserEventType.POINTERUP,\\n        this.handlePointerUp_, this),\\n      /* Note that the listener for `pointercancel is set up on\\n       * `pointerEventHandler_` and not `documentPointerEventHandler_` like\\n       * the `pointerup` and `pointermove` listeners.\\n       *\\n       * The reason for this is the following: `TouchSource.vacuumTouches_()`\\n       * issues `pointercancel` events, when there was no `touchend` for a\\n       * `touchstart`. Now, let's say a first `touchstart` is registered on\\n       * `pointerEventHandler_`. The `documentPointerEventHandler_` is set up.\\n       * But `documentPointerEventHandler_` doesn't know about the first\\n       * `touchstart`. If there is no `touchend` for the `touchstart`, we can\\n       * only receive a `touchcancel` from `pointerEventHandler_`, because it is\\n       * only registered there.\\n       */\\n      listen(this.pointerEventHandler_,\\n        MapBrowserEventType.POINTERCANCEL,\\n        this.handlePointerUp_, this)\\n    );\\n  }\\n};\\n\\n\\n/**\\n * @param {module:ol/pointer/PointerEvent} pointerEvent Pointer\\n * event.\\n * @private\\n */\\nMapBrowserEventHandler.prototype.handlePointerMove_ = function(pointerEvent) {\\n  // Between pointerdown and pointerup, pointermove events are triggered.\\n  // To avoid a 'false' touchmove event to be dispatched, we test if the pointer\\n  // moved a significant distance.\\n  if (this.isMoving_(pointerEvent)) {\\n    this.dragging_ = true;\\n    const newEvent = new MapBrowserPointerEvent(\\n      MapBrowserEventType.POINTERDRAG, this.map_, pointerEvent,\\n      this.dragging_);\\n    this.dispatchEvent(newEvent);\\n  }\\n\\n  // Some native android browser triggers mousemove events during small period\\n  // of time. See: https://code.google.com/p/android/issues/detail?id=5491 or\\n  // https://code.google.com/p/android/issues/detail?id=19827\\n  // ex: Galaxy Tab P3110 + Android 4.1.1\\n  pointerEvent.preventDefault();\\n};\\n\\n\\n/**\\n * Wrap and relay a pointer event.  Note that this requires that the type\\n * string for the MapBrowserPointerEvent matches the PointerEvent type.\\n * @param {module:ol/pointer/PointerEvent} pointerEvent Pointer\\n * event.\\n * @private\\n */\\nMapBrowserEventHandler.prototype.relayEvent_ = function(pointerEvent) {\\n  const dragging = !!(this.down_ && this.isMoving_(pointerEvent));\\n  this.dispatchEvent(new MapBrowserPointerEvent(\\n    pointerEvent.type, this.map_, pointerEvent, dragging));\\n};\\n\\n\\n/**\\n * @param {module:ol/pointer/PointerEvent} pointerEvent Pointer\\n * event.\\n * @return {boolean} Is moving.\\n * @private\\n */\\nMapBrowserEventHandler.prototype.isMoving_ = function(pointerEvent) {\\n  return this.dragging_ ||\\n      Math.abs(pointerEvent.clientX - this.down_.clientX) > this.moveTolerance_ ||\\n      Math.abs(pointerEvent.clientY - this.down_.clientY) > this.moveTolerance_;\\n};\\n\\n\\n/**\\n * @inheritDoc\\n */\\nMapBrowserEventHandler.prototype.disposeInternal = function() {\\n  if (this.relayedListenerKey_) {\\n    unlistenByKey(this.relayedListenerKey_);\\n    this.relayedListenerKey_ = null;\\n  }\\n  if (this.pointerdownListenerKey_) {\\n    unlistenByKey(this.pointerdownListenerKey_);\\n    this.pointerdownListenerKey_ = null;\\n  }\\n\\n  this.dragListenerKeys_.forEach(unlistenByKey);\\n  this.dragListenerKeys_.length = 0;\\n\\n  if (this.documentPointerEventHandler_) {\\n    this.documentPointerEventHandler_.dispose();\\n    this.documentPointerEventHandler_ = null;\\n  }\\n  if (this.pointerEventHandler_) {\\n    this.pointerEventHandler_.dispose();\\n    this.pointerEventHandler_ = null;\\n  }\\n  EventTarget.prototype.disposeInternal.call(this);\\n};\\nexport default MapBrowserEventHandler;\\n\",\"/**\\n * @module ol/MapEventType\\n */\\n\\n/**\\n * @enum {string}\\n */\\nexport default {\\n\\n  /**\\n   * Triggered after a map frame is rendered.\\n   * @event module:ol/MapEvent~MapEvent#postrender\\n   * @api\\n   */\\n  POSTRENDER: 'postrender',\\n\\n  /**\\n   * Triggered when the map starts moving.\\n   * @event module:ol/MapEvent~MapEvent#movestart\\n   * @api\\n   */\\n  MOVESTART: 'movestart',\\n\\n  /**\\n   * Triggered after the map is moved.\\n   * @event module:ol/MapEvent~MapEvent#moveend\\n   * @api\\n   */\\n  MOVEEND: 'moveend'\\n\\n};\\n\",\"/**\\n * @module ol/MapProperty\\n */\\n\\n/**\\n * @enum {string}\\n */\\nexport default {\\n  LAYERGROUP: 'layergroup',\\n  SIZE: 'size',\\n  TARGET: 'target',\\n  VIEW: 'view'\\n};\\n\",\"/**\\n * @module ol/TileState\\n */\\n\\n/**\\n * @enum {number}\\n */\\nexport default {\\n  IDLE: 0,\\n  LOADING: 1,\\n  LOADED: 2,\\n  ERROR: 3,\\n  EMPTY: 4,\\n  ABORT: 5\\n};\\n\",\"/**\\n * @module ol/structs/PriorityQueue\\n */\\nimport {assert} from '../asserts.js';\\nimport {clear} from '../obj.js';\\n\\n/**\\n * Priority queue.\\n *\\n * The implementation is inspired from the Closure Library's Heap class and\\n * Python's heapq module.\\n *\\n * @see http://closure-library.googlecode.com/svn/docs/closure_goog_structs_heap.js.source.html\\n * @see http://hg.python.org/cpython/file/2.7/Lib/heapq.py\\n *\\n * @constructor\\n * @param {function(T): number} priorityFunction Priority function.\\n * @param {function(T): string} keyFunction Key function.\\n * @struct\\n * @template T\\n */\\nconst PriorityQueue = function(priorityFunction, keyFunction) {\\n\\n  /**\\n   * @type {function(T): number}\\n   * @private\\n   */\\n  this.priorityFunction_ = priorityFunction;\\n\\n  /**\\n   * @type {function(T): string}\\n   * @private\\n   */\\n  this.keyFunction_ = keyFunction;\\n\\n  /**\\n   * @type {Array.<T>}\\n   * @private\\n   */\\n  this.elements_ = [];\\n\\n  /**\\n   * @type {Array.<number>}\\n   * @private\\n   */\\n  this.priorities_ = [];\\n\\n  /**\\n   * @type {!Object.<string, boolean>}\\n   * @private\\n   */\\n  this.queuedElements_ = {};\\n\\n};\\n\\n\\n/**\\n * @type {number}\\n */\\nexport const DROP = Infinity;\\n\\n\\n/**\\n * FIXME empty description for jsdoc\\n */\\nPriorityQueue.prototype.clear = function() {\\n  this.elements_.length = 0;\\n  this.priorities_.length = 0;\\n  clear(this.queuedElements_);\\n};\\n\\n\\n/**\\n * Remove and return the highest-priority element. O(log N).\\n * @return {T} Element.\\n */\\nPriorityQueue.prototype.dequeue = function() {\\n  const elements = this.elements_;\\n  const priorities = this.priorities_;\\n  const element = elements[0];\\n  if (elements.length == 1) {\\n    elements.length = 0;\\n    priorities.length = 0;\\n  } else {\\n    elements[0] = elements.pop();\\n    priorities[0] = priorities.pop();\\n    this.siftUp_(0);\\n  }\\n  const elementKey = this.keyFunction_(element);\\n  delete this.queuedElements_[elementKey];\\n  return element;\\n};\\n\\n\\n/**\\n * Enqueue an element. O(log N).\\n * @param {T} element Element.\\n * @return {boolean} The element was added to the queue.\\n */\\nPriorityQueue.prototype.enqueue = function(element) {\\n  assert(!(this.keyFunction_(element) in this.queuedElements_),\\n    31); // Tried to enqueue an `element` that was already added to the queue\\n  const priority = this.priorityFunction_(element);\\n  if (priority != DROP) {\\n    this.elements_.push(element);\\n    this.priorities_.push(priority);\\n    this.queuedElements_[this.keyFunction_(element)] = true;\\n    this.siftDown_(0, this.elements_.length - 1);\\n    return true;\\n  }\\n  return false;\\n};\\n\\n\\n/**\\n * @return {number} Count.\\n */\\nPriorityQueue.prototype.getCount = function() {\\n  return this.elements_.length;\\n};\\n\\n\\n/**\\n * Gets the index of the left child of the node at the given index.\\n * @param {number} index The index of the node to get the left child for.\\n * @return {number} The index of the left child.\\n * @private\\n */\\nPriorityQueue.prototype.getLeftChildIndex_ = function(index) {\\n  return index * 2 + 1;\\n};\\n\\n\\n/**\\n * Gets the index of the right child of the node at the given index.\\n * @param {number} index The index of the node to get the right child for.\\n * @return {number} The index of the right child.\\n * @private\\n */\\nPriorityQueue.prototype.getRightChildIndex_ = function(index) {\\n  return index * 2 + 2;\\n};\\n\\n\\n/**\\n * Gets the index of the parent of the node at the given index.\\n * @param {number} index The index of the node to get the parent for.\\n * @return {number} The index of the parent.\\n * @private\\n */\\nPriorityQueue.prototype.getParentIndex_ = function(index) {\\n  return (index - 1) >> 1;\\n};\\n\\n\\n/**\\n * Make this a heap. O(N).\\n * @private\\n */\\nPriorityQueue.prototype.heapify_ = function() {\\n  let i;\\n  for (i = (this.elements_.length >> 1) - 1; i >= 0; i--) {\\n    this.siftUp_(i);\\n  }\\n};\\n\\n\\n/**\\n * @return {boolean} Is empty.\\n */\\nPriorityQueue.prototype.isEmpty = function() {\\n  return this.elements_.length === 0;\\n};\\n\\n\\n/**\\n * @param {string} key Key.\\n * @return {boolean} Is key queued.\\n */\\nPriorityQueue.prototype.isKeyQueued = function(key) {\\n  return key in this.queuedElements_;\\n};\\n\\n\\n/**\\n * @param {T} element Element.\\n * @return {boolean} Is queued.\\n */\\nPriorityQueue.prototype.isQueued = function(element) {\\n  return this.isKeyQueued(this.keyFunction_(element));\\n};\\n\\n\\n/**\\n * @param {number} index The index of the node to move down.\\n * @private\\n */\\nPriorityQueue.prototype.siftUp_ = function(index) {\\n  const elements = this.elements_;\\n  const priorities = this.priorities_;\\n  const count = elements.length;\\n  const element = elements[index];\\n  const priority = priorities[index];\\n  const startIndex = index;\\n\\n  while (index < (count >> 1)) {\\n    const lIndex = this.getLeftChildIndex_(index);\\n    const rIndex = this.getRightChildIndex_(index);\\n\\n    const smallerChildIndex = rIndex < count &&\\n        priorities[rIndex] < priorities[lIndex] ?\\n      rIndex : lIndex;\\n\\n    elements[index] = elements[smallerChildIndex];\\n    priorities[index] = priorities[smallerChildIndex];\\n    index = smallerChildIndex;\\n  }\\n\\n  elements[index] = element;\\n  priorities[index] = priority;\\n  this.siftDown_(startIndex, index);\\n};\\n\\n\\n/**\\n * @param {number} startIndex The index of the root.\\n * @param {number} index The index of the node to move up.\\n * @private\\n */\\nPriorityQueue.prototype.siftDown_ = function(startIndex, index) {\\n  const elements = this.elements_;\\n  const priorities = this.priorities_;\\n  const element = elements[index];\\n  const priority = priorities[index];\\n\\n  while (index > startIndex) {\\n    const parentIndex = this.getParentIndex_(index);\\n    if (priorities[parentIndex] > priority) {\\n      elements[index] = elements[parentIndex];\\n      priorities[index] = priorities[parentIndex];\\n      index = parentIndex;\\n    } else {\\n      break;\\n    }\\n  }\\n  elements[index] = element;\\n  priorities[index] = priority;\\n};\\n\\n\\n/**\\n * FIXME empty description for jsdoc\\n */\\nPriorityQueue.prototype.reprioritize = function() {\\n  const priorityFunction = this.priorityFunction_;\\n  const elements = this.elements_;\\n  const priorities = this.priorities_;\\n  let index = 0;\\n  const n = elements.length;\\n  let element, i, priority;\\n  for (i = 0; i < n; ++i) {\\n    element = elements[i];\\n    priority = priorityFunction(element);\\n    if (priority == DROP) {\\n      delete this.queuedElements_[this.keyFunction_(element)];\\n    } else {\\n      priorities[index] = priority;\\n      elements[index++] = element;\\n    }\\n  }\\n  elements.length = index;\\n  priorities.length = index;\\n  this.heapify_();\\n};\\nexport default PriorityQueue;\\n\",\"/**\\n * @module ol/TileQueue\\n */\\nimport {inherits} from './index.js';\\nimport TileState from './TileState.js';\\nimport {listen, unlisten} from './events.js';\\nimport EventType from './events/EventType.js';\\nimport PriorityQueue from './structs/PriorityQueue.js';\\n\\n\\n/**\\n * @typedef {function(module:ol/Tile, string, module:ol/coordinate~Coordinate, number): number} PriorityFunction\\n */\\n\\n\\n/**\\n * @constructor\\n * @extends {module:ol/structs/PriorityQueue.<Array>}\\n * @param {module:ol/TileQueue~PriorityFunction} tilePriorityFunction\\n *     Tile priority function.\\n * @param {function(): ?} tileChangeCallback\\n *     Function called on each tile change event.\\n * @struct\\n */\\nconst TileQueue = function(tilePriorityFunction, tileChangeCallback) {\\n\\n  PriorityQueue.call(\\n    this,\\n    /**\\n     * @param {Array} element Element.\\n     * @return {number} Priority.\\n     */\\n    function(element) {\\n      return tilePriorityFunction.apply(null, element);\\n    },\\n    /**\\n     * @param {Array} element Element.\\n     * @return {string} Key.\\n     */\\n    function(element) {\\n      return (/** @type {module:ol/Tile} */ (element[0]).getKey());\\n    });\\n\\n  /**\\n   * @private\\n   * @type {function(): ?}\\n   */\\n  this.tileChangeCallback_ = tileChangeCallback;\\n\\n  /**\\n   * @private\\n   * @type {number}\\n   */\\n  this.tilesLoading_ = 0;\\n\\n  /**\\n   * @private\\n   * @type {!Object.<string,boolean>}\\n   */\\n  this.tilesLoadingKeys_ = {};\\n\\n};\\n\\ninherits(TileQueue, PriorityQueue);\\n\\n\\n/**\\n * @inheritDoc\\n */\\nTileQueue.prototype.enqueue = function(element) {\\n  const added = PriorityQueue.prototype.enqueue.call(this, element);\\n  if (added) {\\n    const tile = element[0];\\n    listen(tile, EventType.CHANGE, this.handleTileChange, this);\\n  }\\n  return added;\\n};\\n\\n\\n/**\\n * @return {number} Number of tiles loading.\\n */\\nTileQueue.prototype.getTilesLoading = function() {\\n  return this.tilesLoading_;\\n};\\n\\n\\n/**\\n * @param {module:ol/events/Event} event Event.\\n * @protected\\n */\\nTileQueue.prototype.handleTileChange = function(event) {\\n  const tile = /** @type {module:ol/Tile} */ (event.target);\\n  const state = tile.getState();\\n  if (state === TileState.LOADED || state === TileState.ERROR ||\\n      state === TileState.EMPTY || state === TileState.ABORT) {\\n    unlisten(tile, EventType.CHANGE, this.handleTileChange, this);\\n    const tileKey = tile.getKey();\\n    if (tileKey in this.tilesLoadingKeys_) {\\n      delete this.tilesLoadingKeys_[tileKey];\\n      --this.tilesLoading_;\\n    }\\n    this.tileChangeCallback_();\\n  }\\n};\\n\\n\\n/**\\n * @param {number} maxTotalLoading Maximum number tiles to load simultaneously.\\n * @param {number} maxNewLoads Maximum number of new tiles to load.\\n */\\nTileQueue.prototype.loadMoreTiles = function(maxTotalLoading, maxNewLoads) {\\n  let newLoads = 0;\\n  let abortedTiles = false;\\n  let state, tile, tileKey;\\n  while (this.tilesLoading_ < maxTotalLoading && newLoads < maxNewLoads &&\\n         this.getCount() > 0) {\\n    tile = /** @type {module:ol/Tile} */ (this.dequeue()[0]);\\n    tileKey = tile.getKey();\\n    state = tile.getState();\\n    if (state === TileState.ABORT) {\\n      abortedTiles = true;\\n    } else if (state === TileState.IDLE && !(tileKey in this.tilesLoadingKeys_)) {\\n      this.tilesLoadingKeys_[tileKey] = true;\\n      ++this.tilesLoading_;\\n      ++newLoads;\\n      tile.load();\\n    }\\n  }\\n  if (newLoads === 0 && abortedTiles) {\\n    // Do not stop the render loop when all wanted tiles were aborted due to\\n    // a small, saturated tile cache.\\n    this.tileChangeCallback_();\\n  }\\n};\\nexport default TileQueue;\\n\",\"/**\\n * @module ol/tilegrid/common\\n */\\n\\n/**\\n * Default maximum zoom for default tile grids.\\n * @type {number}\\n */\\nexport const DEFAULT_MAX_ZOOM = 42;\\n\\n/**\\n * Default tile size.\\n * @type {number}\\n */\\nexport const DEFAULT_TILE_SIZE = 256;\\n\",\"/**\\n * @module ol/centerconstraint\\n */\\nimport {clamp} from './math.js';\\n\\n\\n/**\\n * @typedef {function((module:ol/coordinate~Coordinate|undefined)): (module:ol/coordinate~Coordinate|undefined)} Type\\n */\\n\\n\\n/**\\n * @param {module:ol/extent~Extent} extent Extent.\\n * @return {module:ol/centerconstraint~Type} The constraint.\\n */\\nexport function createExtent(extent) {\\n  return (\\n    /**\\n     * @param {module:ol/coordinate~Coordinate=} center Center.\\n     * @return {module:ol/coordinate~Coordinate|undefined} Center.\\n     */\\n    function(center) {\\n      if (center) {\\n        return [\\n          clamp(center[0], extent[0], extent[2]),\\n          clamp(center[1], extent[1], extent[3])\\n        ];\\n      } else {\\n        return undefined;\\n      }\\n    }\\n  );\\n}\\n\\n\\n/**\\n * @param {module:ol/coordinate~Coordinate=} center Center.\\n * @return {module:ol/coordinate~Coordinate|undefined} Center.\\n */\\nexport function none(center) {\\n  return center;\\n}\\n\",\"/**\\n * @module ol/rotationconstraint\\n */\\nimport {toRadians} from './math.js';\\n\\n\\n/**\\n * @typedef {function((number|undefined), number): (number|undefined)} Type\\n */\\n\\n\\n/**\\n * @param {number|undefined} rotation Rotation.\\n * @param {number} delta Delta.\\n * @return {number|undefined} Rotation.\\n */\\nexport function disable(rotation, delta) {\\n  if (rotation !== undefined) {\\n    return 0;\\n  } else {\\n    return undefined;\\n  }\\n}\\n\\n\\n/**\\n * @param {number|undefined} rotation Rotation.\\n * @param {number} delta Delta.\\n * @return {number|undefined} Rotation.\\n */\\nexport function none(rotation, delta) {\\n  if (rotation !== undefined) {\\n    return rotation + delta;\\n  } else {\\n    return undefined;\\n  }\\n}\\n\\n\\n/**\\n * @param {number} n N.\\n * @return {module:ol/rotationconstraint~Type} Rotation constraint.\\n */\\nexport function createSnapToN(n) {\\n  const theta = 2 * Math.PI / n;\\n  return (\\n    /**\\n     * @param {number|undefined} rotation Rotation.\\n     * @param {number} delta Delta.\\n     * @return {number|undefined} Rotation.\\n     */\\n    function(rotation, delta) {\\n      if (rotation !== undefined) {\\n        rotation = Math.floor((rotation + delta) / theta + 0.5) * theta;\\n        return rotation;\\n      } else {\\n        return undefined;\\n      }\\n    });\\n}\\n\\n\\n/**\\n * @param {number=} opt_tolerance Tolerance.\\n * @return {module:ol/rotationconstraint~Type} Rotation constraint.\\n */\\nexport function createSnapToZero(opt_tolerance) {\\n  const tolerance = opt_tolerance || toRadians(5);\\n  return (\\n    /**\\n     * @param {number|undefined} rotation Rotation.\\n     * @param {number} delta Delta.\\n     * @return {number|undefined} Rotation.\\n     */\\n    function(rotation, delta) {\\n      if (rotation !== undefined) {\\n        if (Math.abs(rotation + delta) <= tolerance) {\\n          return 0;\\n        } else {\\n          return rotation + delta;\\n        }\\n      } else {\\n        return undefined;\\n      }\\n    });\\n}\\n\",\"/**\\n * @module ol/ViewHint\\n */\\n\\n/**\\n * @enum {number}\\n */\\nexport default {\\n  ANIMATING: 0,\\n  INTERACTING: 1\\n};\\n\",\"/**\\n * @module ol/ViewProperty\\n */\\n\\n/**\\n * @enum {string}\\n */\\nexport default {\\n  CENTER: 'center',\\n  RESOLUTION: 'resolution',\\n  ROTATION: 'rotation'\\n};\\n\",\"/**\\n * @module ol/coordinate\\n */\\nimport {modulo} from './math.js';\\nimport {padNumber} from './string.js';\\n\\n\\n/**\\n * An array of numbers representing an xy coordinate. Example: `[16, 48]`.\\n * @typedef {Array.<number>} Coordinate\\n * @api\\n */\\n\\n\\n/**\\n * A function that takes a {@link module:ol/coordinate~Coordinate} and\\n * transforms it into a `{string}`.\\n *\\n * @typedef {function((module:ol/coordinate~Coordinate|undefined)): string} CoordinateFormat\\n * @api\\n */\\n\\n\\n/**\\n * Add `delta` to `coordinate`. `coordinate` is modified in place and returned\\n * by the function.\\n *\\n * Example:\\n *\\n *     import {add} from 'ol/coordinate';\\n *\\n *     var coord = [7.85, 47.983333];\\n *     add(coord, [-2, 4]);\\n *     // coord is now [5.85, 51.983333]\\n *\\n * @param {module:ol/coordinate~Coordinate} coordinate Coordinate.\\n * @param {module:ol/coordinate~Coordinate} delta Delta.\\n * @return {module:ol/coordinate~Coordinate} The input coordinate adjusted by\\n * the given delta.\\n * @api\\n */\\nexport function add(coordinate, delta) {\\n  coordinate[0] += delta[0];\\n  coordinate[1] += delta[1];\\n  return coordinate;\\n}\\n\\n\\n/**\\n * Calculates the point closest to the passed coordinate on the passed circle.\\n *\\n * @param {module:ol/coordinate~Coordinate} coordinate The coordinate.\\n * @param {module:ol/geom/Circle} circle The circle.\\n * @return {module:ol/coordinate~Coordinate} Closest point on the circumference.\\n */\\nexport function closestOnCircle(coordinate, circle) {\\n  const r = circle.getRadius();\\n  const center = circle.getCenter();\\n  const x0 = center[0];\\n  const y0 = center[1];\\n  const x1 = coordinate[0];\\n  const y1 = coordinate[1];\\n\\n  let dx = x1 - x0;\\n  const dy = y1 - y0;\\n  if (dx === 0 && dy === 0) {\\n    dx = 1;\\n  }\\n  const d = Math.sqrt(dx * dx + dy * dy);\\n\\n  const x = x0 + r * dx / d;\\n  const y = y0 + r * dy / d;\\n\\n  return [x, y];\\n}\\n\\n\\n/**\\n * Calculates the point closest to the passed coordinate on the passed segment.\\n * This is the foot of the perpendicular of the coordinate to the segment when\\n * the foot is on the segment, or the closest segment coordinate when the foot\\n * is outside the segment.\\n *\\n * @param {module:ol/coordinate~Coordinate} coordinate The coordinate.\\n * @param {Array.<module:ol/coordinate~Coordinate>} segment The two coordinates\\n * of the segment.\\n * @return {module:ol/coordinate~Coordinate} The foot of the perpendicular of\\n * the coordinate to the segment.\\n */\\nexport function closestOnSegment(coordinate, segment) {\\n  const x0 = coordinate[0];\\n  const y0 = coordinate[1];\\n  const start = segment[0];\\n  const end = segment[1];\\n  const x1 = start[0];\\n  const y1 = start[1];\\n  const x2 = end[0];\\n  const y2 = end[1];\\n  const dx = x2 - x1;\\n  const dy = y2 - y1;\\n  const along = (dx === 0 && dy === 0) ? 0 :\\n    ((dx * (x0 - x1)) + (dy * (y0 - y1))) / ((dx * dx + dy * dy) || 0);\\n  let x, y;\\n  if (along <= 0) {\\n    x = x1;\\n    y = y1;\\n  } else if (along >= 1) {\\n    x = x2;\\n    y = y2;\\n  } else {\\n    x = x1 + along * dx;\\n    y = y1 + along * dy;\\n  }\\n  return [x, y];\\n}\\n\\n\\n/**\\n * Returns a {@link module:ol/coordinate~CoordinateFormat} function that can be\\n * used to format\\n * a {module:ol/coordinate~Coordinate} to a string.\\n *\\n * Example without specifying the fractional digits:\\n *\\n *     import {createStringXY} from 'ol/coordinate';\\n *\\n *     var coord = [7.85, 47.983333];\\n *     var stringifyFunc = createStringXY();\\n *     var out = stringifyFunc(coord);\\n *     // out is now '8, 48'\\n *\\n * Example with explicitly specifying 2 fractional digits:\\n *\\n *     import {createStringXY} from 'ol/coordinate';\\n *\\n *     var coord = [7.85, 47.983333];\\n *     var stringifyFunc = createStringXY(2);\\n *     var out = stringifyFunc(coord);\\n *     // out is now '7.85, 47.98'\\n *\\n * @param {number=} opt_fractionDigits The number of digits to include\\n *    after the decimal point. Default is `0`.\\n * @return {module:ol/coordinate~CoordinateFormat} Coordinate format.\\n * @api\\n */\\nexport function createStringXY(opt_fractionDigits) {\\n  return (\\n    /**\\n     * @param {module:ol/coordinate~Coordinate} coordinate Coordinate.\\n     * @return {string} String XY.\\n     */\\n    function(coordinate) {\\n      return toStringXY(coordinate, opt_fractionDigits);\\n    }\\n  );\\n}\\n\\n\\n/**\\n * @param {string} hemispheres Hemispheres.\\n * @param {number} degrees Degrees.\\n * @param {number=} opt_fractionDigits The number of digits to include\\n *    after the decimal point. Default is `0`.\\n * @return {string} String.\\n */\\nexport function degreesToStringHDMS(hemispheres, degrees, opt_fractionDigits) {\\n  const normalizedDegrees = modulo(degrees + 180, 360) - 180;\\n  const x = Math.abs(3600 * normalizedDegrees);\\n  const dflPrecision = opt_fractionDigits || 0;\\n  const precision = Math.pow(10, dflPrecision);\\n\\n  let deg = Math.floor(x / 3600);\\n  let min = Math.floor((x - deg * 3600) / 60);\\n  let sec = x - (deg * 3600) - (min * 60);\\n  sec = Math.ceil(sec * precision) / precision;\\n\\n  if (sec >= 60) {\\n    sec = 0;\\n    min += 1;\\n  }\\n\\n  if (min >= 60) {\\n    min = 0;\\n    deg += 1;\\n  }\\n\\n  return deg + '\\\\u00b0 ' + padNumber(min, 2) + '\\\\u2032 ' +\\n    padNumber(sec, 2, dflPrecision) + '\\\\u2033' +\\n    (normalizedDegrees == 0 ? '' : ' ' + hemispheres.charAt(normalizedDegrees < 0 ? 1 : 0));\\n}\\n\\n\\n/**\\n * Transforms the given {@link module:ol/coordinate~Coordinate} to a string\\n * using the given string template. The strings `{x}` and `{y}` in the template\\n * will be replaced with the first and second coordinate values respectively.\\n *\\n * Example without specifying the fractional digits:\\n *\\n *     import {format} from 'ol/coordinate';\\n *\\n *     var coord = [7.85, 47.983333];\\n *     var template = 'Coordinate is ({x}|{y}).';\\n *     var out = format(coord, template);\\n *     // out is now 'Coordinate is (8|48).'\\n *\\n * Example explicitly specifying the fractional digits:\\n *\\n *     import {format} from 'ol/coordinate';\\n *\\n *     var coord = [7.85, 47.983333];\\n *     var template = 'Coordinate is ({x}|{y}).';\\n *     var out = format(coord, template, 2);\\n *     // out is now 'Coordinate is (7.85|47.98).'\\n *\\n * @param {module:ol/coordinate~Coordinate} coordinate Coordinate.\\n * @param {string} template A template string with `{x}` and `{y}` placeholders\\n *     that will be replaced by first and second coordinate values.\\n * @param {number=} opt_fractionDigits The number of digits to include\\n *    after the decimal point. Default is `0`.\\n * @return {string} Formatted coordinate.\\n * @api\\n */\\nexport function format(coordinate, template, opt_fractionDigits) {\\n  if (coordinate) {\\n    return template\\n      .replace('{x}', coordinate[0].toFixed(opt_fractionDigits))\\n      .replace('{y}', coordinate[1].toFixed(opt_fractionDigits));\\n  } else {\\n    return '';\\n  }\\n}\\n\\n\\n/**\\n * @param {module:ol/coordinate~Coordinate} coordinate1 First coordinate.\\n * @param {module:ol/coordinate~Coordinate} coordinate2 Second coordinate.\\n * @return {boolean} The two coordinates are equal.\\n */\\nexport function equals(coordinate1, coordinate2) {\\n  let equals = true;\\n  for (let i = coordinate1.length - 1; i >= 0; --i) {\\n    if (coordinate1[i] != coordinate2[i]) {\\n      equals = false;\\n      break;\\n    }\\n  }\\n  return equals;\\n}\\n\\n\\n/**\\n * Rotate `coordinate` by `angle`. `coordinate` is modified in place and\\n * returned by the function.\\n *\\n * Example:\\n *\\n *     import {rotate} from 'ol/coordinate';\\n *\\n *     var coord = [7.85, 47.983333];\\n *     var rotateRadians = Math.PI / 2; // 90 degrees\\n *     rotate(coord, rotateRadians);\\n *     // coord is now [-47.983333, 7.85]\\n *\\n * @param {module:ol/coordinate~Coordinate} coordinate Coordinate.\\n * @param {number} angle Angle in radian.\\n * @return {module:ol/coordinate~Coordinate} Coordinate.\\n * @api\\n */\\nexport function rotate(coordinate, angle) {\\n  const cosAngle = Math.cos(angle);\\n  const sinAngle = Math.sin(angle);\\n  const x = coordinate[0] * cosAngle - coordinate[1] * sinAngle;\\n  const y = coordinate[1] * cosAngle + coordinate[0] * sinAngle;\\n  coordinate[0] = x;\\n  coordinate[1] = y;\\n  return coordinate;\\n}\\n\\n\\n/**\\n * Scale `coordinate` by `scale`. `coordinate` is modified in place and returned\\n * by the function.\\n *\\n * Example:\\n *\\n *     import {scale as scaleCoordinate} from 'ol/coordinate';\\n *\\n *     var coord = [7.85, 47.983333];\\n *     var scale = 1.2;\\n *     scaleCoordinate(coord, scale);\\n *     // coord is now [9.42, 57.5799996]\\n *\\n * @param {module:ol/coordinate~Coordinate} coordinate Coordinate.\\n * @param {number} scale Scale factor.\\n * @return {module:ol/coordinate~Coordinate} Coordinate.\\n */\\nexport function scale(coordinate, scale) {\\n  coordinate[0] *= scale;\\n  coordinate[1] *= scale;\\n  return coordinate;\\n}\\n\\n\\n/**\\n * @param {module:ol/coordinate~Coordinate} coord1 First coordinate.\\n * @param {module:ol/coordinate~Coordinate} coord2 Second coordinate.\\n * @return {number} Squared distance between coord1 and coord2.\\n */\\nexport function squaredDistance(coord1, coord2) {\\n  const dx = coord1[0] - coord2[0];\\n  const dy = coord1[1] - coord2[1];\\n  return dx * dx + dy * dy;\\n}\\n\\n\\n/**\\n * @param {module:ol/coordinate~Coordinate} coord1 First coordinate.\\n * @param {module:ol/coordinate~Coordinate} coord2 Second coordinate.\\n * @return {number} Distance between coord1 and coord2.\\n */\\nexport function distance(coord1, coord2) {\\n  return Math.sqrt(squaredDistance(coord1, coord2));\\n}\\n\\n\\n/**\\n * Calculate the squared distance from a coordinate to a line segment.\\n *\\n * @param {module:ol/coordinate~Coordinate} coordinate Coordinate of the point.\\n * @param {Array.<module:ol/coordinate~Coordinate>} segment Line segment (2\\n * coordinates).\\n * @return {number} Squared distance from the point to the line segment.\\n */\\nexport function squaredDistanceToSegment(coordinate, segment) {\\n  return squaredDistance(coordinate,\\n    closestOnSegment(coordinate, segment));\\n}\\n\\n\\n/**\\n * Format a geographic coordinate with the hemisphere, degrees, minutes, and\\n * seconds.\\n *\\n * Example without specifying fractional digits:\\n *\\n *     import {toStringHDMS} from 'ol/coordinate';\\n *\\n *     var coord = [7.85, 47.983333];\\n *     var out = toStringHDMS(coord);\\n *     // out is now '47 58 60 N 7 50 60 E'\\n *\\n * Example explicitly specifying 1 fractional digit:\\n *\\n *     import {toStringHDMS} from 'ol/coordinate';\\n *\\n *     var coord = [7.85, 47.983333];\\n *     var out = toStringHDMS(coord, 1);\\n *     // out is now '47 58 60.0 N 7 50 60.0 E'\\n *\\n * @param {module:ol/coordinate~Coordinate} coordinate Coordinate.\\n * @param {number=} opt_fractionDigits The number of digits to include\\n *    after the decimal point. Default is `0`.\\n * @return {string} Hemisphere, degrees, minutes and seconds.\\n * @api\\n */\\nexport function toStringHDMS(coordinate, opt_fractionDigits) {\\n  if (coordinate) {\\n    return degreesToStringHDMS('NS', coordinate[1], opt_fractionDigits) + ' ' +\\n        degreesToStringHDMS('EW', coordinate[0], opt_fractionDigits);\\n  } else {\\n    return '';\\n  }\\n}\\n\\n\\n/**\\n * Format a coordinate as a comma delimited string.\\n *\\n * Example without specifying fractional digits:\\n *\\n *     import {toStringXY} from 'ol/coordinate';\\n *\\n *     var coord = [7.85, 47.983333];\\n *     var out = toStringXY(coord);\\n *     // out is now '8, 48'\\n *\\n * Example explicitly specifying 1 fractional digit:\\n *\\n *     import {toStringXY} from 'ol/coordinate';\\n *\\n *     var coord = [7.85, 47.983333];\\n *     var out = toStringXY(coord, 1);\\n *     // out is now '7.8, 48.0'\\n *\\n * @param {module:ol/coordinate~Coordinate} coordinate Coordinate.\\n * @param {number=} opt_fractionDigits The number of digits to include\\n *    after the decimal point. Default is `0`.\\n * @return {string} XY.\\n * @api\\n */\\nexport function toStringXY(coordinate, opt_fractionDigits) {\\n  return format(coordinate, '{x}, {y}', opt_fractionDigits);\\n}\\n\",\"/**\\n * @module ol/easing\\n */\\n\\n\\n/**\\n * Start slow and speed up.\\n * @param {number} t Input between 0 and 1.\\n * @return {number} Output between 0 and 1.\\n * @api\\n */\\nexport function easeIn(t) {\\n  return Math.pow(t, 3);\\n}\\n\\n\\n/**\\n * Start fast and slow down.\\n * @param {number} t Input between 0 and 1.\\n * @return {number} Output between 0 and 1.\\n * @api\\n */\\nexport function easeOut(t) {\\n  return 1 - easeIn(1 - t);\\n}\\n\\n\\n/**\\n * Start slow, speed up, and then slow down again.\\n * @param {number} t Input between 0 and 1.\\n * @return {number} Output between 0 and 1.\\n * @api\\n */\\nexport function inAndOut(t) {\\n  return 3 * t * t - 2 * t * t * t;\\n}\\n\\n\\n/**\\n * Maintain a constant speed over time.\\n * @param {number} t Input between 0 and 1.\\n * @return {number} Output between 0 and 1.\\n * @api\\n */\\nexport function linear(t) {\\n  return t;\\n}\\n\\n\\n/**\\n * Start slow, speed up, and at the very end slow down again.  This has the\\n * same general behavior as {@link module:ol/easing~inAndOut}, but the final\\n * slowdown is delayed.\\n * @param {number} t Input between 0 and 1.\\n * @return {number} Output between 0 and 1.\\n * @api\\n */\\nexport function upAndDown(t) {\\n  if (t < 0.5) {\\n    return inAndOut(2 * t);\\n  } else {\\n    return 1 - inAndOut(2 * (t - 0.5));\\n  }\\n}\\n\",\"/**\\n * @module ol/View\\n */\\nimport {DEFAULT_TILE_SIZE} from './tilegrid/common.js';\\nimport {inherits, getUid} from './index.js';\\nimport {UNDEFINED} from './functions.js';\\nimport {createExtent, none as centerNone} from './centerconstraint.js';\\nimport BaseObject from './Object.js';\\nimport {createSnapToResolutions, createSnapToPower} from './resolutionconstraint.js';\\nimport {createSnapToZero, createSnapToN, none as rotationNone, disable} from './rotationconstraint.js';\\nimport ViewHint from './ViewHint.js';\\nimport ViewProperty from './ViewProperty.js';\\nimport {linearFindNearest} from './array.js';\\nimport {assert} from './asserts.js';\\nimport {add as addCoordinate, rotate as rotateCoordinate, equals as coordinatesEqual} from './coordinate.js';\\nimport {inAndOut} from './easing.js';\\nimport {getForViewAndSize, getCenter, getHeight, getWidth, isEmpty} from './extent.js';\\nimport GeometryType from './geom/GeometryType.js';\\nimport {fromExtent as polygonFromExtent} from './geom/Polygon.js';\\nimport SimpleGeometry from './geom/SimpleGeometry.js';\\nimport {clamp, modulo} from './math.js';\\nimport {assign} from './obj.js';\\nimport {createProjection, METERS_PER_UNIT} from './proj.js';\\nimport Units from './proj/Units.js';\\n\\n\\n/**\\n * An animation configuration\\n *\\n * @typedef {Object} Animation\\n * @property {module:ol/coordinate~Coordinate} [sourceCenter]\\n * @property {module:ol/coordinate~Coordinate} [targetCenter]\\n * @property {number} [sourceResolution]\\n * @property {number} [targetResolution]\\n * @property {number} [sourceRotation]\\n * @property {number} [sourceRotation]\\n * @property {module:ol/coordinate~Coordinate} [anchor]\\n * @property {number} start\\n * @property {number} duration\\n * @property {boolean} complete\\n * @property {function(number):number} easing\\n * @property {function(boolean)} callback\\n */\\n\\n\\n/**\\n * @typedef {Object} Constraints\\n * @property {module:ol/centerconstraint~Type} center\\n * @property {module:ol/resolutionconstraint~Type} resolution\\n * @property {module:ol/rotationconstraint~Type} rotation\\n */\\n\\n\\n/**\\n * @typedef {Object} FitOptions\\n * @property {module:ol/size~Size} [size] The size in pixels of the box to fit\\n * the extent into. Default is the current size of the first map in the DOM that\\n * uses this view, or `[100, 100]` if no such map is found.\\n * @property {!Array.<number>} [padding=[0, 0, 0, 0]] Padding (in pixels) to be\\n * cleared inside the view. Values in the array are top, right, bottom and left\\n * padding.\\n * @property {boolean} [constrainResolution=true] Constrain the resolution.\\n * @property {boolean} [nearest=false] If `constrainResolution` is `true`, get\\n * the nearest extent instead of the closest that actually fits the view.\\n * @property {number} [minResolution=0] Minimum resolution that we zoom to.\\n * @property {number} [maxZoom] Maximum zoom level that we zoom to. If\\n * `minResolution` is given, this property is ignored.\\n * @property {number} [duration] The duration of the animation in milliseconds.\\n * By default, there is no animation to the target extent.\\n * @property {function(number):number} [easing] The easing function used during\\n * the animation (defaults to {@link module:ol/easing~inAndOut}).\\n * The function will be called for each frame with a number representing a\\n * fraction of the animation's duration.  The function should return a number\\n * between 0 and 1 representing the progress toward the destination state.\\n * @property {function(boolean)} [callback] Function called when the view is in\\n * its final position. The callback will be called with `true` if the animation\\n * series completed on its own or `false` if it was cancelled.\\n */\\n\\n\\n/**\\n * @typedef {Object} ViewOptions\\n * @property {module:ol/coordinate~Coordinate} [center] The initial center for\\n * the view. The coordinate system for the center is specified with the\\n * `projection` option. Layer sources will not be fetched if this is not set,\\n * but the center can be set later with {@link #setCenter}.\\n * @property {boolean|number} [constrainRotation=true] Rotation constraint.\\n * `false` means no constraint. `true` means no constraint, but snap to zero\\n * near zero. A number constrains the rotation to that number of values. For\\n * example, `4` will constrain the rotation to 0, 90, 180, and 270 degrees.\\n * @property {boolean} [enableRotation=true] Enable rotation.\\n * If `false`, a rotation constraint that always sets the rotation to zero is\\n * used. The `constrainRotation` option has no effect if `enableRotation` is\\n * `false`.\\n * @property {module:ol/extent~Extent} [extent] The extent that constrains the\\n * center, in other words, center cannot be set outside this extent.\\n * @property {number} [maxResolution] The maximum resolution used to determine\\n * the resolution constraint. It is used together with `minResolution` (or\\n * `maxZoom`) and `zoomFactor`. If unspecified it is calculated in such a way\\n * that the projection's validity extent fits in a 256x256 px tile. If the\\n * projection is Spherical Mercator (the default) then `maxResolution` defaults\\n * to `40075016.68557849 / 256 = 156543.03392804097`.\\n * @property {number} [minResolution] The minimum resolution used to determine\\n * the resolution constraint.  It is used together with `maxResolution` (or\\n * `minZoom`) and `zoomFactor`.  If unspecified it is calculated assuming 29\\n * zoom levels (with a factor of 2). If the projection is Spherical Mercator\\n * (the default) then `minResolution` defaults to\\n * `40075016.68557849 / 256 / Math.pow(2, 28) = 0.0005831682455839253`.\\n * @property {number} [maxZoom=28] The maximum zoom level used to determine the\\n * resolution constraint. It is used together with `minZoom` (or\\n * `maxResolution`) and `zoomFactor`.  Note that if `minResolution` is also\\n * provided, it is given precedence over `maxZoom`.\\n * @property {number} [minZoom=0] The minimum zoom level used to determine the\\n * resolution constraint. It is used together with `maxZoom` (or\\n * `minResolution`) and `zoomFactor`.  Note that if `maxResolution` is also\\n * provided, it is given precedence over `minZoom`.\\n * @property {module:ol/proj~ProjectionLike} [projection='EPSG:3857'] The\\n * projection. The default is Spherical Mercator.\\n * @property {number} [resolution] The initial resolution for the view. The\\n * units are `projection` units per pixel (e.g. meters per pixel). An\\n * alternative to setting this is to set `zoom`. Layer sources will not be\\n * fetched if neither this nor `zoom` are defined, but they can be set later\\n * with {@link #setZoom} or {@link #setResolution}.\\n * @property {Array.<number>} [resolutions] Resolutions to determine the\\n * resolution constraint. If set the `maxResolution`, `minResolution`,\\n * `minZoom`, `maxZoom`, and `zoomFactor` options are ignored.\\n * @property {number} [rotation=0] The initial rotation for the view in radians\\n * (positive rotation clockwise, 0 means North).\\n * @property {number} [zoom] Only used if `resolution` is not defined. Zoom\\n * level used to calculate the initial resolution for the view. The initial\\n * resolution is determined using the {@link #constrainResolution} method.\\n * @property {number} [zoomFactor=2] The zoom factor used to determine the\\n * resolution constraint.\\n */\\n\\n\\n/**\\n * @typedef {Object} AnimationOptions\\n * @property {module:ol/coordinate~Coordinate|undefined} center The center of the view at the end of\\n * the animation.\\n * @property {number|undefined} zoom The zoom level of the view at the end of the\\n * animation. This takes precedence over `resolution`.\\n * @property {number|undefined} resolution The resolution of the view at the end\\n * of the animation.  If `zoom` is also provided, this option will be ignored.\\n * @property {number|undefined} rotation The rotation of the view at the end of\\n * the animation.\\n * @property {module:ol/coordinate~Coordinate|undefined} anchor Optional anchor to remained fixed\\n * during a rotation or resolution animation.\\n * @property {number} [duration=1000] The duration of the animation in milliseconds.\\n * @property {function(number):number} [easing] The easing function used\\n * during the animation (defaults to {@link module:ol/easing~inAndOut}).\\n * The function will be called for each frame with a number representing a\\n * fraction of the animation's duration.  The function should return a number\\n * between 0 and 1 representing the progress toward the destination state.\\n */\\n\\n\\n/**\\n * @typedef {Object} State\\n * @property {module:ol/coordinate~Coordinate} center\\n * @property {module:ol/proj/Projection} projection\\n * @property {number} resolution\\n * @property {number} rotation\\n * @property {number} zoom\\n */\\n\\n\\n/**\\n * Default min zoom level for the map view.\\n * @type {number}\\n */\\nconst DEFAULT_MIN_ZOOM = 0;\\n\\n\\n/**\\n * @classdesc\\n * A View object represents a simple 2D view of the map.\\n *\\n * This is the object to act upon to change the center, resolution,\\n * and rotation of the map.\\n *\\n * ### The view states\\n *\\n * An View is determined by three states: `center`, `resolution`,\\n * and `rotation`. Each state has a corresponding getter and setter, e.g.\\n * `getCenter` and `setCenter` for the `center` state.\\n *\\n * An View has a `projection`. The projection determines the\\n * coordinate system of the center, and its units determine the units of the\\n * resolution (projection units per pixel). The default projection is\\n * Spherical Mercator (EPSG:3857).\\n *\\n * ### The constraints\\n *\\n * `setCenter`, `setResolution` and `setRotation` can be used to change the\\n * states of the view. Any value can be passed to the setters. And the value\\n * that is passed to a setter will effectively be the value set in the view,\\n * and returned by the corresponding getter.\\n *\\n * But a View object also has a *resolution constraint*, a\\n * *rotation constraint* and a *center constraint*.\\n *\\n * As said above, no constraints are applied when the setters are used to set\\n * new states for the view. Applying constraints is done explicitly through\\n * the use of the `constrain*` functions (`constrainResolution` and\\n * `constrainRotation` and `constrainCenter`).\\n *\\n * The main users of the constraints are the interactions and the\\n * controls. For example, double-clicking on the map changes the view to\\n * the \\\"next\\\" resolution. And releasing the fingers after pinch-zooming\\n * snaps to the closest resolution (with an animation).\\n *\\n * The *resolution constraint* snaps to specific resolutions. It is\\n * determined by the following options: `resolutions`, `maxResolution`,\\n * `maxZoom`, and `zoomFactor`. If `resolutions` is set, the other three\\n * options are ignored. See documentation for each option for more\\n * information.\\n *\\n * The *rotation constraint* snaps to specific angles. It is determined\\n * by the following options: `enableRotation` and `constrainRotation`.\\n * By default the rotation value is snapped to zero when approaching the\\n * horizontal.\\n *\\n * The *center constraint* is determined by the `extent` option. By\\n * default the center is not constrained at all.\\n *\\n * @constructor\\n * @extends {module:ol/Object}\\n * @param {module:ol/View~ViewOptions=} opt_options View options.\\n * @api\\n */\\nconst View = function(opt_options) {\\n  BaseObject.call(this);\\n\\n  const options = assign({}, opt_options);\\n\\n  /**\\n   * @private\\n   * @type {Array.<number>}\\n   */\\n  this.hints_ = [0, 0];\\n\\n  /**\\n   * @private\\n   * @type {Array.<Array.<module:ol/View~Animation>>}\\n   */\\n  this.animations_ = [];\\n\\n  /**\\n   * @private\\n   * @type {number|undefined}\\n   */\\n  this.updateAnimationKey_;\\n\\n  this.updateAnimations_ = this.updateAnimations_.bind(this);\\n\\n  /**\\n   * @private\\n   * @const\\n   * @type {module:ol/proj/Projection}\\n   */\\n  this.projection_ = createProjection(options.projection, 'EPSG:3857');\\n\\n  this.applyOptions_(options);\\n};\\n\\ninherits(View, BaseObject);\\n\\n\\n/**\\n * Set up the view with the given options.\\n * @param {module:ol/View~ViewOptions} options View options.\\n */\\nView.prototype.applyOptions_ = function(options) {\\n\\n  /**\\n   * @type {Object.<string, *>}\\n   */\\n  const properties = {};\\n  properties[ViewProperty.CENTER] = options.center !== undefined ?\\n    options.center : null;\\n\\n  const resolutionConstraintInfo = createResolutionConstraint(options);\\n\\n  /**\\n   * @private\\n   * @type {number}\\n   */\\n  this.maxResolution_ = resolutionConstraintInfo.maxResolution;\\n\\n  /**\\n   * @private\\n   * @type {number}\\n   */\\n  this.minResolution_ = resolutionConstraintInfo.minResolution;\\n\\n  /**\\n   * @private\\n   * @type {number}\\n   */\\n  this.zoomFactor_ = resolutionConstraintInfo.zoomFactor;\\n\\n  /**\\n   * @private\\n   * @type {Array.<number>|undefined}\\n   */\\n  this.resolutions_ = options.resolutions;\\n\\n  /**\\n   * @private\\n   * @type {number}\\n   */\\n  this.minZoom_ = resolutionConstraintInfo.minZoom;\\n\\n  const centerConstraint = createCenterConstraint(options);\\n  const resolutionConstraint = resolutionConstraintInfo.constraint;\\n  const rotationConstraint = createRotationConstraint(options);\\n\\n  /**\\n   * @private\\n   * @type {module:ol/View~Constraints}\\n   */\\n  this.constraints_ = {\\n    center: centerConstraint,\\n    resolution: resolutionConstraint,\\n    rotation: rotationConstraint\\n  };\\n\\n  if (options.resolution !== undefined) {\\n    properties[ViewProperty.RESOLUTION] = options.resolution;\\n  } else if (options.zoom !== undefined) {\\n    properties[ViewProperty.RESOLUTION] = this.constrainResolution(\\n      this.maxResolution_, options.zoom - this.minZoom_);\\n\\n    if (this.resolutions_) { // in case map zoom is out of min/max zoom range\\n      properties[ViewProperty.RESOLUTION] = clamp(\\n        Number(this.getResolution() || properties[ViewProperty.RESOLUTION]),\\n        this.minResolution_, this.maxResolution_);\\n    }\\n  }\\n  properties[ViewProperty.ROTATION] = options.rotation !== undefined ? options.rotation : 0;\\n  this.setProperties(properties);\\n\\n  /**\\n   * @private\\n   * @type {module:ol/View~ViewOptions}\\n   */\\n  this.options_ = options;\\n\\n};\\n\\n/**\\n * Get an updated version of the view options used to construct the view.  The\\n * current resolution (or zoom), center, and rotation are applied to any stored\\n * options.  The provided options can be used to apply new min/max zoom or\\n * resolution limits.\\n * @param {module:ol/View~ViewOptions} newOptions New options to be applied.\\n * @return {module:ol/View~ViewOptions} New options updated with the current view state.\\n */\\nView.prototype.getUpdatedOptions_ = function(newOptions) {\\n  const options = assign({}, this.options_);\\n\\n  // preserve resolution (or zoom)\\n  if (options.resolution !== undefined) {\\n    options.resolution = this.getResolution();\\n  } else {\\n    options.zoom = this.getZoom();\\n  }\\n\\n  // preserve center\\n  options.center = this.getCenter();\\n\\n  // preserve rotation\\n  options.rotation = this.getRotation();\\n\\n  return assign({}, options, newOptions);\\n};\\n\\n\\n/**\\n * Animate the view.  The view's center, zoom (or resolution), and rotation\\n * can be animated for smooth transitions between view states.  For example,\\n * to animate the view to a new zoom level:\\n *\\n *     view.animate({zoom: view.getZoom() + 1});\\n *\\n * By default, the animation lasts one second and uses in-and-out easing.  You\\n * can customize this behavior by including `duration` (in milliseconds) and\\n * `easing` options (see {@link module:ol/easing}).\\n *\\n * To chain together multiple animations, call the method with multiple\\n * animation objects.  For example, to first zoom and then pan:\\n *\\n *     view.animate({zoom: 10}, {center: [0, 0]});\\n *\\n * If you provide a function as the last argument to the animate method, it\\n * will get called at the end of an animation series.  The callback will be\\n * called with `true` if the animation series completed on its own or `false`\\n * if it was cancelled.\\n *\\n * Animations are cancelled by user interactions (e.g. dragging the map) or by\\n * calling `view.setCenter()`, `view.setResolution()`, or `view.setRotation()`\\n * (or another method that calls one of these).\\n *\\n * @param {...(module:ol/View~AnimationOptions|function(boolean))} var_args Animation\\n *     options.  Multiple animations can be run in series by passing multiple\\n *     options objects.  To run multiple animations in parallel, call the method\\n *     multiple times.  An optional callback can be provided as a final\\n *     argument.  The callback will be called with a boolean indicating whether\\n *     the animation completed without being cancelled.\\n * @api\\n */\\nView.prototype.animate = function(var_args) {\\n  let animationCount = arguments.length;\\n  let callback;\\n  if (animationCount > 1 && typeof arguments[animationCount - 1] === 'function') {\\n    callback = arguments[animationCount - 1];\\n    --animationCount;\\n  }\\n  if (!this.isDef()) {\\n    // if view properties are not yet set, shortcut to the final state\\n    const state = arguments[animationCount - 1];\\n    if (state.center) {\\n      this.setCenter(state.center);\\n    }\\n    if (state.zoom !== undefined) {\\n      this.setZoom(state.zoom);\\n    }\\n    if (state.rotation !== undefined) {\\n      this.setRotation(state.rotation);\\n    }\\n    if (callback) {\\n      setTimeout(function() {\\n        callback(true);\\n      }, 0);\\n    }\\n    return;\\n  }\\n  let start = Date.now();\\n  let center = this.getCenter().slice();\\n  let resolution = this.getResolution();\\n  let rotation = this.getRotation();\\n  const series = [];\\n  for (let i = 0; i < animationCount; ++i) {\\n    const options = /** @type {module:ol/View~AnimationOptions} */ (arguments[i]);\\n\\n    const animation = /** @type {module:ol/View~Animation} */ ({\\n      start: start,\\n      complete: false,\\n      anchor: options.anchor,\\n      duration: options.duration !== undefined ? options.duration : 1000,\\n      easing: options.easing || inAndOut\\n    });\\n\\n    if (options.center) {\\n      animation.sourceCenter = center;\\n      animation.targetCenter = options.center;\\n      center = animation.targetCenter;\\n    }\\n\\n    if (options.zoom !== undefined) {\\n      animation.sourceResolution = resolution;\\n      animation.targetResolution = this.constrainResolution(\\n        this.maxResolution_, options.zoom - this.minZoom_, 0);\\n      resolution = animation.targetResolution;\\n    } else if (options.resolution) {\\n      animation.sourceResolution = resolution;\\n      animation.targetResolution = options.resolution;\\n      resolution = animation.targetResolution;\\n    }\\n\\n    if (options.rotation !== undefined) {\\n      animation.sourceRotation = rotation;\\n      const delta = modulo(options.rotation - rotation + Math.PI, 2 * Math.PI) - Math.PI;\\n      animation.targetRotation = rotation + delta;\\n      rotation = animation.targetRotation;\\n    }\\n\\n    animation.callback = callback;\\n\\n    // check if animation is a no-op\\n    if (isNoopAnimation(animation)) {\\n      animation.complete = true;\\n      // we still push it onto the series for callback handling\\n    } else {\\n      start += animation.duration;\\n    }\\n    series.push(animation);\\n  }\\n  this.animations_.push(series);\\n  this.setHint(ViewHint.ANIMATING, 1);\\n  this.updateAnimations_();\\n};\\n\\n\\n/**\\n * Determine if the view is being animated.\\n * @return {boolean} The view is being animated.\\n * @api\\n */\\nView.prototype.getAnimating = function() {\\n  return this.hints_[ViewHint.ANIMATING] > 0;\\n};\\n\\n\\n/**\\n * Determine if the user is interacting with the view, such as panning or zooming.\\n * @return {boolean} The view is being interacted with.\\n * @api\\n */\\nView.prototype.getInteracting = function() {\\n  return this.hints_[ViewHint.INTERACTING] > 0;\\n};\\n\\n\\n/**\\n * Cancel any ongoing animations.\\n * @api\\n */\\nView.prototype.cancelAnimations = function() {\\n  this.setHint(ViewHint.ANIMATING, -this.hints_[ViewHint.ANIMATING]);\\n  for (let i = 0, ii = this.animations_.length; i < ii; ++i) {\\n    const series = this.animations_[i];\\n    if (series[0].callback) {\\n      series[0].callback(false);\\n    }\\n  }\\n  this.animations_.length = 0;\\n};\\n\\n/**\\n * Update all animations.\\n */\\nView.prototype.updateAnimations_ = function() {\\n  if (this.updateAnimationKey_ !== undefined) {\\n    cancelAnimationFrame(this.updateAnimationKey_);\\n    this.updateAnimationKey_ = undefined;\\n  }\\n  if (!this.getAnimating()) {\\n    return;\\n  }\\n  const now = Date.now();\\n  let more = false;\\n  for (let i = this.animations_.length - 1; i >= 0; --i) {\\n    const series = this.animations_[i];\\n    let seriesComplete = true;\\n    for (let j = 0, jj = series.length; j < jj; ++j) {\\n      const animation = series[j];\\n      if (animation.complete) {\\n        continue;\\n      }\\n      const elapsed = now - animation.start;\\n      let fraction = animation.duration > 0 ? elapsed / animation.duration : 1;\\n      if (fraction >= 1) {\\n        animation.complete = true;\\n        fraction = 1;\\n      } else {\\n        seriesComplete = false;\\n      }\\n      const progress = animation.easing(fraction);\\n      if (animation.sourceCenter) {\\n        const x0 = animation.sourceCenter[0];\\n        const y0 = animation.sourceCenter[1];\\n        const x1 = animation.targetCenter[0];\\n        const y1 = animation.targetCenter[1];\\n        const x = x0 + progress * (x1 - x0);\\n        const y = y0 + progress * (y1 - y0);\\n        this.set(ViewProperty.CENTER, [x, y]);\\n      }\\n      if (animation.sourceResolution && animation.targetResolution) {\\n        const resolution = progress === 1 ?\\n          animation.targetResolution :\\n          animation.sourceResolution + progress * (animation.targetResolution - animation.sourceResolution);\\n        if (animation.anchor) {\\n          this.set(ViewProperty.CENTER,\\n            this.calculateCenterZoom(resolution, animation.anchor));\\n        }\\n        this.set(ViewProperty.RESOLUTION, resolution);\\n      }\\n      if (animation.sourceRotation !== undefined && animation.targetRotation !== undefined) {\\n        const rotation = progress === 1 ?\\n          modulo(animation.targetRotation + Math.PI, 2 * Math.PI) - Math.PI :\\n          animation.sourceRotation + progress * (animation.targetRotation - animation.sourceRotation);\\n        if (animation.anchor) {\\n          this.set(ViewProperty.CENTER,\\n            this.calculateCenterRotate(rotation, animation.anchor));\\n        }\\n        this.set(ViewProperty.ROTATION, rotation);\\n      }\\n      more = true;\\n      if (!animation.complete) {\\n        break;\\n      }\\n    }\\n    if (seriesComplete) {\\n      this.animations_[i] = null;\\n      this.setHint(ViewHint.ANIMATING, -1);\\n      const callback = series[0].callback;\\n      if (callback) {\\n        setTimeout(function() {\\n          callback(true);\\n        }, 0);\\n      }\\n    }\\n  }\\n  // prune completed series\\n  this.animations_ = this.animations_.filter(Boolean);\\n  if (more && this.updateAnimationKey_ === undefined) {\\n    this.updateAnimationKey_ = requestAnimationFrame(this.updateAnimations_);\\n  }\\n};\\n\\n/**\\n * @param {number} rotation Target rotation.\\n * @param {module:ol/coordinate~Coordinate} anchor Rotation anchor.\\n * @return {module:ol/coordinate~Coordinate|undefined} Center for rotation and anchor.\\n */\\nView.prototype.calculateCenterRotate = function(rotation, anchor) {\\n  let center;\\n  const currentCenter = this.getCenter();\\n  if (currentCenter !== undefined) {\\n    center = [currentCenter[0] - anchor[0], currentCenter[1] - anchor[1]];\\n    rotateCoordinate(center, rotation - this.getRotation());\\n    addCoordinate(center, anchor);\\n  }\\n  return center;\\n};\\n\\n\\n/**\\n * @param {number} resolution Target resolution.\\n * @param {module:ol/coordinate~Coordinate} anchor Zoom anchor.\\n * @return {module:ol/coordinate~Coordinate|undefined} Center for resolution and anchor.\\n */\\nView.prototype.calculateCenterZoom = function(resolution, anchor) {\\n  let center;\\n  const currentCenter = this.getCenter();\\n  const currentResolution = this.getResolution();\\n  if (currentCenter !== undefined && currentResolution !== undefined) {\\n    const x = anchor[0] - resolution * (anchor[0] - currentCenter[0]) / currentResolution;\\n    const y = anchor[1] - resolution * (anchor[1] - currentCenter[1]) / currentResolution;\\n    center = [x, y];\\n  }\\n  return center;\\n};\\n\\n\\n/**\\n * @private\\n * @return {module:ol/size~Size} Viewport size or `[100, 100]` when no viewport is found.\\n */\\nView.prototype.getSizeFromViewport_ = function() {\\n  const size = [100, 100];\\n  const selector = '.ol-viewport[data-view=\\\"' + getUid(this) + '\\\"]';\\n  const element = document.querySelector(selector);\\n  if (element) {\\n    const metrics = getComputedStyle(element);\\n    size[0] = parseInt(metrics.width, 10);\\n    size[1] = parseInt(metrics.height, 10);\\n  }\\n  return size;\\n};\\n\\n\\n/**\\n * Get the constrained center of this view.\\n * @param {module:ol/coordinate~Coordinate|undefined} center Center.\\n * @return {module:ol/coordinate~Coordinate|undefined} Constrained center.\\n * @api\\n */\\nView.prototype.constrainCenter = function(center) {\\n  return this.constraints_.center(center);\\n};\\n\\n\\n/**\\n * Get the constrained resolution of this view.\\n * @param {number|undefined} resolution Resolution.\\n * @param {number=} opt_delta Delta. Default is `0`.\\n * @param {number=} opt_direction Direction. Default is `0`.\\n * @return {number|undefined} Constrained resolution.\\n * @api\\n */\\nView.prototype.constrainResolution = function(resolution, opt_delta, opt_direction) {\\n  const delta = opt_delta || 0;\\n  const direction = opt_direction || 0;\\n  return this.constraints_.resolution(resolution, delta, direction);\\n};\\n\\n\\n/**\\n * Get the constrained rotation of this view.\\n * @param {number|undefined} rotation Rotation.\\n * @param {number=} opt_delta Delta. Default is `0`.\\n * @return {number|undefined} Constrained rotation.\\n * @api\\n */\\nView.prototype.constrainRotation = function(rotation, opt_delta) {\\n  const delta = opt_delta || 0;\\n  return this.constraints_.rotation(rotation, delta);\\n};\\n\\n\\n/**\\n * Get the view center.\\n * @return {module:ol/coordinate~Coordinate|undefined} The center of the view.\\n * @observable\\n * @api\\n */\\nView.prototype.getCenter = function() {\\n  return (\\n    /** @type {module:ol/coordinate~Coordinate|undefined} */ (this.get(ViewProperty.CENTER))\\n  );\\n};\\n\\n\\n/**\\n * @return {module:ol/View~Constraints} Constraints.\\n */\\nView.prototype.getConstraints = function() {\\n  return this.constraints_;\\n};\\n\\n\\n/**\\n * @param {Array.<number>=} opt_hints Destination array.\\n * @return {Array.<number>} Hint.\\n */\\nView.prototype.getHints = function(opt_hints) {\\n  if (opt_hints !== undefined) {\\n    opt_hints[0] = this.hints_[0];\\n    opt_hints[1] = this.hints_[1];\\n    return opt_hints;\\n  } else {\\n    return this.hints_.slice();\\n  }\\n};\\n\\n\\n/**\\n * Calculate the extent for the current view state and the passed size.\\n * The size is the pixel dimensions of the box into which the calculated extent\\n * should fit. In most cases you want to get the extent of the entire map,\\n * that is `map.getSize()`.\\n * @param {module:ol/size~Size=} opt_size Box pixel size. If not provided, the size of the\\n * first map that uses this view will be used.\\n * @return {module:ol/extent~Extent} Extent.\\n * @api\\n */\\nView.prototype.calculateExtent = function(opt_size) {\\n  const size = opt_size || this.getSizeFromViewport_();\\n  const center = /** @type {!module:ol/coordinate~Coordinate} */ (this.getCenter());\\n  assert(center, 1); // The view center is not defined\\n  const resolution = /** @type {!number} */ (this.getResolution());\\n  assert(resolution !== undefined, 2); // The view resolution is not defined\\n  const rotation = /** @type {!number} */ (this.getRotation());\\n  assert(rotation !== undefined, 3); // The view rotation is not defined\\n\\n  return getForViewAndSize(center, resolution, rotation, size);\\n};\\n\\n\\n/**\\n * Get the maximum resolution of the view.\\n * @return {number} The maximum resolution of the view.\\n * @api\\n */\\nView.prototype.getMaxResolution = function() {\\n  return this.maxResolution_;\\n};\\n\\n\\n/**\\n * Get the minimum resolution of the view.\\n * @return {number} The minimum resolution of the view.\\n * @api\\n */\\nView.prototype.getMinResolution = function() {\\n  return this.minResolution_;\\n};\\n\\n\\n/**\\n * Get the maximum zoom level for the view.\\n * @return {number} The maximum zoom level.\\n * @api\\n */\\nView.prototype.getMaxZoom = function() {\\n  return /** @type {number} */ (this.getZoomForResolution(this.minResolution_));\\n};\\n\\n\\n/**\\n * Set a new maximum zoom level for the view.\\n * @param {number} zoom The maximum zoom level.\\n * @api\\n */\\nView.prototype.setMaxZoom = function(zoom) {\\n  this.applyOptions_(this.getUpdatedOptions_({maxZoom: zoom}));\\n};\\n\\n\\n/**\\n * Get the minimum zoom level for the view.\\n * @return {number} The minimum zoom level.\\n * @api\\n */\\nView.prototype.getMinZoom = function() {\\n  return /** @type {number} */ (this.getZoomForResolution(this.maxResolution_));\\n};\\n\\n\\n/**\\n * Set a new minimum zoom level for the view.\\n * @param {number} zoom The minimum zoom level.\\n * @api\\n */\\nView.prototype.setMinZoom = function(zoom) {\\n  this.applyOptions_(this.getUpdatedOptions_({minZoom: zoom}));\\n};\\n\\n\\n/**\\n * Get the view projection.\\n * @return {module:ol/proj/Projection} The projection of the view.\\n * @api\\n */\\nView.prototype.getProjection = function() {\\n  return this.projection_;\\n};\\n\\n\\n/**\\n * Get the view resolution.\\n * @return {number|undefined} The resolution of the view.\\n * @observable\\n * @api\\n */\\nView.prototype.getResolution = function() {\\n  return /** @type {number|undefined} */ (this.get(ViewProperty.RESOLUTION));\\n};\\n\\n\\n/**\\n * Get the resolutions for the view. This returns the array of resolutions\\n * passed to the constructor of the View, or undefined if none were given.\\n * @return {Array.<number>|undefined} The resolutions of the view.\\n * @api\\n */\\nView.prototype.getResolutions = function() {\\n  return this.resolutions_;\\n};\\n\\n\\n/**\\n * Get the resolution for a provided extent (in map units) and size (in pixels).\\n * @param {module:ol/extent~Extent} extent Extent.\\n * @param {module:ol/size~Size=} opt_size Box pixel size.\\n * @return {number} The resolution at which the provided extent will render at\\n *     the given size.\\n * @api\\n */\\nView.prototype.getResolutionForExtent = function(extent, opt_size) {\\n  const size = opt_size || this.getSizeFromViewport_();\\n  const xResolution = getWidth(extent) / size[0];\\n  const yResolution = getHeight(extent) / size[1];\\n  return Math.max(xResolution, yResolution);\\n};\\n\\n\\n/**\\n * Return a function that returns a value between 0 and 1 for a\\n * resolution. Exponential scaling is assumed.\\n * @param {number=} opt_power Power.\\n * @return {function(number): number} Resolution for value function.\\n */\\nView.prototype.getResolutionForValueFunction = function(opt_power) {\\n  const power = opt_power || 2;\\n  const maxResolution = this.maxResolution_;\\n  const minResolution = this.minResolution_;\\n  const max = Math.log(maxResolution / minResolution) / Math.log(power);\\n  return (\\n    /**\\n     * @param {number} value Value.\\n     * @return {number} Resolution.\\n     */\\n    function(value) {\\n      const resolution = maxResolution / Math.pow(power, value * max);\\n      return resolution;\\n    });\\n};\\n\\n\\n/**\\n * Get the view rotation.\\n * @return {number} The rotation of the view in radians.\\n * @observable\\n * @api\\n */\\nView.prototype.getRotation = function() {\\n  return /** @type {number} */ (this.get(ViewProperty.ROTATION));\\n};\\n\\n\\n/**\\n * Return a function that returns a resolution for a value between\\n * 0 and 1. Exponential scaling is assumed.\\n * @param {number=} opt_power Power.\\n * @return {function(number): number} Value for resolution function.\\n */\\nView.prototype.getValueForResolutionFunction = function(opt_power) {\\n  const power = opt_power || 2;\\n  const maxResolution = this.maxResolution_;\\n  const minResolution = this.minResolution_;\\n  const max = Math.log(maxResolution / minResolution) / Math.log(power);\\n  return (\\n    /**\\n     * @param {number} resolution Resolution.\\n     * @return {number} Value.\\n     */\\n    function(resolution) {\\n      const value = (Math.log(maxResolution / resolution) / Math.log(power)) / max;\\n      return value;\\n    });\\n};\\n\\n\\n/**\\n * @return {module:ol/View~State} View state.\\n */\\nView.prototype.getState = function() {\\n  const center = /** @type {module:ol/coordinate~Coordinate} */ (this.getCenter());\\n  const projection = this.getProjection();\\n  const resolution = /** @type {number} */ (this.getResolution());\\n  const rotation = this.getRotation();\\n  return (\\n    /** @type {module:ol/View~State} */ ({\\n      center: center.slice(),\\n      projection: projection !== undefined ? projection : null,\\n      resolution: resolution,\\n      rotation: rotation,\\n      zoom: this.getZoom()\\n    })\\n  );\\n};\\n\\n\\n/**\\n * Get the current zoom level.  If you configured your view with a resolutions\\n * array (this is rare), this method may return non-integer zoom levels (so\\n * the zoom level is not safe to use as an index into a resolutions array).\\n * @return {number|undefined} Zoom.\\n * @api\\n */\\nView.prototype.getZoom = function() {\\n  let zoom;\\n  const resolution = this.getResolution();\\n  if (resolution !== undefined) {\\n    zoom = this.getZoomForResolution(resolution);\\n  }\\n  return zoom;\\n};\\n\\n\\n/**\\n * Get the zoom level for a resolution.\\n * @param {number} resolution The resolution.\\n * @return {number|undefined} The zoom level for the provided resolution.\\n * @api\\n */\\nView.prototype.getZoomForResolution = function(resolution) {\\n  let offset = this.minZoom_ || 0;\\n  let max, zoomFactor;\\n  if (this.resolutions_) {\\n    const nearest = linearFindNearest(this.resolutions_, resolution, 1);\\n    offset = nearest;\\n    max = this.resolutions_[nearest];\\n    if (nearest == this.resolutions_.length - 1) {\\n      zoomFactor = 2;\\n    } else {\\n      zoomFactor = max / this.resolutions_[nearest + 1];\\n    }\\n  } else {\\n    max = this.maxResolution_;\\n    zoomFactor = this.zoomFactor_;\\n  }\\n  return offset + Math.log(max / resolution) / Math.log(zoomFactor);\\n};\\n\\n\\n/**\\n * Get the resolution for a zoom level.\\n * @param {number} zoom Zoom level.\\n * @return {number} The view resolution for the provided zoom level.\\n * @api\\n */\\nView.prototype.getResolutionForZoom = function(zoom) {\\n  return /** @type {number} */ (this.constrainResolution(\\n    this.maxResolution_, zoom - this.minZoom_, 0));\\n};\\n\\n\\n/**\\n * Fit the given geometry or extent based on the given map size and border.\\n * The size is pixel dimensions of the box to fit the extent into.\\n * In most cases you will want to use the map size, that is `map.getSize()`.\\n * Takes care of the map angle.\\n * @param {module:ol/geom/SimpleGeometry|module:ol/extent~Extent} geometryOrExtent The geometry or\\n *     extent to fit the view to.\\n * @param {module:ol/View~FitOptions=} opt_options Options.\\n * @api\\n */\\nView.prototype.fit = function(geometryOrExtent, opt_options) {\\n  const options = opt_options || {};\\n  let size = options.size;\\n  if (!size) {\\n    size = this.getSizeFromViewport_();\\n  }\\n  /** @type {module:ol/geom/SimpleGeometry} */\\n  let geometry;\\n  if (!(geometryOrExtent instanceof SimpleGeometry)) {\\n    assert(Array.isArray(geometryOrExtent),\\n      24); // Invalid extent or geometry provided as `geometry`\\n    assert(!isEmpty(geometryOrExtent),\\n      25); // Cannot fit empty extent provided as `geometry`\\n    geometry = polygonFromExtent(geometryOrExtent);\\n  } else if (geometryOrExtent.getType() === GeometryType.CIRCLE) {\\n    geometryOrExtent = geometryOrExtent.getExtent();\\n    geometry = polygonFromExtent(geometryOrExtent);\\n    geometry.rotate(this.getRotation(), getCenter(geometryOrExtent));\\n  } else {\\n    geometry = geometryOrExtent;\\n  }\\n\\n  const padding = options.padding !== undefined ? options.padding : [0, 0, 0, 0];\\n  const constrainResolution = options.constrainResolution !== undefined ?\\n    options.constrainResolution : true;\\n  const nearest = options.nearest !== undefined ? options.nearest : false;\\n  let minResolution;\\n  if (options.minResolution !== undefined) {\\n    minResolution = options.minResolution;\\n  } else if (options.maxZoom !== undefined) {\\n    minResolution = this.constrainResolution(\\n      this.maxResolution_, options.maxZoom - this.minZoom_, 0);\\n  } else {\\n    minResolution = 0;\\n  }\\n  const coords = geometry.getFlatCoordinates();\\n\\n  // calculate rotated extent\\n  const rotation = this.getRotation();\\n  const cosAngle = Math.cos(-rotation);\\n  let sinAngle = Math.sin(-rotation);\\n  let minRotX = +Infinity;\\n  let minRotY = +Infinity;\\n  let maxRotX = -Infinity;\\n  let maxRotY = -Infinity;\\n  const stride = geometry.getStride();\\n  for (let i = 0, ii = coords.length; i < ii; i += stride) {\\n    const rotX = coords[i] * cosAngle - coords[i + 1] * sinAngle;\\n    const rotY = coords[i] * sinAngle + coords[i + 1] * cosAngle;\\n    minRotX = Math.min(minRotX, rotX);\\n    minRotY = Math.min(minRotY, rotY);\\n    maxRotX = Math.max(maxRotX, rotX);\\n    maxRotY = Math.max(maxRotY, rotY);\\n  }\\n\\n  // calculate resolution\\n  let resolution = this.getResolutionForExtent(\\n    [minRotX, minRotY, maxRotX, maxRotY],\\n    [size[0] - padding[1] - padding[3], size[1] - padding[0] - padding[2]]);\\n  resolution = isNaN(resolution) ? minResolution :\\n    Math.max(resolution, minResolution);\\n  if (constrainResolution) {\\n    let constrainedResolution = this.constrainResolution(resolution, 0, 0);\\n    if (!nearest && constrainedResolution < resolution) {\\n      constrainedResolution = this.constrainResolution(\\n        constrainedResolution, -1, 0);\\n    }\\n    resolution = constrainedResolution;\\n  }\\n\\n  // calculate center\\n  sinAngle = -sinAngle; // go back to original rotation\\n  let centerRotX = (minRotX + maxRotX) / 2;\\n  let centerRotY = (minRotY + maxRotY) / 2;\\n  centerRotX += (padding[1] - padding[3]) / 2 * resolution;\\n  centerRotY += (padding[0] - padding[2]) / 2 * resolution;\\n  const centerX = centerRotX * cosAngle - centerRotY * sinAngle;\\n  const centerY = centerRotY * cosAngle + centerRotX * sinAngle;\\n  const center = [centerX, centerY];\\n  const callback = options.callback ? options.callback : UNDEFINED;\\n\\n  if (options.duration !== undefined) {\\n    this.animate({\\n      resolution: resolution,\\n      center: center,\\n      duration: options.duration,\\n      easing: options.easing\\n    }, callback);\\n  } else {\\n    this.setResolution(resolution);\\n    this.setCenter(center);\\n    setTimeout(callback.bind(undefined, true), 0);\\n  }\\n};\\n\\n\\n/**\\n * Center on coordinate and view position.\\n * @param {module:ol/coordinate~Coordinate} coordinate Coordinate.\\n * @param {module:ol/size~Size} size Box pixel size.\\n * @param {module:ol~Pixel} position Position on the view to center on.\\n * @api\\n */\\nView.prototype.centerOn = function(coordinate, size, position) {\\n  // calculate rotated position\\n  const rotation = this.getRotation();\\n  const cosAngle = Math.cos(-rotation);\\n  let sinAngle = Math.sin(-rotation);\\n  let rotX = coordinate[0] * cosAngle - coordinate[1] * sinAngle;\\n  let rotY = coordinate[1] * cosAngle + coordinate[0] * sinAngle;\\n  const resolution = this.getResolution();\\n  rotX += (size[0] / 2 - position[0]) * resolution;\\n  rotY += (position[1] - size[1] / 2) * resolution;\\n\\n  // go back to original angle\\n  sinAngle = -sinAngle; // go back to original rotation\\n  const centerX = rotX * cosAngle - rotY * sinAngle;\\n  const centerY = rotY * cosAngle + rotX * sinAngle;\\n\\n  this.setCenter([centerX, centerY]);\\n};\\n\\n\\n/**\\n * @return {boolean} Is defined.\\n */\\nView.prototype.isDef = function() {\\n  return !!this.getCenter() && this.getResolution() !== undefined;\\n};\\n\\n\\n/**\\n * Rotate the view around a given coordinate.\\n * @param {number} rotation New rotation value for the view.\\n * @param {module:ol/coordinate~Coordinate=} opt_anchor The rotation center.\\n * @api\\n */\\nView.prototype.rotate = function(rotation, opt_anchor) {\\n  if (opt_anchor !== undefined) {\\n    const center = this.calculateCenterRotate(rotation, opt_anchor);\\n    this.setCenter(center);\\n  }\\n  this.setRotation(rotation);\\n};\\n\\n\\n/**\\n * Set the center of the current view.\\n * @param {module:ol/coordinate~Coordinate|undefined} center The center of the view.\\n * @observable\\n * @api\\n */\\nView.prototype.setCenter = function(center) {\\n  this.set(ViewProperty.CENTER, center);\\n  if (this.getAnimating()) {\\n    this.cancelAnimations();\\n  }\\n};\\n\\n\\n/**\\n * @param {module:ol/ViewHint} hint Hint.\\n * @param {number} delta Delta.\\n * @return {number} New value.\\n */\\nView.prototype.setHint = function(hint, delta) {\\n  this.hints_[hint] += delta;\\n  this.changed();\\n  return this.hints_[hint];\\n};\\n\\n\\n/**\\n * Set the resolution for this view.\\n * @param {number|undefined} resolution The resolution of the view.\\n * @observable\\n * @api\\n */\\nView.prototype.setResolution = function(resolution) {\\n  this.set(ViewProperty.RESOLUTION, resolution);\\n  if (this.getAnimating()) {\\n    this.cancelAnimations();\\n  }\\n};\\n\\n\\n/**\\n * Set the rotation for this view.\\n * @param {number} rotation The rotation of the view in radians.\\n * @observable\\n * @api\\n */\\nView.prototype.setRotation = function(rotation) {\\n  this.set(ViewProperty.ROTATION, rotation);\\n  if (this.getAnimating()) {\\n    this.cancelAnimations();\\n  }\\n};\\n\\n\\n/**\\n * Zoom to a specific zoom level.\\n * @param {number} zoom Zoom level.\\n * @api\\n */\\nView.prototype.setZoom = function(zoom) {\\n  this.setResolution(this.getResolutionForZoom(zoom));\\n};\\n\\n\\n/**\\n * @param {module:ol/View~ViewOptions} options View options.\\n * @return {module:ol/centerconstraint~Type} The constraint.\\n */\\nexport function createCenterConstraint(options) {\\n  if (options.extent !== undefined) {\\n    return createExtent(options.extent);\\n  } else {\\n    return centerNone;\\n  }\\n}\\n\\n\\n/**\\n * @param {module:ol/View~ViewOptions} options View options.\\n * @return {{constraint: module:ol/resolutionconstraint~Type, maxResolution: number,\\n *     minResolution: number, minZoom: number, zoomFactor: number}} The constraint.\\n */\\nexport function createResolutionConstraint(options) {\\n  let resolutionConstraint;\\n  let maxResolution;\\n  let minResolution;\\n\\n  // TODO: move these to be ol constants\\n  // see https://github.com/openlayers/openlayers/issues/2076\\n  const defaultMaxZoom = 28;\\n  const defaultZoomFactor = 2;\\n\\n  let minZoom = options.minZoom !== undefined ?\\n    options.minZoom : DEFAULT_MIN_ZOOM;\\n\\n  let maxZoom = options.maxZoom !== undefined ?\\n    options.maxZoom : defaultMaxZoom;\\n\\n  const zoomFactor = options.zoomFactor !== undefined ?\\n    options.zoomFactor : defaultZoomFactor;\\n\\n  if (options.resolutions !== undefined) {\\n    const resolutions = options.resolutions;\\n    maxResolution = resolutions[minZoom];\\n    minResolution = resolutions[maxZoom] !== undefined ?\\n      resolutions[maxZoom] : resolutions[resolutions.length - 1];\\n    resolutionConstraint = createSnapToResolutions(\\n      resolutions);\\n  } else {\\n    // calculate the default min and max resolution\\n    const projection = createProjection(options.projection, 'EPSG:3857');\\n    const extent = projection.getExtent();\\n    const size = !extent ?\\n      // use an extent that can fit the whole world if need be\\n      360 * METERS_PER_UNIT[Units.DEGREES] /\\n            projection.getMetersPerUnit() :\\n      Math.max(getWidth(extent), getHeight(extent));\\n\\n    const defaultMaxResolution = size / DEFAULT_TILE_SIZE / Math.pow(\\n      defaultZoomFactor, DEFAULT_MIN_ZOOM);\\n\\n    const defaultMinResolution = defaultMaxResolution / Math.pow(\\n      defaultZoomFactor, defaultMaxZoom - DEFAULT_MIN_ZOOM);\\n\\n    // user provided maxResolution takes precedence\\n    maxResolution = options.maxResolution;\\n    if (maxResolution !== undefined) {\\n      minZoom = 0;\\n    } else {\\n      maxResolution = defaultMaxResolution / Math.pow(zoomFactor, minZoom);\\n    }\\n\\n    // user provided minResolution takes precedence\\n    minResolution = options.minResolution;\\n    if (minResolution === undefined) {\\n      if (options.maxZoom !== undefined) {\\n        if (options.maxResolution !== undefined) {\\n          minResolution = maxResolution / Math.pow(zoomFactor, maxZoom);\\n        } else {\\n          minResolution = defaultMaxResolution / Math.pow(zoomFactor, maxZoom);\\n        }\\n      } else {\\n        minResolution = defaultMinResolution;\\n      }\\n    }\\n\\n    // given discrete zoom levels, minResolution may be different than provided\\n    maxZoom = minZoom + Math.floor(\\n      Math.log(maxResolution / minResolution) / Math.log(zoomFactor));\\n    minResolution = maxResolution / Math.pow(zoomFactor, maxZoom - minZoom);\\n\\n    resolutionConstraint = createSnapToPower(\\n      zoomFactor, maxResolution, maxZoom - minZoom);\\n  }\\n  return {constraint: resolutionConstraint, maxResolution: maxResolution,\\n    minResolution: minResolution, minZoom: minZoom, zoomFactor: zoomFactor};\\n}\\n\\n\\n/**\\n * @param {module:ol/View~ViewOptions} options View options.\\n * @return {module:ol/rotationconstraint~Type} Rotation constraint.\\n */\\nexport function createRotationConstraint(options) {\\n  const enableRotation = options.enableRotation !== undefined ?\\n    options.enableRotation : true;\\n  if (enableRotation) {\\n    const constrainRotation = options.constrainRotation;\\n    if (constrainRotation === undefined || constrainRotation === true) {\\n      return createSnapToZero();\\n    } else if (constrainRotation === false) {\\n      return rotationNone;\\n    } else if (typeof constrainRotation === 'number') {\\n      return createSnapToN(constrainRotation);\\n    } else {\\n      return rotationNone;\\n    }\\n  } else {\\n    return disable;\\n  }\\n}\\n\\n\\n/**\\n * Determine if an animation involves no view change.\\n * @param {module:ol/View~Animation} animation The animation.\\n * @return {boolean} The animation involves no view change.\\n */\\nexport function isNoopAnimation(animation) {\\n  if (animation.sourceCenter && animation.targetCenter) {\\n    if (!coordinatesEqual(animation.sourceCenter, animation.targetCenter)) {\\n      return false;\\n    }\\n  }\\n  if (animation.sourceResolution !== animation.targetResolution) {\\n    return false;\\n  }\\n  if (animation.sourceRotation !== animation.targetRotation) {\\n    return false;\\n  }\\n  return true;\\n}\\n\\nexport default View;\\n\",\"/**\\n * @module ol/resolutionconstraint\\n */\\nimport {linearFindNearest} from './array.js';\\nimport {clamp} from './math.js';\\n\\n\\n/**\\n * @typedef {function((number|undefined), number, number): (number|undefined)} Type\\n */\\n\\n\\n/**\\n * @param {Array.<number>} resolutions Resolutions.\\n * @return {module:ol/resolutionconstraint~Type} Zoom function.\\n */\\nexport function createSnapToResolutions(resolutions) {\\n  return (\\n    /**\\n     * @param {number|undefined} resolution Resolution.\\n     * @param {number} delta Delta.\\n     * @param {number} direction Direction.\\n     * @return {number|undefined} Resolution.\\n     */\\n    function(resolution, delta, direction) {\\n      if (resolution !== undefined) {\\n        let z = linearFindNearest(resolutions, resolution, direction);\\n        z = clamp(z + delta, 0, resolutions.length - 1);\\n        const index = Math.floor(z);\\n        if (z != index && index < resolutions.length - 1) {\\n          const power = resolutions[index] / resolutions[index + 1];\\n          return resolutions[index] / Math.pow(power, z - index);\\n        } else {\\n          return resolutions[index];\\n        }\\n      } else {\\n        return undefined;\\n      }\\n    }\\n  );\\n}\\n\\n\\n/**\\n * @param {number} power Power.\\n * @param {number} maxResolution Maximum resolution.\\n * @param {number=} opt_maxLevel Maximum level.\\n * @return {module:ol/resolutionconstraint~Type} Zoom function.\\n */\\nexport function createSnapToPower(power, maxResolution, opt_maxLevel) {\\n  return (\\n    /**\\n     * @param {number|undefined} resolution Resolution.\\n     * @param {number} delta Delta.\\n     * @param {number} direction Direction.\\n     * @return {number|undefined} Resolution.\\n     */\\n    function(resolution, delta, direction) {\\n      if (resolution !== undefined) {\\n        const offset = -direction / 2 + 0.5;\\n        const oldLevel = Math.floor(\\n          Math.log(maxResolution / resolution) / Math.log(power) + offset);\\n        let newLevel = Math.max(oldLevel + delta, 0);\\n        if (opt_maxLevel !== undefined) {\\n          newLevel = Math.min(newLevel, opt_maxLevel);\\n        }\\n        return maxResolution / Math.pow(power, newLevel);\\n      } else {\\n        return undefined;\\n      }\\n    });\\n}\\n\",\"/**\\n * @module ol/layer/Property\\n */\\n\\n/**\\n * @enum {string}\\n */\\nexport default {\\n  OPACITY: 'opacity',\\n  VISIBLE: 'visible',\\n  EXTENT: 'extent',\\n  Z_INDEX: 'zIndex',\\n  MAX_RESOLUTION: 'maxResolution',\\n  MIN_RESOLUTION: 'minResolution',\\n  SOURCE: 'source'\\n};\\n\",\"/**\\n * @module ol/layer/Base\\n */\\nimport {inherits} from '../index.js';\\nimport BaseObject from '../Object.js';\\nimport LayerProperty from '../layer/Property.js';\\nimport {clamp} from '../math.js';\\nimport {assign} from '../obj.js';\\n\\n\\n/**\\n * @typedef {Object} Options\\n * @property {number} [opacity=1] Opacity (0, 1).\\n * @property {boolean} [visible=true] Visibility.\\n * @property {module:ol/extent~Extent} [extent] The bounding extent for layer rendering.  The layer will not be\\n * rendered outside of this extent.\\n * @property {number} [zIndex=0] The z-index for layer rendering.  At rendering time, the layers\\n * will be ordered, first by Z-index and then by position.\\n * @property {number} [minResolution] The minimum resolution (inclusive) at which this layer will be\\n * visible.\\n * @property {number} [maxResolution] The maximum resolution (exclusive) below which this layer will\\n * be visible.\\n */\\n\\n\\n/**\\n * @classdesc\\n * Abstract base class; normally only used for creating subclasses and not\\n * instantiated in apps.\\n * Note that with {@link module:ol/layer/Base} and all its subclasses, any property set in\\n * the options is set as a {@link module:ol/Object} property on the layer object, so\\n * is observable, and has get/set accessors.\\n *\\n * @constructor\\n * @abstract\\n * @extends {module:ol/Object}\\n * @param {module:ol/layer/Base~Options} options Layer options.\\n * @api\\n */\\nconst BaseLayer = function(options) {\\n\\n  BaseObject.call(this);\\n\\n  /**\\n   * @type {Object.<string, *>}\\n   */\\n  const properties = assign({}, options);\\n  properties[LayerProperty.OPACITY] =\\n      options.opacity !== undefined ? options.opacity : 1;\\n  properties[LayerProperty.VISIBLE] =\\n      options.visible !== undefined ? options.visible : true;\\n  properties[LayerProperty.Z_INDEX] =\\n      options.zIndex !== undefined ? options.zIndex : 0;\\n  properties[LayerProperty.MAX_RESOLUTION] =\\n      options.maxResolution !== undefined ? options.maxResolution : Infinity;\\n  properties[LayerProperty.MIN_RESOLUTION] =\\n      options.minResolution !== undefined ? options.minResolution : 0;\\n\\n  this.setProperties(properties);\\n\\n  /**\\n   * @type {module:ol/layer/Layer~State}\\n   * @private\\n   */\\n  this.state_ = /** @type {module:ol/layer/Layer~State} */ ({\\n    layer: /** @type {module:ol/layer/Layer} */ (this),\\n    managed: true\\n  });\\n\\n  /**\\n   * The layer type.\\n   * @type {module:ol/LayerType}\\n   * @protected;\\n   */\\n  this.type;\\n\\n};\\n\\ninherits(BaseLayer, BaseObject);\\n\\n\\n/**\\n * Get the layer type (used when creating a layer renderer).\\n * @return {module:ol/LayerType} The layer type.\\n */\\nBaseLayer.prototype.getType = function() {\\n  return this.type;\\n};\\n\\n\\n/**\\n * @return {module:ol/layer/Layer~State} Layer state.\\n */\\nBaseLayer.prototype.getLayerState = function() {\\n  this.state_.opacity = clamp(this.getOpacity(), 0, 1);\\n  this.state_.sourceState = this.getSourceState();\\n  this.state_.visible = this.getVisible();\\n  this.state_.extent = this.getExtent();\\n  this.state_.zIndex = this.getZIndex();\\n  this.state_.maxResolution = this.getMaxResolution();\\n  this.state_.minResolution = Math.max(this.getMinResolution(), 0);\\n\\n  return this.state_;\\n};\\n\\n\\n/**\\n * @abstract\\n * @param {Array.<module:ol/layer/Layer>=} opt_array Array of layers (to be\\n *     modified in place).\\n * @return {Array.<module:ol/layer/Layer>} Array of layers.\\n */\\nBaseLayer.prototype.getLayersArray = function(opt_array) {};\\n\\n\\n/**\\n * @abstract\\n * @param {Array.<module:ol/layer/Layer~State>=} opt_states Optional list of layer\\n *     states (to be modified in place).\\n * @return {Array.<module:ol/layer/Layer~State>} List of layer states.\\n */\\nBaseLayer.prototype.getLayerStatesArray = function(opt_states) {};\\n\\n\\n/**\\n * Return the {@link module:ol/extent~Extent extent} of the layer or `undefined` if it\\n * will be visible regardless of extent.\\n * @return {module:ol/extent~Extent|undefined} The layer extent.\\n * @observable\\n * @api\\n */\\nBaseLayer.prototype.getExtent = function() {\\n  return (\\n    /** @type {module:ol/extent~Extent|undefined} */ (this.get(LayerProperty.EXTENT))\\n  );\\n};\\n\\n\\n/**\\n * Return the maximum resolution of the layer.\\n * @return {number} The maximum resolution of the layer.\\n * @observable\\n * @api\\n */\\nBaseLayer.prototype.getMaxResolution = function() {\\n  return /** @type {number} */ (this.get(LayerProperty.MAX_RESOLUTION));\\n};\\n\\n\\n/**\\n * Return the minimum resolution of the layer.\\n * @return {number} The minimum resolution of the layer.\\n * @observable\\n * @api\\n */\\nBaseLayer.prototype.getMinResolution = function() {\\n  return /** @type {number} */ (this.get(LayerProperty.MIN_RESOLUTION));\\n};\\n\\n\\n/**\\n * Return the opacity of the layer (between 0 and 1).\\n * @return {number} The opacity of the layer.\\n * @observable\\n * @api\\n */\\nBaseLayer.prototype.getOpacity = function() {\\n  return /** @type {number} */ (this.get(LayerProperty.OPACITY));\\n};\\n\\n\\n/**\\n * @abstract\\n * @return {module:ol/source/State} Source state.\\n */\\nBaseLayer.prototype.getSourceState = function() {};\\n\\n\\n/**\\n * Return the visibility of the layer (`true` or `false`).\\n * @return {boolean} The visibility of the layer.\\n * @observable\\n * @api\\n */\\nBaseLayer.prototype.getVisible = function() {\\n  return /** @type {boolean} */ (this.get(LayerProperty.VISIBLE));\\n};\\n\\n\\n/**\\n * Return the Z-index of the layer, which is used to order layers before\\n * rendering. The default Z-index is 0.\\n * @return {number} The Z-index of the layer.\\n * @observable\\n * @api\\n */\\nBaseLayer.prototype.getZIndex = function() {\\n  return /** @type {number} */ (this.get(LayerProperty.Z_INDEX));\\n};\\n\\n\\n/**\\n * Set the extent at which the layer is visible.  If `undefined`, the layer\\n * will be visible at all extents.\\n * @param {module:ol/extent~Extent|undefined} extent The extent of the layer.\\n * @observable\\n * @api\\n */\\nBaseLayer.prototype.setExtent = function(extent) {\\n  this.set(LayerProperty.EXTENT, extent);\\n};\\n\\n\\n/**\\n * Set the maximum resolution at which the layer is visible.\\n * @param {number} maxResolution The maximum resolution of the layer.\\n * @observable\\n * @api\\n */\\nBaseLayer.prototype.setMaxResolution = function(maxResolution) {\\n  this.set(LayerProperty.MAX_RESOLUTION, maxResolution);\\n};\\n\\n\\n/**\\n * Set the minimum resolution at which the layer is visible.\\n * @param {number} minResolution The minimum resolution of the layer.\\n * @observable\\n * @api\\n */\\nBaseLayer.prototype.setMinResolution = function(minResolution) {\\n  this.set(LayerProperty.MIN_RESOLUTION, minResolution);\\n};\\n\\n\\n/**\\n * Set the opacity of the layer, allowed values range from 0 to 1.\\n * @param {number} opacity The opacity of the layer.\\n * @observable\\n * @api\\n */\\nBaseLayer.prototype.setOpacity = function(opacity) {\\n  this.set(LayerProperty.OPACITY, opacity);\\n};\\n\\n\\n/**\\n * Set the visibility of the layer (`true` or `false`).\\n * @param {boolean} visible The visibility of the layer.\\n * @observable\\n * @api\\n */\\nBaseLayer.prototype.setVisible = function(visible) {\\n  this.set(LayerProperty.VISIBLE, visible);\\n};\\n\\n\\n/**\\n * Set Z-index of the layer, which is used to order layers before rendering.\\n * The default Z-index is 0.\\n * @param {number} zindex The z-index of the layer.\\n * @observable\\n * @api\\n */\\nBaseLayer.prototype.setZIndex = function(zindex) {\\n  this.set(LayerProperty.Z_INDEX, zindex);\\n};\\nexport default BaseLayer;\\n\",\"/**\\n * @module ol/source/State\\n */\\n\\n/**\\n * State of the source, one of 'undefined', 'loading', 'ready' or 'error'.\\n * @enum {string}\\n */\\nexport default {\\n  UNDEFINED: 'undefined',\\n  LOADING: 'loading',\\n  READY: 'ready',\\n  ERROR: 'error'\\n};\\n\",\"/**\\n * @module ol/layer/Group\\n */\\nimport {getUid, inherits} from '../index.js';\\nimport Collection from '../Collection.js';\\nimport CollectionEventType from '../CollectionEventType.js';\\nimport {getChangeEventType} from '../Object.js';\\nimport ObjectEventType from '../ObjectEventType.js';\\nimport {assert} from '../asserts.js';\\nimport {listen, unlistenByKey} from '../events.js';\\nimport EventType from '../events/EventType.js';\\nimport {getIntersection} from '../extent.js';\\nimport BaseLayer from '../layer/Base.js';\\nimport {assign, clear} from '../obj.js';\\nimport SourceState from '../source/State.js';\\n\\n\\n/**\\n * @typedef {Object} Options\\n * @property {number} [opacity=1] Opacity (0, 1).\\n * @property {boolean} [visible=true] Visibility.\\n * @property {module:ol/extent~Extent} [extent] The bounding extent for layer rendering.  The layer will not be\\n * rendered outside of this extent.\\n * @property {number} [zIndex=0] The z-index for layer rendering.  At rendering time, the layers\\n * will be ordered, first by Z-index and then by position.\\n * @property {number} [minResolution] The minimum resolution (inclusive) at which this layer will be\\n * visible.\\n * @property {number} [maxResolution] The maximum resolution (exclusive) below which this layer will\\n * be visible.\\n * @property {(Array.<module:ol/layer/Base>|module:ol/Collection.<module:ol/layer/Base>)} [layers] Child layers.\\n */\\n\\n\\n/**\\n * @enum {string}\\n * @private\\n */\\nconst Property = {\\n  LAYERS: 'layers'\\n};\\n\\n\\n/**\\n * @classdesc\\n * A {@link module:ol/Collection~Collection} of layers that are handled together.\\n *\\n * A generic `change` event is triggered when the group/Collection changes.\\n *\\n * @constructor\\n * @extends {module:ol/layer/Base}\\n * @param {module:ol/layer/Group~Options=} opt_options Layer options.\\n * @api\\n */\\nconst LayerGroup = function(opt_options) {\\n\\n  const options = opt_options || {};\\n  const baseOptions = /** @type {module:ol/layer/Group~Options} */ (assign({}, options));\\n  delete baseOptions.layers;\\n\\n  let layers = options.layers;\\n\\n  BaseLayer.call(this, baseOptions);\\n\\n  /**\\n   * @private\\n   * @type {Array.<module:ol/events~EventsKey>}\\n   */\\n  this.layersListenerKeys_ = [];\\n\\n  /**\\n   * @private\\n   * @type {Object.<string, Array.<module:ol/events~EventsKey>>}\\n   */\\n  this.listenerKeys_ = {};\\n\\n  listen(this,\\n    getChangeEventType(Property.LAYERS),\\n    this.handleLayersChanged_, this);\\n\\n  if (layers) {\\n    if (Array.isArray(layers)) {\\n      layers = new Collection(layers.slice(), {unique: true});\\n    } else {\\n      assert(layers instanceof Collection,\\n        43); // Expected `layers` to be an array or a `Collection`\\n      layers = layers;\\n    }\\n  } else {\\n    layers = new Collection(undefined, {unique: true});\\n  }\\n\\n  this.setLayers(layers);\\n\\n};\\n\\ninherits(LayerGroup, BaseLayer);\\n\\n\\n/**\\n * @private\\n */\\nLayerGroup.prototype.handleLayerChange_ = function() {\\n  this.changed();\\n};\\n\\n\\n/**\\n * @param {module:ol/events/Event} event Event.\\n * @private\\n */\\nLayerGroup.prototype.handleLayersChanged_ = function(event) {\\n  this.layersListenerKeys_.forEach(unlistenByKey);\\n  this.layersListenerKeys_.length = 0;\\n\\n  const layers = this.getLayers();\\n  this.layersListenerKeys_.push(\\n    listen(layers, CollectionEventType.ADD, this.handleLayersAdd_, this),\\n    listen(layers, CollectionEventType.REMOVE, this.handleLayersRemove_, this)\\n  );\\n\\n  for (const id in this.listenerKeys_) {\\n    this.listenerKeys_[id].forEach(unlistenByKey);\\n  }\\n  clear(this.listenerKeys_);\\n\\n  const layersArray = layers.getArray();\\n  for (let i = 0, ii = layersArray.length; i < ii; i++) {\\n    const layer = layersArray[i];\\n    this.listenerKeys_[getUid(layer).toString()] = [\\n      listen(layer, ObjectEventType.PROPERTYCHANGE, this.handleLayerChange_, this),\\n      listen(layer, EventType.CHANGE, this.handleLayerChange_, this)\\n    ];\\n  }\\n\\n  this.changed();\\n};\\n\\n\\n/**\\n * @param {module:ol/Collection~CollectionEvent} collectionEvent CollectionEvent.\\n * @private\\n */\\nLayerGroup.prototype.handleLayersAdd_ = function(collectionEvent) {\\n  const layer = /** @type {module:ol/layer/Base} */ (collectionEvent.element);\\n  const key = getUid(layer).toString();\\n  this.listenerKeys_[key] = [\\n    listen(layer, ObjectEventType.PROPERTYCHANGE, this.handleLayerChange_, this),\\n    listen(layer, EventType.CHANGE, this.handleLayerChange_, this)\\n  ];\\n  this.changed();\\n};\\n\\n\\n/**\\n * @param {module:ol/Collection~CollectionEvent} collectionEvent CollectionEvent.\\n * @private\\n */\\nLayerGroup.prototype.handleLayersRemove_ = function(collectionEvent) {\\n  const layer = /** @type {module:ol/layer/Base} */ (collectionEvent.element);\\n  const key = getUid(layer).toString();\\n  this.listenerKeys_[key].forEach(unlistenByKey);\\n  delete this.listenerKeys_[key];\\n  this.changed();\\n};\\n\\n\\n/**\\n * Returns the {@link module:ol/Collection collection} of {@link module:ol/layer/Layer~Layer layers}\\n * in this group.\\n * @return {!module:ol/Collection.<module:ol/layer/Base>} Collection of\\n *   {@link module:ol/layer/Base layers} that are part of this group.\\n * @observable\\n * @api\\n */\\nLayerGroup.prototype.getLayers = function() {\\n  return (\\n    /** @type {!module:ol/Collection.<module:ol/layer/Base>} */ (this.get(Property.LAYERS))\\n  );\\n};\\n\\n\\n/**\\n * Set the {@link module:ol/Collection collection} of {@link module:ol/layer/Layer~Layer layers}\\n * in this group.\\n * @param {!module:ol/Collection.<module:ol/layer/Base>} layers Collection of\\n *   {@link module:ol/layer/Base layers} that are part of this group.\\n * @observable\\n * @api\\n */\\nLayerGroup.prototype.setLayers = function(layers) {\\n  this.set(Property.LAYERS, layers);\\n};\\n\\n\\n/**\\n * @inheritDoc\\n */\\nLayerGroup.prototype.getLayersArray = function(opt_array) {\\n  const array = opt_array !== undefined ? opt_array : [];\\n  this.getLayers().forEach(function(layer) {\\n    layer.getLayersArray(array);\\n  });\\n  return array;\\n};\\n\\n\\n/**\\n * @inheritDoc\\n */\\nLayerGroup.prototype.getLayerStatesArray = function(opt_states) {\\n  const states = opt_states !== undefined ? opt_states : [];\\n\\n  const pos = states.length;\\n\\n  this.getLayers().forEach(function(layer) {\\n    layer.getLayerStatesArray(states);\\n  });\\n\\n  const ownLayerState = this.getLayerState();\\n  for (let i = pos, ii = states.length; i < ii; i++) {\\n    const layerState = states[i];\\n    layerState.opacity *= ownLayerState.opacity;\\n    layerState.visible = layerState.visible && ownLayerState.visible;\\n    layerState.maxResolution = Math.min(\\n      layerState.maxResolution, ownLayerState.maxResolution);\\n    layerState.minResolution = Math.max(\\n      layerState.minResolution, ownLayerState.minResolution);\\n    if (ownLayerState.extent !== undefined) {\\n      if (layerState.extent !== undefined) {\\n        layerState.extent = getIntersection(layerState.extent, ownLayerState.extent);\\n      } else {\\n        layerState.extent = ownLayerState.extent;\\n      }\\n    }\\n  }\\n\\n  return states;\\n};\\n\\n\\n/**\\n * @inheritDoc\\n */\\nLayerGroup.prototype.getSourceState = function() {\\n  return SourceState.READY;\\n};\\n\\nexport default LayerGroup;\\n\",\"/**\\n * @module ol/size\\n */\\n\\n\\n/**\\n * An array of numbers representing a size: `[width, height]`.\\n * @typedef {Array.<number>} Size\\n * @api\\n */\\n\\n\\n/**\\n * Returns a buffered size.\\n * @param {module:ol/size~Size} size Size.\\n * @param {number} num The amount by which to buffer.\\n * @param {module:ol/size~Size=} opt_size Optional reusable size array.\\n * @return {module:ol/size~Size} The buffered size.\\n */\\nexport function buffer(size, num, opt_size) {\\n  if (opt_size === undefined) {\\n    opt_size = [0, 0];\\n  }\\n  opt_size[0] = size[0] + 2 * num;\\n  opt_size[1] = size[1] + 2 * num;\\n  return opt_size;\\n}\\n\\n\\n/**\\n * Determines if a size has a positive area.\\n * @param {module:ol/size~Size} size The size to test.\\n * @return {boolean} The size has a positive area.\\n */\\nexport function hasArea(size) {\\n  return size[0] > 0 && size[1] > 0;\\n}\\n\\n\\n/**\\n * Returns a size scaled by a ratio. The result will be an array of integers.\\n * @param {module:ol/size~Size} size Size.\\n * @param {number} ratio Ratio.\\n * @param {module:ol/size~Size=} opt_size Optional reusable size array.\\n * @return {module:ol/size~Size} The scaled size.\\n */\\nexport function scale(size, ratio, opt_size) {\\n  if (opt_size === undefined) {\\n    opt_size = [0, 0];\\n  }\\n  opt_size[0] = (size[0] * ratio + 0.5) | 0;\\n  opt_size[1] = (size[1] * ratio + 0.5) | 0;\\n  return opt_size;\\n}\\n\\n\\n/**\\n * Returns an `module:ol/size~Size` array for the passed in number (meaning: square) or\\n * `module:ol/size~Size` array.\\n * (meaning: non-square),\\n * @param {number|module:ol/size~Size} size Width and height.\\n * @param {module:ol/size~Size=} opt_size Optional reusable size array.\\n * @return {module:ol/size~Size} Size.\\n * @api\\n */\\nexport function toSize(size, opt_size) {\\n  if (Array.isArray(size)) {\\n    return size;\\n  } else {\\n    if (opt_size === undefined) {\\n      opt_size = [size, size];\\n    } else {\\n      opt_size[0] = opt_size[1] = /** @type {number} */ (size);\\n    }\\n    return opt_size;\\n  }\\n}\\n\",\"/**\\n * @module ol/PluggableMap\\n */\\nimport {getUid, inherits} from './index.js';\\nimport Collection from './Collection.js';\\nimport CollectionEventType from './CollectionEventType.js';\\nimport MapBrowserEvent from './MapBrowserEvent.js';\\nimport MapBrowserEventHandler from './MapBrowserEventHandler.js';\\nimport MapBrowserEventType from './MapBrowserEventType.js';\\nimport MapEvent from './MapEvent.js';\\nimport MapEventType from './MapEventType.js';\\nimport MapProperty from './MapProperty.js';\\nimport BaseObject, {getChangeEventType} from './Object.js';\\nimport ObjectEventType from './ObjectEventType.js';\\nimport TileQueue from './TileQueue.js';\\nimport View from './View.js';\\nimport ViewHint from './ViewHint.js';\\nimport {assert} from './asserts.js';\\nimport {removeNode} from './dom.js';\\nimport {listen, unlistenByKey, unlisten} from './events.js';\\nimport {stopPropagation} from './events/Event.js';\\nimport EventType from './events/EventType.js';\\nimport {createEmpty, clone, createOrUpdateEmpty, equals, getForViewAndSize, isEmpty} from './extent.js';\\nimport {TRUE} from './functions.js';\\nimport {DEVICE_PIXEL_RATIO, TOUCH} from './has.js';\\nimport LayerGroup from './layer/Group.js';\\nimport {hasArea} from './size.js';\\nimport {DROP} from './structs/PriorityQueue.js';\\nimport {create as createTransform, apply as applyTransform} from './transform.js';\\n\\n\\n/**\\n * State of the current frame. Only `pixelRatio`, `time` and `viewState` should\\n * be used in applications.\\n * @typedef {Object} FrameState\\n * @property {number} pixelRatio The pixel ratio of the frame.\\n * @property {number} time The time when rendering of the frame was requested.\\n * @property {module:ol/View~State} viewState The state of the current view.\\n * @property {boolean} animate\\n * @property {module:ol/transform~Transform} coordinateToPixelTransform\\n * @property {null|module:ol/extent~Extent} extent\\n * @property {module:ol/coordinate~Coordinate} focus\\n * @property {number} index\\n * @property {Object.<number, module:ol/layer/Layer~State>} layerStates\\n * @property {Array.<module:ol/layer/Layer~State>} layerStatesArray\\n * @property {module:ol/transform~Transform} pixelToCoordinateTransform\\n * @property {Array.<module:ol/PluggableMap~PostRenderFunction>} postRenderFunctions\\n * @property {module:ol/size~Size} size\\n * @property {!Object.<string, boolean>} skippedFeatureUids\\n * @property {module:ol/TileQueue} tileQueue\\n * @property {Object.<string, Object.<string, module:ol/TileRange>>} usedTiles\\n * @property {Array.<number>} viewHints\\n * @property {!Object.<string, Object.<string, boolean>>} wantedTiles\\n */\\n\\n\\n/**\\n * @typedef {function(module:ol/PluggableMap, ?module:ol/PluggableMap~FrameState): boolean} PostRenderFunction\\n */\\n\\n\\n/**\\n * @typedef {Object} AtPixelOptions\\n * @property {((function(module:ol/layer/Layer): boolean)|undefined)} layerFilter Layer filter\\n * function. The filter function will receive one argument, the\\n * {@link module:ol/layer/Layer layer-candidate} and it should return a boolean value.\\n * Only layers which are visible and for which this function returns `true`\\n * will be tested for features. By default, all visible layers will be tested.\\n * @property {number} [hitTolerance=0] Hit-detection tolerance in pixels. Pixels\\n * inside the radius around the given position will be checked for features. This only\\n * works for the canvas renderer and not for WebGL.\\n */\\n\\n\\n/**\\n * @typedef {Object} MapOptionsInternal\\n * @property {module:ol/Collection.<module:ol/control/Control>} [controls]\\n * @property {module:ol/Collection.<module:ol/interaction/Interaction>} [interactions]\\n * @property {Element|Document} keyboardEventTarget\\n * @property {module:ol/Collection.<module:ol/Overlay>} overlays\\n * @property {Object.<string, *>} values\\n */\\n\\n\\n/**\\n * Object literal with config options for the map.\\n * @typedef {Object} MapOptions\\n * @property {module:ol/Collection.<module:ol/control/Control>|Array.<module:ol/control/Control>} [controls]\\n * Controls initially added to the map. If not specified,\\n * {@link module:ol/control/util~defaults} is used.\\n * @property {number} [pixelRatio=window.devicePixelRatio] The ratio between\\n * physical pixels and device-independent pixels (dips) on the device.\\n * @property {module:ol/Collection.<module:ol/interaction/Interaction>|Array.<module:ol/interaction/Interaction>} [interactions]\\n * Interactions that are initially added to the map. If not specified,\\n * {@link module:ol/interaction~defaults} is used.\\n * @property {Element|Document|string} [keyboardEventTarget] The element to\\n * listen to keyboard events on. This determines when the `KeyboardPan` and\\n * `KeyboardZoom` interactions trigger. For example, if this option is set to\\n * `document` the keyboard interactions will always trigger. If this option is\\n * not specified, the element the library listens to keyboard events on is the\\n * map target (i.e. the user-provided div for the map). If this is not\\n * `document`, the target element needs to be focused for key events to be\\n * emitted, requiring that the target element has a `tabindex` attribute.\\n * @property {Array.<module:ol/layer/Base>|module:ol/Collection.<module:ol/layer/Base>} [layers]\\n * Layers. If this is not defined, a map with no layers will be rendered. Note\\n * that layers are rendered in the order supplied, so if you want, for example,\\n * a vector layer to appear on top of a tile layer, it must come after the tile\\n * layer.\\n * @property {number} [maxTilesLoading=16] Maximum number tiles to load\\n * simultaneously.\\n * @property {boolean} [loadTilesWhileAnimating=false] When set to `true`, tiles\\n * will be loaded during animations. This may improve the user experience, but\\n * can also make animations stutter on devices with slow memory.\\n * @property {boolean} [loadTilesWhileInteracting=false] When set to `true`,\\n * tiles will be loaded while interacting with the map. This may improve the\\n * user experience, but can also make map panning and zooming choppy on devices\\n * with slow memory.\\n * @property {number} [moveTolerance=1] The minimum distance in pixels the\\n * cursor must move to be detected as a map move event instead of a click.\\n * Increasing this value can make it easier to click on the map.\\n * @property {module:ol/Collection.<module:ol/Overlay>|Array.<module:ol/Overlay>} [overlays]\\n * Overlays initially added to the map. By default, no overlays are added.\\n * @property {Element|string} [target] The container for the map, either the\\n * element itself or the `id` of the element. If not specified at construction\\n * time, {@link module:ol/Map~Map#setTarget} must be called for the map to be\\n * rendered.\\n * @property {module:ol/View} [view] The map's view.  No layer sources will be\\n * fetched unless this is specified at construction time or through\\n * {@link module:ol/Map~Map#setView}.\\n */\\n\\n\\n/**\\n * @constructor\\n * @extends {module:ol/Object}\\n * @param {module:ol/PluggableMap~MapOptions} options Map options.\\n * @fires module:ol/MapBrowserEvent~MapBrowserEvent\\n * @fires module:ol/MapEvent~MapEvent\\n * @fires module:ol/render/Event~RenderEvent#postcompose\\n * @fires module:ol/render/Event~RenderEvent#precompose\\n * @api\\n */\\nconst PluggableMap = function(options) {\\n\\n  BaseObject.call(this);\\n\\n  const optionsInternal = createOptionsInternal(options);\\n\\n  /**\\n   * @type {number}\\n   * @private\\n   */\\n  this.maxTilesLoading_ = options.maxTilesLoading !== undefined ? options.maxTilesLoading : 16;\\n\\n  /**\\n   * @type {boolean}\\n   * @private\\n   */\\n  this.loadTilesWhileAnimating_ =\\n      options.loadTilesWhileAnimating !== undefined ?\\n        options.loadTilesWhileAnimating : false;\\n\\n  /**\\n   * @type {boolean}\\n   * @private\\n   */\\n  this.loadTilesWhileInteracting_ =\\n      options.loadTilesWhileInteracting !== undefined ?\\n        options.loadTilesWhileInteracting : false;\\n\\n  /**\\n   * @private\\n   * @type {number}\\n   */\\n  this.pixelRatio_ = options.pixelRatio !== undefined ?\\n    options.pixelRatio : DEVICE_PIXEL_RATIO;\\n\\n  /**\\n   * @private\\n   * @type {number|undefined}\\n   */\\n  this.animationDelayKey_;\\n\\n  /**\\n   * @private\\n   */\\n  this.animationDelay_ = function() {\\n    this.animationDelayKey_ = undefined;\\n    this.renderFrame_.call(this, Date.now());\\n  }.bind(this);\\n\\n  /**\\n   * @private\\n   * @type {module:ol/transform~Transform}\\n   */\\n  this.coordinateToPixelTransform_ = createTransform();\\n\\n  /**\\n   * @private\\n   * @type {module:ol/transform~Transform}\\n   */\\n  this.pixelToCoordinateTransform_ = createTransform();\\n\\n  /**\\n   * @private\\n   * @type {number}\\n   */\\n  this.frameIndex_ = 0;\\n\\n  /**\\n   * @private\\n   * @type {?module:ol/PluggableMap~FrameState}\\n   */\\n  this.frameState_ = null;\\n\\n  /**\\n   * The extent at the previous 'moveend' event.\\n   * @private\\n   * @type {module:ol/extent~Extent}\\n   */\\n  this.previousExtent_ = null;\\n\\n  /**\\n   * @private\\n   * @type {?module:ol/events~EventsKey}\\n   */\\n  this.viewPropertyListenerKey_ = null;\\n\\n  /**\\n   * @private\\n   * @type {?module:ol/events~EventsKey}\\n   */\\n  this.viewChangeListenerKey_ = null;\\n\\n  /**\\n   * @private\\n   * @type {Array.<module:ol/events~EventsKey>}\\n   */\\n  this.layerGroupPropertyListenerKeys_ = null;\\n\\n  /**\\n   * @private\\n   * @type {Element}\\n   */\\n  this.viewport_ = document.createElement('DIV');\\n  this.viewport_.className = 'ol-viewport' + (TOUCH ? ' ol-touch' : '');\\n  this.viewport_.style.position = 'relative';\\n  this.viewport_.style.overflow = 'hidden';\\n  this.viewport_.style.width = '100%';\\n  this.viewport_.style.height = '100%';\\n  // prevent page zoom on IE >= 10 browsers\\n  this.viewport_.style.msTouchAction = 'none';\\n  this.viewport_.style.touchAction = 'none';\\n\\n  /**\\n   * @private\\n   * @type {!Element}\\n   */\\n  this.overlayContainer_ = document.createElement('DIV');\\n  this.overlayContainer_.className = 'ol-overlaycontainer';\\n  this.viewport_.appendChild(this.overlayContainer_);\\n\\n  /**\\n   * @private\\n   * @type {!Element}\\n   */\\n  this.overlayContainerStopEvent_ = document.createElement('DIV');\\n  this.overlayContainerStopEvent_.className = 'ol-overlaycontainer-stopevent';\\n  const overlayEvents = [\\n    EventType.CLICK,\\n    EventType.DBLCLICK,\\n    EventType.MOUSEDOWN,\\n    EventType.TOUCHSTART,\\n    EventType.MSPOINTERDOWN,\\n    MapBrowserEventType.POINTERDOWN,\\n    EventType.MOUSEWHEEL,\\n    EventType.WHEEL\\n  ];\\n  for (let i = 0, ii = overlayEvents.length; i < ii; ++i) {\\n    listen(this.overlayContainerStopEvent_, overlayEvents[i], stopPropagation);\\n  }\\n  this.viewport_.appendChild(this.overlayContainerStopEvent_);\\n\\n  /**\\n   * @private\\n   * @type {module:ol/MapBrowserEventHandler}\\n   */\\n  this.mapBrowserEventHandler_ = new MapBrowserEventHandler(this, options.moveTolerance);\\n  for (const key in MapBrowserEventType) {\\n    listen(this.mapBrowserEventHandler_, MapBrowserEventType[key],\\n      this.handleMapBrowserEvent, this);\\n  }\\n\\n  /**\\n   * @private\\n   * @type {Element|Document}\\n   */\\n  this.keyboardEventTarget_ = optionsInternal.keyboardEventTarget;\\n\\n  /**\\n   * @private\\n   * @type {Array.<module:ol/events~EventsKey>}\\n   */\\n  this.keyHandlerKeys_ = null;\\n\\n  listen(this.viewport_, EventType.CONTEXTMENU, this.handleBrowserEvent, this);\\n  listen(this.viewport_, EventType.WHEEL, this.handleBrowserEvent, this);\\n  listen(this.viewport_, EventType.MOUSEWHEEL, this.handleBrowserEvent, this);\\n\\n  /**\\n   * @type {module:ol/Collection.<module:ol/control/Control>}\\n   * @protected\\n   */\\n  this.controls = optionsInternal.controls || new Collection();\\n\\n  /**\\n   * @type {module:ol/Collection.<module:ol/interaction/Interaction>}\\n   * @protected\\n   */\\n  this.interactions = optionsInternal.interactions || new Collection();\\n\\n  /**\\n   * @type {module:ol/Collection.<module:ol/Overlay>}\\n   * @private\\n   */\\n  this.overlays_ = optionsInternal.overlays;\\n\\n  /**\\n   * A lookup of overlays by id.\\n   * @private\\n   * @type {Object.<string, module:ol/Overlay>}\\n   */\\n  this.overlayIdIndex_ = {};\\n\\n  /**\\n   * @type {module:ol/renderer/Map}\\n   * @private\\n   */\\n  this.renderer_ = this.createRenderer(this.viewport_, this);\\n\\n  /**\\n   * @type {function(Event)|undefined}\\n   * @private\\n   */\\n  this.handleResize_;\\n\\n  /**\\n   * @private\\n   * @type {module:ol/coordinate~Coordinate}\\n   */\\n  this.focus_ = null;\\n\\n  /**\\n   * @private\\n   * @type {!Array.<module:ol/PluggableMap~PostRenderFunction>}\\n   */\\n  this.postRenderFunctions_ = [];\\n\\n  /**\\n   * @private\\n   * @type {module:ol/TileQueue}\\n   */\\n  this.tileQueue_ = new TileQueue(\\n    this.getTilePriority.bind(this),\\n    this.handleTileChange_.bind(this));\\n\\n  /**\\n   * Uids of features to skip at rendering time.\\n   * @type {Object.<string, boolean>}\\n   * @private\\n   */\\n  this.skippedFeatureUids_ = {};\\n\\n  listen(\\n    this, getChangeEventType(MapProperty.LAYERGROUP),\\n    this.handleLayerGroupChanged_, this);\\n  listen(this, getChangeEventType(MapProperty.VIEW),\\n    this.handleViewChanged_, this);\\n  listen(this, getChangeEventType(MapProperty.SIZE),\\n    this.handleSizeChanged_, this);\\n  listen(this, getChangeEventType(MapProperty.TARGET),\\n    this.handleTargetChanged_, this);\\n\\n  // setProperties will trigger the rendering of the map if the map\\n  // is \\\"defined\\\" already.\\n  this.setProperties(optionsInternal.values);\\n\\n  this.controls.forEach(\\n    /**\\n     * @param {module:ol/control/Control} control Control.\\n     * @this {module:ol/PluggableMap}\\n     */\\n    (function(control) {\\n      control.setMap(this);\\n    }).bind(this));\\n\\n  listen(this.controls, CollectionEventType.ADD,\\n    /**\\n     * @param {module:ol/Collection~CollectionEvent} event CollectionEvent.\\n     */\\n    function(event) {\\n      event.element.setMap(this);\\n    }, this);\\n\\n  listen(this.controls, CollectionEventType.REMOVE,\\n    /**\\n     * @param {module:ol/Collection~CollectionEvent} event CollectionEvent.\\n     */\\n    function(event) {\\n      event.element.setMap(null);\\n    }, this);\\n\\n  this.interactions.forEach(\\n    /**\\n     * @param {module:ol/interaction/Interaction} interaction Interaction.\\n     * @this {module:ol/PluggableMap}\\n     */\\n    (function(interaction) {\\n      interaction.setMap(this);\\n    }).bind(this));\\n\\n  listen(this.interactions, CollectionEventType.ADD,\\n    /**\\n     * @param {module:ol/Collection~CollectionEvent} event CollectionEvent.\\n     */\\n    function(event) {\\n      event.element.setMap(this);\\n    }, this);\\n\\n  listen(this.interactions, CollectionEventType.REMOVE,\\n    /**\\n     * @param {module:ol/Collection~CollectionEvent} event CollectionEvent.\\n     */\\n    function(event) {\\n      event.element.setMap(null);\\n    }, this);\\n\\n  this.overlays_.forEach(this.addOverlayInternal_.bind(this));\\n\\n  listen(this.overlays_, CollectionEventType.ADD,\\n    /**\\n     * @param {module:ol/Collection~CollectionEvent} event CollectionEvent.\\n     */\\n    function(event) {\\n      this.addOverlayInternal_(/** @type {module:ol/Overlay} */ (event.element));\\n    }, this);\\n\\n  listen(this.overlays_, CollectionEventType.REMOVE,\\n    /**\\n     * @param {module:ol/Collection~CollectionEvent} event CollectionEvent.\\n     */\\n    function(event) {\\n      const overlay = /** @type {module:ol/Overlay} */ (event.element);\\n      const id = overlay.getId();\\n      if (id !== undefined) {\\n        delete this.overlayIdIndex_[id.toString()];\\n      }\\n      event.element.setMap(null);\\n    }, this);\\n\\n};\\n\\ninherits(PluggableMap, BaseObject);\\n\\n\\nPluggableMap.prototype.createRenderer = function() {\\n  throw new Error('Use a map type that has a createRenderer method');\\n};\\n\\n\\n/**\\n * Add the given control to the map.\\n * @param {module:ol/control/Control} control Control.\\n * @api\\n */\\nPluggableMap.prototype.addControl = function(control) {\\n  this.getControls().push(control);\\n};\\n\\n\\n/**\\n * Add the given interaction to the map.\\n * @param {module:ol/interaction/Interaction} interaction Interaction to add.\\n * @api\\n */\\nPluggableMap.prototype.addInteraction = function(interaction) {\\n  this.getInteractions().push(interaction);\\n};\\n\\n\\n/**\\n * Adds the given layer to the top of this map. If you want to add a layer\\n * elsewhere in the stack, use `getLayers()` and the methods available on\\n * {@link module:ol/Collection~Collection}.\\n * @param {module:ol/layer/Base} layer Layer.\\n * @api\\n */\\nPluggableMap.prototype.addLayer = function(layer) {\\n  const layers = this.getLayerGroup().getLayers();\\n  layers.push(layer);\\n};\\n\\n\\n/**\\n * Add the given overlay to the map.\\n * @param {module:ol/Overlay} overlay Overlay.\\n * @api\\n */\\nPluggableMap.prototype.addOverlay = function(overlay) {\\n  this.getOverlays().push(overlay);\\n};\\n\\n\\n/**\\n * This deals with map's overlay collection changes.\\n * @param {module:ol/Overlay} overlay Overlay.\\n * @private\\n */\\nPluggableMap.prototype.addOverlayInternal_ = function(overlay) {\\n  const id = overlay.getId();\\n  if (id !== undefined) {\\n    this.overlayIdIndex_[id.toString()] = overlay;\\n  }\\n  overlay.setMap(this);\\n};\\n\\n\\n/**\\n *\\n * @inheritDoc\\n */\\nPluggableMap.prototype.disposeInternal = function() {\\n  this.mapBrowserEventHandler_.dispose();\\n  unlisten(this.viewport_, EventType.CONTEXTMENU, this.handleBrowserEvent, this);\\n  unlisten(this.viewport_, EventType.WHEEL, this.handleBrowserEvent, this);\\n  unlisten(this.viewport_, EventType.MOUSEWHEEL, this.handleBrowserEvent, this);\\n  if (this.handleResize_ !== undefined) {\\n    removeEventListener(EventType.RESIZE, this.handleResize_, false);\\n    this.handleResize_ = undefined;\\n  }\\n  if (this.animationDelayKey_) {\\n    cancelAnimationFrame(this.animationDelayKey_);\\n    this.animationDelayKey_ = undefined;\\n  }\\n  this.setTarget(null);\\n  BaseObject.prototype.disposeInternal.call(this);\\n};\\n\\n\\n/**\\n * Detect features that intersect a pixel on the viewport, and execute a\\n * callback with each intersecting feature. Layers included in the detection can\\n * be configured through the `layerFilter` option in `opt_options`.\\n * @param {module:ol~Pixel} pixel Pixel.\\n * @param {function(this: S, (module:ol/Feature|module:ol/render/Feature),\\n *     module:ol/layer/Layer): T} callback Feature callback. The callback will be\\n *     called with two arguments. The first argument is one\\n *     {@link module:ol/Feature feature} or\\n *     {@link module:ol/render/Feature render feature} at the pixel, the second is\\n *     the {@link module:ol/layer/Layer layer} of the feature and will be null for\\n *     unmanaged layers. To stop detection, callback functions can return a\\n *     truthy value.\\n * @param {module:ol/PluggableMap~AtPixelOptions=} opt_options Optional options.\\n * @return {T|undefined} Callback result, i.e. the return value of last\\n * callback execution, or the first truthy callback return value.\\n * @template S,T\\n * @api\\n */\\nPluggableMap.prototype.forEachFeatureAtPixel = function(pixel, callback, opt_options) {\\n  if (!this.frameState_) {\\n    return;\\n  }\\n  const coordinate = this.getCoordinateFromPixel(pixel);\\n  opt_options = opt_options !== undefined ? opt_options : {};\\n  const hitTolerance = opt_options.hitTolerance !== undefined ?\\n    opt_options.hitTolerance * this.frameState_.pixelRatio : 0;\\n  const layerFilter = opt_options.layerFilter !== undefined ?\\n    opt_options.layerFilter : TRUE;\\n  return this.renderer_.forEachFeatureAtCoordinate(\\n    coordinate, this.frameState_, hitTolerance, callback, null,\\n    layerFilter, null);\\n};\\n\\n\\n/**\\n * Get all features that intersect a pixel on the viewport.\\n * @param {module:ol~Pixel} pixel Pixel.\\n * @param {module:ol/PluggableMap~AtPixelOptions=} opt_options Optional options.\\n * @return {Array.<module:ol/Feature|module:ol/render/Feature>} The detected features or\\n * `null` if none were found.\\n * @api\\n */\\nPluggableMap.prototype.getFeaturesAtPixel = function(pixel, opt_options) {\\n  let features = null;\\n  this.forEachFeatureAtPixel(pixel, function(feature) {\\n    if (!features) {\\n      features = [];\\n    }\\n    features.push(feature);\\n  }, opt_options);\\n  return features;\\n};\\n\\n/**\\n * Detect layers that have a color value at a pixel on the viewport, and\\n * execute a callback with each matching layer. Layers included in the\\n * detection can be configured through `opt_layerFilter`.\\n * @param {module:ol~Pixel} pixel Pixel.\\n * @param {function(this: S, module:ol/layer/Layer, (Uint8ClampedArray|Uint8Array)): T} callback\\n *     Layer callback. This callback will receive two arguments: first is the\\n *     {@link module:ol/layer/Layer layer}, second argument is an array representing\\n *     [R, G, B, A] pixel values (0 - 255) and will be `null` for layer types\\n *     that do not currently support this argument. To stop detection, callback\\n *     functions can return a truthy value.\\n * @param {S=} opt_this Value to use as `this` when executing `callback`.\\n * @param {(function(this: U, module:ol/layer/Layer): boolean)=} opt_layerFilter Layer\\n *     filter function. The filter function will receive one argument, the\\n *     {@link module:ol/layer/Layer layer-candidate} and it should return a boolean\\n *     value. Only layers which are visible and for which this function returns\\n *     `true` will be tested for features. By default, all visible layers will\\n *     be tested.\\n * @param {U=} opt_this2 Value to use as `this` when executing `layerFilter`.\\n * @return {T|undefined} Callback result, i.e. the return value of last\\n * callback execution, or the first truthy callback return value.\\n * @template S,T,U\\n * @api\\n */\\nPluggableMap.prototype.forEachLayerAtPixel = function(pixel, callback, opt_this, opt_layerFilter, opt_this2) {\\n  if (!this.frameState_) {\\n    return;\\n  }\\n  const thisArg = opt_this !== undefined ? opt_this : null;\\n  const layerFilter = opt_layerFilter !== undefined ? opt_layerFilter : TRUE;\\n  const thisArg2 = opt_this2 !== undefined ? opt_this2 : null;\\n  return this.renderer_.forEachLayerAtPixel(\\n    pixel, this.frameState_, callback, thisArg,\\n    layerFilter, thisArg2);\\n};\\n\\n\\n/**\\n * Detect if features intersect a pixel on the viewport. Layers included in the\\n * detection can be configured through `opt_layerFilter`.\\n * @param {module:ol~Pixel} pixel Pixel.\\n * @param {module:ol/PluggableMap~AtPixelOptions=} opt_options Optional options.\\n * @return {boolean} Is there a feature at the given pixel?\\n * @template U\\n * @api\\n */\\nPluggableMap.prototype.hasFeatureAtPixel = function(pixel, opt_options) {\\n  if (!this.frameState_) {\\n    return false;\\n  }\\n  const coordinate = this.getCoordinateFromPixel(pixel);\\n  opt_options = opt_options !== undefined ? opt_options : {};\\n  const layerFilter = opt_options.layerFilter !== undefined ? opt_options.layerFilter : TRUE;\\n  const hitTolerance = opt_options.hitTolerance !== undefined ?\\n    opt_options.hitTolerance * this.frameState_.pixelRatio : 0;\\n  return this.renderer_.hasFeatureAtCoordinate(\\n    coordinate, this.frameState_, hitTolerance, layerFilter, null);\\n};\\n\\n\\n/**\\n * Returns the coordinate in view projection for a browser event.\\n * @param {Event} event Event.\\n * @return {module:ol/coordinate~Coordinate} Coordinate.\\n * @api\\n */\\nPluggableMap.prototype.getEventCoordinate = function(event) {\\n  return this.getCoordinateFromPixel(this.getEventPixel(event));\\n};\\n\\n\\n/**\\n * Returns the map pixel position for a browser event relative to the viewport.\\n * @param {Event} event Event.\\n * @return {module:ol~Pixel} Pixel.\\n * @api\\n */\\nPluggableMap.prototype.getEventPixel = function(event) {\\n  const viewportPosition = this.viewport_.getBoundingClientRect();\\n  const eventPosition = event.changedTouches ? event.changedTouches[0] : event;\\n  return [\\n    eventPosition.clientX - viewportPosition.left,\\n    eventPosition.clientY - viewportPosition.top\\n  ];\\n};\\n\\n\\n/**\\n * Get the target in which this map is rendered.\\n * Note that this returns what is entered as an option or in setTarget:\\n * if that was an element, it returns an element; if a string, it returns that.\\n * @return {Element|string|undefined} The Element or id of the Element that the\\n *     map is rendered in.\\n * @observable\\n * @api\\n */\\nPluggableMap.prototype.getTarget = function() {\\n  return /** @type {Element|string|undefined} */ (this.get(MapProperty.TARGET));\\n};\\n\\n\\n/**\\n * Get the DOM element into which this map is rendered. In contrast to\\n * `getTarget` this method always return an `Element`, or `null` if the\\n * map has no target.\\n * @return {Element} The element that the map is rendered in.\\n * @api\\n */\\nPluggableMap.prototype.getTargetElement = function() {\\n  const target = this.getTarget();\\n  if (target !== undefined) {\\n    return typeof target === 'string' ? document.getElementById(target) : target;\\n  } else {\\n    return null;\\n  }\\n};\\n\\n\\n/**\\n * Get the coordinate for a given pixel.  This returns a coordinate in the\\n * map view projection.\\n * @param {module:ol~Pixel} pixel Pixel position in the map viewport.\\n * @return {module:ol/coordinate~Coordinate} The coordinate for the pixel position.\\n * @api\\n */\\nPluggableMap.prototype.getCoordinateFromPixel = function(pixel) {\\n  const frameState = this.frameState_;\\n  if (!frameState) {\\n    return null;\\n  } else {\\n    return applyTransform(frameState.pixelToCoordinateTransform, pixel.slice());\\n  }\\n};\\n\\n\\n/**\\n * Get the map controls. Modifying this collection changes the controls\\n * associated with the map.\\n * @return {module:ol/Collection.<module:ol/control/Control>} Controls.\\n * @api\\n */\\nPluggableMap.prototype.getControls = function() {\\n  return this.controls;\\n};\\n\\n\\n/**\\n * Get the map overlays. Modifying this collection changes the overlays\\n * associated with the map.\\n * @return {module:ol/Collection.<module:ol/Overlay>} Overlays.\\n * @api\\n */\\nPluggableMap.prototype.getOverlays = function() {\\n  return this.overlays_;\\n};\\n\\n\\n/**\\n * Get an overlay by its identifier (the value returned by overlay.getId()).\\n * Note that the index treats string and numeric identifiers as the same. So\\n * `map.getOverlayById(2)` will return an overlay with id `'2'` or `2`.\\n * @param {string|number} id Overlay identifier.\\n * @return {module:ol/Overlay} Overlay.\\n * @api\\n */\\nPluggableMap.prototype.getOverlayById = function(id) {\\n  const overlay = this.overlayIdIndex_[id.toString()];\\n  return overlay !== undefined ? overlay : null;\\n};\\n\\n\\n/**\\n * Get the map interactions. Modifying this collection changes the interactions\\n * associated with the map.\\n *\\n * Interactions are used for e.g. pan, zoom and rotate.\\n * @return {module:ol/Collection.<module:ol/interaction/Interaction>} Interactions.\\n * @api\\n */\\nPluggableMap.prototype.getInteractions = function() {\\n  return this.interactions;\\n};\\n\\n\\n/**\\n * Get the layergroup associated with this map.\\n * @return {module:ol/layer/Group} A layer group containing the layers in this map.\\n * @observable\\n * @api\\n */\\nPluggableMap.prototype.getLayerGroup = function() {\\n  return (\\n    /** @type {module:ol/layer/Group} */ (this.get(MapProperty.LAYERGROUP))\\n  );\\n};\\n\\n\\n/**\\n * Get the collection of layers associated with this map.\\n * @return {!module:ol/Collection.<module:ol/layer/Base>} Layers.\\n * @api\\n */\\nPluggableMap.prototype.getLayers = function() {\\n  const layers = this.getLayerGroup().getLayers();\\n  return layers;\\n};\\n\\n\\n/**\\n * Get the pixel for a coordinate.  This takes a coordinate in the map view\\n * projection and returns the corresponding pixel.\\n * @param {module:ol/coordinate~Coordinate} coordinate A map coordinate.\\n * @return {module:ol~Pixel} A pixel position in the map viewport.\\n * @api\\n */\\nPluggableMap.prototype.getPixelFromCoordinate = function(coordinate) {\\n  const frameState = this.frameState_;\\n  if (!frameState) {\\n    return null;\\n  } else {\\n    return applyTransform(frameState.coordinateToPixelTransform, coordinate.slice(0, 2));\\n  }\\n};\\n\\n\\n/**\\n * Get the map renderer.\\n * @return {module:ol/renderer/Map} Renderer\\n */\\nPluggableMap.prototype.getRenderer = function() {\\n  return this.renderer_;\\n};\\n\\n\\n/**\\n * Get the size of this map.\\n * @return {module:ol/size~Size|undefined} The size in pixels of the map in the DOM.\\n * @observable\\n * @api\\n */\\nPluggableMap.prototype.getSize = function() {\\n  return (\\n    /** @type {module:ol/size~Size|undefined} */ (this.get(MapProperty.SIZE))\\n  );\\n};\\n\\n\\n/**\\n * Get the view associated with this map. A view manages properties such as\\n * center and resolution.\\n * @return {module:ol/View} The view that controls this map.\\n * @observable\\n * @api\\n */\\nPluggableMap.prototype.getView = function() {\\n  return (\\n    /** @type {module:ol/View} */ (this.get(MapProperty.VIEW))\\n  );\\n};\\n\\n\\n/**\\n * Get the element that serves as the map viewport.\\n * @return {Element} Viewport.\\n * @api\\n */\\nPluggableMap.prototype.getViewport = function() {\\n  return this.viewport_;\\n};\\n\\n\\n/**\\n * Get the element that serves as the container for overlays.  Elements added to\\n * this container will let mousedown and touchstart events through to the map,\\n * so clicks and gestures on an overlay will trigger {@link module:ol/MapBrowserEvent~MapBrowserEvent}\\n * events.\\n * @return {!Element} The map's overlay container.\\n */\\nPluggableMap.prototype.getOverlayContainer = function() {\\n  return this.overlayContainer_;\\n};\\n\\n\\n/**\\n * Get the element that serves as a container for overlays that don't allow\\n * event propagation. Elements added to this container won't let mousedown and\\n * touchstart events through to the map, so clicks and gestures on an overlay\\n * don't trigger any {@link module:ol/MapBrowserEvent~MapBrowserEvent}.\\n * @return {!Element} The map's overlay container that stops events.\\n */\\nPluggableMap.prototype.getOverlayContainerStopEvent = function() {\\n  return this.overlayContainerStopEvent_;\\n};\\n\\n\\n/**\\n * @param {module:ol/Tile} tile Tile.\\n * @param {string} tileSourceKey Tile source key.\\n * @param {module:ol/coordinate~Coordinate} tileCenter Tile center.\\n * @param {number} tileResolution Tile resolution.\\n * @return {number} Tile priority.\\n */\\nPluggableMap.prototype.getTilePriority = function(tile, tileSourceKey, tileCenter, tileResolution) {\\n  // Filter out tiles at higher zoom levels than the current zoom level, or that\\n  // are outside the visible extent.\\n  const frameState = this.frameState_;\\n  if (!frameState || !(tileSourceKey in frameState.wantedTiles)) {\\n    return DROP;\\n  }\\n  if (!frameState.wantedTiles[tileSourceKey][tile.getKey()]) {\\n    return DROP;\\n  }\\n  // Prioritize the highest zoom level tiles closest to the focus.\\n  // Tiles at higher zoom levels are prioritized using Math.log(tileResolution).\\n  // Within a zoom level, tiles are prioritized by the distance in pixels\\n  // between the center of the tile and the focus.  The factor of 65536 means\\n  // that the prioritization should behave as desired for tiles up to\\n  // 65536 * Math.log(2) = 45426 pixels from the focus.\\n  const deltaX = tileCenter[0] - frameState.focus[0];\\n  const deltaY = tileCenter[1] - frameState.focus[1];\\n  return 65536 * Math.log(tileResolution) +\\n      Math.sqrt(deltaX * deltaX + deltaY * deltaY) / tileResolution;\\n};\\n\\n\\n/**\\n * @param {Event} browserEvent Browser event.\\n * @param {string=} opt_type Type.\\n */\\nPluggableMap.prototype.handleBrowserEvent = function(browserEvent, opt_type) {\\n  const type = opt_type || browserEvent.type;\\n  const mapBrowserEvent = new MapBrowserEvent(type, this, browserEvent);\\n  this.handleMapBrowserEvent(mapBrowserEvent);\\n};\\n\\n\\n/**\\n * @param {module:ol/MapBrowserEvent} mapBrowserEvent The event to handle.\\n */\\nPluggableMap.prototype.handleMapBrowserEvent = function(mapBrowserEvent) {\\n  if (!this.frameState_) {\\n    // With no view defined, we cannot translate pixels into geographical\\n    // coordinates so interactions cannot be used.\\n    return;\\n  }\\n  this.focus_ = mapBrowserEvent.coordinate;\\n  mapBrowserEvent.frameState = this.frameState_;\\n  const interactionsArray = this.getInteractions().getArray();\\n  if (this.dispatchEvent(mapBrowserEvent) !== false) {\\n    for (let i = interactionsArray.length - 1; i >= 0; i--) {\\n      const interaction = interactionsArray[i];\\n      if (!interaction.getActive()) {\\n        continue;\\n      }\\n      const cont = interaction.handleEvent(mapBrowserEvent);\\n      if (!cont) {\\n        break;\\n      }\\n    }\\n  }\\n};\\n\\n\\n/**\\n * @protected\\n */\\nPluggableMap.prototype.handlePostRender = function() {\\n\\n  const frameState = this.frameState_;\\n\\n  // Manage the tile queue\\n  // Image loads are expensive and a limited resource, so try to use them\\n  // efficiently:\\n  // * When the view is static we allow a large number of parallel tile loads\\n  //   to complete the frame as quickly as possible.\\n  // * When animating or interacting, image loads can cause janks, so we reduce\\n  //   the maximum number of loads per frame and limit the number of parallel\\n  //   tile loads to remain reactive to view changes and to reduce the chance of\\n  //   loading tiles that will quickly disappear from view.\\n  const tileQueue = this.tileQueue_;\\n  if (!tileQueue.isEmpty()) {\\n    let maxTotalLoading = this.maxTilesLoading_;\\n    let maxNewLoads = maxTotalLoading;\\n    if (frameState) {\\n      const hints = frameState.viewHints;\\n      if (hints[ViewHint.ANIMATING]) {\\n        maxTotalLoading = this.loadTilesWhileAnimating_ ? 8 : 0;\\n        maxNewLoads = 2;\\n      }\\n      if (hints[ViewHint.INTERACTING]) {\\n        maxTotalLoading = this.loadTilesWhileInteracting_ ? 8 : 0;\\n        maxNewLoads = 2;\\n      }\\n    }\\n    if (tileQueue.getTilesLoading() < maxTotalLoading) {\\n      tileQueue.reprioritize(); // FIXME only call if view has changed\\n      tileQueue.loadMoreTiles(maxTotalLoading, maxNewLoads);\\n    }\\n  }\\n\\n  const postRenderFunctions = this.postRenderFunctions_;\\n  for (let i = 0, ii = postRenderFunctions.length; i < ii; ++i) {\\n    postRenderFunctions[i](this, frameState);\\n  }\\n  postRenderFunctions.length = 0;\\n};\\n\\n\\n/**\\n * @private\\n */\\nPluggableMap.prototype.handleSizeChanged_ = function() {\\n  this.render();\\n};\\n\\n\\n/**\\n * @private\\n */\\nPluggableMap.prototype.handleTargetChanged_ = function() {\\n  // target may be undefined, null, a string or an Element.\\n  // If it's a string we convert it to an Element before proceeding.\\n  // If it's not now an Element we remove the viewport from the DOM.\\n  // If it's an Element we append the viewport element to it.\\n\\n  let targetElement;\\n  if (this.getTarget()) {\\n    targetElement = this.getTargetElement();\\n  }\\n\\n  if (this.keyHandlerKeys_) {\\n    for (let i = 0, ii = this.keyHandlerKeys_.length; i < ii; ++i) {\\n      unlistenByKey(this.keyHandlerKeys_[i]);\\n    }\\n    this.keyHandlerKeys_ = null;\\n  }\\n\\n  if (!targetElement) {\\n    this.renderer_.removeLayerRenderers();\\n    removeNode(this.viewport_);\\n    if (this.handleResize_ !== undefined) {\\n      removeEventListener(EventType.RESIZE, this.handleResize_, false);\\n      this.handleResize_ = undefined;\\n    }\\n  } else {\\n    targetElement.appendChild(this.viewport_);\\n\\n    const keyboardEventTarget = !this.keyboardEventTarget_ ?\\n      targetElement : this.keyboardEventTarget_;\\n    this.keyHandlerKeys_ = [\\n      listen(keyboardEventTarget, EventType.KEYDOWN, this.handleBrowserEvent, this),\\n      listen(keyboardEventTarget, EventType.KEYPRESS, this.handleBrowserEvent, this)\\n    ];\\n\\n    if (!this.handleResize_) {\\n      this.handleResize_ = this.updateSize.bind(this);\\n      addEventListener(EventType.RESIZE, this.handleResize_, false);\\n    }\\n  }\\n\\n  this.updateSize();\\n  // updateSize calls setSize, so no need to call this.render\\n  // ourselves here.\\n};\\n\\n\\n/**\\n * @private\\n */\\nPluggableMap.prototype.handleTileChange_ = function() {\\n  this.render();\\n};\\n\\n\\n/**\\n * @private\\n */\\nPluggableMap.prototype.handleViewPropertyChanged_ = function() {\\n  this.render();\\n};\\n\\n\\n/**\\n * @private\\n */\\nPluggableMap.prototype.handleViewChanged_ = function() {\\n  if (this.viewPropertyListenerKey_) {\\n    unlistenByKey(this.viewPropertyListenerKey_);\\n    this.viewPropertyListenerKey_ = null;\\n  }\\n  if (this.viewChangeListenerKey_) {\\n    unlistenByKey(this.viewChangeListenerKey_);\\n    this.viewChangeListenerKey_ = null;\\n  }\\n  const view = this.getView();\\n  if (view) {\\n    this.viewport_.setAttribute('data-view', getUid(view));\\n    this.viewPropertyListenerKey_ = listen(\\n      view, ObjectEventType.PROPERTYCHANGE,\\n      this.handleViewPropertyChanged_, this);\\n    this.viewChangeListenerKey_ = listen(\\n      view, EventType.CHANGE,\\n      this.handleViewPropertyChanged_, this);\\n  }\\n  this.render();\\n};\\n\\n\\n/**\\n * @private\\n */\\nPluggableMap.prototype.handleLayerGroupChanged_ = function() {\\n  if (this.layerGroupPropertyListenerKeys_) {\\n    this.layerGroupPropertyListenerKeys_.forEach(unlistenByKey);\\n    this.layerGroupPropertyListenerKeys_ = null;\\n  }\\n  const layerGroup = this.getLayerGroup();\\n  if (layerGroup) {\\n    this.layerGroupPropertyListenerKeys_ = [\\n      listen(\\n        layerGroup, ObjectEventType.PROPERTYCHANGE,\\n        this.render, this),\\n      listen(\\n        layerGroup, EventType.CHANGE,\\n        this.render, this)\\n    ];\\n  }\\n  this.render();\\n};\\n\\n\\n/**\\n * @return {boolean} Is rendered.\\n */\\nPluggableMap.prototype.isRendered = function() {\\n  return !!this.frameState_;\\n};\\n\\n\\n/**\\n * Requests an immediate render in a synchronous manner.\\n * @api\\n */\\nPluggableMap.prototype.renderSync = function() {\\n  if (this.animationDelayKey_) {\\n    cancelAnimationFrame(this.animationDelayKey_);\\n  }\\n  this.animationDelay_();\\n};\\n\\n\\n/**\\n * Request a map rendering (at the next animation frame).\\n * @api\\n */\\nPluggableMap.prototype.render = function() {\\n  if (this.animationDelayKey_ === undefined) {\\n    this.animationDelayKey_ = requestAnimationFrame(this.animationDelay_);\\n  }\\n};\\n\\n\\n/**\\n * Remove the given control from the map.\\n * @param {module:ol/control/Control} control Control.\\n * @return {module:ol/control/Control|undefined} The removed control (or undefined\\n *     if the control was not found).\\n * @api\\n */\\nPluggableMap.prototype.removeControl = function(control) {\\n  return this.getControls().remove(control);\\n};\\n\\n\\n/**\\n * Remove the given interaction from the map.\\n * @param {module:ol/interaction/Interaction} interaction Interaction to remove.\\n * @return {module:ol/interaction/Interaction|undefined} The removed interaction (or\\n *     undefined if the interaction was not found).\\n * @api\\n */\\nPluggableMap.prototype.removeInteraction = function(interaction) {\\n  return this.getInteractions().remove(interaction);\\n};\\n\\n\\n/**\\n * Removes the given layer from the map.\\n * @param {module:ol/layer/Base} layer Layer.\\n * @return {module:ol/layer/Base|undefined} The removed layer (or undefined if the\\n *     layer was not found).\\n * @api\\n */\\nPluggableMap.prototype.removeLayer = function(layer) {\\n  const layers = this.getLayerGroup().getLayers();\\n  return layers.remove(layer);\\n};\\n\\n\\n/**\\n * Remove the given overlay from the map.\\n * @param {module:ol/Overlay} overlay Overlay.\\n * @return {module:ol/Overlay|undefined} The removed overlay (or undefined\\n *     if the overlay was not found).\\n * @api\\n */\\nPluggableMap.prototype.removeOverlay = function(overlay) {\\n  return this.getOverlays().remove(overlay);\\n};\\n\\n\\n/**\\n * @param {number} time Time.\\n * @private\\n */\\nPluggableMap.prototype.renderFrame_ = function(time) {\\n  let viewState;\\n\\n  const size = this.getSize();\\n  const view = this.getView();\\n  const extent = createEmpty();\\n  const previousFrameState = this.frameState_;\\n  /** @type {?module:ol/PluggableMap~FrameState} */\\n  let frameState = null;\\n  if (size !== undefined && hasArea(size) && view && view.isDef()) {\\n    const viewHints = view.getHints(this.frameState_ ? this.frameState_.viewHints : undefined);\\n    const layerStatesArray = this.getLayerGroup().getLayerStatesArray();\\n    const layerStates = {};\\n    for (let i = 0, ii = layerStatesArray.length; i < ii; ++i) {\\n      layerStates[getUid(layerStatesArray[i].layer)] = layerStatesArray[i];\\n    }\\n    viewState = view.getState();\\n    let focus = this.focus_;\\n    if (!focus) {\\n      focus = viewState.center;\\n      const pixelResolution = viewState.resolution / this.pixelRatio_;\\n      focus[0] = Math.round(focus[0] / pixelResolution) * pixelResolution;\\n      focus[1] = Math.round(focus[1] / pixelResolution) * pixelResolution;\\n    }\\n    frameState = /** @type {module:ol/PluggableMap~FrameState} */ ({\\n      animate: false,\\n      coordinateToPixelTransform: this.coordinateToPixelTransform_,\\n      extent: extent,\\n      focus: focus,\\n      index: this.frameIndex_++,\\n      layerStates: layerStates,\\n      layerStatesArray: layerStatesArray,\\n      pixelRatio: this.pixelRatio_,\\n      pixelToCoordinateTransform: this.pixelToCoordinateTransform_,\\n      postRenderFunctions: [],\\n      size: size,\\n      skippedFeatureUids: this.skippedFeatureUids_,\\n      tileQueue: this.tileQueue_,\\n      time: time,\\n      usedTiles: {},\\n      viewState: viewState,\\n      viewHints: viewHints,\\n      wantedTiles: {}\\n    });\\n  }\\n\\n  if (frameState) {\\n    frameState.extent = getForViewAndSize(viewState.center,\\n      viewState.resolution, viewState.rotation, frameState.size, extent);\\n  }\\n\\n  this.frameState_ = frameState;\\n  this.renderer_.renderFrame(frameState);\\n\\n  if (frameState) {\\n    if (frameState.animate) {\\n      this.render();\\n    }\\n    Array.prototype.push.apply(this.postRenderFunctions_, frameState.postRenderFunctions);\\n\\n    if (previousFrameState) {\\n      const moveStart = !this.previousExtent_ ||\\n                  (!isEmpty(this.previousExtent_) &&\\n                  !equals(frameState.extent, this.previousExtent_));\\n      if (moveStart) {\\n        this.dispatchEvent(\\n          new MapEvent(MapEventType.MOVESTART, this, previousFrameState));\\n        this.previousExtent_ = createOrUpdateEmpty(this.previousExtent_);\\n      }\\n    }\\n\\n    const idle = this.previousExtent_ &&\\n        !frameState.viewHints[ViewHint.ANIMATING] &&\\n        !frameState.viewHints[ViewHint.INTERACTING] &&\\n        !equals(frameState.extent, this.previousExtent_);\\n\\n    if (idle) {\\n      this.dispatchEvent(new MapEvent(MapEventType.MOVEEND, this, frameState));\\n      clone(frameState.extent, this.previousExtent_);\\n    }\\n  }\\n\\n  this.dispatchEvent(new MapEvent(MapEventType.POSTRENDER, this, frameState));\\n\\n  setTimeout(this.handlePostRender.bind(this), 0);\\n\\n};\\n\\n\\n/**\\n * Sets the layergroup of this map.\\n * @param {module:ol/layer/Group} layerGroup A layer group containing the layers in this map.\\n * @observable\\n * @api\\n */\\nPluggableMap.prototype.setLayerGroup = function(layerGroup) {\\n  this.set(MapProperty.LAYERGROUP, layerGroup);\\n};\\n\\n\\n/**\\n * Set the size of this map.\\n * @param {module:ol/size~Size|undefined} size The size in pixels of the map in the DOM.\\n * @observable\\n * @api\\n */\\nPluggableMap.prototype.setSize = function(size) {\\n  this.set(MapProperty.SIZE, size);\\n};\\n\\n\\n/**\\n * Set the target element to render this map into.\\n * @param {Element|string|undefined} target The Element or id of the Element\\n *     that the map is rendered in.\\n * @observable\\n * @api\\n */\\nPluggableMap.prototype.setTarget = function(target) {\\n  this.set(MapProperty.TARGET, target);\\n};\\n\\n\\n/**\\n * Set the view for this map.\\n * @param {module:ol/View} view The view that controls this map.\\n * @observable\\n * @api\\n */\\nPluggableMap.prototype.setView = function(view) {\\n  this.set(MapProperty.VIEW, view);\\n};\\n\\n\\n/**\\n * @param {module:ol/Feature} feature Feature.\\n */\\nPluggableMap.prototype.skipFeature = function(feature) {\\n  const featureUid = getUid(feature).toString();\\n  this.skippedFeatureUids_[featureUid] = true;\\n  this.render();\\n};\\n\\n\\n/**\\n * Force a recalculation of the map viewport size.  This should be called when\\n * third-party code changes the size of the map viewport.\\n * @api\\n */\\nPluggableMap.prototype.updateSize = function() {\\n  const targetElement = this.getTargetElement();\\n\\n  if (!targetElement) {\\n    this.setSize(undefined);\\n  } else {\\n    const computedStyle = getComputedStyle(targetElement);\\n    this.setSize([\\n      targetElement.offsetWidth -\\n          parseFloat(computedStyle['borderLeftWidth']) -\\n          parseFloat(computedStyle['paddingLeft']) -\\n          parseFloat(computedStyle['paddingRight']) -\\n          parseFloat(computedStyle['borderRightWidth']),\\n      targetElement.offsetHeight -\\n          parseFloat(computedStyle['borderTopWidth']) -\\n          parseFloat(computedStyle['paddingTop']) -\\n          parseFloat(computedStyle['paddingBottom']) -\\n          parseFloat(computedStyle['borderBottomWidth'])\\n    ]);\\n  }\\n};\\n\\n\\n/**\\n * @param {module:ol/Feature} feature Feature.\\n */\\nPluggableMap.prototype.unskipFeature = function(feature) {\\n  const featureUid = getUid(feature).toString();\\n  delete this.skippedFeatureUids_[featureUid];\\n  this.render();\\n};\\n\\n\\n/**\\n * @param {MapOptions} options Map options.\\n * @return {module:ol/PluggableMap~MapOptionsInternal} Internal map options.\\n */\\nfunction createOptionsInternal(options) {\\n\\n  /**\\n   * @type {Element|Document}\\n   */\\n  let keyboardEventTarget = null;\\n  if (options.keyboardEventTarget !== undefined) {\\n    keyboardEventTarget = typeof options.keyboardEventTarget === 'string' ?\\n      document.getElementById(options.keyboardEventTarget) :\\n      options.keyboardEventTarget;\\n  }\\n\\n  /**\\n   * @type {Object.<string, *>}\\n   */\\n  const values = {};\\n\\n  const layerGroup = (options.layers instanceof LayerGroup) ?\\n    options.layers : new LayerGroup({layers: options.layers});\\n  values[MapProperty.LAYERGROUP] = layerGroup;\\n\\n  values[MapProperty.TARGET] = options.target;\\n\\n  values[MapProperty.VIEW] = options.view !== undefined ?\\n    options.view : new View();\\n\\n  let controls;\\n  if (options.controls !== undefined) {\\n    if (Array.isArray(options.controls)) {\\n      controls = new Collection(options.controls.slice());\\n    } else {\\n      assert(options.controls instanceof Collection,\\n        47); // Expected `controls` to be an array or an `module:ol/Collection~Collection`\\n      controls = options.controls;\\n    }\\n  }\\n\\n  let interactions;\\n  if (options.interactions !== undefined) {\\n    if (Array.isArray(options.interactions)) {\\n      interactions = new Collection(options.interactions.slice());\\n    } else {\\n      assert(options.interactions instanceof Collection,\\n        48); // Expected `interactions` to be an array or an `module:ol/Collection~Collection`\\n      interactions = options.interactions;\\n    }\\n  }\\n\\n  let overlays;\\n  if (options.overlays !== undefined) {\\n    if (Array.isArray(options.overlays)) {\\n      overlays = new Collection(options.overlays.slice());\\n    } else {\\n      assert(options.overlays instanceof Collection,\\n        49); // Expected `overlays` to be an array or an `module:ol/Collection~Collection`\\n      overlays = options.overlays;\\n    }\\n  } else {\\n    overlays = new Collection();\\n  }\\n\\n  return {\\n    controls: controls,\\n    interactions: interactions,\\n    keyboardEventTarget: keyboardEventTarget,\\n    overlays: overlays,\\n    values: values\\n  };\\n\\n}\\nexport default PluggableMap;\\n\",\"/**\\n * @module ol/control/Control\\n */\\nimport {inherits} from '../index.js';\\nimport {UNDEFINED} from '../functions.js';\\nimport MapEventType from '../MapEventType.js';\\nimport BaseObject from '../Object.js';\\nimport {removeNode} from '../dom.js';\\nimport {listen, unlistenByKey} from '../events.js';\\n\\n\\n/**\\n * @typedef {Object} Options\\n * @property {Element} [element] The element is the control's\\n * container element. This only needs to be specified if you're developing\\n * a custom control.\\n * @property {function(module:ol/MapEvent)} [render] Function called when\\n * the control should be re-rendered. This is called in a `requestAnimationFrame`\\n * callback.\\n * @property {Element|string} [target] Specify a target if you want\\n * the control to be rendered outside of the map's viewport.\\n */\\n\\n\\n/**\\n * @classdesc\\n * A control is a visible widget with a DOM element in a fixed position on the\\n * screen. They can involve user input (buttons), or be informational only;\\n * the position is determined using CSS. By default these are placed in the\\n * container with CSS class name `ol-overlaycontainer-stopevent`, but can use\\n * any outside DOM element.\\n *\\n * This is the base class for controls. You can use it for simple custom\\n * controls by creating the element with listeners, creating an instance:\\n * ```js\\n * var myControl = new Control({element: myElement});\\n * ```\\n * and then adding this to the map.\\n *\\n * The main advantage of having this as a control rather than a simple separate\\n * DOM element is that preventing propagation is handled for you. Controls\\n * will also be objects in a {@link module:ol/Collection~Collection}, so you can use their methods.\\n *\\n * You can also extend this base for your own control class. See\\n * examples/custom-controls for an example of how to do this.\\n *\\n * @constructor\\n * @extends {module:ol/Object}\\n * @param {module:ol/control/Control~Options} options Control options.\\n * @api\\n */\\nconst Control = function(options) {\\n\\n  BaseObject.call(this);\\n\\n  /**\\n   * @protected\\n   * @type {Element}\\n   */\\n  this.element = options.element ? options.element : null;\\n\\n  /**\\n   * @private\\n   * @type {Element}\\n   */\\n  this.target_ = null;\\n\\n  /**\\n   * @private\\n   * @type {module:ol/PluggableMap}\\n   */\\n  this.map_ = null;\\n\\n  /**\\n   * @protected\\n   * @type {!Array.<module:ol/events~EventsKey>}\\n   */\\n  this.listenerKeys = [];\\n\\n  /**\\n   * @type {function(module:ol/MapEvent)}\\n   */\\n  this.render = options.render ? options.render : UNDEFINED;\\n\\n  if (options.target) {\\n    this.setTarget(options.target);\\n  }\\n\\n};\\n\\ninherits(Control, BaseObject);\\n\\n\\n/**\\n * @inheritDoc\\n */\\nControl.prototype.disposeInternal = function() {\\n  removeNode(this.element);\\n  BaseObject.prototype.disposeInternal.call(this);\\n};\\n\\n\\n/**\\n * Get the map associated with this control.\\n * @return {module:ol/PluggableMap} Map.\\n * @api\\n */\\nControl.prototype.getMap = function() {\\n  return this.map_;\\n};\\n\\n\\n/**\\n * Remove the control from its current map and attach it to the new map.\\n * Subclasses may set up event handlers to get notified about changes to\\n * the map here.\\n * @param {module:ol/PluggableMap} map Map.\\n * @api\\n */\\nControl.prototype.setMap = function(map) {\\n  if (this.map_) {\\n    removeNode(this.element);\\n  }\\n  for (let i = 0, ii = this.listenerKeys.length; i < ii; ++i) {\\n    unlistenByKey(this.listenerKeys[i]);\\n  }\\n  this.listenerKeys.length = 0;\\n  this.map_ = map;\\n  if (this.map_) {\\n    const target = this.target_ ?\\n      this.target_ : map.getOverlayContainerStopEvent();\\n    target.appendChild(this.element);\\n    if (this.render !== UNDEFINED) {\\n      this.listenerKeys.push(listen(map,\\n        MapEventType.POSTRENDER, this.render, this));\\n    }\\n    map.render();\\n  }\\n};\\n\\n\\n/**\\n * This function is used to set a target element for the control. It has no\\n * effect if it is called after the control has been added to the map (i.e.\\n * after `setMap` is called on the control). If no `target` is set in the\\n * options passed to the control constructor and if `setTarget` is not called\\n * then the control is added to the map's overlay container.\\n * @param {Element|string} target Target.\\n * @api\\n */\\nControl.prototype.setTarget = function(target) {\\n  this.target_ = typeof target === 'string' ?\\n    document.getElementById(target) :\\n    target;\\n};\\nexport default Control;\\n\",\"/**\\n * @module ol/render/EventType\\n */\\n\\n/**\\n * @enum {string}\\n */\\nexport default {\\n  /**\\n   * @event module:ol/render/Event~RenderEvent#postcompose\\n   * @api\\n   */\\n  POSTCOMPOSE: 'postcompose',\\n  /**\\n   * @event module:ol/render/Event~RenderEvent#precompose\\n   * @api\\n   */\\n  PRECOMPOSE: 'precompose',\\n  /**\\n   * @event module:ol/render/Event~RenderEvent#render\\n   * @api\\n   */\\n  RENDER: 'render'\\n};\\n\",\"/**\\n * @module ol/layer/Layer\\n */\\nimport {listen, unlistenByKey} from '../events.js';\\nimport EventType from '../events/EventType.js';\\nimport {getUid, inherits} from '../index.js';\\nimport {getChangeEventType} from '../Object.js';\\nimport BaseLayer from '../layer/Base.js';\\nimport LayerProperty from '../layer/Property.js';\\nimport {assign} from '../obj.js';\\nimport RenderEventType from '../render/EventType.js';\\nimport SourceState from '../source/State.js';\\n\\n\\n/**\\n * @typedef {Object} Options\\n * @property {number} [opacity=1] Opacity (0, 1).\\n * @property {boolean} [visible=true] Visibility.\\n * @property {module:ol/extent~Extent} [extent] The bounding extent for layer rendering.  The layer will not be\\n * rendered outside of this extent.\\n * @property {number} [zIndex=0] The z-index for layer rendering.  At rendering time, the layers\\n * will be ordered, first by Z-index and then by position.\\n * @property {number} [minResolution] The minimum resolution (inclusive) at which this layer will be\\n * visible.\\n * @property {number} [maxResolution] The maximum resolution (exclusive) below which this layer will\\n * be visible.\\n * @property {module:ol/source/Source} [source] Source for this layer.  If not provided to the constructor,\\n * the source can be set by calling {@link module:ol/layer/Layer#setSource layer.setSource(source)} after\\n * construction.\\n */\\n\\n\\n/**\\n * @typedef {Object} State\\n * @property {module:ol/layer/Layer} layer\\n * @property {number} opacity\\n * @property {module:ol/source/Source~State} sourceState\\n * @property {boolean} visible\\n * @property {boolean} managed\\n * @property {module:ol/extent~Extent} [extent]\\n * @property {number} zIndex\\n * @property {number} maxResolution\\n * @property {number} minResolution\\n */\\n\\n\\n/**\\n * @classdesc\\n * Abstract base class; normally only used for creating subclasses and not\\n * instantiated in apps.\\n * A visual representation of raster or vector map data.\\n * Layers group together those properties that pertain to how the data is to be\\n * displayed, irrespective of the source of that data.\\n *\\n * Layers are usually added to a map with {@link module:ol/Map#addLayer}. Components\\n * like {@link module:ol/interaction/Select~Select} use unmanaged layers\\n * internally. These unmanaged layers are associated with the map using\\n * {@link module:ol/layer/Layer~Layer#setMap} instead.\\n *\\n * A generic `change` event is fired when the state of the source changes.\\n *\\n * @constructor\\n * @abstract\\n * @extends {module:ol/layer/Base}\\n * @fires module:ol/render/Event~RenderEvent\\n * @param {module:ol/layer/Layer~Options} options Layer options.\\n * @api\\n */\\nconst Layer = function(options) {\\n\\n  const baseOptions = assign({}, options);\\n  delete baseOptions.source;\\n\\n  BaseLayer.call(this, /** @type {module:ol/layer/Base~Options} */ (baseOptions));\\n\\n  /**\\n   * @private\\n   * @type {?module:ol/events~EventsKey}\\n   */\\n  this.mapPrecomposeKey_ = null;\\n\\n  /**\\n   * @private\\n   * @type {?module:ol/events~EventsKey}\\n   */\\n  this.mapRenderKey_ = null;\\n\\n  /**\\n   * @private\\n   * @type {?module:ol/events~EventsKey}\\n   */\\n  this.sourceChangeKey_ = null;\\n\\n  if (options.map) {\\n    this.setMap(options.map);\\n  }\\n\\n  listen(this,\\n    getChangeEventType(LayerProperty.SOURCE),\\n    this.handleSourcePropertyChange_, this);\\n\\n  const source = options.source ? options.source : null;\\n  this.setSource(source);\\n};\\n\\ninherits(Layer, BaseLayer);\\n\\n\\n/**\\n * Return `true` if the layer is visible, and if the passed resolution is\\n * between the layer's minResolution and maxResolution. The comparison is\\n * inclusive for `minResolution` and exclusive for `maxResolution`.\\n * @param {module:ol/layer/Layer~State} layerState Layer state.\\n * @param {number} resolution Resolution.\\n * @return {boolean} The layer is visible at the given resolution.\\n */\\nexport function visibleAtResolution(layerState, resolution) {\\n  return layerState.visible && resolution >= layerState.minResolution &&\\n      resolution < layerState.maxResolution;\\n}\\n\\n\\n/**\\n * @inheritDoc\\n */\\nLayer.prototype.getLayersArray = function(opt_array) {\\n  const array = opt_array ? opt_array : [];\\n  array.push(this);\\n  return array;\\n};\\n\\n\\n/**\\n * @inheritDoc\\n */\\nLayer.prototype.getLayerStatesArray = function(opt_states) {\\n  const states = opt_states ? opt_states : [];\\n  states.push(this.getLayerState());\\n  return states;\\n};\\n\\n\\n/**\\n * Get the layer source.\\n * @return {module:ol/source/Source} The layer source (or `null` if not yet set).\\n * @observable\\n * @api\\n */\\nLayer.prototype.getSource = function() {\\n  const source = this.get(LayerProperty.SOURCE);\\n  return (\\n    /** @type {module:ol/source/Source} */ (source) || null\\n  );\\n};\\n\\n\\n/**\\n  * @inheritDoc\\n  */\\nLayer.prototype.getSourceState = function() {\\n  const source = this.getSource();\\n  return !source ? SourceState.UNDEFINED : source.getState();\\n};\\n\\n\\n/**\\n * @private\\n */\\nLayer.prototype.handleSourceChange_ = function() {\\n  this.changed();\\n};\\n\\n\\n/**\\n * @private\\n */\\nLayer.prototype.handleSourcePropertyChange_ = function() {\\n  if (this.sourceChangeKey_) {\\n    unlistenByKey(this.sourceChangeKey_);\\n    this.sourceChangeKey_ = null;\\n  }\\n  const source = this.getSource();\\n  if (source) {\\n    this.sourceChangeKey_ = listen(source,\\n      EventType.CHANGE, this.handleSourceChange_, this);\\n  }\\n  this.changed();\\n};\\n\\n\\n/**\\n * Sets the layer to be rendered on top of other layers on a map. The map will\\n * not manage this layer in its layers collection, and the callback in\\n * {@link module:ol/Map#forEachLayerAtPixel} will receive `null` as layer. This\\n * is useful for temporary layers. To remove an unmanaged layer from the map,\\n * use `#setMap(null)`.\\n *\\n * To add the layer to a map and have it managed by the map, use\\n * {@link module:ol/Map#addLayer} instead.\\n * @param {module:ol/PluggableMap} map Map.\\n * @api\\n */\\nLayer.prototype.setMap = function(map) {\\n  if (this.mapPrecomposeKey_) {\\n    unlistenByKey(this.mapPrecomposeKey_);\\n    this.mapPrecomposeKey_ = null;\\n  }\\n  if (!map) {\\n    this.changed();\\n  }\\n  if (this.mapRenderKey_) {\\n    unlistenByKey(this.mapRenderKey_);\\n    this.mapRenderKey_ = null;\\n  }\\n  if (map) {\\n    this.mapPrecomposeKey_ = listen(map, RenderEventType.PRECOMPOSE, function(evt) {\\n      const layerState = this.getLayerState();\\n      layerState.managed = false;\\n      layerState.zIndex = Infinity;\\n      evt.frameState.layerStatesArray.push(layerState);\\n      evt.frameState.layerStates[getUid(this)] = layerState;\\n    }, this);\\n    this.mapRenderKey_ = listen(this, EventType.CHANGE, map.render, map);\\n    this.changed();\\n  }\\n};\\n\\n\\n/**\\n * Set the layer source.\\n * @param {module:ol/source/Source} source The layer source.\\n * @observable\\n * @api\\n */\\nLayer.prototype.setSource = function(source) {\\n  this.set(LayerProperty.SOURCE, source);\\n};\\nexport default Layer;\\n\",\"/**\\n * @module ol/control/Attribution\\n */\\nimport {inherits} from '../index.js';\\nimport {equals} from '../array.js';\\nimport Control from '../control/Control.js';\\nimport {CLASS_CONTROL, CLASS_UNSELECTABLE, CLASS_COLLAPSED} from '../css.js';\\nimport {removeChildren, replaceNode} from '../dom.js';\\nimport {listen} from '../events.js';\\nimport EventType from '../events/EventType.js';\\nimport {visibleAtResolution} from '../layer/Layer.js';\\n\\n\\n/**\\n * @typedef {Object} Options\\n * @property {string} [className='ol-attribution'] CSS class name.\\n * @property {Element|string} [target] Specify a target if you\\n * want the control to be rendered outside of the map's\\n * viewport.\\n * @property {boolean} [collapsible=true] Specify if attributions can\\n * be collapsed. If you use an OSM source, should be set to `false`  see\\n * {@link https://www.openstreetmap.org/copyright OSM Copyright} \\n * @property {boolean} [collapsed=true] Specify if attributions should\\n * be collapsed at startup.\\n * @property {string} [tipLabel='Attributions'] Text label to use for the button tip.\\n * @property {string} [label='i'] Text label to use for the\\n * collapsed attributions button.\\n * Instead of text, also an element (e.g. a `span` element) can be used.\\n * @property {string|Element} [collapseLabel=''] Text label to use\\n * for the expanded attributions button.\\n * Instead of text, also an element (e.g. a `span` element) can be used.\\n * @property {function(module:ol/MapEvent)} [render] Function called when\\n * the control should be re-rendered. This is called in a `requestAnimationFrame`\\n * callback.\\n */\\n\\n\\n/**\\n * @classdesc\\n * Control to show all the attributions associated with the layer sources\\n * in the map. This control is one of the default controls included in maps.\\n * By default it will show in the bottom right portion of the map, but this can\\n * be changed by using a css selector for `.ol-attribution`.\\n *\\n * @constructor\\n * @extends {module:ol/control/Control}\\n * @param {module:ol/control/Attribution~Options=} opt_options Attribution options.\\n * @api\\n */\\nconst Attribution = function(opt_options) {\\n\\n  const options = opt_options ? opt_options : {};\\n\\n  /**\\n   * @private\\n   * @type {Element}\\n   */\\n  this.ulElement_ = document.createElement('UL');\\n\\n  /**\\n   * @private\\n   * @type {boolean}\\n   */\\n  this.collapsed_ = options.collapsed !== undefined ? options.collapsed : true;\\n\\n  /**\\n   * @private\\n   * @type {boolean}\\n   */\\n  this.collapsible_ = options.collapsible !== undefined ?\\n    options.collapsible : true;\\n\\n  if (!this.collapsible_) {\\n    this.collapsed_ = false;\\n  }\\n\\n  const className = options.className !== undefined ? options.className : 'ol-attribution';\\n\\n  const tipLabel = options.tipLabel !== undefined ? options.tipLabel : 'Attributions';\\n\\n  const collapseLabel = options.collapseLabel !== undefined ? options.collapseLabel : '\\\\u00BB';\\n\\n  if (typeof collapseLabel === 'string') {\\n    /**\\n     * @private\\n     * @type {Element}\\n     */\\n    this.collapseLabel_ = document.createElement('span');\\n    this.collapseLabel_.textContent = collapseLabel;\\n  } else {\\n    this.collapseLabel_ = collapseLabel;\\n  }\\n\\n  const label = options.label !== undefined ? options.label : 'i';\\n\\n  if (typeof label === 'string') {\\n    /**\\n     * @private\\n     * @type {Element}\\n     */\\n    this.label_ = document.createElement('span');\\n    this.label_.textContent = label;\\n  } else {\\n    this.label_ = label;\\n  }\\n\\n\\n  const activeLabel = (this.collapsible_ && !this.collapsed_) ?\\n    this.collapseLabel_ : this.label_;\\n  const button = document.createElement('button');\\n  button.setAttribute('type', 'button');\\n  button.title = tipLabel;\\n  button.appendChild(activeLabel);\\n\\n  listen(button, EventType.CLICK, this.handleClick_, this);\\n\\n  const cssClasses = className + ' ' + CLASS_UNSELECTABLE + ' ' + CLASS_CONTROL +\\n      (this.collapsed_ && this.collapsible_ ? ' ' + CLASS_COLLAPSED : '') +\\n      (this.collapsible_ ? '' : ' ol-uncollapsible');\\n  const element = document.createElement('div');\\n  element.className = cssClasses;\\n  element.appendChild(this.ulElement_);\\n  element.appendChild(button);\\n\\n  Control.call(this, {\\n    element: element,\\n    render: options.render || render,\\n    target: options.target\\n  });\\n\\n  /**\\n   * A list of currently rendered resolutions.\\n   * @type {Array.<string>}\\n   * @private\\n   */\\n  this.renderedAttributions_ = [];\\n\\n  /**\\n   * @private\\n   * @type {boolean}\\n   */\\n  this.renderedVisible_ = true;\\n\\n};\\n\\ninherits(Attribution, Control);\\n\\n\\n/**\\n * Get a list of visible attributions.\\n * @param {module:ol/PluggableMap~FrameState} frameState Frame state.\\n * @return {Array.<string>} Attributions.\\n * @private\\n */\\nAttribution.prototype.getSourceAttributions_ = function(frameState) {\\n  /**\\n   * Used to determine if an attribution already exists.\\n   * @type {!Object.<string, boolean>}\\n   */\\n  const lookup = {};\\n\\n  /**\\n   * A list of visible attributions.\\n   * @type {Array.<string>}\\n   */\\n  const visibleAttributions = [];\\n\\n  const layerStatesArray = frameState.layerStatesArray;\\n  const resolution = frameState.viewState.resolution;\\n  for (let i = 0, ii = layerStatesArray.length; i < ii; ++i) {\\n    const layerState = layerStatesArray[i];\\n    if (!visibleAtResolution(layerState, resolution)) {\\n      continue;\\n    }\\n\\n    const source = layerState.layer.getSource();\\n    if (!source) {\\n      continue;\\n    }\\n\\n    const attributionGetter = source.getAttributions();\\n    if (!attributionGetter) {\\n      continue;\\n    }\\n\\n    const attributions = attributionGetter(frameState);\\n    if (!attributions) {\\n      continue;\\n    }\\n\\n    if (Array.isArray(attributions)) {\\n      for (let j = 0, jj = attributions.length; j < jj; ++j) {\\n        if (!(attributions[j] in lookup)) {\\n          visibleAttributions.push(attributions[j]);\\n          lookup[attributions[j]] = true;\\n        }\\n      }\\n    } else {\\n      if (!(attributions in lookup)) {\\n        visibleAttributions.push(attributions);\\n        lookup[attributions] = true;\\n      }\\n    }\\n  }\\n  return visibleAttributions;\\n};\\n\\n\\n/**\\n * Update the attribution element.\\n * @param {module:ol/MapEvent} mapEvent Map event.\\n * @this {module:ol/control/Attribution}\\n * @api\\n */\\nexport function render(mapEvent) {\\n  this.updateElement_(mapEvent.frameState);\\n}\\n\\n\\n/**\\n * @private\\n * @param {?module:ol/PluggableMap~FrameState} frameState Frame state.\\n */\\nAttribution.prototype.updateElement_ = function(frameState) {\\n  if (!frameState) {\\n    if (this.renderedVisible_) {\\n      this.element.style.display = 'none';\\n      this.renderedVisible_ = false;\\n    }\\n    return;\\n  }\\n\\n  const attributions = this.getSourceAttributions_(frameState);\\n\\n  const visible = attributions.length > 0;\\n  if (this.renderedVisible_ != visible) {\\n    this.element.style.display = visible ? '' : 'none';\\n    this.renderedVisible_ = visible;\\n  }\\n\\n  if (equals(attributions, this.renderedAttributions_)) {\\n    return;\\n  }\\n\\n  removeChildren(this.ulElement_);\\n\\n  // append the attributions\\n  for (let i = 0, ii = attributions.length; i < ii; ++i) {\\n    const element = document.createElement('LI');\\n    element.innerHTML = attributions[i];\\n    this.ulElement_.appendChild(element);\\n  }\\n\\n  this.renderedAttributions_ = attributions;\\n};\\n\\n\\n/**\\n * @param {Event} event The event to handle\\n * @private\\n */\\nAttribution.prototype.handleClick_ = function(event) {\\n  event.preventDefault();\\n  this.handleToggle_();\\n};\\n\\n\\n/**\\n * @private\\n */\\nAttribution.prototype.handleToggle_ = function() {\\n  this.element.classList.toggle(CLASS_COLLAPSED);\\n  if (this.collapsed_) {\\n    replaceNode(this.collapseLabel_, this.label_);\\n  } else {\\n    replaceNode(this.label_, this.collapseLabel_);\\n  }\\n  this.collapsed_ = !this.collapsed_;\\n};\\n\\n\\n/**\\n * Return `true` if the attribution is collapsible, `false` otherwise.\\n * @return {boolean} True if the widget is collapsible.\\n * @api\\n */\\nAttribution.prototype.getCollapsible = function() {\\n  return this.collapsible_;\\n};\\n\\n\\n/**\\n * Set whether the attribution should be collapsible.\\n * @param {boolean} collapsible True if the widget is collapsible.\\n * @api\\n */\\nAttribution.prototype.setCollapsible = function(collapsible) {\\n  if (this.collapsible_ === collapsible) {\\n    return;\\n  }\\n  this.collapsible_ = collapsible;\\n  this.element.classList.toggle('ol-uncollapsible');\\n  if (!collapsible && this.collapsed_) {\\n    this.handleToggle_();\\n  }\\n};\\n\\n\\n/**\\n * Collapse or expand the attribution according to the passed parameter. Will\\n * not do anything if the attribution isn't collapsible or if the current\\n * collapsed state is already the one requested.\\n * @param {boolean} collapsed True if the widget is collapsed.\\n * @api\\n */\\nAttribution.prototype.setCollapsed = function(collapsed) {\\n  if (!this.collapsible_ || this.collapsed_ === collapsed) {\\n    return;\\n  }\\n  this.handleToggle_();\\n};\\n\\n\\n/**\\n * Return `true` when the attribution is currently collapsed or `false`\\n * otherwise.\\n * @return {boolean} True if the widget is collapsed.\\n * @api\\n */\\nAttribution.prototype.getCollapsed = function() {\\n  return this.collapsed_;\\n};\\nexport default Attribution;\\n\",\"/**\\n * @module ol/control/Rotate\\n */\\n\\nimport Control from '../control/Control.js';\\nimport {CLASS_CONTROL, CLASS_HIDDEN, CLASS_UNSELECTABLE} from '../css.js';\\nimport {easeOut} from '../easing.js';\\nimport {listen} from '../events.js';\\nimport EventType from '../events/EventType.js';\\nimport {inherits} from '../index.js';\\n\\n\\n/**\\n * @typedef {Object} Options\\n * @property {string} [className='ol-rotate'] CSS class name.\\n * @property {string|Element} [label=''] Text label to use for the rotate button.\\n * Instead of text, also an element (e.g. a `span` element) can be used.\\n * @property {string} [tipLabel='Reset rotation'] Text label to use for the rotate tip.\\n * @property {number} [duration=250] Animation duration in milliseconds.\\n * @property {boolean} [autoHide=true] Hide the control when rotation is 0.\\n * @property {function(module:ol/MapEvent)} [render] Function called when the control should\\n * be re-rendered. This is called in a `requestAnimationFrame` callback.\\n * @property {function()} [resetNorth] Function called when the control is clicked.\\n * This will override the default `resetNorth`.\\n * @property {Element|string} [target] Specify a target if you want the control to be\\n * rendered outside of the map's viewport.\\n */\\n\\n\\n/**\\n * @classdesc\\n * A button control to reset rotation to 0.\\n * To style this control use css selector `.ol-rotate`. A `.ol-hidden` css\\n * selector is added to the button when the rotation is 0.\\n *\\n * @constructor\\n * @extends {module:ol/control/Control}\\n * @param {module:ol/control/Rotate~Options=} opt_options Rotate options.\\n * @api\\n */\\nconst Rotate = function(opt_options) {\\n\\n  const options = opt_options ? opt_options : {};\\n\\n  const className = options.className !== undefined ? options.className : 'ol-rotate';\\n\\n  const label = options.label !== undefined ? options.label : '\\\\u21E7';\\n\\n  /**\\n   * @type {Element}\\n   * @private\\n   */\\n  this.label_ = null;\\n\\n  if (typeof label === 'string') {\\n    this.label_ = document.createElement('span');\\n    this.label_.className = 'ol-compass';\\n    this.label_.textContent = label;\\n  } else {\\n    this.label_ = label;\\n    this.label_.classList.add('ol-compass');\\n  }\\n\\n  const tipLabel = options.tipLabel ? options.tipLabel : 'Reset rotation';\\n\\n  const button = document.createElement('button');\\n  button.className = className + '-reset';\\n  button.setAttribute('type', 'button');\\n  button.title = tipLabel;\\n  button.appendChild(this.label_);\\n\\n  listen(button, EventType.CLICK,\\n    Rotate.prototype.handleClick_, this);\\n\\n  const cssClasses = className + ' ' + CLASS_UNSELECTABLE + ' ' + CLASS_CONTROL;\\n  const element = document.createElement('div');\\n  element.className = cssClasses;\\n  element.appendChild(button);\\n\\n  this.callResetNorth_ = options.resetNorth ? options.resetNorth : undefined;\\n\\n  Control.call(this, {\\n    element: element,\\n    render: options.render || render,\\n    target: options.target\\n  });\\n\\n  /**\\n   * @type {number}\\n   * @private\\n   */\\n  this.duration_ = options.duration !== undefined ? options.duration : 250;\\n\\n  /**\\n   * @type {boolean}\\n   * @private\\n   */\\n  this.autoHide_ = options.autoHide !== undefined ? options.autoHide : true;\\n\\n  /**\\n   * @private\\n   * @type {number|undefined}\\n   */\\n  this.rotation_ = undefined;\\n\\n  if (this.autoHide_) {\\n    this.element.classList.add(CLASS_HIDDEN);\\n  }\\n\\n};\\n\\ninherits(Rotate, Control);\\n\\n\\n/**\\n * @param {Event} event The event to handle\\n * @private\\n */\\nRotate.prototype.handleClick_ = function(event) {\\n  event.preventDefault();\\n  if (this.callResetNorth_ !== undefined) {\\n    this.callResetNorth_();\\n  } else {\\n    this.resetNorth_();\\n  }\\n};\\n\\n\\n/**\\n * @private\\n */\\nRotate.prototype.resetNorth_ = function() {\\n  const map = this.getMap();\\n  const view = map.getView();\\n  if (!view) {\\n    // the map does not have a view, so we can't act\\n    // upon it\\n    return;\\n  }\\n  if (view.getRotation() !== undefined) {\\n    if (this.duration_ > 0) {\\n      view.animate({\\n        rotation: 0,\\n        duration: this.duration_,\\n        easing: easeOut\\n      });\\n    } else {\\n      view.setRotation(0);\\n    }\\n  }\\n};\\n\\n\\n/**\\n * Update the rotate control element.\\n * @param {module:ol/MapEvent} mapEvent Map event.\\n * @this {module:ol/control/Rotate}\\n * @api\\n */\\nexport function render(mapEvent) {\\n  const frameState = mapEvent.frameState;\\n  if (!frameState) {\\n    return;\\n  }\\n  const rotation = frameState.viewState.rotation;\\n  if (rotation != this.rotation_) {\\n    const transform = 'rotate(' + rotation + 'rad)';\\n    if (this.autoHide_) {\\n      const contains = this.element.classList.contains(CLASS_HIDDEN);\\n      if (!contains && rotation === 0) {\\n        this.element.classList.add(CLASS_HIDDEN);\\n      } else if (contains && rotation !== 0) {\\n        this.element.classList.remove(CLASS_HIDDEN);\\n      }\\n    }\\n    this.label_.style.msTransform = transform;\\n    this.label_.style.webkitTransform = transform;\\n    this.label_.style.transform = transform;\\n  }\\n  this.rotation_ = rotation;\\n}\\n\\nexport default Rotate;\\n\",\"/**\\n * @module ol/control/Zoom\\n */\\nimport {inherits} from '../index.js';\\nimport {listen} from '../events.js';\\nimport EventType from '../events/EventType.js';\\nimport Control from '../control/Control.js';\\nimport {CLASS_CONTROL, CLASS_UNSELECTABLE} from '../css.js';\\nimport {easeOut} from '../easing.js';\\n\\n\\n/**\\n * @typedef {Object} Options\\n * @property {number} [duration=250] Animation duration in milliseconds.\\n * @property {string} [className='ol-zoom'] CSS class name.\\n * @property {string|Element} [zoomInLabel='+'] Text label to use for the zoom-in\\n * button. Instead of text, also an element (e.g. a `span` element) can be used.\\n * @property {string|Element} [zoomOutLabel='-'] Text label to use for the zoom-out button.\\n * Instead of text, also an element (e.g. a `span` element) can be used.\\n * @property {string} [zoomInTipLabel='Zoom in'] Text label to use for the button tip.\\n * @property {string} [zoomOutTipLabel='Zoom out'] Text label to use for the button tip.\\n * @property {number} [delta=1] The zoom delta applied on each click.\\n * @property {Element|string} [target] Specify a target if you want the control to be\\n * rendered outside of the map's viewport.\\n */\\n\\n\\n/**\\n * @classdesc\\n * A control with 2 buttons, one for zoom in and one for zoom out.\\n * This control is one of the default controls of a map. To style this control\\n * use css selectors `.ol-zoom-in` and `.ol-zoom-out`.\\n *\\n * @constructor\\n * @extends {module:ol/control/Control}\\n * @param {module:ol/control/Zoom~Options=} opt_options Zoom options.\\n * @api\\n */\\nconst Zoom = function(opt_options) {\\n\\n  const options = opt_options ? opt_options : {};\\n\\n  const className = options.className !== undefined ? options.className : 'ol-zoom';\\n\\n  const delta = options.delta !== undefined ? options.delta : 1;\\n\\n  const zoomInLabel = options.zoomInLabel !== undefined ? options.zoomInLabel : '+';\\n  const zoomOutLabel = options.zoomOutLabel !== undefined ? options.zoomOutLabel : '\\\\u2212';\\n\\n  const zoomInTipLabel = options.zoomInTipLabel !== undefined ?\\n    options.zoomInTipLabel : 'Zoom in';\\n  const zoomOutTipLabel = options.zoomOutTipLabel !== undefined ?\\n    options.zoomOutTipLabel : 'Zoom out';\\n\\n  const inElement = document.createElement('button');\\n  inElement.className = className + '-in';\\n  inElement.setAttribute('type', 'button');\\n  inElement.title = zoomInTipLabel;\\n  inElement.appendChild(\\n    typeof zoomInLabel === 'string' ? document.createTextNode(zoomInLabel) : zoomInLabel\\n  );\\n\\n  listen(inElement, EventType.CLICK,\\n    Zoom.prototype.handleClick_.bind(this, delta));\\n\\n  const outElement = document.createElement('button');\\n  outElement.className = className + '-out';\\n  outElement.setAttribute('type', 'button');\\n  outElement.title = zoomOutTipLabel;\\n  outElement.appendChild(\\n    typeof zoomOutLabel === 'string' ? document.createTextNode(zoomOutLabel) : zoomOutLabel\\n  );\\n\\n  listen(outElement, EventType.CLICK,\\n    Zoom.prototype.handleClick_.bind(this, -delta));\\n\\n  const cssClasses = className + ' ' + CLASS_UNSELECTABLE + ' ' + CLASS_CONTROL;\\n  const element = document.createElement('div');\\n  element.className = cssClasses;\\n  element.appendChild(inElement);\\n  element.appendChild(outElement);\\n\\n  Control.call(this, {\\n    element: element,\\n    target: options.target\\n  });\\n\\n  /**\\n   * @type {number}\\n   * @private\\n   */\\n  this.duration_ = options.duration !== undefined ? options.duration : 250;\\n\\n};\\n\\ninherits(Zoom, Control);\\n\\n\\n/**\\n * @param {number} delta Zoom delta.\\n * @param {Event} event The event to handle\\n * @private\\n */\\nZoom.prototype.handleClick_ = function(delta, event) {\\n  event.preventDefault();\\n  this.zoomByDelta_(delta);\\n};\\n\\n\\n/**\\n * @param {number} delta Zoom delta.\\n * @private\\n */\\nZoom.prototype.zoomByDelta_ = function(delta) {\\n  const map = this.getMap();\\n  const view = map.getView();\\n  if (!view) {\\n    // the map does not have a view, so we can't act\\n    // upon it\\n    return;\\n  }\\n  const currentResolution = view.getResolution();\\n  if (currentResolution) {\\n    const newResolution = view.constrainResolution(currentResolution, delta);\\n    if (this.duration_ > 0) {\\n      if (view.getAnimating()) {\\n        view.cancelAnimations();\\n      }\\n      view.animate({\\n        resolution: newResolution,\\n        duration: this.duration_,\\n        easing: easeOut\\n      });\\n    } else {\\n      view.setResolution(newResolution);\\n    }\\n  }\\n};\\nexport default Zoom;\\n\",\"/**\\n * @module ol/Kinetic\\n */\\n\\n/**\\n * @classdesc\\n * Implementation of inertial deceleration for map movement.\\n *\\n * @constructor\\n * @param {number} decay Rate of decay (must be negative).\\n * @param {number} minVelocity Minimum velocity (pixels/millisecond).\\n * @param {number} delay Delay to consider to calculate the kinetic\\n *     initial values (milliseconds).\\n * @struct\\n * @api\\n */\\nconst Kinetic = function(decay, minVelocity, delay) {\\n\\n  /**\\n   * @private\\n   * @type {number}\\n   */\\n  this.decay_ = decay;\\n\\n  /**\\n   * @private\\n   * @type {number}\\n   */\\n  this.minVelocity_ = minVelocity;\\n\\n  /**\\n   * @private\\n   * @type {number}\\n   */\\n  this.delay_ = delay;\\n\\n  /**\\n   * @private\\n   * @type {Array.<number>}\\n   */\\n  this.points_ = [];\\n\\n  /**\\n   * @private\\n   * @type {number}\\n   */\\n  this.angle_ = 0;\\n\\n  /**\\n   * @private\\n   * @type {number}\\n   */\\n  this.initialVelocity_ = 0;\\n};\\n\\n\\n/**\\n * FIXME empty description for jsdoc\\n */\\nKinetic.prototype.begin = function() {\\n  this.points_.length = 0;\\n  this.angle_ = 0;\\n  this.initialVelocity_ = 0;\\n};\\n\\n\\n/**\\n * @param {number} x X.\\n * @param {number} y Y.\\n */\\nKinetic.prototype.update = function(x, y) {\\n  this.points_.push(x, y, Date.now());\\n};\\n\\n\\n/**\\n * @return {boolean} Whether we should do kinetic animation.\\n */\\nKinetic.prototype.end = function() {\\n  if (this.points_.length < 6) {\\n    // at least 2 points are required (i.e. there must be at least 6 elements\\n    // in the array)\\n    return false;\\n  }\\n  const delay = Date.now() - this.delay_;\\n  const lastIndex = this.points_.length - 3;\\n  if (this.points_[lastIndex + 2] < delay) {\\n    // the last tracked point is too old, which means that the user stopped\\n    // panning before releasing the map\\n    return false;\\n  }\\n\\n  // get the first point which still falls into the delay time\\n  let firstIndex = lastIndex - 3;\\n  while (firstIndex > 0 && this.points_[firstIndex + 2] > delay) {\\n    firstIndex -= 3;\\n  }\\n\\n  const duration = this.points_[lastIndex + 2] - this.points_[firstIndex + 2];\\n  // we don't want a duration of 0 (divide by zero)\\n  // we also make sure the user panned for a duration of at least one frame\\n  // (1/60s) to compute sane displacement values\\n  if (duration < 1000 / 60) {\\n    return false;\\n  }\\n\\n  const dx = this.points_[lastIndex] - this.points_[firstIndex];\\n  const dy = this.points_[lastIndex + 1] - this.points_[firstIndex + 1];\\n  this.angle_ = Math.atan2(dy, dx);\\n  this.initialVelocity_ = Math.sqrt(dx * dx + dy * dy) / duration;\\n  return this.initialVelocity_ > this.minVelocity_;\\n};\\n\\n\\n/**\\n * @return {number} Total distance travelled (pixels).\\n */\\nKinetic.prototype.getDistance = function() {\\n  return (this.minVelocity_ - this.initialVelocity_) / this.decay_;\\n};\\n\\n\\n/**\\n * @return {number} Angle of the kinetic panning animation (radians).\\n */\\nKinetic.prototype.getAngle = function() {\\n  return this.angle_;\\n};\\nexport default Kinetic;\\n\",\"/**\\n * @module ol/interaction/Property\\n */\\n\\n/**\\n * @enum {string}\\n */\\nexport default {\\n  ACTIVE: 'active'\\n};\\n\",\"/**\\n * @module ol/interaction/Interaction\\n */\\nimport {inherits} from '../index.js';\\nimport BaseObject from '../Object.js';\\nimport {easeOut, linear} from '../easing.js';\\nimport InteractionProperty from '../interaction/Property.js';\\nimport {clamp} from '../math.js';\\n\\n\\n/**\\n * Object literal with config options for interactions.\\n * @typedef {Object} InteractionOptions\\n * @property {function(module:ol/MapBrowserEvent):boolean} handleEvent\\n * Method called by the map to notify the interaction that a browser event was\\n * dispatched to the map. If the function returns a falsy value, propagation of\\n * the event to other interactions in the map's interactions chain will be\\n * prevented (this includes functions with no explicit return).\\n */\\n\\n\\n/**\\n * @classdesc\\n * Abstract base class; normally only used for creating subclasses and not\\n * instantiated in apps.\\n * User actions that change the state of the map. Some are similar to controls,\\n * but are not associated with a DOM element.\\n * For example, {@link module:ol/interaction/KeyboardZoom~KeyboardZoom} is\\n * functionally the same as {@link module:ol/control/Zoom~Zoom}, but triggered\\n * by a keyboard event not a button element event.\\n * Although interactions do not have a DOM element, some of them do render\\n * vectors and so are visible on the screen.\\n *\\n * @constructor\\n * @param {module:ol/interaction/Interaction~InteractionOptions} options Options.\\n * @extends {module:ol/Object}\\n * @api\\n */\\nconst Interaction = function(options) {\\n\\n  BaseObject.call(this);\\n\\n  /**\\n   * @private\\n   * @type {module:ol/PluggableMap}\\n   */\\n  this.map_ = null;\\n\\n  this.setActive(true);\\n\\n  /**\\n   * @type {function(module:ol/MapBrowserEvent):boolean}\\n   */\\n  this.handleEvent = options.handleEvent;\\n\\n};\\n\\ninherits(Interaction, BaseObject);\\n\\n\\n/**\\n * Return whether the interaction is currently active.\\n * @return {boolean} `true` if the interaction is active, `false` otherwise.\\n * @observable\\n * @api\\n */\\nInteraction.prototype.getActive = function() {\\n  return /** @type {boolean} */ (this.get(InteractionProperty.ACTIVE));\\n};\\n\\n\\n/**\\n * Get the map associated with this interaction.\\n * @return {module:ol/PluggableMap} Map.\\n * @api\\n */\\nInteraction.prototype.getMap = function() {\\n  return this.map_;\\n};\\n\\n\\n/**\\n * Activate or deactivate the interaction.\\n * @param {boolean} active Active.\\n * @observable\\n * @api\\n */\\nInteraction.prototype.setActive = function(active) {\\n  this.set(InteractionProperty.ACTIVE, active);\\n};\\n\\n\\n/**\\n * Remove the interaction from its current map and attach it to the new map.\\n * Subclasses may set up event handlers to get notified about changes to\\n * the map here.\\n * @param {module:ol/PluggableMap} map Map.\\n */\\nInteraction.prototype.setMap = function(map) {\\n  this.map_ = map;\\n};\\n\\n\\n/**\\n * @param {module:ol/View} view View.\\n * @param {module:ol/coordinate~Coordinate} delta Delta.\\n * @param {number=} opt_duration Duration.\\n */\\nexport function pan(view, delta, opt_duration) {\\n  const currentCenter = view.getCenter();\\n  if (currentCenter) {\\n    const center = view.constrainCenter(\\n      [currentCenter[0] + delta[0], currentCenter[1] + delta[1]]);\\n    if (opt_duration) {\\n      view.animate({\\n        duration: opt_duration,\\n        easing: linear,\\n        center: center\\n      });\\n    } else {\\n      view.setCenter(center);\\n    }\\n  }\\n}\\n\\n\\n/**\\n * @param {module:ol/View} view View.\\n * @param {number|undefined} rotation Rotation.\\n * @param {module:ol/coordinate~Coordinate=} opt_anchor Anchor coordinate.\\n * @param {number=} opt_duration Duration.\\n */\\nexport function rotate(view, rotation, opt_anchor, opt_duration) {\\n  rotation = view.constrainRotation(rotation, 0);\\n  rotateWithoutConstraints(view, rotation, opt_anchor, opt_duration);\\n}\\n\\n\\n/**\\n * @param {module:ol/View} view View.\\n * @param {number|undefined} rotation Rotation.\\n * @param {module:ol/coordinate~Coordinate=} opt_anchor Anchor coordinate.\\n * @param {number=} opt_duration Duration.\\n */\\nexport function rotateWithoutConstraints(view, rotation, opt_anchor, opt_duration) {\\n  if (rotation !== undefined) {\\n    const currentRotation = view.getRotation();\\n    const currentCenter = view.getCenter();\\n    if (currentRotation !== undefined && currentCenter && opt_duration > 0) {\\n      view.animate({\\n        rotation: rotation,\\n        anchor: opt_anchor,\\n        duration: opt_duration,\\n        easing: easeOut\\n      });\\n    } else {\\n      view.rotate(rotation, opt_anchor);\\n    }\\n  }\\n}\\n\\n\\n/**\\n * @param {module:ol/View} view View.\\n * @param {number|undefined} resolution Resolution to go to.\\n * @param {module:ol/coordinate~Coordinate=} opt_anchor Anchor coordinate.\\n * @param {number=} opt_duration Duration.\\n * @param {number=} opt_direction Zooming direction; > 0 indicates\\n *     zooming out, in which case the constraints system will select\\n *     the largest nearest resolution; < 0 indicates zooming in, in\\n *     which case the constraints system will select the smallest\\n *     nearest resolution; == 0 indicates that the zooming direction\\n *     is unknown/not relevant, in which case the constraints system\\n *     will select the nearest resolution. If not defined 0 is\\n *     assumed.\\n */\\nexport function zoom(view, resolution, opt_anchor, opt_duration, opt_direction) {\\n  resolution = view.constrainResolution(resolution, 0, opt_direction);\\n  zoomWithoutConstraints(view, resolution, opt_anchor, opt_duration);\\n}\\n\\n\\n/**\\n * @param {module:ol/View} view View.\\n * @param {number} delta Delta from previous zoom level.\\n * @param {module:ol/coordinate~Coordinate=} opt_anchor Anchor coordinate.\\n * @param {number=} opt_duration Duration.\\n */\\nexport function zoomByDelta(view, delta, opt_anchor, opt_duration) {\\n  const currentResolution = view.getResolution();\\n  let resolution = view.constrainResolution(currentResolution, delta, 0);\\n\\n  if (resolution !== undefined) {\\n    const resolutions = view.getResolutions();\\n    resolution = clamp(\\n      resolution,\\n      view.getMinResolution() || resolutions[resolutions.length - 1],\\n      view.getMaxResolution() || resolutions[0]);\\n  }\\n\\n  // If we have a constraint on center, we need to change the anchor so that the\\n  // new center is within the extent. We first calculate the new center, apply\\n  // the constraint to it, and then calculate back the anchor\\n  if (opt_anchor && resolution !== undefined && resolution !== currentResolution) {\\n    const currentCenter = view.getCenter();\\n    let center = view.calculateCenterZoom(resolution, opt_anchor);\\n    center = view.constrainCenter(center);\\n\\n    opt_anchor = [\\n      (resolution * currentCenter[0] - currentResolution * center[0]) /\\n          (resolution - currentResolution),\\n      (resolution * currentCenter[1] - currentResolution * center[1]) /\\n          (resolution - currentResolution)\\n    ];\\n  }\\n\\n  zoomWithoutConstraints(view, resolution, opt_anchor, opt_duration);\\n}\\n\\n\\n/**\\n * @param {module:ol/View} view View.\\n * @param {number|undefined} resolution Resolution to go to.\\n * @param {module:ol/coordinate~Coordinate=} opt_anchor Anchor coordinate.\\n * @param {number=} opt_duration Duration.\\n */\\nexport function zoomWithoutConstraints(view, resolution, opt_anchor, opt_duration) {\\n  if (resolution) {\\n    const currentResolution = view.getResolution();\\n    const currentCenter = view.getCenter();\\n    if (currentResolution !== undefined && currentCenter &&\\n        resolution !== currentResolution && opt_duration) {\\n      view.animate({\\n        resolution: resolution,\\n        anchor: opt_anchor,\\n        duration: opt_duration,\\n        easing: easeOut\\n      });\\n    } else {\\n      if (opt_anchor) {\\n        const center = view.calculateCenterZoom(resolution, opt_anchor);\\n        view.setCenter(center);\\n      }\\n      view.setResolution(resolution);\\n    }\\n  }\\n}\\n\\nexport default Interaction;\\n\",\"/**\\n * @module ol/interaction/DoubleClickZoom\\n */\\nimport {inherits} from '../index.js';\\nimport MapBrowserEventType from '../MapBrowserEventType.js';\\nimport Interaction, {zoomByDelta} from '../interaction/Interaction.js';\\n\\n\\n/**\\n * @typedef {Object} Options\\n * @property {number} [duration=250] Animation duration in milliseconds.\\n * @property {number} [delta=1] The zoom delta applied on each double click.\\n */\\n\\n\\n/**\\n * @classdesc\\n * Allows the user to zoom by double-clicking on the map.\\n *\\n * @constructor\\n * @extends {module:ol/interaction/Interaction}\\n * @param {module:ol/interaction/DoubleClickZoom~Options=} opt_options Options.\\n * @api\\n */\\nconst DoubleClickZoom = function(opt_options) {\\n\\n  const options = opt_options ? opt_options : {};\\n\\n  /**\\n   * @private\\n   * @type {number}\\n   */\\n  this.delta_ = options.delta ? options.delta : 1;\\n\\n  Interaction.call(this, {\\n    handleEvent: handleEvent\\n  });\\n\\n  /**\\n   * @private\\n   * @type {number}\\n   */\\n  this.duration_ = options.duration !== undefined ? options.duration : 250;\\n\\n};\\n\\ninherits(DoubleClickZoom, Interaction);\\n\\n\\n/**\\n * Handles the {@link module:ol/MapBrowserEvent map browser event} (if it was a\\n * doubleclick) and eventually zooms the map.\\n * @param {module:ol/MapBrowserEvent} mapBrowserEvent Map browser event.\\n * @return {boolean} `false` to stop event propagation.\\n * @this {module:ol/interaction/DoubleClickZoom}\\n */\\nfunction handleEvent(mapBrowserEvent) {\\n  let stopEvent = false;\\n  const browserEvent = mapBrowserEvent.originalEvent;\\n  if (mapBrowserEvent.type == MapBrowserEventType.DBLCLICK) {\\n    const map = mapBrowserEvent.map;\\n    const anchor = mapBrowserEvent.coordinate;\\n    const delta = browserEvent.shiftKey ? -this.delta_ : this.delta_;\\n    const view = map.getView();\\n    zoomByDelta(view, delta, anchor, this.duration_);\\n    mapBrowserEvent.preventDefault();\\n    stopEvent = true;\\n  }\\n  return !stopEvent;\\n}\\n\\nexport default DoubleClickZoom;\\n\",\"/**\\n * @module ol/events/condition\\n */\\nimport MapBrowserEventType from '../MapBrowserEventType.js';\\nimport {assert} from '../asserts.js';\\nimport {TRUE, FALSE} from '../functions.js';\\nimport {WEBKIT, MAC} from '../has.js';\\n\\n\\n/**\\n * A function that takes an {@link module:ol/MapBrowserEvent} and returns a\\n * `{boolean}`. If the condition is met, true should be returned.\\n *\\n * @typedef {function(this: ?, module:ol/MapBrowserEvent): boolean} Condition\\n */\\n\\n\\n/**\\n * Return `true` if only the alt-key is pressed, `false` otherwise (e.g. when\\n * additionally the shift-key is pressed).\\n *\\n * @param {module:ol/MapBrowserEvent} mapBrowserEvent Map browser event.\\n * @return {boolean} True if only the alt key is pressed.\\n * @api\\n */\\nexport const altKeyOnly = function(mapBrowserEvent) {\\n  const originalEvent = mapBrowserEvent.originalEvent;\\n  return (\\n    originalEvent.altKey &&\\n      !(originalEvent.metaKey || originalEvent.ctrlKey) &&\\n      !originalEvent.shiftKey);\\n};\\n\\n\\n/**\\n * Return `true` if only the alt-key and shift-key is pressed, `false` otherwise\\n * (e.g. when additionally the platform-modifier-key is pressed).\\n *\\n * @param {module:ol/MapBrowserEvent} mapBrowserEvent Map browser event.\\n * @return {boolean} True if only the alt and shift keys are pressed.\\n * @api\\n */\\nexport const altShiftKeysOnly = function(mapBrowserEvent) {\\n  const originalEvent = mapBrowserEvent.originalEvent;\\n  return (\\n    originalEvent.altKey &&\\n      !(originalEvent.metaKey || originalEvent.ctrlKey) &&\\n      originalEvent.shiftKey);\\n};\\n\\n\\n/**\\n * Return `true` if the map has the focus. This condition requires a map target\\n * element with a `tabindex` attribute, e.g. `<div id=\\\"map\\\" tabindex=\\\"1\\\">`.\\n *\\n * @param {module:ol/MapBrowserEvent} event Map browser event.\\n * @return {boolean} The map has the focus.\\n * @api\\n */\\nexport const focus = function(event) {\\n  return event.target.getTargetElement() === document.activeElement;\\n};\\n\\n\\n/**\\n * Return always true.\\n *\\n * @param {module:ol/MapBrowserEvent} mapBrowserEvent Map browser event.\\n * @return {boolean} True.\\n * @function\\n * @api\\n */\\nexport const always = TRUE;\\n\\n\\n/**\\n * Return `true` if the event is a `click` event, `false` otherwise.\\n *\\n * @param {module:ol/MapBrowserEvent} mapBrowserEvent Map browser event.\\n * @return {boolean} True if the event is a map `click` event.\\n * @api\\n */\\nexport const click = function(mapBrowserEvent) {\\n  return mapBrowserEvent.type == MapBrowserEventType.CLICK;\\n};\\n\\n\\n/**\\n * Return `true` if the event has an \\\"action\\\"-producing mouse button.\\n *\\n * By definition, this includes left-click on windows/linux, and left-click\\n * without the ctrl key on Macs.\\n *\\n * @param {module:ol/MapBrowserEvent} mapBrowserEvent Map browser event.\\n * @return {boolean} The result.\\n */\\nexport const mouseActionButton = function(mapBrowserEvent) {\\n  const originalEvent = mapBrowserEvent.originalEvent;\\n  return originalEvent.button == 0 &&\\n      !(WEBKIT && MAC && originalEvent.ctrlKey);\\n};\\n\\n\\n/**\\n * Return always false.\\n *\\n * @param {module:ol/MapBrowserEvent} mapBrowserEvent Map browser event.\\n * @return {boolean} False.\\n * @function\\n * @api\\n */\\nexport const never = FALSE;\\n\\n\\n/**\\n * Return `true` if the browser event is a `pointermove` event, `false`\\n * otherwise.\\n *\\n * @param {module:ol/MapBrowserEvent} mapBrowserEvent Map browser event.\\n * @return {boolean} True if the browser event is a `pointermove` event.\\n * @api\\n */\\nexport const pointerMove = function(mapBrowserEvent) {\\n  return mapBrowserEvent.type == 'pointermove';\\n};\\n\\n\\n/**\\n * Return `true` if the event is a map `singleclick` event, `false` otherwise.\\n *\\n * @param {module:ol/MapBrowserEvent} mapBrowserEvent Map browser event.\\n * @return {boolean} True if the event is a map `singleclick` event.\\n * @api\\n */\\nexport const singleClick = function(mapBrowserEvent) {\\n  return mapBrowserEvent.type == MapBrowserEventType.SINGLECLICK;\\n};\\n\\n\\n/**\\n * Return `true` if the event is a map `dblclick` event, `false` otherwise.\\n *\\n * @param {module:ol/MapBrowserEvent} mapBrowserEvent Map browser event.\\n * @return {boolean} True if the event is a map `dblclick` event.\\n * @api\\n */\\nexport const doubleClick = function(mapBrowserEvent) {\\n  return mapBrowserEvent.type == MapBrowserEventType.DBLCLICK;\\n};\\n\\n\\n/**\\n * Return `true` if no modifier key (alt-, shift- or platform-modifier-key) is\\n * pressed.\\n *\\n * @param {module:ol/MapBrowserEvent} mapBrowserEvent Map browser event.\\n * @return {boolean} True only if there no modifier keys are pressed.\\n * @api\\n */\\nexport const noModifierKeys = function(mapBrowserEvent) {\\n  const originalEvent = mapBrowserEvent.originalEvent;\\n  return (\\n    !originalEvent.altKey &&\\n      !(originalEvent.metaKey || originalEvent.ctrlKey) &&\\n      !originalEvent.shiftKey);\\n};\\n\\n\\n/**\\n * Return `true` if only the platform-modifier-key (the meta-key on Mac,\\n * ctrl-key otherwise) is pressed, `false` otherwise (e.g. when additionally\\n * the shift-key is pressed).\\n *\\n * @param {module:ol/MapBrowserEvent} mapBrowserEvent Map browser event.\\n * @return {boolean} True if only the platform modifier key is pressed.\\n * @api\\n */\\nexport const platformModifierKeyOnly = function(mapBrowserEvent) {\\n  const originalEvent = mapBrowserEvent.originalEvent;\\n  return !originalEvent.altKey &&\\n    (MAC ? originalEvent.metaKey : originalEvent.ctrlKey) &&\\n    !originalEvent.shiftKey;\\n};\\n\\n\\n/**\\n * Return `true` if only the shift-key is pressed, `false` otherwise (e.g. when\\n * additionally the alt-key is pressed).\\n *\\n * @param {module:ol/MapBrowserEvent} mapBrowserEvent Map browser event.\\n * @return {boolean} True if only the shift key is pressed.\\n * @api\\n */\\nexport const shiftKeyOnly = function(mapBrowserEvent) {\\n  const originalEvent = mapBrowserEvent.originalEvent;\\n  return (\\n    !originalEvent.altKey &&\\n      !(originalEvent.metaKey || originalEvent.ctrlKey) &&\\n      originalEvent.shiftKey);\\n};\\n\\n\\n/**\\n * Return `true` if the target element is not editable, i.e. not a `<input>`-,\\n * `<select>`- or `<textarea>`-element, `false` otherwise.\\n *\\n * @param {module:ol/MapBrowserEvent} mapBrowserEvent Map browser event.\\n * @return {boolean} True only if the target element is not editable.\\n * @api\\n */\\nexport const targetNotEditable = function(mapBrowserEvent) {\\n  const target = mapBrowserEvent.originalEvent.target;\\n  const tagName = target.tagName;\\n  return (\\n    tagName !== 'INPUT' &&\\n      tagName !== 'SELECT' &&\\n      tagName !== 'TEXTAREA');\\n};\\n\\n\\n/**\\n * Return `true` if the event originates from a mouse device.\\n *\\n * @param {module:ol/MapBrowserEvent} mapBrowserEvent Map browser event.\\n * @return {boolean} True if the event originates from a mouse device.\\n * @api\\n */\\nexport const mouseOnly = function(mapBrowserEvent) {\\n  assert(mapBrowserEvent.pointerEvent, 56); // mapBrowserEvent must originate from a pointer event\\n  // see http://www.w3.org/TR/pointerevents/#widl-PointerEvent-pointerType\\n  return (\\n    /** @type {module:ol/MapBrowserEvent} */ (mapBrowserEvent).pointerEvent.pointerType == 'mouse'\\n  );\\n};\\n\\n\\n/**\\n * Return `true` if the event originates from a primary pointer in\\n * contact with the surface or if the left mouse button is pressed.\\n * @see http://www.w3.org/TR/pointerevents/#button-states\\n *\\n * @param {module:ol/MapBrowserEvent} mapBrowserEvent Map browser event.\\n * @return {boolean} True if the event originates from a primary pointer.\\n * @api\\n */\\nexport const primaryAction = function(mapBrowserEvent) {\\n  const pointerEvent = mapBrowserEvent.pointerEvent;\\n  return pointerEvent.isPrimary && pointerEvent.button === 0;\\n};\\n\",\"/**\\n * @module ol/interaction/Pointer\\n */\\nimport {inherits} from '../index.js';\\nimport {FALSE, UNDEFINED} from '../functions.js';\\nimport MapBrowserEventType from '../MapBrowserEventType.js';\\nimport MapBrowserPointerEvent from '../MapBrowserPointerEvent.js';\\nimport Interaction from '../interaction/Interaction.js';\\nimport {getValues} from '../obj.js';\\n\\n\\n/**\\n * @param {module:ol/MapBrowserPointerEvent} mapBrowserEvent Event.\\n * @this {module:ol/interaction/Pointer}\\n */\\nconst handleDragEvent = UNDEFINED;\\n\\n\\n/**\\n * @param {module:ol/MapBrowserPointerEvent} mapBrowserEvent Event.\\n * @return {boolean} Capture dragging.\\n * @this {module:ol/interaction/Pointer}\\n */\\nconst handleUpEvent = FALSE;\\n\\n\\n/**\\n * @param {module:ol/MapBrowserPointerEvent} mapBrowserEvent Event.\\n * @return {boolean} Capture dragging.\\n * @this {module:ol/interaction/Pointer}\\n */\\nconst handleDownEvent = FALSE;\\n\\n\\n/**\\n * @param {module:ol/MapBrowserPointerEvent} mapBrowserEvent Event.\\n * @this {module:ol/interaction/Pointer}\\n */\\nconst handleMoveEvent = UNDEFINED;\\n\\n\\n/**\\n * @typedef {Object} Options\\n * @property {(function(module:ol/MapBrowserPointerEvent):boolean)} [handleDownEvent]\\n * Function handling \\\"down\\\" events. If the function returns `true` then a drag\\n * sequence is started.\\n * @property {(function(module:ol/MapBrowserPointerEvent))} [handleDragEvent]\\n * Function handling \\\"drag\\\" events. This function is called on \\\"move\\\" events\\n * during a drag sequence.\\n * @property {(function(module:ol/MapBrowserEvent):boolean)} [handleEvent]\\n * Method called by the map to notify the interaction that a browser event was\\n * dispatched to the map. The function may return `false` to prevent the\\n * propagation of the event to other interactions in the map's interactions\\n * chain.\\n * @property {(function(module:ol/MapBrowserPointerEvent))} [handleMoveEvent]\\n * Function handling \\\"move\\\" events. This function is called on \\\"move\\\" events,\\n * also during a drag sequence (so during a drag sequence both the\\n * `handleDragEvent` function and this function are called).\\n * @property {(function(module:ol/MapBrowserPointerEvent):boolean)} [handleUpEvent]\\n *  Function handling \\\"up\\\" events. If the function returns `false` then the\\n * current drag sequence is stopped.\\n */\\n\\n\\n/**\\n * @classdesc\\n * Base class that calls user-defined functions on `down`, `move` and `up`\\n * events. This class also manages \\\"drag sequences\\\".\\n *\\n * When the `handleDownEvent` user function returns `true` a drag sequence is\\n * started. During a drag sequence the `handleDragEvent` user function is\\n * called on `move` events. The drag sequence ends when the `handleUpEvent`\\n * user function is called and returns `false`.\\n *\\n * @constructor\\n * @param {module:ol/interaction/Pointer~Options=} opt_options Options.\\n * @extends {module:ol/interaction/Interaction}\\n * @api\\n */\\nconst PointerInteraction = function(opt_options) {\\n\\n  const options = opt_options ? opt_options : {};\\n\\n  Interaction.call(this, {\\n    handleEvent: options.handleEvent || handleEvent\\n  });\\n\\n  /**\\n   * @type {function(module:ol/MapBrowserPointerEvent):boolean}\\n   * @private\\n   */\\n  this.handleDownEvent_ = options.handleDownEvent ?\\n    options.handleDownEvent : handleDownEvent;\\n\\n  /**\\n   * @type {function(module:ol/MapBrowserPointerEvent)}\\n   * @private\\n   */\\n  this.handleDragEvent_ = options.handleDragEvent ?\\n    options.handleDragEvent : handleDragEvent;\\n\\n  /**\\n   * @type {function(module:ol/MapBrowserPointerEvent)}\\n   * @private\\n   */\\n  this.handleMoveEvent_ = options.handleMoveEvent ?\\n    options.handleMoveEvent : handleMoveEvent;\\n\\n  /**\\n   * @type {function(module:ol/MapBrowserPointerEvent):boolean}\\n   * @private\\n   */\\n  this.handleUpEvent_ = options.handleUpEvent ?\\n    options.handleUpEvent : handleUpEvent;\\n\\n  /**\\n   * @type {boolean}\\n   * @protected\\n   */\\n  this.handlingDownUpSequence = false;\\n\\n  /**\\n   * @type {!Object.<string, module:ol/pointer/PointerEvent>}\\n   * @private\\n   */\\n  this.trackedPointers_ = {};\\n\\n  /**\\n   * @type {Array.<module:ol/pointer/PointerEvent>}\\n   * @protected\\n   */\\n  this.targetPointers = [];\\n\\n};\\n\\ninherits(PointerInteraction, Interaction);\\n\\n\\n/**\\n * @param {Array.<module:ol/pointer/PointerEvent>} pointerEvents List of events.\\n * @return {module:ol~Pixel} Centroid pixel.\\n */\\nexport function centroid(pointerEvents) {\\n  const length = pointerEvents.length;\\n  let clientX = 0;\\n  let clientY = 0;\\n  for (let i = 0; i < length; i++) {\\n    clientX += pointerEvents[i].clientX;\\n    clientY += pointerEvents[i].clientY;\\n  }\\n  return [clientX / length, clientY / length];\\n}\\n\\n\\n/**\\n * @param {module:ol/MapBrowserPointerEvent} mapBrowserEvent Event.\\n * @return {boolean} Whether the event is a pointerdown, pointerdrag\\n *     or pointerup event.\\n */\\nfunction isPointerDraggingEvent(mapBrowserEvent) {\\n  const type = mapBrowserEvent.type;\\n  return type === MapBrowserEventType.POINTERDOWN ||\\n    type === MapBrowserEventType.POINTERDRAG ||\\n    type === MapBrowserEventType.POINTERUP;\\n}\\n\\n\\n/**\\n * @param {module:ol/MapBrowserPointerEvent} mapBrowserEvent Event.\\n * @private\\n */\\nPointerInteraction.prototype.updateTrackedPointers_ = function(mapBrowserEvent) {\\n  if (isPointerDraggingEvent(mapBrowserEvent)) {\\n    const event = mapBrowserEvent.pointerEvent;\\n\\n    const id = event.pointerId.toString();\\n    if (mapBrowserEvent.type == MapBrowserEventType.POINTERUP) {\\n      delete this.trackedPointers_[id];\\n    } else if (mapBrowserEvent.type ==\\n        MapBrowserEventType.POINTERDOWN) {\\n      this.trackedPointers_[id] = event;\\n    } else if (id in this.trackedPointers_) {\\n      // update only when there was a pointerdown event for this pointer\\n      this.trackedPointers_[id] = event;\\n    }\\n    this.targetPointers = getValues(this.trackedPointers_);\\n  }\\n};\\n\\n\\n/**\\n * Handles the {@link module:ol/MapBrowserEvent map browser event} and may call into\\n * other functions, if event sequences like e.g. 'drag' or 'down-up' etc. are\\n * detected.\\n * @param {module:ol/MapBrowserEvent} mapBrowserEvent Map browser event.\\n * @return {boolean} `false` to stop event propagation.\\n * @this {module:ol/interaction/Pointer}\\n * @api\\n */\\nexport function handleEvent(mapBrowserEvent) {\\n  if (!(mapBrowserEvent instanceof MapBrowserPointerEvent)) {\\n    return true;\\n  }\\n\\n  let stopEvent = false;\\n  this.updateTrackedPointers_(mapBrowserEvent);\\n  if (this.handlingDownUpSequence) {\\n    if (mapBrowserEvent.type == MapBrowserEventType.POINTERDRAG) {\\n      this.handleDragEvent_(mapBrowserEvent);\\n    } else if (mapBrowserEvent.type == MapBrowserEventType.POINTERUP) {\\n      const handledUp = this.handleUpEvent_(mapBrowserEvent);\\n      this.handlingDownUpSequence = handledUp && this.targetPointers.length > 0;\\n    }\\n  } else {\\n    if (mapBrowserEvent.type == MapBrowserEventType.POINTERDOWN) {\\n      const handled = this.handleDownEvent_(mapBrowserEvent);\\n      this.handlingDownUpSequence = handled;\\n      stopEvent = this.shouldStopEvent(handled);\\n    } else if (mapBrowserEvent.type == MapBrowserEventType.POINTERMOVE) {\\n      this.handleMoveEvent_(mapBrowserEvent);\\n    }\\n  }\\n  return !stopEvent;\\n}\\n\\n\\n/**\\n * This method is used to determine if \\\"down\\\" events should be propagated to\\n * other interactions or should be stopped.\\n *\\n * The method receives the return code of the \\\"handleDownEvent\\\" function.\\n *\\n * By default this function is the \\\"identity\\\" function. It's overridden in\\n * child classes.\\n *\\n * @param {boolean} handled Was the event handled by the interaction?\\n * @return {boolean} Should the event be stopped?\\n * @protected\\n */\\nPointerInteraction.prototype.shouldStopEvent = function(handled) {\\n  return handled;\\n};\\n\\nexport default PointerInteraction;\\n\",\"/**\\n * @module ol/interaction/DragPan\\n */\\nimport {inherits} from '../index.js';\\nimport ViewHint from '../ViewHint.js';\\nimport {scale as scaleCoordinate, rotate as rotateCoordinate, add as addCoordinate} from '../coordinate.js';\\nimport {easeOut} from '../easing.js';\\nimport {noModifierKeys} from '../events/condition.js';\\nimport {FALSE} from '../functions.js';\\nimport PointerInteraction, {centroid as centroidFromPointers} from '../interaction/Pointer.js';\\n\\n\\n/**\\n * @typedef {Object} Options\\n * @property {module:ol/events/condition~Condition} [condition] A function that takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a boolean\\n * to indicate whether that event should be handled.\\n * Default is {@link module:ol/events/condition~noModifierKeys}.\\n * @property {module:ol/Kinetic} [kinetic] Kinetic inertia to apply to the pan.\\n */\\n\\n\\n/**\\n * @classdesc\\n * Allows the user to pan the map by dragging the map.\\n *\\n * @constructor\\n * @extends {module:ol/interaction/Pointer}\\n * @param {module:ol/interaction/DragPan~Options=} opt_options Options.\\n * @api\\n */\\nconst DragPan = function(opt_options) {\\n\\n  PointerInteraction.call(this, {\\n    handleDownEvent: handleDownEvent,\\n    handleDragEvent: handleDragEvent,\\n    handleUpEvent: handleUpEvent\\n  });\\n\\n  const options = opt_options ? opt_options : {};\\n\\n  /**\\n   * @private\\n   * @type {module:ol/Kinetic|undefined}\\n   */\\n  this.kinetic_ = options.kinetic;\\n\\n  /**\\n   * @type {module:ol~Pixel}\\n   */\\n  this.lastCentroid = null;\\n\\n  /**\\n   * @type {number}\\n   */\\n  this.lastPointersCount_;\\n\\n  /**\\n   * @private\\n   * @type {module:ol/events/condition~Condition}\\n   */\\n  this.condition_ = options.condition ? options.condition : noModifierKeys;\\n\\n  /**\\n   * @private\\n   * @type {boolean}\\n   */\\n  this.noKinetic_ = false;\\n\\n};\\n\\ninherits(DragPan, PointerInteraction);\\n\\n\\n/**\\n * @param {module:ol/MapBrowserPointerEvent} mapBrowserEvent Event.\\n * @this {module:ol/interaction/DragPan}\\n */\\nfunction handleDragEvent(mapBrowserEvent) {\\n  const targetPointers = this.targetPointers;\\n  const centroid = centroidFromPointers(targetPointers);\\n  if (targetPointers.length == this.lastPointersCount_) {\\n    if (this.kinetic_) {\\n      this.kinetic_.update(centroid[0], centroid[1]);\\n    }\\n    if (this.lastCentroid) {\\n      const deltaX = this.lastCentroid[0] - centroid[0];\\n      const deltaY = centroid[1] - this.lastCentroid[1];\\n      const map = mapBrowserEvent.map;\\n      const view = map.getView();\\n      let center = [deltaX, deltaY];\\n      scaleCoordinate(center, view.getResolution());\\n      rotateCoordinate(center, view.getRotation());\\n      addCoordinate(center, view.getCenter());\\n      center = view.constrainCenter(center);\\n      view.setCenter(center);\\n    }\\n  } else if (this.kinetic_) {\\n    // reset so we don't overestimate the kinetic energy after\\n    // after one finger down, tiny drag, second finger down\\n    this.kinetic_.begin();\\n  }\\n  this.lastCentroid = centroid;\\n  this.lastPointersCount_ = targetPointers.length;\\n}\\n\\n\\n/**\\n * @param {module:ol/MapBrowserPointerEvent} mapBrowserEvent Event.\\n * @return {boolean} Stop drag sequence?\\n * @this {module:ol/interaction/DragPan}\\n */\\nfunction handleUpEvent(mapBrowserEvent) {\\n  const map = mapBrowserEvent.map;\\n  const view = map.getView();\\n  if (this.targetPointers.length === 0) {\\n    if (!this.noKinetic_ && this.kinetic_ && this.kinetic_.end()) {\\n      const distance = this.kinetic_.getDistance();\\n      const angle = this.kinetic_.getAngle();\\n      const center = /** @type {!module:ol/coordinate~Coordinate} */ (view.getCenter());\\n      const centerpx = map.getPixelFromCoordinate(center);\\n      const dest = map.getCoordinateFromPixel([\\n        centerpx[0] - distance * Math.cos(angle),\\n        centerpx[1] - distance * Math.sin(angle)\\n      ]);\\n      view.animate({\\n        center: view.constrainCenter(dest),\\n        duration: 500,\\n        easing: easeOut\\n      });\\n    }\\n    view.setHint(ViewHint.INTERACTING, -1);\\n    return false;\\n  } else {\\n    if (this.kinetic_) {\\n      // reset so we don't overestimate the kinetic energy after\\n      // after one finger up, tiny drag, second finger up\\n      this.kinetic_.begin();\\n    }\\n    this.lastCentroid = null;\\n    return true;\\n  }\\n}\\n\\n\\n/**\\n * @param {module:ol/MapBrowserPointerEvent} mapBrowserEvent Event.\\n * @return {boolean} Start drag sequence?\\n * @this {module:ol/interaction/DragPan}\\n */\\nfunction handleDownEvent(mapBrowserEvent) {\\n  if (this.targetPointers.length > 0 && this.condition_(mapBrowserEvent)) {\\n    const map = mapBrowserEvent.map;\\n    const view = map.getView();\\n    this.lastCentroid = null;\\n    if (!this.handlingDownUpSequence) {\\n      view.setHint(ViewHint.INTERACTING, 1);\\n    }\\n    // stop any current animation\\n    if (view.getAnimating()) {\\n      view.setCenter(mapBrowserEvent.frameState.viewState.center);\\n    }\\n    if (this.kinetic_) {\\n      this.kinetic_.begin();\\n    }\\n    // No kinetic as soon as more than one pointer on the screen is\\n    // detected. This is to prevent nasty pans after pinch.\\n    this.noKinetic_ = this.targetPointers.length > 1;\\n    return true;\\n  } else {\\n    return false;\\n  }\\n}\\n\\n\\n/**\\n * @inheritDoc\\n */\\nDragPan.prototype.shouldStopEvent = FALSE;\\nexport default DragPan;\\n\",\"/**\\n * @module ol/interaction/DragRotate\\n */\\nimport {inherits} from '../index.js';\\nimport {disable} from '../rotationconstraint.js';\\nimport ViewHint from '../ViewHint.js';\\nimport {altShiftKeysOnly, mouseOnly, mouseActionButton} from '../events/condition.js';\\nimport {FALSE} from '../functions.js';\\nimport {rotate, rotateWithoutConstraints} from '../interaction/Interaction.js';\\nimport PointerInteraction from '../interaction/Pointer.js';\\n\\n\\n/**\\n * @typedef {Object} Options\\n * @property {module:ol/events/condition~Condition} [condition] A function that takes an\\n * {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a boolean\\n * to indicate whether that event should be handled.\\n * Default is {@link module:ol/events/condition~altShiftKeysOnly}.\\n * @property {number} [duration=250] Animation duration in milliseconds.\\n */\\n\\n\\n/**\\n * @classdesc\\n * Allows the user to rotate the map by clicking and dragging on the map,\\n * normally combined with an {@link module:ol/events/condition} that limits\\n * it to when the alt and shift keys are held down.\\n *\\n * This interaction is only supported for mouse devices.\\n *\\n * @constructor\\n * @extends {module:ol/interaction/Pointer}\\n * @param {module:ol/interaction/DragRotate~Options=} opt_options Options.\\n * @api\\n */\\nconst DragRotate = function(opt_options) {\\n\\n  const options = opt_options ? opt_options : {};\\n\\n  PointerInteraction.call(this, {\\n    handleDownEvent: handleDownEvent,\\n    handleDragEvent: handleDragEvent,\\n    handleUpEvent: handleUpEvent\\n  });\\n\\n  /**\\n   * @private\\n   * @type {module:ol/events/condition~Condition}\\n   */\\n  this.condition_ = options.condition ? options.condition : altShiftKeysOnly;\\n\\n  /**\\n   * @private\\n   * @type {number|undefined}\\n   */\\n  this.lastAngle_ = undefined;\\n\\n  /**\\n   * @private\\n   * @type {number}\\n   */\\n  this.duration_ = options.duration !== undefined ? options.duration : 250;\\n};\\n\\ninherits(DragRotate, PointerInteraction);\\n\\n\\n/**\\n * @param {module:ol/MapBrowserPointerEvent} mapBrowserEvent Event.\\n * @this {module:ol/interaction/DragRotate}\\n */\\nfunction handleDragEvent(mapBrowserEvent) {\\n  if (!mouseOnly(mapBrowserEvent)) {\\n    return;\\n  }\\n\\n  const map = mapBrowserEvent.map;\\n  const view = map.getView();\\n  if (view.getConstraints().rotation === disable) {\\n    return;\\n  }\\n  const size = map.getSize();\\n  const offset = mapBrowserEvent.pixel;\\n  const theta =\\n      Math.atan2(size[1] / 2 - offset[1], offset[0] - size[0] / 2);\\n  if (this.lastAngle_ !== undefined) {\\n    const delta = theta - this.lastAngle_;\\n    const rotation = view.getRotation();\\n    rotateWithoutConstraints(view, rotation - delta);\\n  }\\n  this.lastAngle_ = theta;\\n}\\n\\n\\n/**\\n * @param {module:ol/MapBrowserPointerEvent} mapBrowserEvent Event.\\n * @return {boolean} Stop drag sequence?\\n * @this {module:ol/interaction/DragRotate}\\n */\\nfunction handleUpEvent(mapBrowserEvent) {\\n  if (!mouseOnly(mapBrowserEvent)) {\\n    return true;\\n  }\\n\\n  const map = mapBrowserEvent.map;\\n  const view = map.getView();\\n  view.setHint(ViewHint.INTERACTING, -1);\\n  const rotation = view.getRotation();\\n  rotate(view, rotation, undefined, this.duration_);\\n  return false;\\n}\\n\\n\\n/**\\n * @param {module:ol/MapBrowserPointerEvent} mapBrowserEvent Event.\\n * @return {boolean} Start drag sequence?\\n * @this {module:ol/interaction/DragRotate}\\n */\\nfunction handleDownEvent(mapBrowserEvent) {\\n  if (!mouseOnly(mapBrowserEvent)) {\\n    return false;\\n  }\\n\\n  if (mouseActionButton(mapBrowserEvent) && this.condition_(mapBrowserEvent)) {\\n    const map = mapBrowserEvent.map;\\n    map.getView().setHint(ViewHint.INTERACTING, 1);\\n    this.lastAngle_ = undefined;\\n    return true;\\n  } else {\\n    return false;\\n  }\\n}\\n\\n\\n/**\\n * @inheritDoc\\n */\\nDragRotate.prototype.shouldStopEvent = FALSE;\\nexport default DragRotate;\\n\",\"/**\\n * @module ol/render/Box\\n */\\n// FIXME add rotation\\n\\nimport {inherits} from '../index.js';\\nimport Disposable from '../Disposable.js';\\nimport Polygon from '../geom/Polygon.js';\\n\\n/**\\n * @constructor\\n * @extends {module:ol/Disposable}\\n * @param {string} className CSS class name.\\n */\\nconst RenderBox = function(className) {\\n\\n  /**\\n   * @type {module:ol/geom/Polygon}\\n   * @private\\n   */\\n  this.geometry_ = null;\\n\\n  /**\\n   * @type {HTMLDivElement}\\n   * @private\\n   */\\n  this.element_ = /** @type {HTMLDivElement} */ (document.createElement('div'));\\n  this.element_.style.position = 'absolute';\\n  this.element_.className = 'ol-box ' + className;\\n\\n  /**\\n   * @private\\n   * @type {module:ol/PluggableMap}\\n   */\\n  this.map_ = null;\\n\\n  /**\\n   * @private\\n   * @type {module:ol~Pixel}\\n   */\\n  this.startPixel_ = null;\\n\\n  /**\\n   * @private\\n   * @type {module:ol~Pixel}\\n   */\\n  this.endPixel_ = null;\\n\\n};\\n\\ninherits(RenderBox, Disposable);\\n\\n\\n/**\\n * @inheritDoc\\n */\\nRenderBox.prototype.disposeInternal = function() {\\n  this.setMap(null);\\n};\\n\\n\\n/**\\n * @private\\n */\\nRenderBox.prototype.render_ = function() {\\n  const startPixel = this.startPixel_;\\n  const endPixel = this.endPixel_;\\n  const px = 'px';\\n  const style = this.element_.style;\\n  style.left = Math.min(startPixel[0], endPixel[0]) + px;\\n  style.top = Math.min(startPixel[1], endPixel[1]) + px;\\n  style.width = Math.abs(endPixel[0] - startPixel[0]) + px;\\n  style.height = Math.abs(endPixel[1] - startPixel[1]) + px;\\n};\\n\\n\\n/**\\n * @param {module:ol/PluggableMap} map Map.\\n */\\nRenderBox.prototype.setMap = function(map) {\\n  if (this.map_) {\\n    this.map_.getOverlayContainer().removeChild(this.element_);\\n    const style = this.element_.style;\\n    style.left = style.top = style.width = style.height = 'inherit';\\n  }\\n  this.map_ = map;\\n  if (this.map_) {\\n    this.map_.getOverlayContainer().appendChild(this.element_);\\n  }\\n};\\n\\n\\n/**\\n * @param {module:ol~Pixel} startPixel Start pixel.\\n * @param {module:ol~Pixel} endPixel End pixel.\\n */\\nRenderBox.prototype.setPixels = function(startPixel, endPixel) {\\n  this.startPixel_ = startPixel;\\n  this.endPixel_ = endPixel;\\n  this.createOrUpdateGeometry();\\n  this.render_();\\n};\\n\\n\\n/**\\n * Creates or updates the cached geometry.\\n */\\nRenderBox.prototype.createOrUpdateGeometry = function() {\\n  const startPixel = this.startPixel_;\\n  const endPixel = this.endPixel_;\\n  const pixels = [\\n    startPixel,\\n    [startPixel[0], endPixel[1]],\\n    endPixel,\\n    [endPixel[0], startPixel[1]]\\n  ];\\n  const coordinates = pixels.map(this.map_.getCoordinateFromPixel, this.map_);\\n  // close the polygon\\n  coordinates[4] = coordinates[0].slice();\\n  if (!this.geometry_) {\\n    this.geometry_ = new Polygon([coordinates]);\\n  } else {\\n    this.geometry_.setCoordinates([coordinates]);\\n  }\\n};\\n\\n\\n/**\\n * @return {module:ol/geom/Polygon} Geometry.\\n */\\nRenderBox.prototype.getGeometry = function() {\\n  return this.geometry_;\\n};\\nexport default RenderBox;\\n\",\"/**\\n * @module ol/interaction/DragBox\\n */\\n// FIXME draw drag box\\nimport Event from '../events/Event.js';\\nimport {inherits} from '../index.js';\\nimport {always, mouseOnly, mouseActionButton} from '../events/condition.js';\\nimport {UNDEFINED} from '../functions.js';\\nimport PointerInteraction from '../interaction/Pointer.js';\\nimport RenderBox from '../render/Box.js';\\n\\n\\n/**\\n * A function that takes a {@link module:ol/MapBrowserEvent} and two\\n * {@link module:ol~Pixel}s and returns a `{boolean}`. If the condition is met,\\n * true should be returned.\\n * @typedef {function(this: ?, module:ol/MapBrowserEvent, module:ol~Pixel, module:ol~Pixel):boolean} EndCondition\\n */\\n\\n\\n/**\\n * @typedef {Object} Options\\n * @property {string} [className='ol-dragbox'] CSS class name for styling the box.\\n * @property {module:ol/events/condition~Condition} [condition] A function that takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a boolean\\n * to indicate whether that event should be handled.\\n * Default is {@link ol/events/condition~always}.\\n * @property {number} [minArea=64] The minimum area of the box in pixel, this value is used by the default\\n * `boxEndCondition` function.\\n * @property {module:ol/interaction/DragBox~EndCondition} [boxEndCondition] A function that takes a {@link module:ol/MapBrowserEvent~MapBrowserEvent} and two\\n * {@link module:ol~Pixel}s to indicate whether a `boxend` event should be fired.\\n * Default is `true` if the area of the box is bigger than the `minArea` option.\\n */\\n\\n\\n/**\\n * @enum {string}\\n */\\nconst DragBoxEventType = {\\n  /**\\n   * Triggered upon drag box start.\\n   * @event module:ol/interaction/DragBox~DragBoxEvent#boxstart\\n   * @api\\n   */\\n  BOXSTART: 'boxstart',\\n\\n  /**\\n   * Triggered on drag when box is active.\\n   * @event module:ol/interaction/DragBox~DragBoxEvent#boxdrag\\n   * @api\\n   */\\n  BOXDRAG: 'boxdrag',\\n\\n  /**\\n   * Triggered upon drag box end.\\n   * @event module:ol/interaction/DragBox~DragBoxEvent#boxend\\n   * @api\\n   */\\n  BOXEND: 'boxend'\\n};\\n\\n\\n/**\\n * @classdesc\\n * Events emitted by {@link module:ol/interaction/DragBox~DragBox} instances are instances of\\n * this type.\\n *\\n * @param {string} type The event type.\\n * @param {module:ol/coordinate~Coordinate} coordinate The event coordinate.\\n * @param {module:ol/MapBrowserEvent} mapBrowserEvent Originating event.\\n * @extends {module:ol/events/Event}\\n * @constructor\\n */\\nconst DragBoxEvent = function(type, coordinate, mapBrowserEvent) {\\n  Event.call(this, type);\\n\\n  /**\\n   * The coordinate of the drag event.\\n   * @const\\n   * @type {module:ol/coordinate~Coordinate}\\n   * @api\\n   */\\n  this.coordinate = coordinate;\\n\\n  /**\\n   * @const\\n   * @type {module:ol/MapBrowserEvent}\\n   * @api\\n   */\\n  this.mapBrowserEvent = mapBrowserEvent;\\n\\n};\\n\\ninherits(DragBoxEvent, Event);\\n\\n\\n/**\\n * @classdesc\\n * Allows the user to draw a vector box by clicking and dragging on the map,\\n * normally combined with an {@link module:ol/events/condition} that limits\\n * it to when the shift or other key is held down. This is used, for example,\\n * for zooming to a specific area of the map\\n * (see {@link module:ol/interaction/DragZoom~DragZoom} and\\n * {@link module:ol/interaction/DragRotateAndZoom}).\\n *\\n * This interaction is only supported for mouse devices.\\n *\\n * @constructor\\n * @extends {module:ol/interaction/Pointer}\\n * @fires module:ol/interaction/DragBox~DragBoxEvent\\n * @param {module:ol/interaction/DragBox~Options=} opt_options Options.\\n * @api\\n */\\nconst DragBox = function(opt_options) {\\n\\n  PointerInteraction.call(this, {\\n    handleDownEvent: handleDownEvent,\\n    handleDragEvent: handleDragEvent,\\n    handleUpEvent: handleUpEvent\\n  });\\n\\n  const options = opt_options ? opt_options : {};\\n\\n  /**\\n   * @type {module:ol/render/Box}\\n   * @private\\n   */\\n  this.box_ = new RenderBox(options.className || 'ol-dragbox');\\n\\n  /**\\n   * @type {number}\\n   * @private\\n   */\\n  this.minArea_ = options.minArea !== undefined ? options.minArea : 64;\\n\\n  /**\\n   * @type {module:ol~Pixel}\\n   * @private\\n   */\\n  this.startPixel_ = null;\\n\\n  /**\\n   * @private\\n   * @type {module:ol/events/condition~Condition}\\n   */\\n  this.condition_ = options.condition ? options.condition : always;\\n\\n  /**\\n   * @private\\n   * @type {module:ol/interaction/DragBox~EndCondition}\\n   */\\n  this.boxEndCondition_ = options.boxEndCondition ?\\n    options.boxEndCondition : defaultBoxEndCondition;\\n};\\n\\ninherits(DragBox, PointerInteraction);\\n\\n\\n/**\\n * The default condition for determining whether the boxend event\\n * should fire.\\n * @param {module:ol/MapBrowserEvent} mapBrowserEvent The originating MapBrowserEvent\\n *     leading to the box end.\\n * @param {module:ol~Pixel} startPixel The starting pixel of the box.\\n * @param {module:ol~Pixel} endPixel The end pixel of the box.\\n * @return {boolean} Whether or not the boxend condition should be fired.\\n * @this {module:ol/interaction/DragBox}\\n */\\nfunction defaultBoxEndCondition(mapBrowserEvent, startPixel, endPixel) {\\n  const width = endPixel[0] - startPixel[0];\\n  const height = endPixel[1] - startPixel[1];\\n  return width * width + height * height >= this.minArea_;\\n}\\n\\n\\n/**\\n * @param {module:ol/MapBrowserPointerEvent} mapBrowserEvent Event.\\n * @this {module:ol/interaction/DragBox}\\n */\\nfunction handleDragEvent(mapBrowserEvent) {\\n  if (!mouseOnly(mapBrowserEvent)) {\\n    return;\\n  }\\n\\n  this.box_.setPixels(this.startPixel_, mapBrowserEvent.pixel);\\n\\n  this.dispatchEvent(new DragBoxEvent(DragBoxEventType.BOXDRAG,\\n    mapBrowserEvent.coordinate, mapBrowserEvent));\\n}\\n\\n\\n/**\\n * Returns geometry of last drawn box.\\n * @return {module:ol/geom/Polygon} Geometry.\\n * @api\\n */\\nDragBox.prototype.getGeometry = function() {\\n  return this.box_.getGeometry();\\n};\\n\\n\\n/**\\n * To be overridden by child classes.\\n * FIXME: use constructor option instead of relying on overriding.\\n * @param {module:ol/MapBrowserEvent} mapBrowserEvent Map browser event.\\n * @protected\\n */\\nDragBox.prototype.onBoxEnd = UNDEFINED;\\n\\n\\n/**\\n * @param {module:ol/MapBrowserPointerEvent} mapBrowserEvent Event.\\n * @return {boolean} Stop drag sequence?\\n * @this {module:ol/interaction/DragBox}\\n */\\nfunction handleUpEvent(mapBrowserEvent) {\\n  if (!mouseOnly(mapBrowserEvent)) {\\n    return true;\\n  }\\n\\n  this.box_.setMap(null);\\n\\n  if (this.boxEndCondition_(mapBrowserEvent,\\n    this.startPixel_, mapBrowserEvent.pixel)) {\\n    this.onBoxEnd(mapBrowserEvent);\\n    this.dispatchEvent(new DragBoxEvent(DragBoxEventType.BOXEND,\\n      mapBrowserEvent.coordinate, mapBrowserEvent));\\n  }\\n  return false;\\n}\\n\\n\\n/**\\n * @param {module:ol/MapBrowserPointerEvent} mapBrowserEvent Event.\\n * @return {boolean} Start drag sequence?\\n * @this {module:ol/interaction/DragBox}\\n */\\nfunction handleDownEvent(mapBrowserEvent) {\\n  if (!mouseOnly(mapBrowserEvent)) {\\n    return false;\\n  }\\n\\n  if (mouseActionButton(mapBrowserEvent) &&\\n      this.condition_(mapBrowserEvent)) {\\n    this.startPixel_ = mapBrowserEvent.pixel;\\n    this.box_.setMap(mapBrowserEvent.map);\\n    this.box_.setPixels(this.startPixel_, this.startPixel_);\\n    this.dispatchEvent(new DragBoxEvent(DragBoxEventType.BOXSTART,\\n      mapBrowserEvent.coordinate, mapBrowserEvent));\\n    return true;\\n  } else {\\n    return false;\\n  }\\n}\\n\\n\\nexport default DragBox;\\n\",\"/**\\n * @module ol/interaction/DragZoom\\n */\\nimport {inherits} from '../index.js';\\nimport {easeOut} from '../easing.js';\\nimport {shiftKeyOnly} from '../events/condition.js';\\nimport {createOrUpdateFromCoordinates, getBottomLeft, getCenter, getTopRight, scaleFromCenter} from '../extent.js';\\nimport DragBox from '../interaction/DragBox.js';\\n\\n\\n/**\\n * @typedef {Object} Options\\n * @property {string} [className='ol-dragzoom'] CSS class name for styling the\\n * box.\\n * @property {module:ol/events/condition~Condition} [condition] A function that\\n * takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a\\n * boolean to indicate whether that event should be handled.\\n * Default is {@link module:ol/events/condition~shiftKeyOnly}.\\n * @property {number} [duration=200] Animation duration in milliseconds.\\n * @property {boolean} [out=false] Use interaction for zooming out.\\n */\\n\\n\\n/**\\n * @classdesc\\n * Allows the user to zoom the map by clicking and dragging on the map,\\n * normally combined with an {@link module:ol/events/condition} that limits\\n * it to when a key, shift by default, is held down.\\n *\\n * To change the style of the box, use CSS and the `.ol-dragzoom` selector, or\\n * your custom one configured with `className`.\\n *\\n * @constructor\\n * @extends {module:ol/interaction/DragBox}\\n * @param {module:ol/interaction/DragZoom~Options=} opt_options Options.\\n * @api\\n */\\nconst DragZoom = function(opt_options) {\\n  const options = opt_options ? opt_options : {};\\n\\n  const condition = options.condition ? options.condition : shiftKeyOnly;\\n\\n  /**\\n   * @private\\n   * @type {number}\\n   */\\n  this.duration_ = options.duration !== undefined ? options.duration : 200;\\n\\n  /**\\n   * @private\\n   * @type {boolean}\\n   */\\n  this.out_ = options.out !== undefined ? options.out : false;\\n\\n  DragBox.call(this, {\\n    condition: condition,\\n    className: options.className || 'ol-dragzoom'\\n  });\\n\\n};\\n\\ninherits(DragZoom, DragBox);\\n\\n\\n/**\\n * @inheritDoc\\n */\\nDragZoom.prototype.onBoxEnd = function() {\\n  const map = this.getMap();\\n\\n  const view = /** @type {!module:ol/View} */ (map.getView());\\n\\n  const size = /** @type {!module:ol/size~Size} */ (map.getSize());\\n\\n  let extent = this.getGeometry().getExtent();\\n\\n  if (this.out_) {\\n    const mapExtent = view.calculateExtent(size);\\n    const boxPixelExtent = createOrUpdateFromCoordinates([\\n      map.getPixelFromCoordinate(getBottomLeft(extent)),\\n      map.getPixelFromCoordinate(getTopRight(extent))]);\\n    const factor = view.getResolutionForExtent(boxPixelExtent, size);\\n\\n    scaleFromCenter(mapExtent, 1 / factor);\\n    extent = mapExtent;\\n  }\\n\\n  const resolution = view.constrainResolution(\\n    view.getResolutionForExtent(extent, size));\\n\\n  let center = getCenter(extent);\\n  center = view.constrainCenter(center);\\n\\n  view.animate({\\n    resolution: resolution,\\n    center: center,\\n    duration: this.duration_,\\n    easing: easeOut\\n  });\\n\\n};\\nexport default DragZoom;\\n\",\"/**\\n * @module ol/events/KeyCode\\n */\\n\\n/**\\n * @enum {number}\\n * @const\\n */\\nexport default {\\n  LEFT: 37,\\n  UP: 38,\\n  RIGHT: 39,\\n  DOWN: 40\\n};\\n\",\"/**\\n * @module ol/interaction/KeyboardPan\\n */\\nimport {inherits} from '../index.js';\\nimport {rotate as rotateCoordinate} from '../coordinate.js';\\nimport EventType from '../events/EventType.js';\\nimport KeyCode from '../events/KeyCode.js';\\nimport {noModifierKeys, targetNotEditable} from '../events/condition.js';\\nimport Interaction, {pan} from '../interaction/Interaction.js';\\n\\n\\n/**\\n * @typedef {Object} Options\\n * @property {module:ol/events/condition~Condition} [condition] A function that\\n * takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a\\n * boolean to indicate whether that event should be handled. Default is\\n * {@link module:ol/events/condition~noModifierKeys} and\\n * {@link module:ol/events/condition~targetNotEditable}.\\n * @property {number} [duration=100] Animation duration in milliseconds.\\n * @property {number} [pixelDelta=128] The amount of pixels to pan on each key\\n * press.\\n */\\n\\n\\n/**\\n * @classdesc\\n * Allows the user to pan the map using keyboard arrows.\\n * Note that, although this interaction is by default included in maps,\\n * the keys can only be used when browser focus is on the element to which\\n * the keyboard events are attached. By default, this is the map div,\\n * though you can change this with the `keyboardEventTarget` in\\n * {@link module:ol/Map~Map}. `document` never loses focus but, for any other\\n * element, focus will have to be on, and returned to, this element if the keys\\n * are to function.\\n * See also {@link module:ol/interaction/KeyboardZoom~KeyboardZoom}.\\n *\\n * @constructor\\n * @extends {module:ol/interaction/Interaction}\\n * @param {module:ol/interaction/KeyboardPan~Options=} opt_options Options.\\n * @api\\n */\\nconst KeyboardPan = function(opt_options) {\\n\\n  Interaction.call(this, {\\n    handleEvent: handleEvent\\n  });\\n\\n  const options = opt_options || {};\\n\\n  /**\\n   * @private\\n   * @param {module:ol/MapBrowserEvent} mapBrowserEvent Browser event.\\n   * @return {boolean} Combined condition result.\\n   */\\n  this.defaultCondition_ = function(mapBrowserEvent) {\\n    return noModifierKeys(mapBrowserEvent) &&\\n      targetNotEditable(mapBrowserEvent);\\n  };\\n\\n  /**\\n   * @private\\n   * @type {module:ol/events/condition~Condition}\\n   */\\n  this.condition_ = options.condition !== undefined ?\\n    options.condition : this.defaultCondition_;\\n\\n  /**\\n   * @private\\n   * @type {number}\\n   */\\n  this.duration_ = options.duration !== undefined ? options.duration : 100;\\n\\n  /**\\n   * @private\\n   * @type {number}\\n   */\\n  this.pixelDelta_ = options.pixelDelta !== undefined ?\\n    options.pixelDelta : 128;\\n\\n};\\n\\ninherits(KeyboardPan, Interaction);\\n\\n/**\\n * Handles the {@link module:ol/MapBrowserEvent map browser event} if it was a\\n * `KeyEvent`, and decides the direction to pan to (if an arrow key was\\n * pressed).\\n * @param {module:ol/MapBrowserEvent} mapBrowserEvent Map browser event.\\n * @return {boolean} `false` to stop event propagation.\\n * @this {module:ol/interaction/KeyboardPan}\\n */\\nfunction handleEvent(mapBrowserEvent) {\\n  let stopEvent = false;\\n  if (mapBrowserEvent.type == EventType.KEYDOWN) {\\n    const keyEvent = mapBrowserEvent.originalEvent;\\n    const keyCode = keyEvent.keyCode;\\n    if (this.condition_(mapBrowserEvent) &&\\n        (keyCode == KeyCode.DOWN ||\\n        keyCode == KeyCode.LEFT ||\\n        keyCode == KeyCode.RIGHT ||\\n        keyCode == KeyCode.UP)) {\\n      const map = mapBrowserEvent.map;\\n      const view = map.getView();\\n      const mapUnitsDelta = view.getResolution() * this.pixelDelta_;\\n      let deltaX = 0, deltaY = 0;\\n      if (keyCode == KeyCode.DOWN) {\\n        deltaY = -mapUnitsDelta;\\n      } else if (keyCode == KeyCode.LEFT) {\\n        deltaX = -mapUnitsDelta;\\n      } else if (keyCode == KeyCode.RIGHT) {\\n        deltaX = mapUnitsDelta;\\n      } else {\\n        deltaY = mapUnitsDelta;\\n      }\\n      const delta = [deltaX, deltaY];\\n      rotateCoordinate(delta, view.getRotation());\\n      pan(view, delta, this.duration_);\\n      mapBrowserEvent.preventDefault();\\n      stopEvent = true;\\n    }\\n  }\\n  return !stopEvent;\\n}\\n\\nexport default KeyboardPan;\\n\",\"/**\\n * @module ol/interaction/KeyboardZoom\\n */\\nimport {inherits} from '../index.js';\\nimport EventType from '../events/EventType.js';\\nimport {targetNotEditable} from '../events/condition.js';\\nimport Interaction, {zoomByDelta} from '../interaction/Interaction.js';\\n\\n\\n/**\\n * @typedef {Object} Options\\n * @property {number} [duration=100] Animation duration in milliseconds.\\n * @property {module:ol/events/condition~Condition} [condition] A function that\\n * takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a\\n * boolean to indicate whether that event should be handled. Default is\\n * {@link module:ol/events/condition~targetNotEditable}.\\n * @property {number} [delta=1] The zoom level delta on each key press.\\n */\\n\\n\\n/**\\n * @classdesc\\n * Allows the user to zoom the map using keyboard + and -.\\n * Note that, although this interaction is by default included in maps,\\n * the keys can only be used when browser focus is on the element to which\\n * the keyboard events are attached. By default, this is the map div,\\n * though you can change this with the `keyboardEventTarget` in\\n * {@link module:ol/Map~Map}. `document` never loses focus but, for any other\\n * element, focus will have to be on, and returned to, this element if the keys\\n * are to function.\\n * See also {@link moudle:ol/interaction/KeyboardPan~KeyboardPan}.\\n *\\n * @constructor\\n * @param {module:ol/interaction/KeyboardZoom~Options=} opt_options Options.\\n * @extends {module:ol/interaction/Interaction}\\n * @api\\n */\\nconst KeyboardZoom = function(opt_options) {\\n\\n  Interaction.call(this, {\\n    handleEvent: handleEvent\\n  });\\n\\n  const options = opt_options ? opt_options : {};\\n\\n  /**\\n   * @private\\n   * @type {module:ol/events/condition~Condition}\\n   */\\n  this.condition_ = options.condition ? options.condition : targetNotEditable;\\n\\n  /**\\n   * @private\\n   * @type {number}\\n   */\\n  this.delta_ = options.delta ? options.delta : 1;\\n\\n  /**\\n   * @private\\n   * @type {number}\\n   */\\n  this.duration_ = options.duration !== undefined ? options.duration : 100;\\n\\n};\\n\\ninherits(KeyboardZoom, Interaction);\\n\\n\\n/**\\n * Handles the {@link module:ol/MapBrowserEvent map browser event} if it was a\\n * `KeyEvent`, and decides whether to zoom in or out (depending on whether the\\n * key pressed was '+' or '-').\\n * @param {module:ol/MapBrowserEvent} mapBrowserEvent Map browser event.\\n * @return {boolean} `false` to stop event propagation.\\n * @this {module:ol/interaction/KeyboardZoom}\\n */\\nfunction handleEvent(mapBrowserEvent) {\\n  let stopEvent = false;\\n  if (mapBrowserEvent.type == EventType.KEYDOWN ||\\n      mapBrowserEvent.type == EventType.KEYPRESS) {\\n    const keyEvent = mapBrowserEvent.originalEvent;\\n    const charCode = keyEvent.charCode;\\n    if (this.condition_(mapBrowserEvent) &&\\n        (charCode == '+'.charCodeAt(0) || charCode == '-'.charCodeAt(0))) {\\n      const map = mapBrowserEvent.map;\\n      const delta = (charCode == '+'.charCodeAt(0)) ? this.delta_ : -this.delta_;\\n      const view = map.getView();\\n      zoomByDelta(view, delta, undefined, this.duration_);\\n      mapBrowserEvent.preventDefault();\\n      stopEvent = true;\\n    }\\n  }\\n  return !stopEvent;\\n}\\n\\nexport default KeyboardZoom;\\n\",\"/**\\n * @module ol/interaction/MouseWheelZoom\\n */\\nimport {inherits} from '../index.js';\\nimport ViewHint from '../ViewHint.js';\\nimport {always} from '../events/condition.js';\\nimport {easeOut} from '../easing.js';\\nimport EventType from '../events/EventType.js';\\nimport {DEVICE_PIXEL_RATIO, FIREFOX, SAFARI} from '../has.js';\\nimport Interaction, {zoomByDelta} from '../interaction/Interaction.js';\\nimport {clamp} from '../math.js';\\n\\n\\n/**\\n * Maximum mouse wheel delta.\\n * @type {number}\\n */\\nconst MAX_DELTA = 1;\\n\\n\\n/**\\n * @enum {string}\\n */\\nexport const Mode = {\\n  TRACKPAD: 'trackpad',\\n  WHEEL: 'wheel'\\n};\\n\\n\\n/**\\n * @typedef {Object} Options\\n * @property {module:ol/events/condition~Condition} [condition] A function that\\n * takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a\\n * boolean to indicate whether that event should be handled. Default is\\n * {@link module:ol/events/condition~always}.\\n * @property {number} [duration=250] Animation duration in milliseconds.\\n * @property {number} [timeout=80] Mouse wheel timeout duration in milliseconds.\\n * @property {boolean} [constrainResolution=false] When using a trackpad or\\n * magic mouse, zoom to the closest integer zoom level after the scroll gesture\\n * ends.\\n * @property {boolean} [useAnchor=true] Enable zooming using the mouse's\\n * location as the anchor. When set to `false`, zooming in and out will zoom to\\n * the center of the screen instead of zooming on the mouse's location.\\n */\\n\\n\\n/**\\n * @classdesc\\n * Allows the user to zoom the map by scrolling the mouse wheel.\\n *\\n * @constructor\\n * @extends {module:ol/interaction/Interaction}\\n * @param {module:ol/interaction/MouseWheelZoom~Options=} opt_options Options.\\n * @api\\n */\\nconst MouseWheelZoom = function(opt_options) {\\n\\n  Interaction.call(this, {\\n    handleEvent: handleEvent\\n  });\\n\\n  const options = opt_options || {};\\n\\n  /**\\n   * @private\\n   * @type {number}\\n   */\\n  this.delta_ = 0;\\n\\n  /**\\n   * @private\\n   * @type {number}\\n   */\\n  this.duration_ = options.duration !== undefined ? options.duration : 250;\\n\\n  /**\\n   * @private\\n   * @type {number}\\n   */\\n  this.timeout_ = options.timeout !== undefined ? options.timeout : 80;\\n\\n  /**\\n   * @private\\n   * @type {boolean}\\n   */\\n  this.useAnchor_ = options.useAnchor !== undefined ? options.useAnchor : true;\\n\\n  /**\\n   * @private\\n   * @type {boolean}\\n   */\\n  this.constrainResolution_ = options.constrainResolution || false;\\n\\n  /**\\n   * @private\\n   * @type {module:ol/events/condition~Condition}\\n   */\\n  this.condition_ = options.condition ? options.condition : always;\\n\\n  /**\\n   * @private\\n   * @type {?module:ol/coordinate~Coordinate}\\n   */\\n  this.lastAnchor_ = null;\\n\\n  /**\\n   * @private\\n   * @type {number|undefined}\\n   */\\n  this.startTime_ = undefined;\\n\\n  /**\\n   * @private\\n   * @type {number|undefined}\\n   */\\n  this.timeoutId_ = undefined;\\n\\n  /**\\n   * @private\\n   * @type {module:ol/interaction/MouseWheelZoom~Mode|undefined}\\n   */\\n  this.mode_ = undefined;\\n\\n  /**\\n   * Trackpad events separated by this delay will be considered separate\\n   * interactions.\\n   * @type {number}\\n   */\\n  this.trackpadEventGap_ = 400;\\n\\n  /**\\n   * @type {number|undefined}\\n   */\\n  this.trackpadTimeoutId_ = undefined;\\n\\n  /**\\n   * The number of delta values per zoom level\\n   * @private\\n   * @type {number}\\n   */\\n  this.trackpadDeltaPerZoom_ = 300;\\n\\n  /**\\n   * The zoom factor by which scroll zooming is allowed to exceed the limits.\\n   * @private\\n   * @type {number}\\n   */\\n  this.trackpadZoomBuffer_ = 1.5;\\n\\n};\\n\\ninherits(MouseWheelZoom, Interaction);\\n\\n\\n/**\\n * Handles the {@link module:ol/MapBrowserEvent map browser event} (if it was a\\n * mousewheel-event) and eventually zooms the map.\\n * @param {module:ol/MapBrowserEvent} mapBrowserEvent Map browser event.\\n * @return {boolean} Allow event propagation.\\n * @this {module:ol/interaction/MouseWheelZoom}\\n */\\nfunction handleEvent(mapBrowserEvent) {\\n  if (!this.condition_(mapBrowserEvent)) {\\n    return true;\\n  }\\n  const type = mapBrowserEvent.type;\\n  if (type !== EventType.WHEEL && type !== EventType.MOUSEWHEEL) {\\n    return true;\\n  }\\n\\n  mapBrowserEvent.preventDefault();\\n\\n  const map = mapBrowserEvent.map;\\n  const wheelEvent = /** @type {WheelEvent} */ (mapBrowserEvent.originalEvent);\\n\\n  if (this.useAnchor_) {\\n    this.lastAnchor_ = mapBrowserEvent.coordinate;\\n  }\\n\\n  // Delta normalisation inspired by\\n  // https://github.com/mapbox/mapbox-gl-js/blob/001c7b9/js/ui/handler/scroll_zoom.js\\n  let delta;\\n  if (mapBrowserEvent.type == EventType.WHEEL) {\\n    delta = wheelEvent.deltaY;\\n    if (FIREFOX &&\\n        wheelEvent.deltaMode === WheelEvent.DOM_DELTA_PIXEL) {\\n      delta /= DEVICE_PIXEL_RATIO;\\n    }\\n    if (wheelEvent.deltaMode === WheelEvent.DOM_DELTA_LINE) {\\n      delta *= 40;\\n    }\\n  } else if (mapBrowserEvent.type == EventType.MOUSEWHEEL) {\\n    delta = -wheelEvent.wheelDeltaY;\\n    if (SAFARI) {\\n      delta /= 3;\\n    }\\n  }\\n\\n  if (delta === 0) {\\n    return false;\\n  }\\n\\n  const now = Date.now();\\n\\n  if (this.startTime_ === undefined) {\\n    this.startTime_ = now;\\n  }\\n\\n  if (!this.mode_ || now - this.startTime_ > this.trackpadEventGap_) {\\n    this.mode_ = Math.abs(delta) < 4 ?\\n      Mode.TRACKPAD :\\n      Mode.WHEEL;\\n  }\\n\\n  if (this.mode_ === Mode.TRACKPAD) {\\n    const view = map.getView();\\n    if (this.trackpadTimeoutId_) {\\n      clearTimeout(this.trackpadTimeoutId_);\\n    } else {\\n      view.setHint(ViewHint.INTERACTING, 1);\\n    }\\n    this.trackpadTimeoutId_ = setTimeout(this.decrementInteractingHint_.bind(this), this.trackpadEventGap_);\\n    let resolution = view.getResolution() * Math.pow(2, delta / this.trackpadDeltaPerZoom_);\\n    const minResolution = view.getMinResolution();\\n    const maxResolution = view.getMaxResolution();\\n    let rebound = 0;\\n    if (resolution < minResolution) {\\n      resolution = Math.max(resolution, minResolution / this.trackpadZoomBuffer_);\\n      rebound = 1;\\n    } else if (resolution > maxResolution) {\\n      resolution = Math.min(resolution, maxResolution * this.trackpadZoomBuffer_);\\n      rebound = -1;\\n    }\\n    if (this.lastAnchor_) {\\n      const center = view.calculateCenterZoom(resolution, this.lastAnchor_);\\n      view.setCenter(view.constrainCenter(center));\\n    }\\n    view.setResolution(resolution);\\n\\n    if (rebound === 0 && this.constrainResolution_) {\\n      view.animate({\\n        resolution: view.constrainResolution(resolution, delta > 0 ? -1 : 1),\\n        easing: easeOut,\\n        anchor: this.lastAnchor_,\\n        duration: this.duration_\\n      });\\n    }\\n\\n    if (rebound > 0) {\\n      view.animate({\\n        resolution: minResolution,\\n        easing: easeOut,\\n        anchor: this.lastAnchor_,\\n        duration: 500\\n      });\\n    } else if (rebound < 0) {\\n      view.animate({\\n        resolution: maxResolution,\\n        easing: easeOut,\\n        anchor: this.lastAnchor_,\\n        duration: 500\\n      });\\n    }\\n    this.startTime_ = now;\\n    return false;\\n  }\\n\\n  this.delta_ += delta;\\n\\n  const timeLeft = Math.max(this.timeout_ - (now - this.startTime_), 0);\\n\\n  clearTimeout(this.timeoutId_);\\n  this.timeoutId_ = setTimeout(this.handleWheelZoom_.bind(this, map), timeLeft);\\n\\n  return false;\\n}\\n\\n\\n/**\\n * @private\\n */\\nMouseWheelZoom.prototype.decrementInteractingHint_ = function() {\\n  this.trackpadTimeoutId_ = undefined;\\n  const view = this.getMap().getView();\\n  view.setHint(ViewHint.INTERACTING, -1);\\n};\\n\\n\\n/**\\n * @private\\n * @param {module:ol/PluggableMap} map Map.\\n */\\nMouseWheelZoom.prototype.handleWheelZoom_ = function(map) {\\n  const view = map.getView();\\n  if (view.getAnimating()) {\\n    view.cancelAnimations();\\n  }\\n  const maxDelta = MAX_DELTA;\\n  const delta = clamp(this.delta_, -maxDelta, maxDelta);\\n  zoomByDelta(view, -delta, this.lastAnchor_, this.duration_);\\n  this.mode_ = undefined;\\n  this.delta_ = 0;\\n  this.lastAnchor_ = null;\\n  this.startTime_ = undefined;\\n  this.timeoutId_ = undefined;\\n};\\n\\n\\n/**\\n * Enable or disable using the mouse's location as an anchor when zooming\\n * @param {boolean} useAnchor true to zoom to the mouse's location, false\\n * to zoom to the center of the map\\n * @api\\n */\\nMouseWheelZoom.prototype.setMouseAnchor = function(useAnchor) {\\n  this.useAnchor_ = useAnchor;\\n  if (!useAnchor) {\\n    this.lastAnchor_ = null;\\n  }\\n};\\n\\n\\nexport default MouseWheelZoom;\\n\",\"/**\\n * @module ol/interaction/PinchRotate\\n */\\nimport {inherits} from '../index.js';\\nimport ViewHint from '../ViewHint.js';\\nimport {FALSE} from '../functions.js';\\nimport {rotate, rotateWithoutConstraints} from '../interaction/Interaction.js';\\nimport PointerInteraction, {centroid as centroidFromPointers} from '../interaction/Pointer.js';\\nimport {disable} from '../rotationconstraint.js';\\n\\n\\n/**\\n * @typedef {Object} Options\\n * @property {number} [duration=250] The duration of the animation in\\n * milliseconds.\\n * @property {number} [threshold=0.3] Minimal angle in radians to start a rotation.\\n */\\n\\n\\n/**\\n * @classdesc\\n * Allows the user to rotate the map by twisting with two fingers\\n * on a touch screen.\\n *\\n * @constructor\\n * @extends {module:ol/interaction/Pointer}\\n * @param {module:ol/interaction/PinchRotate~Options=} opt_options Options.\\n * @api\\n */\\nconst PinchRotate = function(opt_options) {\\n\\n  PointerInteraction.call(this, {\\n    handleDownEvent: handleDownEvent,\\n    handleDragEvent: handleDragEvent,\\n    handleUpEvent: handleUpEvent\\n  });\\n\\n  const options = opt_options || {};\\n\\n  /**\\n   * @private\\n   * @type {module:ol/coordinate~Coordinate}\\n   */\\n  this.anchor_ = null;\\n\\n  /**\\n   * @private\\n   * @type {number|undefined}\\n   */\\n  this.lastAngle_ = undefined;\\n\\n  /**\\n   * @private\\n   * @type {boolean}\\n   */\\n  this.rotating_ = false;\\n\\n  /**\\n   * @private\\n   * @type {number}\\n   */\\n  this.rotationDelta_ = 0.0;\\n\\n  /**\\n   * @private\\n   * @type {number}\\n   */\\n  this.threshold_ = options.threshold !== undefined ? options.threshold : 0.3;\\n\\n  /**\\n   * @private\\n   * @type {number}\\n   */\\n  this.duration_ = options.duration !== undefined ? options.duration : 250;\\n\\n};\\n\\ninherits(PinchRotate, PointerInteraction);\\n\\n\\n/**\\n * @param {module:ol/MapBrowserPointerEvent} mapBrowserEvent Event.\\n * @this {module:ol/interaction/PinchRotate}\\n */\\nfunction handleDragEvent(mapBrowserEvent) {\\n  let rotationDelta = 0.0;\\n\\n  const touch0 = this.targetPointers[0];\\n  const touch1 = this.targetPointers[1];\\n\\n  // angle between touches\\n  const angle = Math.atan2(\\n    touch1.clientY - touch0.clientY,\\n    touch1.clientX - touch0.clientX);\\n\\n  if (this.lastAngle_ !== undefined) {\\n    const delta = angle - this.lastAngle_;\\n    this.rotationDelta_ += delta;\\n    if (!this.rotating_ &&\\n        Math.abs(this.rotationDelta_) > this.threshold_) {\\n      this.rotating_ = true;\\n    }\\n    rotationDelta = delta;\\n  }\\n  this.lastAngle_ = angle;\\n\\n  const map = mapBrowserEvent.map;\\n  const view = map.getView();\\n  if (view.getConstraints().rotation === disable) {\\n    return;\\n  }\\n\\n  // rotate anchor point.\\n  // FIXME: should be the intersection point between the lines:\\n  //     touch0,touch1 and previousTouch0,previousTouch1\\n  const viewportPosition = map.getViewport().getBoundingClientRect();\\n  const centroid = centroidFromPointers(this.targetPointers);\\n  centroid[0] -= viewportPosition.left;\\n  centroid[1] -= viewportPosition.top;\\n  this.anchor_ = map.getCoordinateFromPixel(centroid);\\n\\n  // rotate\\n  if (this.rotating_) {\\n    const rotation = view.getRotation();\\n    map.render();\\n    rotateWithoutConstraints(view, rotation + rotationDelta, this.anchor_);\\n  }\\n}\\n\\n\\n/**\\n * @param {module:ol/MapBrowserPointerEvent} mapBrowserEvent Event.\\n * @return {boolean} Stop drag sequence?\\n * @this {module:ol/interaction/PinchRotate}\\n */\\nfunction handleUpEvent(mapBrowserEvent) {\\n  if (this.targetPointers.length < 2) {\\n    const map = mapBrowserEvent.map;\\n    const view = map.getView();\\n    view.setHint(ViewHint.INTERACTING, -1);\\n    if (this.rotating_) {\\n      const rotation = view.getRotation();\\n      rotate(view, rotation, this.anchor_, this.duration_);\\n    }\\n    return false;\\n  } else {\\n    return true;\\n  }\\n}\\n\\n\\n/**\\n * @param {module:ol/MapBrowserPointerEvent} mapBrowserEvent Event.\\n * @return {boolean} Start drag sequence?\\n * @this {module:ol/interaction/PinchRotate}\\n */\\nfunction handleDownEvent(mapBrowserEvent) {\\n  if (this.targetPointers.length >= 2) {\\n    const map = mapBrowserEvent.map;\\n    this.anchor_ = null;\\n    this.lastAngle_ = undefined;\\n    this.rotating_ = false;\\n    this.rotationDelta_ = 0.0;\\n    if (!this.handlingDownUpSequence) {\\n      map.getView().setHint(ViewHint.INTERACTING, 1);\\n    }\\n    return true;\\n  } else {\\n    return false;\\n  }\\n}\\n\\n\\n/**\\n * @inheritDoc\\n */\\nPinchRotate.prototype.shouldStopEvent = FALSE;\\n\\nexport default PinchRotate;\\n\",\"/**\\n * @module ol/interaction/PinchZoom\\n */\\nimport {inherits} from '../index.js';\\nimport ViewHint from '../ViewHint.js';\\nimport {FALSE} from '../functions.js';\\nimport {zoom, zoomWithoutConstraints} from '../interaction/Interaction.js';\\nimport PointerInteraction, {centroid as centroidFromPointers} from '../interaction/Pointer.js';\\n\\n\\n/**\\n * @typedef {Object} Options\\n * @property {number} [duration=400] Animation duration in milliseconds.\\n * @property {boolean} [constrainResolution=false] Zoom to the closest integer\\n * zoom level after the pinch gesture ends.\\n */\\n\\n\\n/**\\n * @classdesc\\n * Allows the user to zoom the map by pinching with two fingers\\n * on a touch screen.\\n *\\n * @constructor\\n * @extends {module:ol/interaction/Pointer}\\n * @param {module:ol/interaction/PinchZoom~Options=} opt_options Options.\\n * @api\\n */\\nconst PinchZoom = function(opt_options) {\\n\\n  PointerInteraction.call(this, {\\n    handleDownEvent: handleDownEvent,\\n    handleDragEvent: handleDragEvent,\\n    handleUpEvent: handleUpEvent\\n  });\\n\\n  const options = opt_options ? opt_options : {};\\n\\n  /**\\n   * @private\\n   * @type {boolean}\\n   */\\n  this.constrainResolution_ = options.constrainResolution || false;\\n\\n  /**\\n   * @private\\n   * @type {module:ol/coordinate~Coordinate}\\n   */\\n  this.anchor_ = null;\\n\\n  /**\\n   * @private\\n   * @type {number}\\n   */\\n  this.duration_ = options.duration !== undefined ? options.duration : 400;\\n\\n  /**\\n   * @private\\n   * @type {number|undefined}\\n   */\\n  this.lastDistance_ = undefined;\\n\\n  /**\\n   * @private\\n   * @type {number}\\n   */\\n  this.lastScaleDelta_ = 1;\\n\\n};\\n\\ninherits(PinchZoom, PointerInteraction);\\n\\n\\n/**\\n * @param {module:ol/MapBrowserPointerEvent} mapBrowserEvent Event.\\n * @this {module:ol/interaction/PinchZoom}\\n */\\nfunction handleDragEvent(mapBrowserEvent) {\\n  let scaleDelta = 1.0;\\n\\n  const touch0 = this.targetPointers[0];\\n  const touch1 = this.targetPointers[1];\\n  const dx = touch0.clientX - touch1.clientX;\\n  const dy = touch0.clientY - touch1.clientY;\\n\\n  // distance between touches\\n  const distance = Math.sqrt(dx * dx + dy * dy);\\n\\n  if (this.lastDistance_ !== undefined) {\\n    scaleDelta = this.lastDistance_ / distance;\\n  }\\n  this.lastDistance_ = distance;\\n\\n\\n  const map = mapBrowserEvent.map;\\n  const view = map.getView();\\n  const resolution = view.getResolution();\\n  const maxResolution = view.getMaxResolution();\\n  const minResolution = view.getMinResolution();\\n  let newResolution = resolution * scaleDelta;\\n  if (newResolution > maxResolution) {\\n    scaleDelta = maxResolution / resolution;\\n    newResolution = maxResolution;\\n  } else if (newResolution < minResolution) {\\n    scaleDelta = minResolution / resolution;\\n    newResolution = minResolution;\\n  }\\n\\n  if (scaleDelta != 1.0) {\\n    this.lastScaleDelta_ = scaleDelta;\\n  }\\n\\n  // scale anchor point.\\n  const viewportPosition = map.getViewport().getBoundingClientRect();\\n  const centroid = centroidFromPointers(this.targetPointers);\\n  centroid[0] -= viewportPosition.left;\\n  centroid[1] -= viewportPosition.top;\\n  this.anchor_ = map.getCoordinateFromPixel(centroid);\\n\\n  // scale, bypass the resolution constraint\\n  map.render();\\n  zoomWithoutConstraints(view, newResolution, this.anchor_);\\n}\\n\\n\\n/**\\n * @param {module:ol/MapBrowserPointerEvent} mapBrowserEvent Event.\\n * @return {boolean} Stop drag sequence?\\n * @this {module:ol/interaction/PinchZoom}\\n */\\nfunction handleUpEvent(mapBrowserEvent) {\\n  if (this.targetPointers.length < 2) {\\n    const map = mapBrowserEvent.map;\\n    const view = map.getView();\\n    view.setHint(ViewHint.INTERACTING, -1);\\n    const resolution = view.getResolution();\\n    if (this.constrainResolution_ ||\\n        resolution < view.getMinResolution() ||\\n        resolution > view.getMaxResolution()) {\\n      // Zoom to final resolution, with an animation, and provide a\\n      // direction not to zoom out/in if user was pinching in/out.\\n      // Direction is > 0 if pinching out, and < 0 if pinching in.\\n      const direction = this.lastScaleDelta_ - 1;\\n      zoom(view, resolution, this.anchor_, this.duration_, direction);\\n    }\\n    return false;\\n  } else {\\n    return true;\\n  }\\n}\\n\\n\\n/**\\n * @param {module:ol/MapBrowserPointerEvent} mapBrowserEvent Event.\\n * @return {boolean} Start drag sequence?\\n * @this {module:ol/interaction/PinchZoom}\\n */\\nfunction handleDownEvent(mapBrowserEvent) {\\n  if (this.targetPointers.length >= 2) {\\n    const map = mapBrowserEvent.map;\\n    this.anchor_ = null;\\n    this.lastDistance_ = undefined;\\n    this.lastScaleDelta_ = 1;\\n    if (!this.handlingDownUpSequence) {\\n      map.getView().setHint(ViewHint.INTERACTING, 1);\\n    }\\n    return true;\\n  } else {\\n    return false;\\n  }\\n}\\n\\n\\n/**\\n * @inheritDoc\\n */\\nPinchZoom.prototype.shouldStopEvent = FALSE;\\nexport default PinchZoom;\\n\",\"/**\\n * @module ol/interaction/DragAndDrop\\n */\\n// FIXME should handle all geo-referenced data, not just vector data\\n\\nimport {inherits} from '../index.js';\\nimport {TRUE} from '../functions.js';\\nimport {listen, unlistenByKey} from '../events.js';\\nimport Event from '../events/Event.js';\\nimport EventType from '../events/EventType.js';\\nimport Interaction from '../interaction/Interaction.js';\\nimport {get as getProjection} from '../proj.js';\\n\\n\\n/**\\n * @typedef {Object} Options\\n * @property {Array.<function(new: module:ol/format/Feature)>} [formatConstructors] Format constructors.\\n * @property {module:ol/source/Vector} [source] Optional vector source where features will be added.  If a source is provided\\n * all existing features will be removed and new features will be added when\\n * they are dropped on the target.  If you want to add features to a vector\\n * source without removing the existing features (append only), instead of\\n * providing the source option listen for the \\\"addfeatures\\\" event.\\n * @property {module:ol/proj~ProjectionLike} [projection] Target projection. By default, the map's view's projection is used.\\n * @property {Element} [target] The element that is used as the drop target, default is the viewport element.\\n */\\n\\n\\n/**\\n * @enum {string}\\n */\\nconst DragAndDropEventType = {\\n  /**\\n   * Triggered when features are added\\n   * @event module:ol/interaction/DragAndDrop~DragAndDropEvent#addfeatures\\n   * @api\\n   */\\n  ADD_FEATURES: 'addfeatures'\\n};\\n\\n\\n/**\\n * @classdesc\\n * Events emitted by {@link module:ol/interaction/DragAndDrop~DragAndDrop} instances are instances\\n * of this type.\\n *\\n * @constructor\\n * @extends {module:ol/events/Event}\\n * @param {module:ol/interaction/DragAndDrop~DragAndDropEventType} type Type.\\n * @param {File} file File.\\n * @param {Array.<module:ol/Feature>=} opt_features Features.\\n * @param {module:ol/proj/Projection=} opt_projection Projection.\\n */\\nconst DragAndDropEvent = function(type, file, opt_features, opt_projection) {\\n\\n  Event.call(this, type);\\n\\n  /**\\n   * The features parsed from dropped data.\\n   * @type {Array.<module:ol/Feature>|undefined}\\n   * @api\\n   */\\n  this.features = opt_features;\\n\\n  /**\\n   * The dropped file.\\n   * @type {File}\\n   * @api\\n   */\\n  this.file = file;\\n\\n  /**\\n   * The feature projection.\\n   * @type {module:ol/proj/Projection|undefined}\\n   * @api\\n   */\\n  this.projection = opt_projection;\\n\\n};\\ninherits(DragAndDropEvent, Event);\\n\\n\\n/**\\n * @classdesc\\n * Handles input of vector data by drag and drop.\\n *\\n * @constructor\\n * @extends {module:ol/interaction/Interaction}\\n * @fires module:ol/interaction/DragAndDrop~DragAndDropEvent\\n * @param {module:ol/interaction/DragAndDrop~Options=} opt_options Options.\\n * @api\\n */\\nconst DragAndDrop = function(opt_options) {\\n\\n  const options = opt_options ? opt_options : {};\\n\\n  Interaction.call(this, {\\n    handleEvent: TRUE\\n  });\\n\\n  /**\\n   * @private\\n   * @type {Array.<function(new: module:ol/format/Feature)>}\\n   */\\n  this.formatConstructors_ = options.formatConstructors ?\\n    options.formatConstructors : [];\\n\\n  /**\\n   * @private\\n   * @type {module:ol/proj/Projection}\\n   */\\n  this.projection_ = options.projection ?\\n    getProjection(options.projection) : null;\\n\\n  /**\\n   * @private\\n   * @type {Array.<module:ol/events~EventsKey>}\\n   */\\n  this.dropListenKeys_ = null;\\n\\n  /**\\n   * @private\\n   * @type {module:ol/source/Vector}\\n   */\\n  this.source_ = options.source || null;\\n\\n  /**\\n   * @private\\n   * @type {Element}\\n   */\\n  this.target = options.target ? options.target : null;\\n\\n};\\n\\ninherits(DragAndDrop, Interaction);\\n\\n\\n/**\\n * @param {DragEvent} event Event.\\n * @this {module:ol/interaction/DragAndDrop}\\n */\\nfunction handleDrop(event) {\\n  const files = event.dataTransfer.files;\\n  for (let i = 0, ii = files.length; i < ii; ++i) {\\n    const file = files.item(i);\\n    const reader = new FileReader();\\n    reader.addEventListener(EventType.LOAD, this.handleResult_.bind(this, file));\\n    reader.readAsText(file);\\n  }\\n}\\n\\n\\n/**\\n * @param {DragEvent} event Event.\\n */\\nfunction handleStop(event) {\\n  event.stopPropagation();\\n  event.preventDefault();\\n  event.dataTransfer.dropEffect = 'copy';\\n}\\n\\n\\n/**\\n * @param {File} file File.\\n * @param {Event} event Load event.\\n * @private\\n */\\nDragAndDrop.prototype.handleResult_ = function(file, event) {\\n  const result = event.target.result;\\n  const map = this.getMap();\\n  let projection = this.projection_;\\n  if (!projection) {\\n    const view = map.getView();\\n    projection = view.getProjection();\\n  }\\n\\n  const formatConstructors = this.formatConstructors_;\\n  let features = [];\\n  for (let i = 0, ii = formatConstructors.length; i < ii; ++i) {\\n    /**\\n     * Avoid \\\"cannot instantiate abstract class\\\" error.\\n     * @type {Function}\\n     */\\n    const formatConstructor = formatConstructors[i];\\n    /**\\n     * @type {module:ol/format/Feature}\\n     */\\n    const format = new formatConstructor();\\n    features = this.tryReadFeatures_(format, result, {\\n      featureProjection: projection\\n    });\\n    if (features && features.length > 0) {\\n      break;\\n    }\\n  }\\n  if (this.source_) {\\n    this.source_.clear();\\n    this.source_.addFeatures(features);\\n  }\\n  this.dispatchEvent(\\n    new DragAndDropEvent(\\n      DragAndDropEventType.ADD_FEATURES, file,\\n      features, projection));\\n};\\n\\n\\n/**\\n * @private\\n */\\nDragAndDrop.prototype.registerListeners_ = function() {\\n  const map = this.getMap();\\n  if (map) {\\n    const dropArea = this.target ? this.target : map.getViewport();\\n    this.dropListenKeys_ = [\\n      listen(dropArea, EventType.DROP, handleDrop, this),\\n      listen(dropArea, EventType.DRAGENTER, handleStop, this),\\n      listen(dropArea, EventType.DRAGOVER, handleStop, this),\\n      listen(dropArea, EventType.DROP, handleStop, this)\\n    ];\\n  }\\n};\\n\\n\\n/**\\n * @inheritDoc\\n */\\nDragAndDrop.prototype.setActive = function(active) {\\n  Interaction.prototype.setActive.call(this, active);\\n  if (active) {\\n    this.registerListeners_();\\n  } else {\\n    this.unregisterListeners_();\\n  }\\n};\\n\\n\\n/**\\n * @inheritDoc\\n */\\nDragAndDrop.prototype.setMap = function(map) {\\n  this.unregisterListeners_();\\n  Interaction.prototype.setMap.call(this, map);\\n  if (this.getActive()) {\\n    this.registerListeners_();\\n  }\\n};\\n\\n\\n/**\\n * @param {module:ol/format/Feature} format Format.\\n * @param {string} text Text.\\n * @param {module:ol/format/Feature~ReadOptions} options Read options.\\n * @private\\n * @return {Array.<module:ol/Feature>} Features.\\n */\\nDragAndDrop.prototype.tryReadFeatures_ = function(format, text, options) {\\n  try {\\n    return format.readFeatures(text, options);\\n  } catch (e) {\\n    return null;\\n  }\\n};\\n\\n\\n/**\\n * @private\\n */\\nDragAndDrop.prototype.unregisterListeners_ = function() {\\n  if (this.dropListenKeys_) {\\n    this.dropListenKeys_.forEach(unlistenByKey);\\n    this.dropListenKeys_ = null;\\n  }\\n};\\n\\n\\nexport default DragAndDrop;\\n\",\"/**\\n * @module ol/interaction/DragRotateAndZoom\\n */\\nimport {inherits} from '../index.js';\\nimport {disable} from '../rotationconstraint.js';\\nimport ViewHint from '../ViewHint.js';\\nimport {shiftKeyOnly, mouseOnly} from '../events/condition.js';\\nimport {rotate, rotateWithoutConstraints, zoom, zoomWithoutConstraints} from '../interaction/Interaction.js';\\nimport PointerInteraction from '../interaction/Pointer.js';\\n\\n\\n/**\\n * @typedef {Object} Options\\n * @property {module:ol/events/condition~Condition} [condition] A function that\\n * takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a\\n * boolean to indicate whether that event should be handled.\\n * Default is {@link module:ol/events/condition~shiftKeyOnly}.\\n * @property {number} [duration=400] Animation duration in milliseconds.\\n */\\n\\n\\n/**\\n * @classdesc\\n * Allows the user to zoom and rotate the map by clicking and dragging\\n * on the map.  By default, this interaction is limited to when the shift\\n * key is held down.\\n *\\n * This interaction is only supported for mouse devices.\\n *\\n * And this interaction is not included in the default interactions.\\n *\\n * @constructor\\n * @extends {module:ol/interaction/Pointer}\\n * @param {module:ol/interaction/DragRotateAndZoom~Options=} opt_options Options.\\n * @api\\n */\\nconst DragRotateAndZoom = function(opt_options) {\\n\\n  const options = opt_options ? opt_options : {};\\n\\n  PointerInteraction.call(this, {\\n    handleDownEvent: handleDownEvent,\\n    handleDragEvent: handleDragEvent,\\n    handleUpEvent: handleUpEvent\\n  });\\n\\n  /**\\n   * @private\\n   * @type {module:ol/events/condition~Condition}\\n   */\\n  this.condition_ = options.condition ? options.condition : shiftKeyOnly;\\n\\n  /**\\n   * @private\\n   * @type {number|undefined}\\n   */\\n  this.lastAngle_ = undefined;\\n\\n  /**\\n   * @private\\n   * @type {number|undefined}\\n   */\\n  this.lastMagnitude_ = undefined;\\n\\n  /**\\n   * @private\\n   * @type {number}\\n   */\\n  this.lastScaleDelta_ = 0;\\n\\n  /**\\n   * @private\\n   * @type {number}\\n   */\\n  this.duration_ = options.duration !== undefined ? options.duration : 400;\\n\\n};\\n\\ninherits(DragRotateAndZoom, PointerInteraction);\\n\\n\\n/**\\n * @param {module:ol/MapBrowserPointerEvent} mapBrowserEvent Event.\\n * @this {module:ol/interaction/DragRotateAndZoom}\\n */\\nfunction handleDragEvent(mapBrowserEvent) {\\n  if (!mouseOnly(mapBrowserEvent)) {\\n    return;\\n  }\\n\\n  const map = mapBrowserEvent.map;\\n  const size = map.getSize();\\n  const offset = mapBrowserEvent.pixel;\\n  const deltaX = offset[0] - size[0] / 2;\\n  const deltaY = size[1] / 2 - offset[1];\\n  const theta = Math.atan2(deltaY, deltaX);\\n  const magnitude = Math.sqrt(deltaX * deltaX + deltaY * deltaY);\\n  const view = map.getView();\\n  if (view.getConstraints().rotation !== disable && this.lastAngle_ !== undefined) {\\n    const angleDelta = theta - this.lastAngle_;\\n    rotateWithoutConstraints(view, view.getRotation() - angleDelta);\\n  }\\n  this.lastAngle_ = theta;\\n  if (this.lastMagnitude_ !== undefined) {\\n    const resolution = this.lastMagnitude_ * (view.getResolution() / magnitude);\\n    zoomWithoutConstraints(view, resolution);\\n  }\\n  if (this.lastMagnitude_ !== undefined) {\\n    this.lastScaleDelta_ = this.lastMagnitude_ / magnitude;\\n  }\\n  this.lastMagnitude_ = magnitude;\\n}\\n\\n\\n/**\\n * @param {module:ol/MapBrowserPointerEvent} mapBrowserEvent Event.\\n * @return {boolean} Stop drag sequence?\\n * @this {module:ol/interaction/DragRotateAndZoom}\\n */\\nfunction handleUpEvent(mapBrowserEvent) {\\n  if (!mouseOnly(mapBrowserEvent)) {\\n    return true;\\n  }\\n\\n  const map = mapBrowserEvent.map;\\n  const view = map.getView();\\n  view.setHint(ViewHint.INTERACTING, -1);\\n  const direction = this.lastScaleDelta_ - 1;\\n  rotate(view, view.getRotation());\\n  zoom(view, view.getResolution(), undefined, this.duration_, direction);\\n  this.lastScaleDelta_ = 0;\\n  return false;\\n}\\n\\n\\n/**\\n * @param {module:ol/MapBrowserPointerEvent} mapBrowserEvent Event.\\n * @return {boolean} Start drag sequence?\\n * @this {module:ol/interaction/DragRotateAndZoom}\\n */\\nfunction handleDownEvent(mapBrowserEvent) {\\n  if (!mouseOnly(mapBrowserEvent)) {\\n    return false;\\n  }\\n\\n  if (this.condition_(mapBrowserEvent)) {\\n    mapBrowserEvent.map.getView().setHint(ViewHint.INTERACTING, 1);\\n    this.lastAngle_ = undefined;\\n    this.lastMagnitude_ = undefined;\\n    return true;\\n  } else {\\n    return false;\\n  }\\n}\\n\\nexport default DragRotateAndZoom;\\n\",\"/**\\n * @module ol/geom/Circle\\n */\\nimport {inherits} from '../index.js';\\nimport {createOrUpdate, forEachCorner, intersects} from '../extent.js';\\nimport GeometryLayout from '../geom/GeometryLayout.js';\\nimport GeometryType from '../geom/GeometryType.js';\\nimport SimpleGeometry from '../geom/SimpleGeometry.js';\\nimport {deflateCoordinate} from '../geom/flat/deflate.js';\\n\\n/**\\n * @classdesc\\n * Circle geometry.\\n *\\n * @constructor\\n * @extends {module:ol/geom/SimpleGeometry}\\n * @param {module:ol/coordinate~Coordinate} center Center.\\n * @param {number=} opt_radius Radius.\\n * @param {module:ol/geom/GeometryLayout=} opt_layout Layout.\\n * @api\\n */\\nconst Circle = function(center, opt_radius, opt_layout) {\\n  SimpleGeometry.call(this);\\n  const radius = opt_radius ? opt_radius : 0;\\n  this.setCenterAndRadius(center, radius, opt_layout);\\n};\\n\\ninherits(Circle, SimpleGeometry);\\n\\n\\n/**\\n * Make a complete copy of the geometry.\\n * @return {!module:ol/geom/Circle} Clone.\\n * @override\\n * @api\\n */\\nCircle.prototype.clone = function() {\\n  const circle = new Circle(null);\\n  circle.setFlatCoordinates(this.layout, this.flatCoordinates.slice());\\n  return circle;\\n};\\n\\n\\n/**\\n * @inheritDoc\\n */\\nCircle.prototype.closestPointXY = function(x, y, closestPoint, minSquaredDistance) {\\n  const flatCoordinates = this.flatCoordinates;\\n  const dx = x - flatCoordinates[0];\\n  const dy = y - flatCoordinates[1];\\n  const squaredDistance = dx * dx + dy * dy;\\n  if (squaredDistance < minSquaredDistance) {\\n    if (squaredDistance === 0) {\\n      for (let i = 0; i < this.stride; ++i) {\\n        closestPoint[i] = flatCoordinates[i];\\n      }\\n    } else {\\n      const delta = this.getRadius() / Math.sqrt(squaredDistance);\\n      closestPoint[0] = flatCoordinates[0] + delta * dx;\\n      closestPoint[1] = flatCoordinates[1] + delta * dy;\\n      for (let i = 2; i < this.stride; ++i) {\\n        closestPoint[i] = flatCoordinates[i];\\n      }\\n    }\\n    closestPoint.length = this.stride;\\n    return squaredDistance;\\n  } else {\\n    return minSquaredDistance;\\n  }\\n};\\n\\n\\n/**\\n * @inheritDoc\\n */\\nCircle.prototype.containsXY = function(x, y) {\\n  const flatCoordinates = this.flatCoordinates;\\n  const dx = x - flatCoordinates[0];\\n  const dy = y - flatCoordinates[1];\\n  return dx * dx + dy * dy <= this.getRadiusSquared_();\\n};\\n\\n\\n/**\\n * Return the center of the circle as {@link module:ol/coordinate~Coordinate coordinate}.\\n * @return {module:ol/coordinate~Coordinate} Center.\\n * @api\\n */\\nCircle.prototype.getCenter = function() {\\n  return this.flatCoordinates.slice(0, this.stride);\\n};\\n\\n\\n/**\\n * @inheritDoc\\n */\\nCircle.prototype.computeExtent = function(extent) {\\n  const flatCoordinates = this.flatCoordinates;\\n  const radius = flatCoordinates[this.stride] - flatCoordinates[0];\\n  return createOrUpdate(\\n    flatCoordinates[0] - radius, flatCoordinates[1] - radius,\\n    flatCoordinates[0] + radius, flatCoordinates[1] + radius,\\n    extent);\\n};\\n\\n\\n/**\\n * Return the radius of the circle.\\n * @return {number} Radius.\\n * @api\\n */\\nCircle.prototype.getRadius = function() {\\n  return Math.sqrt(this.getRadiusSquared_());\\n};\\n\\n\\n/**\\n * @private\\n * @return {number} Radius squared.\\n */\\nCircle.prototype.getRadiusSquared_ = function() {\\n  const dx = this.flatCoordinates[this.stride] - this.flatCoordinates[0];\\n  const dy = this.flatCoordinates[this.stride + 1] - this.flatCoordinates[1];\\n  return dx * dx + dy * dy;\\n};\\n\\n\\n/**\\n * @inheritDoc\\n * @api\\n */\\nCircle.prototype.getType = function() {\\n  return GeometryType.CIRCLE;\\n};\\n\\n\\n/**\\n * @inheritDoc\\n * @api\\n */\\nCircle.prototype.intersectsExtent = function(extent) {\\n  const circleExtent = this.getExtent();\\n  if (intersects(extent, circleExtent)) {\\n    const center = this.getCenter();\\n\\n    if (extent[0] <= center[0] && extent[2] >= center[0]) {\\n      return true;\\n    }\\n    if (extent[1] <= center[1] && extent[3] >= center[1]) {\\n      return true;\\n    }\\n\\n    return forEachCorner(extent, this.intersectsCoordinate, this);\\n  }\\n  return false;\\n\\n};\\n\\n\\n/**\\n * Set the center of the circle as {@link module:ol/coordinate~Coordinate coordinate}.\\n * @param {module:ol/coordinate~Coordinate} center Center.\\n * @api\\n */\\nCircle.prototype.setCenter = function(center) {\\n  const stride = this.stride;\\n  const radius = this.flatCoordinates[stride] - this.flatCoordinates[0];\\n  const flatCoordinates = center.slice();\\n  flatCoordinates[stride] = flatCoordinates[0] + radius;\\n  for (let i = 1; i < stride; ++i) {\\n    flatCoordinates[stride + i] = center[i];\\n  }\\n  this.setFlatCoordinates(this.layout, flatCoordinates);\\n};\\n\\n\\n/**\\n * Set the center (as {@link module:ol/coordinate~Coordinate coordinate}) and the radius (as\\n * number) of the circle.\\n * @param {module:ol/coordinate~Coordinate} center Center.\\n * @param {number} radius Radius.\\n * @param {module:ol/geom/GeometryLayout=} opt_layout Layout.\\n * @api\\n */\\nCircle.prototype.setCenterAndRadius = function(center, radius, opt_layout) {\\n  if (!center) {\\n    this.setFlatCoordinates(GeometryLayout.XY, null);\\n  } else {\\n    this.setLayout(opt_layout, center, 0);\\n    if (!this.flatCoordinates) {\\n      this.flatCoordinates = [];\\n    }\\n    /** @type {Array.<number>} */\\n    const flatCoordinates = this.flatCoordinates;\\n    let offset = deflateCoordinate(\\n      flatCoordinates, 0, center, this.stride);\\n    flatCoordinates[offset++] = flatCoordinates[0] + radius;\\n    for (let i = 1, ii = this.stride; i < ii; ++i) {\\n      flatCoordinates[offset++] = flatCoordinates[i];\\n    }\\n    flatCoordinates.length = offset;\\n    this.changed();\\n  }\\n};\\n\\n\\n/**\\n * @inheritDoc\\n */\\nCircle.prototype.getCoordinates = function() {};\\n\\n\\n/**\\n * @inheritDoc\\n */\\nCircle.prototype.setCoordinates = function(coordinates, opt_layout) {};\\n\\n\\n/**\\n * @param {module:ol/geom/GeometryLayout} layout Layout.\\n * @param {Array.<number>} flatCoordinates Flat coordinates.\\n */\\nCircle.prototype.setFlatCoordinates = function(layout, flatCoordinates) {\\n  this.setFlatCoordinatesInternal(layout, flatCoordinates);\\n  this.changed();\\n};\\n\\n\\n/**\\n * Set the radius of the circle. The radius is in the units of the projection.\\n * @param {number} radius Radius.\\n * @api\\n */\\nCircle.prototype.setRadius = function(radius) {\\n  this.flatCoordinates[this.stride] = this.flatCoordinates[0] + radius;\\n  this.changed();\\n};\\n\\n\\n/**\\n * Transform each coordinate of the circle from one coordinate reference system\\n * to another. The geometry is modified in place.\\n * If you do not want the geometry modified in place, first clone() it and\\n * then use this function on the clone.\\n *\\n * Internally a circle is currently represented by two points: the center of\\n * the circle `[cx, cy]`, and the point to the right of the circle\\n * `[cx + r, cy]`. This `transform` function just transforms these two points.\\n * So the resulting geometry is also a circle, and that circle does not\\n * correspond to the shape that would be obtained by transforming every point\\n * of the original circle.\\n *\\n * @param {module:ol/proj~ProjectionLike} source The current projection.  Can be a\\n *     string identifier or a {@link module:ol/proj/Projection~Projection} object.\\n * @param {module:ol/proj~ProjectionLike} destination The desired projection.  Can be a\\n *     string identifier or a {@link module:ol/proj/Projection~Projection} object.\\n * @return {module:ol/geom/Circle} This geometry.  Note that original geometry is\\n *     modified in place.\\n * @function\\n * @api\\n */\\nCircle.prototype.transform;\\nexport default Circle;\\n\",\"/**\\n * @module ol/LayerType\\n */\\n\\n/**\\n * A layer type used when creating layer renderers.\\n * @enum {string}\\n */\\nexport default {\\n  IMAGE: 'IMAGE',\\n  TILE: 'TILE',\\n  VECTOR_TILE: 'VECTOR_TILE',\\n  VECTOR: 'VECTOR'\\n};\\n\",\"/**\\n * @module ol/layer/VectorRenderType\\n */\\n\\n/**\\n * @enum {string}\\n * Render mode for vector layers:\\n *  * `'image'`: Vector layers are rendered as images. Great performance, but\\n *    point symbols and texts are always rotated with the view and pixels are\\n *    scaled during zoom animations.\\n *  * `'vector'`: Vector layers are rendered as vectors. Most accurate rendering\\n *    even during animations, but slower performance.\\n * @api\\n */\\nexport default {\\n  IMAGE: 'image',\\n  VECTOR: 'vector'\\n};\\n\",\"/**\\n * @module ol/layer/Vector\\n */\\nimport {inherits} from '../index.js';\\nimport LayerType from '../LayerType.js';\\nimport Layer from '../layer/Layer.js';\\nimport VectorRenderType from '../layer/VectorRenderType.js';\\nimport {assign} from '../obj.js';\\nimport {createDefaultStyle, toFunction as toStyleFunction} from '../style/Style.js';\\n\\n\\n/**\\n * @typedef {Object} Options\\n * @property {number} [opacity=1] Opacity (0, 1).\\n * @property {boolean} [visible=true] Visibility.\\n * @property {module:ol/extent~Extent} [extent] The bounding extent for layer rendering.  The layer will not be\\n * rendered outside of this extent.\\n * @property {number} [zIndex=0] The z-index for layer rendering.  At rendering time, the layers\\n * will be ordered, first by Z-index and then by position.\\n * @property {number} [minResolution] The minimum resolution (inclusive) at which this layer will be\\n * visible.\\n * @property {number} [maxResolution] The maximum resolution (exclusive) below which this layer will\\n * be visible.\\n * @property {module:ol/render~OrderFunction} [renderOrder] Render order. Function to be used when sorting\\n * features before rendering. By default features are drawn in the order that they are created. Use\\n * `null` to avoid the sort, but get an undefined draw order.\\n * @property {number} [renderBuffer=100] The buffer in pixels around the viewport extent used by the\\n * renderer when getting features from the vector source for the rendering or hit-detection.\\n * Recommended value: the size of the largest symbol, line width or label.\\n * @property {module:ol/layer/VectorRenderType|string} [renderMode='vector'] Render mode for vector layers:\\n *  * `'image'`: Vector layers are rendered as images. Great performance, but point symbols and\\n *    texts are always rotated with the view and pixels are scaled during zoom animations.\\n *  * `'vector'`: Vector layers are rendered as vectors. Most accurate rendering even during\\n *    animations, but slower performance.\\n * @property {module:ol/source/Vector} [source] Source.\\n * @property {module:ol/PluggableMap} [map] Sets the layer as overlay on a map. The map will not manage\\n * this layer in its layers collection, and the layer will be rendered on top. This is useful for\\n * temporary layers. The standard way to add a layer to a map and have it managed by the map is to\\n * use {@link module:ol/Map#addLayer}.\\n * @property {boolean} [declutter=false] Declutter images and text. Decluttering is applied to all\\n * image and text styles, and the priority is defined by the z-index of the style. Lower z-index\\n * means higher priority.\\n * @property {module:ol/style/Style|Array.<module:ol/style/Style>|module:ol/style/Style~StyleFunction} [style] Layer style. See\\n * {@link module:ol/style} for default style which will be used if this is not defined.\\n * @property {number} [maxTilesLoading=16] Maximum number tiles to load simultaneously.\\n * @property {boolean} [updateWhileAnimating=false] When set to `true` and `renderMode`\\n * is `vector`, feature batches will be recreated during animations. This means that no\\n * vectors will be shown clipped, but the setting will have a performance impact for large\\n * amounts of vector data. When set to `false`, batches will be recreated when no animation\\n * is active.\\n * @property {boolean} [updateWhileInteracting=false] When set to `true` and `renderMode`\\n * is `vector`, feature batches will be recreated during interactions. See also\\n * `updateWhileAnimating`.\\n */\\n\\n\\n/**\\n * @enum {string}\\n * Render mode for vector layers:\\n *  * `'image'`: Vector layers are rendered as images. Great performance, but\\n *    point symbols and texts are always rotated with the view and pixels are\\n *    scaled during zoom animations.\\n *  * `'vector'`: Vector layers are rendered as vectors. Most accurate rendering\\n *    even during animations, but slower performance.\\n * @api\\n */\\nexport const RenderType = {\\n  IMAGE: 'image',\\n  VECTOR: 'vector'\\n};\\n\\n\\n/**\\n * @enum {string}\\n * @private\\n */\\nconst Property = {\\n  RENDER_ORDER: 'renderOrder'\\n};\\n\\n\\n/**\\n * @classdesc\\n * Vector data that is rendered client-side.\\n * Note that any property set in the options is set as a {@link module:ol/Object~BaseObject}\\n * property on the layer object; for example, setting `title: 'My Title'` in the\\n * options means that `title` is observable, and has get/set accessors.\\n *\\n * @constructor\\n * @extends {module:ol/layer/Layer}\\n * @fires module:ol/render/Event~RenderEvent\\n * @param {module:ol/layer/Vector~Options=} opt_options Options.\\n * @api\\n */\\nconst VectorLayer = function(opt_options) {\\n  const options = opt_options ?\\n    opt_options : /** @type {module:ol/layer/Vector~Options} */ ({});\\n\\n  const baseOptions = assign({}, options);\\n\\n  delete baseOptions.style;\\n  delete baseOptions.renderBuffer;\\n  delete baseOptions.updateWhileAnimating;\\n  delete baseOptions.updateWhileInteracting;\\n  Layer.call(this, /** @type {module:ol/layer/Layer~Options} */ (baseOptions));\\n\\n  /**\\n   * @private\\n   * @type {boolean}\\n   */\\n  this.declutter_ = options.declutter !== undefined ? options.declutter : false;\\n\\n  /**\\n   * @type {number}\\n   * @private\\n   */\\n  this.renderBuffer_ = options.renderBuffer !== undefined ?\\n    options.renderBuffer : 100;\\n\\n  /**\\n   * User provided style.\\n   * @type {module:ol/style/Style|Array.<module:ol/style/Style>|module:ol/style/Style~StyleFunction}\\n   * @private\\n   */\\n  this.style_ = null;\\n\\n  /**\\n   * Style function for use within the library.\\n   * @type {module:ol/style/Style~StyleFunction|undefined}\\n   * @private\\n   */\\n  this.styleFunction_ = undefined;\\n\\n  this.setStyle(options.style);\\n\\n  /**\\n   * @type {boolean}\\n   * @private\\n   */\\n  this.updateWhileAnimating_ = options.updateWhileAnimating !== undefined ?\\n    options.updateWhileAnimating : false;\\n\\n  /**\\n   * @type {boolean}\\n   * @private\\n   */\\n  this.updateWhileInteracting_ = options.updateWhileInteracting !== undefined ?\\n    options.updateWhileInteracting : false;\\n\\n  /**\\n   * @private\\n   * @type {module:ol/layer/VectorTileRenderType|string}\\n   */\\n  this.renderMode_ = options.renderMode || VectorRenderType.VECTOR;\\n\\n  /**\\n   * The layer type.\\n   * @protected\\n   * @type {module:ol/LayerType}\\n   */\\n  this.type = LayerType.VECTOR;\\n\\n};\\n\\ninherits(VectorLayer, Layer);\\n\\n\\n/**\\n * @return {boolean} Declutter.\\n */\\nVectorLayer.prototype.getDeclutter = function() {\\n  return this.declutter_;\\n};\\n\\n\\n/**\\n * @param {boolean} declutter Declutter.\\n */\\nVectorLayer.prototype.setDeclutter = function(declutter) {\\n  this.declutter_ = declutter;\\n};\\n\\n\\n/**\\n * @return {number|undefined} Render buffer.\\n */\\nVectorLayer.prototype.getRenderBuffer = function() {\\n  return this.renderBuffer_;\\n};\\n\\n\\n/**\\n * @return {function(module:ol/Feature, module:ol/Feature): number|null|undefined} Render\\n *     order.\\n */\\nVectorLayer.prototype.getRenderOrder = function() {\\n  return (\\n    /** @type {module:ol/render~OrderFunction|null|undefined} */ (this.get(Property.RENDER_ORDER))\\n  );\\n};\\n\\n\\n/**\\n * Return the associated {@link module:ol/source/Vector vectorsource} of the layer.\\n * @function\\n * @return {module:ol/source/Vector} Source.\\n * @api\\n */\\nVectorLayer.prototype.getSource;\\n\\n\\n/**\\n * Get the style for features.  This returns whatever was passed to the `style`\\n * option at construction or to the `setStyle` method.\\n * @return {module:ol/style/Style|Array.<module:ol/style/Style>|module:ol/style/Style~StyleFunction}\\n *     Layer style.\\n * @api\\n */\\nVectorLayer.prototype.getStyle = function() {\\n  return this.style_;\\n};\\n\\n\\n/**\\n * Get the style function.\\n * @return {module:ol/style/Style~StyleFunction|undefined} Layer style function.\\n * @api\\n */\\nVectorLayer.prototype.getStyleFunction = function() {\\n  return this.styleFunction_;\\n};\\n\\n\\n/**\\n * @return {boolean} Whether the rendered layer should be updated while\\n *     animating.\\n */\\nVectorLayer.prototype.getUpdateWhileAnimating = function() {\\n  return this.updateWhileAnimating_;\\n};\\n\\n\\n/**\\n * @return {boolean} Whether the rendered layer should be updated while\\n *     interacting.\\n */\\nVectorLayer.prototype.getUpdateWhileInteracting = function() {\\n  return this.updateWhileInteracting_;\\n};\\n\\n\\n/**\\n * @param {module:ol/render~OrderFunction|null|undefined} renderOrder\\n *     Render order.\\n */\\nVectorLayer.prototype.setRenderOrder = function(renderOrder) {\\n  this.set(Property.RENDER_ORDER, renderOrder);\\n};\\n\\n\\n/**\\n * Set the style for features.  This can be a single style object, an array\\n * of styles, or a function that takes a feature and resolution and returns\\n * an array of styles. If it is `undefined` the default style is used. If\\n * it is `null` the layer has no style (a `null` style), so only features\\n * that have their own styles will be rendered in the layer. See\\n * {@link module:ol/style} for information on the default style.\\n * @param {module:ol/style/Style|Array.<module:ol/style/Style>|module:ol/style/Style~StyleFunction|null|undefined}\\n *     style Layer style.\\n * @api\\n */\\nVectorLayer.prototype.setStyle = function(style) {\\n  this.style_ = style !== undefined ? style : createDefaultStyle;\\n  this.styleFunction_ = style === null ?\\n    undefined : toStyleFunction(this.style_);\\n  this.changed();\\n};\\n\\n\\n/**\\n * @return {module:ol/layer/VectorRenderType|string} The render mode.\\n */\\nVectorLayer.prototype.getRenderMode = function() {\\n  return this.renderMode_;\\n};\\n\\n\\nexport default VectorLayer;\\n\",\"/**\\n * @module ol/featureloader\\n */\\nimport {UNDEFINED} from './functions.js';\\nimport FormatType from './format/FormatType.js';\\n\\n\\n/**\\n * {@link module:ol/source/Vector} sources use a function of this type to\\n * load features.\\n *\\n * This function takes an {@link module:ol/extent~Extent} representing the area to be loaded,\\n * a `{number}` representing the resolution (map units per pixel) and an\\n * {@link module:ol/proj/Projection} for the projection  as\\n * arguments. `this` within the function is bound to the\\n * {@link module:ol/source/Vector} it's called from.\\n *\\n * The function is responsible for loading the features and adding them to the\\n * source.\\n * @typedef {function(this:module:ol/source/Vector, module:ol/extent~Extent, number,\\n *                    module:ol/proj/Projection)} FeatureLoader\\n * @api\\n */\\n\\n\\n/**\\n * {@link module:ol/source/Vector} sources use a function of this type to\\n * get the url to load features from.\\n *\\n * This function takes an {@link module:ol/extent~Extent} representing the area\\n * to be loaded, a `{number}` representing the resolution (map units per pixel)\\n * and an {@link module:ol/proj/Projection} for the projection  as\\n * arguments and returns a `{string}` representing the URL.\\n * @typedef {function(module:ol/extent~Extent, number, module:ol/proj/Projection): string} FeatureUrlFunction\\n * @api\\n */\\n\\n\\n/**\\n * @param {string|module:ol/featureloader~FeatureUrlFunction} url Feature URL service.\\n * @param {module:ol/format/Feature} format Feature format.\\n * @param {function(this:module:ol/VectorTile, Array.<module:ol/Feature>, module:ol/proj/Projection, module:ol/extent~Extent)|function(this:module:ol/source/Vector, Array.<module:ol/Feature>)} success\\n *     Function called with the loaded features and optionally with the data\\n *     projection. Called with the vector tile or source as `this`.\\n * @param {function(this:module:ol/VectorTile)|function(this:module:ol/source/Vector)} failure\\n *     Function called when loading failed. Called with the vector tile or\\n *     source as `this`.\\n * @return {module:ol/featureloader~FeatureLoader} The feature loader.\\n */\\nexport function loadFeaturesXhr(url, format, success, failure) {\\n  return (\\n    /**\\n     * @param {module:ol/extent~Extent} extent Extent.\\n     * @param {number} resolution Resolution.\\n     * @param {module:ol/proj/Projection} projection Projection.\\n     * @this {module:ol/source/Vector|module:ol/VectorTile}\\n     */\\n    function(extent, resolution, projection) {\\n      const xhr = new XMLHttpRequest();\\n      xhr.open('GET',\\n        typeof url === 'function' ? url(extent, resolution, projection) : url,\\n        true);\\n      if (format.getType() == FormatType.ARRAY_BUFFER) {\\n        xhr.responseType = 'arraybuffer';\\n      }\\n      /**\\n       * @param {Event} event Event.\\n       * @private\\n       */\\n      xhr.onload = function(event) {\\n        // status will be 0 for file:// urls\\n        if (!xhr.status || xhr.status >= 200 && xhr.status < 300) {\\n          const type = format.getType();\\n          /** @type {Document|Node|Object|string|undefined} */\\n          let source;\\n          if (type == FormatType.JSON || type == FormatType.TEXT) {\\n            source = xhr.responseText;\\n          } else if (type == FormatType.XML) {\\n            source = xhr.responseXML;\\n            if (!source) {\\n              source = new DOMParser().parseFromString(xhr.responseText, 'application/xml');\\n            }\\n          } else if (type == FormatType.ARRAY_BUFFER) {\\n            source = /** @type {ArrayBuffer} */ (xhr.response);\\n          }\\n          if (source) {\\n            success.call(this, format.readFeatures(source,\\n              {featureProjection: projection}),\\n            format.readProjection(source), format.getLastExtent());\\n          } else {\\n            failure.call(this);\\n          }\\n        } else {\\n          failure.call(this);\\n        }\\n      }.bind(this);\\n      /**\\n       * @private\\n       */\\n      xhr.onerror = function() {\\n        failure.call(this);\\n      }.bind(this);\\n      xhr.send();\\n    }\\n  );\\n}\\n\\n\\n/**\\n * Create an XHR feature loader for a `url` and `format`. The feature loader\\n * loads features (with XHR), parses the features, and adds them to the\\n * vector source.\\n * @param {string|module:ol/featureloader~FeatureUrlFunction} url Feature URL service.\\n * @param {module:ol/format/Feature} format Feature format.\\n * @return {module:ol/featureloader~FeatureLoader} The feature loader.\\n * @api\\n */\\nexport function xhr(url, format) {\\n  return loadFeaturesXhr(url, format,\\n    /**\\n     * @param {Array.<module:ol/Feature>} features The loaded features.\\n     * @param {module:ol/proj/Projection} dataProjection Data\\n     * projection.\\n     * @this {module:ol/source/Vector}\\n     */\\n    function(features, dataProjection) {\\n      this.addFeatures(features);\\n    }, /* FIXME handle error */ UNDEFINED);\\n}\\n\",\"/**\\n * @module ol/loadingstrategy\\n */\\n\\n\\n/**\\n * Strategy function for loading all features with a single request.\\n * @param {module:ol/extent~Extent} extent Extent.\\n * @param {number} resolution Resolution.\\n * @return {Array.<module:ol/extent~Extent>} Extents.\\n * @api\\n */\\nexport function all(extent, resolution) {\\n  return [[-Infinity, -Infinity, Infinity, Infinity]];\\n}\\n\\n\\n/**\\n * Strategy function for loading features based on the view's extent and\\n * resolution.\\n * @param {module:ol/extent~Extent} extent Extent.\\n * @param {number} resolution Resolution.\\n * @return {Array.<module:ol/extent~Extent>} Extents.\\n * @api\\n */\\nexport function bbox(extent, resolution) {\\n  return [extent];\\n}\\n\\n\\n/**\\n * Creates a strategy function for loading features based on a tile grid.\\n * @param {module:ol/tilegrid/TileGrid} tileGrid Tile grid.\\n * @return {function(module:ol/extent~Extent, number): Array.<module:ol/extent~Extent>} Loading strategy.\\n * @api\\n */\\nexport function tile(tileGrid) {\\n  return (\\n    /**\\n     * @param {module:ol/extent~Extent} extent Extent.\\n     * @param {number} resolution Resolution.\\n     * @return {Array.<module:ol/extent~Extent>} Extents.\\n     */\\n    function(extent, resolution) {\\n      const z = tileGrid.getZForResolution(resolution);\\n      const tileRange = tileGrid.getTileRangeForExtentAndZ(extent, z);\\n      /** @type {Array.<module:ol/extent~Extent>} */\\n      const extents = [];\\n      /** @type {module:ol/tilecoord~TileCoord} */\\n      const tileCoord = [z, 0, 0];\\n      for (tileCoord[1] = tileRange.minX; tileCoord[1] <= tileRange.maxX; ++tileCoord[1]) {\\n        for (tileCoord[2] = tileRange.minY; tileCoord[2] <= tileRange.maxY; ++tileCoord[2]) {\\n          extents.push(tileGrid.getTileCoordExtent(tileCoord));\\n        }\\n      }\\n      return extents;\\n    }\\n  );\\n}\\n\",\"/**\\n * @module ol/source/Source\\n */\\nimport {inherits} from '../index.js';\\nimport {UNDEFINED} from '../functions.js';\\nimport BaseObject from '../Object.js';\\nimport {get as getProjection} from '../proj.js';\\nimport SourceState from '../source/State.js';\\n\\n\\n/**\\n * A function that returns a string or an array of strings representing source\\n * attributions.\\n *\\n * @typedef {function(module:ol/PluggableMap~FrameState): (string|Array.<string>)} Attribution\\n */\\n\\n\\n/**\\n * A type that can be used to provide attribution information for data sources.\\n *\\n * It represents either\\n * * a simple string (e.g. `' Acme Inc.'`)\\n * * an array of simple strings (e.g. `[' Acme Inc.', ' Bacme Inc.']`)\\n * * a function that returns a string or array of strings (`{@link module:ol/source/Source~Attribution}`)\\n *\\n * @typedef {string|Array.<string>|module:ol/source/Source~Attribution} AttributionLike\\n */\\n\\n\\n/**\\n * @typedef {Object} Options\\n * @property {module:ol/source/Source~AttributionLike} [attributions]\\n * @property {module:ol/proj~ProjectionLike} projection\\n * @property {module:ol/source/State} [state]\\n * @property {boolean} [wrapX]\\n */\\n\\n\\n/**\\n * @classdesc\\n * Abstract base class; normally only used for creating subclasses and not\\n * instantiated in apps.\\n * Base class for {@link module:ol/layer/Layer~Layer} sources.\\n *\\n * A generic `change` event is triggered when the state of the source changes.\\n *\\n * @constructor\\n * @abstract\\n * @extends {module:ol/Object}\\n * @param {module:ol/source/Source~Options} options Source options.\\n * @api\\n */\\nconst Source = function(options) {\\n\\n  BaseObject.call(this);\\n\\n  /**\\n   * @private\\n   * @type {module:ol/proj/Projection}\\n   */\\n  this.projection_ = getProjection(options.projection);\\n\\n  /**\\n   * @private\\n   * @type {?module:ol/source/Source~Attribution}\\n   */\\n  this.attributions_ = this.adaptAttributions_(options.attributions);\\n\\n  /**\\n   * @private\\n   * @type {module:ol/source/State}\\n   */\\n  this.state_ = options.state !== undefined ?\\n    options.state : SourceState.READY;\\n\\n  /**\\n   * @private\\n   * @type {boolean}\\n   */\\n  this.wrapX_ = options.wrapX !== undefined ? options.wrapX : false;\\n\\n};\\n\\ninherits(Source, BaseObject);\\n\\n/**\\n * Turns the attributions option into an attributions function.\\n * @param {module:ol/source/Source~AttributionLike|undefined} attributionLike The attribution option.\\n * @return {?module:ol/source/Source~Attribution} An attribution function (or null).\\n */\\nSource.prototype.adaptAttributions_ = function(attributionLike) {\\n  if (!attributionLike) {\\n    return null;\\n  }\\n  if (Array.isArray(attributionLike)) {\\n    return function(frameState) {\\n      return attributionLike;\\n    };\\n  }\\n\\n  if (typeof attributionLike === 'function') {\\n    return attributionLike;\\n  }\\n\\n  return function(frameState) {\\n    return [attributionLike];\\n  };\\n};\\n\\n/**\\n * @param {module:ol/coordinate~Coordinate} coordinate Coordinate.\\n * @param {number} resolution Resolution.\\n * @param {number} rotation Rotation.\\n * @param {number} hitTolerance Hit tolerance in pixels.\\n * @param {Object.<string, boolean>} skippedFeatureUids Skipped feature uids.\\n * @param {function((module:ol/Feature|module:ol/render/Feature)): T} callback Feature callback.\\n * @return {T|undefined} Callback result.\\n * @template T\\n */\\nSource.prototype.forEachFeatureAtCoordinate = UNDEFINED;\\n\\n\\n/**\\n * Get the attribution function for the source.\\n * @return {?module:ol/source/Source~Attribution} Attribution function.\\n */\\nSource.prototype.getAttributions = function() {\\n  return this.attributions_;\\n};\\n\\n\\n/**\\n * Get the projection of the source.\\n * @return {module:ol/proj/Projection} Projection.\\n * @api\\n */\\nSource.prototype.getProjection = function() {\\n  return this.projection_;\\n};\\n\\n\\n/**\\n * @abstract\\n * @return {Array.<number>|undefined} Resolutions.\\n */\\nSource.prototype.getResolutions = function() {};\\n\\n\\n/**\\n * Get the state of the source, see {@link module:ol/source/State~State} for possible states.\\n * @return {module:ol/source/State} State.\\n * @api\\n */\\nSource.prototype.getState = function() {\\n  return this.state_;\\n};\\n\\n\\n/**\\n * @return {boolean|undefined} Wrap X.\\n */\\nSource.prototype.getWrapX = function() {\\n  return this.wrapX_;\\n};\\n\\n\\n/**\\n * Refreshes the source and finally dispatches a 'change' event.\\n * @api\\n */\\nSource.prototype.refresh = function() {\\n  this.changed();\\n};\\n\\n\\n/**\\n * Set the attributions of the source.\\n * @param {module:ol/source/Source~AttributionLike|undefined} attributions Attributions.\\n *     Can be passed as `string`, `Array<string>`, `{@link module:ol/source/Source~Attribution}`,\\n *     or `undefined`.\\n * @api\\n */\\nSource.prototype.setAttributions = function(attributions) {\\n  this.attributions_ = this.adaptAttributions_(attributions);\\n  this.changed();\\n};\\n\\n\\n/**\\n * Set the state of the source.\\n * @param {module:ol/source/State} state State.\\n * @protected\\n */\\nSource.prototype.setState = function(state) {\\n  this.state_ = state;\\n  this.changed();\\n};\\nexport default Source;\\n\",\"/**\\n * @module ol/source/VectorEventType\\n */\\n\\n/**\\n * @enum {string}\\n */\\nexport default {\\n  /**\\n   * Triggered when a feature is added to the source.\\n   * @event ol/source/Vector~VectorSourceEvent#addfeature\\n   * @api\\n   */\\n  ADDFEATURE: 'addfeature',\\n\\n  /**\\n   * Triggered when a feature is updated.\\n   * @event ol/source/Vector~VectorSourceEvent#changefeature\\n   * @api\\n   */\\n  CHANGEFEATURE: 'changefeature',\\n\\n  /**\\n   * Triggered when the clear method is called on the source.\\n   * @event ol/source/Vector~VectorSourceEvent#clear\\n   * @api\\n   */\\n  CLEAR: 'clear',\\n\\n  /**\\n   * Triggered when a feature is removed from the source.\\n   * See {@link module:ol/source/Vector#clear source.clear()} for exceptions.\\n   * @event ol/source/Vector~VectorSourceEvent#removefeature\\n   * @api\\n   */\\n  REMOVEFEATURE: 'removefeature'\\n};\\n\",\"/**\\n * @module ol/structs/RBush\\n */\\nimport {getUid} from '../index.js';\\nimport rbush from 'rbush';\\nimport {createOrUpdate, equals} from '../extent.js';\\nimport {isEmpty} from '../obj.js';\\n\\n/**\\n * @typedef {Object} Entry\\n * @property {number} minX\\n * @property {number} minY\\n * @property {number} maxX\\n * @property {number} maxY\\n * @property {Object} [value]\\n */\\n\\n/**\\n * Wrapper around the RBush by Vladimir Agafonkin.\\n *\\n * @constructor\\n * @param {number=} opt_maxEntries Max entries.\\n * @see https://github.com/mourner/rbush\\n * @struct\\n * @template T\\n */\\nconst RBush = function(opt_maxEntries) {\\n\\n  /**\\n   * @private\\n   */\\n  this.rbush_ = rbush(opt_maxEntries, undefined);\\n\\n  /**\\n   * A mapping between the objects added to this rbush wrapper\\n   * and the objects that are actually added to the internal rbush.\\n   * @private\\n   * @type {Object.<number, module:ol/structs/RBush~Entry>}\\n   */\\n  this.items_ = {};\\n\\n};\\n\\n\\n/**\\n * Insert a value into the RBush.\\n * @param {module:ol/extent~Extent} extent Extent.\\n * @param {T} value Value.\\n */\\nRBush.prototype.insert = function(extent, value) {\\n  /** @type {module:ol/structs/RBush~Entry} */\\n  const item = {\\n    minX: extent[0],\\n    minY: extent[1],\\n    maxX: extent[2],\\n    maxY: extent[3],\\n    value: value\\n  };\\n\\n  this.rbush_.insert(item);\\n  this.items_[getUid(value)] = item;\\n};\\n\\n\\n/**\\n * Bulk-insert values into the RBush.\\n * @param {Array.<module:ol/extent~Extent>} extents Extents.\\n * @param {Array.<T>} values Values.\\n */\\nRBush.prototype.load = function(extents, values) {\\n  const items = new Array(values.length);\\n  for (let i = 0, l = values.length; i < l; i++) {\\n    const extent = extents[i];\\n    const value = values[i];\\n\\n    /** @type {module:ol/structs/RBush~Entry} */\\n    const item = {\\n      minX: extent[0],\\n      minY: extent[1],\\n      maxX: extent[2],\\n      maxY: extent[3],\\n      value: value\\n    };\\n    items[i] = item;\\n    this.items_[getUid(value)] = item;\\n  }\\n  this.rbush_.load(items);\\n};\\n\\n\\n/**\\n * Remove a value from the RBush.\\n * @param {T} value Value.\\n * @return {boolean} Removed.\\n */\\nRBush.prototype.remove = function(value) {\\n  const uid = getUid(value);\\n\\n  // get the object in which the value was wrapped when adding to the\\n  // internal rbush. then use that object to do the removal.\\n  const item = this.items_[uid];\\n  delete this.items_[uid];\\n  return this.rbush_.remove(item) !== null;\\n};\\n\\n\\n/**\\n * Update the extent of a value in the RBush.\\n * @param {module:ol/extent~Extent} extent Extent.\\n * @param {T} value Value.\\n */\\nRBush.prototype.update = function(extent, value) {\\n  const item = this.items_[getUid(value)];\\n  const bbox = [item.minX, item.minY, item.maxX, item.maxY];\\n  if (!equals(bbox, extent)) {\\n    this.remove(value);\\n    this.insert(extent, value);\\n  }\\n};\\n\\n\\n/**\\n * Return all values in the RBush.\\n * @return {Array.<T>} All.\\n */\\nRBush.prototype.getAll = function() {\\n  const items = this.rbush_.all();\\n  return items.map(function(item) {\\n    return item.value;\\n  });\\n};\\n\\n\\n/**\\n * Return all values in the given extent.\\n * @param {module:ol/extent~Extent} extent Extent.\\n * @return {Array.<T>} All in extent.\\n */\\nRBush.prototype.getInExtent = function(extent) {\\n  /** @type {module:ol/structs/RBush~Entry} */\\n  const bbox = {\\n    minX: extent[0],\\n    minY: extent[1],\\n    maxX: extent[2],\\n    maxY: extent[3]\\n  };\\n  const items = this.rbush_.search(bbox);\\n  return items.map(function(item) {\\n    return item.value;\\n  });\\n};\\n\\n\\n/**\\n * Calls a callback function with each value in the tree.\\n * If the callback returns a truthy value, this value is returned without\\n * checking the rest of the tree.\\n * @param {function(this: S, T): *} callback Callback.\\n * @param {S=} opt_this The object to use as `this` in `callback`.\\n * @return {*} Callback return value.\\n * @template S\\n */\\nRBush.prototype.forEach = function(callback, opt_this) {\\n  return this.forEach_(this.getAll(), callback, opt_this);\\n};\\n\\n\\n/**\\n * Calls a callback function with each value in the provided extent.\\n * @param {module:ol/extent~Extent} extent Extent.\\n * @param {function(this: S, T): *} callback Callback.\\n * @param {S=} opt_this The object to use as `this` in `callback`.\\n * @return {*} Callback return value.\\n * @template S\\n */\\nRBush.prototype.forEachInExtent = function(extent, callback, opt_this) {\\n  return this.forEach_(this.getInExtent(extent), callback, opt_this);\\n};\\n\\n\\n/**\\n * @param {Array.<T>} values Values.\\n * @param {function(this: S, T): *} callback Callback.\\n * @param {S=} opt_this The object to use as `this` in `callback`.\\n * @private\\n * @return {*} Callback return value.\\n * @template S\\n */\\nRBush.prototype.forEach_ = function(values, callback, opt_this) {\\n  let result;\\n  for (let i = 0, l = values.length; i < l; i++) {\\n    result = callback.call(opt_this, values[i]);\\n    if (result) {\\n      return result;\\n    }\\n  }\\n  return result;\\n};\\n\\n\\n/**\\n * @return {boolean} Is empty.\\n */\\nRBush.prototype.isEmpty = function() {\\n  return isEmpty(this.items_);\\n};\\n\\n\\n/**\\n * Remove all values from the RBush.\\n */\\nRBush.prototype.clear = function() {\\n  this.rbush_.clear();\\n  this.items_ = {};\\n};\\n\\n\\n/**\\n * @param {module:ol/extent~Extent=} opt_extent Extent.\\n * @return {module:ol/extent~Extent} Extent.\\n */\\nRBush.prototype.getExtent = function(opt_extent) {\\n  // FIXME add getExtent() to rbush\\n  const data = this.rbush_.data;\\n  return createOrUpdate(data.minX, data.minY, data.maxX, data.maxY, opt_extent);\\n};\\n\\n\\n/**\\n * @param {module:ol/structs/RBush} rbush R-Tree.\\n */\\nRBush.prototype.concat = function(rbush) {\\n  this.rbush_.load(rbush.rbush_.all());\\n  for (const i in rbush.items_) {\\n    this.items_[i | 0] = rbush.items_[i | 0];\\n  }\\n};\\nexport default RBush;\\n\",\"/**\\n * @module ol/source/Vector\\n */\\n\\nimport {getUid, inherits} from '../index.js';\\nimport Collection from '../Collection.js';\\nimport CollectionEventType from '../CollectionEventType.js';\\nimport ObjectEventType from '../ObjectEventType.js';\\nimport {extend} from '../array.js';\\nimport {assert} from '../asserts.js';\\nimport {listen, unlistenByKey} from '../events.js';\\nimport Event from '../events/Event.js';\\nimport EventType from '../events/EventType.js';\\nimport {containsExtent, equals} from '../extent.js';\\nimport {xhr} from '../featureloader.js';\\nimport {TRUE, UNDEFINED} from '../functions.js';\\nimport {all as allStrategy} from '../loadingstrategy.js';\\nimport {isEmpty, getValues} from '../obj.js';\\nimport Source from '../source/Source.js';\\nimport SourceState from '../source/State.js';\\nimport VectorEventType from '../source/VectorEventType.js';\\nimport RBush from '../structs/RBush.js';\\n\\n/**\\n * A function that takes an {@link module:ol/extent~Extent} and a resolution as arguments, and\\n * returns an array of {@link module:ol/extent~Extent} with the extents to load. Usually this\\n * is one of the standard {@link module:ol/loadingstrategy} strategies.\\n *\\n * @typedef {function(module:ol/extent~Extent, number): Array.<module:ol/extent~Extent>} LoadingStrategy\\n * @api\\n */\\n\\n\\n/**\\n * @classdesc\\n * Events emitted by {@link module:ol/source/Vector} instances are instances of this\\n * type.\\n *\\n * @constructor\\n * @extends {module:ol/events/Event}\\n * @param {string} type Type.\\n * @param {module:ol/Feature=} opt_feature Feature.\\n */\\nexport const VectorSourceEvent = function(type, opt_feature) {\\n\\n  Event.call(this, type);\\n\\n  /**\\n   * The feature being added or removed.\\n   * @type {module:ol/Feature|undefined}\\n   * @api\\n   */\\n  this.feature = opt_feature;\\n\\n};\\ninherits(VectorSourceEvent, Event);\\n\\n\\n/**\\n * @typedef {Object} Options\\n * @property {module:ol/source/Source~AttributionLike} [attributions] Attributions.\\n * @property {Array.<module:ol/Feature>|module:ol/Collection.<module:ol/Feature>} [features]\\n * Features. If provided as {@link module:ol/Collection}, the features in the source\\n * and the collection will stay in sync.\\n * @property {module:ol/format/Feature} [format] The feature format used by the XHR\\n * feature loader when `url` is set. Required if `url` is set, otherwise ignored.\\n * @property {module:ol/featureloader~FeatureLoader} [loader]\\n * The loader function used to load features, from a remote source for example.\\n * If this is not set and `url` is set, the source will create and use an XHR\\n * feature loader.\\n *\\n * Example:\\n *\\n * ```js\\n * import {Vector} from 'ol/source';\\n * import {GeoJSON} from 'ol/format';\\n * import {bbox} from 'ol/loadingstrategy';\\n *\\n * var vectorSource = new Vector({\\n *   format: new GeoJSON(),\\n *   loader: function(extent, resolution, projection) {\\n *      var proj = projection.getCode();\\n *      var url = 'https://ahocevar.com/geoserver/wfs?service=WFS&' +\\n *          'version=1.1.0&request=GetFeature&typename=osm:water_areas&' +\\n *          'outputFormat=application/json&srsname=' + proj + '&' +\\n *          'bbox=' + extent.join(',') + ',' + proj;\\n *      var xhr = new XMLHttpRequest();\\n *      xhr.open('GET', url);\\n *      var onError = function() {\\n *        vectorSource.removeLoadedExtent(extent);\\n *      }\\n *      xhr.onerror = onError;\\n *      xhr.onload = function() {\\n *        if (xhr.status == 200) {\\n *          vectorSource.addFeatures(\\n *              vectorSource.getFormat().readFeatures(xhr.responseText));\\n *        } else {\\n *          onError();\\n *        }\\n *      }\\n *      xhr.send();\\n *    },\\n *    strategy: bbox\\n *  });\\n * ```\\n * @property {boolean} [overlaps=true] This source may have overlapping geometries.\\n * Setting this to `false` (e.g. for sources with polygons that represent administrative\\n * boundaries or TopoJSON sources) allows the renderer to optimise fill and\\n * stroke operations.\\n * @property {module:ol/source/Vector~LoadingStrategy} [strategy] The loading strategy to use.\\n * By default an {@link module:ol/loadingstrategy~all}\\n * strategy is used, a one-off strategy which loads all features at once.\\n * @property {string|module:ol/featureloader~FeatureUrlfunction} [url]\\n * Setting this option instructs the source to load features using an XHR loader\\n * (see {@link module:ol/featureloader~xhr}). Use a `string` and an\\n * {@link module:ol/loadingstrategy~all} for a one-off download of all features from\\n * the given URL. Use a {@link module:ol/featureloader~FeatureUrlfunction} to generate the url with\\n * other loading strategies.\\n * Requires `format` to be set as well.\\n * When default XHR feature loader is provided, the features will\\n * be transformed from the data projection to the view projection\\n * during parsing. If your remote data source does not advertise its projection\\n * properly, this transformation will be incorrect. For some formats, the\\n * default projection (usually EPSG:4326) can be overridden by setting the\\n * defaultDataProjection constructor option on the format.\\n * Note that if a source contains non-feature data, such as a GeoJSON geometry\\n * or a KML NetworkLink, these will be ignored. Use a custom loader to load these.\\n * @property {boolean} [useSpatialIndex=true]\\n * By default, an RTree is used as spatial index. When features are removed and\\n * added frequently, and the total number of features is low, setting this to\\n * `false` may improve performance.\\n *\\n * Note that\\n * {@link module:ol/source/Vector~VectorSource#getFeaturesInExtent},\\n * {@link module:ol/source/Vector~VectorSource#getClosestFeatureToCoordinate} and\\n * {@link module:ol/source/Vector~VectorSource#getExtent} cannot be used when `useSpatialIndex` is\\n * set to `false`, and {@link module:ol/source/Vector~VectorSource#forEachFeatureInExtent} will loop\\n * through all features.\\n *\\n * When set to `false`, the features will be maintained in an\\n * {@link module:ol/Collection}, which can be retrieved through\\n * {@link module:ol/source/Vector~VectorSource#getFeaturesCollection}.\\n * @property {boolean} [wrapX=true] Wrap the world horizontally. For vector editing across the\\n * -180 and 180 meridians to work properly, this should be set to `false`. The\\n * resulting geometry coordinates will then exceed the world bounds.\\n */\\n\\n\\n/**\\n * @classdesc\\n * Provides a source of features for vector layers. Vector features provided\\n * by this source are suitable for editing. See {@link module:ol/source/VectorTile~VectorTile} for\\n * vector data that is optimized for rendering.\\n *\\n * @constructor\\n * @extends {module:ol/source/Source}\\n * @fires ol/source/Vector~VectorSourceEvent\\n * @param {module:ol/source/Vector~Options=} opt_options Vector source options.\\n * @api\\n */\\nconst VectorSource = function(opt_options) {\\n\\n  const options = opt_options || {};\\n\\n  Source.call(this, {\\n    attributions: options.attributions,\\n    projection: undefined,\\n    state: SourceState.READY,\\n    wrapX: options.wrapX !== undefined ? options.wrapX : true\\n  });\\n\\n  /**\\n   * @private\\n   * @type {module:ol/featureloader~FeatureLoader}\\n   */\\n  this.loader_ = UNDEFINED;\\n\\n  /**\\n   * @private\\n   * @type {module:ol/format/Feature|undefined}\\n   */\\n  this.format_ = options.format;\\n\\n  /**\\n   * @private\\n   * @type {boolean}\\n   */\\n  this.overlaps_ = options.overlaps == undefined ? true : options.overlaps;\\n\\n  /**\\n   * @private\\n   * @type {string|module:ol/featureloader~FeatureUrlFunction|undefined}\\n   */\\n  this.url_ = options.url;\\n\\n  if (options.loader !== undefined) {\\n    this.loader_ = options.loader;\\n  } else if (this.url_ !== undefined) {\\n    assert(this.format_, 7); // `format` must be set when `url` is set\\n    // create a XHR feature loader for \\\"url\\\" and \\\"format\\\"\\n    this.loader_ = xhr(this.url_, /** @type {module:ol/format/Feature} */ (this.format_));\\n  }\\n\\n  /**\\n   * @private\\n   * @type {module:ol/source/Vector~LoadingStrategy}\\n   */\\n  this.strategy_ = options.strategy !== undefined ? options.strategy : allStrategy;\\n\\n  const useSpatialIndex =\\n      options.useSpatialIndex !== undefined ? options.useSpatialIndex : true;\\n\\n  /**\\n   * @private\\n   * @type {module:ol/structs/RBush.<module:ol/Feature>}\\n   */\\n  this.featuresRtree_ = useSpatialIndex ? new RBush() : null;\\n\\n  /**\\n   * @private\\n   * @type {module:ol/structs/RBush.<{extent: module:ol/extent~Extent}>}\\n   */\\n  this.loadedExtentsRtree_ = new RBush();\\n\\n  /**\\n   * @private\\n   * @type {!Object.<string, module:ol/Feature>}\\n   */\\n  this.nullGeometryFeatures_ = {};\\n\\n  /**\\n   * A lookup of features by id (the return from feature.getId()).\\n   * @private\\n   * @type {!Object.<string, module:ol/Feature>}\\n   */\\n  this.idIndex_ = {};\\n\\n  /**\\n   * A lookup of features without id (keyed by getUid(feature)).\\n   * @private\\n   * @type {!Object.<string, module:ol/Feature>}\\n   */\\n  this.undefIdIndex_ = {};\\n\\n  /**\\n   * @private\\n   * @type {Object.<string, Array.<module:ol/events~EventsKey>>}\\n   */\\n  this.featureChangeKeys_ = {};\\n\\n  /**\\n   * @private\\n   * @type {module:ol/Collection.<module:ol/Feature>}\\n   */\\n  this.featuresCollection_ = null;\\n\\n  let collection, features;\\n  if (options.features instanceof Collection) {\\n    collection = options.features;\\n    features = collection.getArray();\\n  } else if (Array.isArray(options.features)) {\\n    features = options.features;\\n  }\\n  if (!useSpatialIndex && collection === undefined) {\\n    collection = new Collection(features);\\n  }\\n  if (features !== undefined) {\\n    this.addFeaturesInternal(features);\\n  }\\n  if (collection !== undefined) {\\n    this.bindFeaturesCollection_(collection);\\n  }\\n\\n};\\n\\ninherits(VectorSource, Source);\\n\\n\\n/**\\n * Add a single feature to the source.  If you want to add a batch of features\\n * at once, call {@link module:ol/source/Vector~VectorSource#addFeatures #addFeatures()}\\n * instead. A feature will not be added to the source if feature with\\n * the same id is already there. The reason for this behavior is to avoid\\n * feature duplication when using bbox or tile loading strategies.\\n * @param {module:ol/Feature} feature Feature to add.\\n * @api\\n */\\nVectorSource.prototype.addFeature = function(feature) {\\n  this.addFeatureInternal(feature);\\n  this.changed();\\n};\\n\\n\\n/**\\n * Add a feature without firing a `change` event.\\n * @param {module:ol/Feature} feature Feature.\\n * @protected\\n */\\nVectorSource.prototype.addFeatureInternal = function(feature) {\\n  const featureKey = getUid(feature).toString();\\n\\n  if (!this.addToIndex_(featureKey, feature)) {\\n    return;\\n  }\\n\\n  this.setupChangeEvents_(featureKey, feature);\\n\\n  const geometry = feature.getGeometry();\\n  if (geometry) {\\n    const extent = geometry.getExtent();\\n    if (this.featuresRtree_) {\\n      this.featuresRtree_.insert(extent, feature);\\n    }\\n  } else {\\n    this.nullGeometryFeatures_[featureKey] = feature;\\n  }\\n\\n  this.dispatchEvent(\\n    new VectorSourceEvent(VectorEventType.ADDFEATURE, feature));\\n};\\n\\n\\n/**\\n * @param {string} featureKey Unique identifier for the feature.\\n * @param {module:ol/Feature} feature The feature.\\n * @private\\n */\\nVectorSource.prototype.setupChangeEvents_ = function(featureKey, feature) {\\n  this.featureChangeKeys_[featureKey] = [\\n    listen(feature, EventType.CHANGE,\\n      this.handleFeatureChange_, this),\\n    listen(feature, ObjectEventType.PROPERTYCHANGE,\\n      this.handleFeatureChange_, this)\\n  ];\\n};\\n\\n\\n/**\\n * @param {string} featureKey Unique identifier for the feature.\\n * @param {module:ol/Feature} feature The feature.\\n * @return {boolean} The feature is \\\"valid\\\", in the sense that it is also a\\n *     candidate for insertion into the Rtree.\\n * @private\\n */\\nVectorSource.prototype.addToIndex_ = function(featureKey, feature) {\\n  let valid = true;\\n  const id = feature.getId();\\n  if (id !== undefined) {\\n    if (!(id.toString() in this.idIndex_)) {\\n      this.idIndex_[id.toString()] = feature;\\n    } else {\\n      valid = false;\\n    }\\n  } else {\\n    assert(!(featureKey in this.undefIdIndex_),\\n      30); // The passed `feature` was already added to the source\\n    this.undefIdIndex_[featureKey] = feature;\\n  }\\n  return valid;\\n};\\n\\n\\n/**\\n * Add a batch of features to the source.\\n * @param {Array.<module:ol/Feature>} features Features to add.\\n * @api\\n */\\nVectorSource.prototype.addFeatures = function(features) {\\n  this.addFeaturesInternal(features);\\n  this.changed();\\n};\\n\\n\\n/**\\n * Add features without firing a `change` event.\\n * @param {Array.<module:ol/Feature>} features Features.\\n * @protected\\n */\\nVectorSource.prototype.addFeaturesInternal = function(features) {\\n  const extents = [];\\n  const newFeatures = [];\\n  const geometryFeatures = [];\\n\\n  for (let i = 0, length = features.length; i < length; i++) {\\n    const feature = features[i];\\n    const featureKey = getUid(feature).toString();\\n    if (this.addToIndex_(featureKey, feature)) {\\n      newFeatures.push(feature);\\n    }\\n  }\\n\\n  for (let i = 0, length = newFeatures.length; i < length; i++) {\\n    const feature = newFeatures[i];\\n    const featureKey = getUid(feature).toString();\\n    this.setupChangeEvents_(featureKey, feature);\\n\\n    const geometry = feature.getGeometry();\\n    if (geometry) {\\n      const extent = geometry.getExtent();\\n      extents.push(extent);\\n      geometryFeatures.push(feature);\\n    } else {\\n      this.nullGeometryFeatures_[featureKey] = feature;\\n    }\\n  }\\n  if (this.featuresRtree_) {\\n    this.featuresRtree_.load(extents, geometryFeatures);\\n  }\\n\\n  for (let i = 0, length = newFeatures.length; i < length; i++) {\\n    this.dispatchEvent(new VectorSourceEvent(VectorEventType.ADDFEATURE, newFeatures[i]));\\n  }\\n};\\n\\n\\n/**\\n * @param {!module:ol/Collection.<module:ol/Feature>} collection Collection.\\n * @private\\n */\\nVectorSource.prototype.bindFeaturesCollection_ = function(collection) {\\n  let modifyingCollection = false;\\n  listen(this, VectorEventType.ADDFEATURE,\\n    function(evt) {\\n      if (!modifyingCollection) {\\n        modifyingCollection = true;\\n        collection.push(evt.feature);\\n        modifyingCollection = false;\\n      }\\n    });\\n  listen(this, VectorEventType.REMOVEFEATURE,\\n    function(evt) {\\n      if (!modifyingCollection) {\\n        modifyingCollection = true;\\n        collection.remove(evt.feature);\\n        modifyingCollection = false;\\n      }\\n    });\\n  listen(collection, CollectionEventType.ADD,\\n    function(evt) {\\n      if (!modifyingCollection) {\\n        modifyingCollection = true;\\n        this.addFeature(/** @type {module:ol/Feature} */ (evt.element));\\n        modifyingCollection = false;\\n      }\\n    }, this);\\n  listen(collection, CollectionEventType.REMOVE,\\n    function(evt) {\\n      if (!modifyingCollection) {\\n        modifyingCollection = true;\\n        this.removeFeature(/** @type {module:ol/Feature} */ (evt.element));\\n        modifyingCollection = false;\\n      }\\n    }, this);\\n  this.featuresCollection_ = collection;\\n};\\n\\n\\n/**\\n * Remove all features from the source.\\n * @param {boolean=} opt_fast Skip dispatching of {@link module:ol/source/Vector~VectorSourceEvent#removefeature} events.\\n * @api\\n */\\nVectorSource.prototype.clear = function(opt_fast) {\\n  if (opt_fast) {\\n    for (const featureId in this.featureChangeKeys_) {\\n      const keys = this.featureChangeKeys_[featureId];\\n      keys.forEach(unlistenByKey);\\n    }\\n    if (!this.featuresCollection_) {\\n      this.featureChangeKeys_ = {};\\n      this.idIndex_ = {};\\n      this.undefIdIndex_ = {};\\n    }\\n  } else {\\n    if (this.featuresRtree_) {\\n      this.featuresRtree_.forEach(this.removeFeatureInternal, this);\\n      for (const id in this.nullGeometryFeatures_) {\\n        this.removeFeatureInternal(this.nullGeometryFeatures_[id]);\\n      }\\n    }\\n  }\\n  if (this.featuresCollection_) {\\n    this.featuresCollection_.clear();\\n  }\\n\\n  if (this.featuresRtree_) {\\n    this.featuresRtree_.clear();\\n  }\\n  this.loadedExtentsRtree_.clear();\\n  this.nullGeometryFeatures_ = {};\\n\\n  const clearEvent = new VectorSourceEvent(VectorEventType.CLEAR);\\n  this.dispatchEvent(clearEvent);\\n  this.changed();\\n};\\n\\n\\n/**\\n * Iterate through all features on the source, calling the provided callback\\n * with each one.  If the callback returns any \\\"truthy\\\" value, iteration will\\n * stop and the function will return the same value.\\n * Note: this function only iterate through the feature that have a defined geometry.\\n *\\n * @param {function(module:ol/Feature): T} callback Called with each feature\\n *     on the source.  Return a truthy value to stop iteration.\\n * @return {T|undefined} The return value from the last call to the callback.\\n * @template T\\n * @api\\n */\\nVectorSource.prototype.forEachFeature = function(callback) {\\n  if (this.featuresRtree_) {\\n    return this.featuresRtree_.forEach(callback);\\n  } else if (this.featuresCollection_) {\\n    return this.featuresCollection_.forEach(callback);\\n  }\\n};\\n\\n\\n/**\\n * Iterate through all features whose geometries contain the provided\\n * coordinate, calling the callback with each feature.  If the callback returns\\n * a \\\"truthy\\\" value, iteration will stop and the function will return the same\\n * value.\\n *\\n * @param {module:ol/coordinate~Coordinate} coordinate Coordinate.\\n * @param {function(module:ol/Feature): T} callback Called with each feature\\n *     whose goemetry contains the provided coordinate.\\n * @return {T|undefined} The return value from the last call to the callback.\\n * @template T\\n */\\nVectorSource.prototype.forEachFeatureAtCoordinateDirect = function(coordinate, callback) {\\n  const extent = [coordinate[0], coordinate[1], coordinate[0], coordinate[1]];\\n  return this.forEachFeatureInExtent(extent, function(feature) {\\n    const geometry = feature.getGeometry();\\n    if (geometry.intersectsCoordinate(coordinate)) {\\n      return callback(feature);\\n    } else {\\n      return undefined;\\n    }\\n  });\\n};\\n\\n\\n/**\\n * Iterate through all features whose bounding box intersects the provided\\n * extent (note that the feature's geometry may not intersect the extent),\\n * calling the callback with each feature.  If the callback returns a \\\"truthy\\\"\\n * value, iteration will stop and the function will return the same value.\\n *\\n * If you are interested in features whose geometry intersects an extent, call\\n * the {@link module:ol/source/Vector~VectorSource#forEachFeatureIntersectingExtent #forEachFeatureIntersectingExtent()} method instead.\\n *\\n * When `useSpatialIndex` is set to false, this method will loop through all\\n * features, equivalent to {@link module:ol/source/Vector~VectorSource#forEachFeature #forEachFeature()}.\\n *\\n * @param {module:ol/extent~Extent} extent Extent.\\n * @param {function(module:ol/Feature): T} callback Called with each feature\\n *     whose bounding box intersects the provided extent.\\n * @return {T|undefined} The return value from the last call to the callback.\\n * @template T\\n * @api\\n */\\nVectorSource.prototype.forEachFeatureInExtent = function(extent, callback) {\\n  if (this.featuresRtree_) {\\n    return this.featuresRtree_.forEachInExtent(extent, callback);\\n  } else if (this.featuresCollection_) {\\n    return this.featuresCollection_.forEach(callback);\\n  }\\n};\\n\\n\\n/**\\n * Iterate through all features whose geometry intersects the provided extent,\\n * calling the callback with each feature.  If the callback returns a \\\"truthy\\\"\\n * value, iteration will stop and the function will return the same value.\\n *\\n * If you only want to test for bounding box intersection, call the\\n * {@link module:ol/source/Vector~VectorSource#forEachFeatureInExtent #forEachFeatureInExtent()} method instead.\\n *\\n * @param {module:ol/extent~Extent} extent Extent.\\n * @param {function(module:ol/Feature): T} callback Called with each feature\\n *     whose geometry intersects the provided extent.\\n * @return {T|undefined} The return value from the last call to the callback.\\n * @template T\\n * @api\\n */\\nVectorSource.prototype.forEachFeatureIntersectingExtent = function(extent, callback) {\\n  return this.forEachFeatureInExtent(extent,\\n    /**\\n     * @param {module:ol/Feature} feature Feature.\\n     * @return {T|undefined} The return value from the last call to the callback.\\n     * @template T\\n     */\\n    function(feature) {\\n      const geometry = feature.getGeometry();\\n      if (geometry.intersectsExtent(extent)) {\\n        const result = callback(feature);\\n        if (result) {\\n          return result;\\n        }\\n      }\\n    });\\n};\\n\\n\\n/**\\n * Get the features collection associated with this source. Will be `null`\\n * unless the source was configured with `useSpatialIndex` set to `false`, or\\n * with an {@link module:ol/Collection} as `features`.\\n * @return {module:ol/Collection.<module:ol/Feature>} The collection of features.\\n * @api\\n */\\nVectorSource.prototype.getFeaturesCollection = function() {\\n  return this.featuresCollection_;\\n};\\n\\n\\n/**\\n * Get all features on the source in random order.\\n * @return {Array.<module:ol/Feature>} Features.\\n * @api\\n */\\nVectorSource.prototype.getFeatures = function() {\\n  let features;\\n  if (this.featuresCollection_) {\\n    features = this.featuresCollection_.getArray();\\n  } else if (this.featuresRtree_) {\\n    features = this.featuresRtree_.getAll();\\n    if (!isEmpty(this.nullGeometryFeatures_)) {\\n      extend(features, getValues(this.nullGeometryFeatures_));\\n    }\\n  }\\n  return (\\n    /** @type {Array.<module:ol/Feature>} */ (features)\\n  );\\n};\\n\\n\\n/**\\n * Get all features whose geometry intersects the provided coordinate.\\n * @param {module:ol/coordinate~Coordinate} coordinate Coordinate.\\n * @return {Array.<module:ol/Feature>} Features.\\n * @api\\n */\\nVectorSource.prototype.getFeaturesAtCoordinate = function(coordinate) {\\n  const features = [];\\n  this.forEachFeatureAtCoordinateDirect(coordinate, function(feature) {\\n    features.push(feature);\\n  });\\n  return features;\\n};\\n\\n\\n/**\\n * Get all features in the provided extent.  Note that this returns an array of\\n * all features intersecting the given extent in random order (so it may include\\n * features whose geometries do not intersect the extent).\\n *\\n * This method is not available when the source is configured with\\n * `useSpatialIndex` set to `false`.\\n * @param {module:ol/extent~Extent} extent Extent.\\n * @return {Array.<module:ol/Feature>} Features.\\n * @api\\n */\\nVectorSource.prototype.getFeaturesInExtent = function(extent) {\\n  return this.featuresRtree_.getInExtent(extent);\\n};\\n\\n\\n/**\\n * Get the closest feature to the provided coordinate.\\n *\\n * This method is not available when the source is configured with\\n * `useSpatialIndex` set to `false`.\\n * @param {module:ol/coordinate~Coordinate} coordinate Coordinate.\\n * @param {function(module:ol/Feature):boolean=} opt_filter Feature filter function.\\n *     The filter function will receive one argument, the {@link module:ol/Feature feature}\\n *     and it should return a boolean value. By default, no filtering is made.\\n * @return {module:ol/Feature} Closest feature.\\n * @api\\n */\\nVectorSource.prototype.getClosestFeatureToCoordinate = function(coordinate, opt_filter) {\\n  // Find the closest feature using branch and bound.  We start searching an\\n  // infinite extent, and find the distance from the first feature found.  This\\n  // becomes the closest feature.  We then compute a smaller extent which any\\n  // closer feature must intersect.  We continue searching with this smaller\\n  // extent, trying to find a closer feature.  Every time we find a closer\\n  // feature, we update the extent being searched so that any even closer\\n  // feature must intersect it.  We continue until we run out of features.\\n  const x = coordinate[0];\\n  const y = coordinate[1];\\n  let closestFeature = null;\\n  const closestPoint = [NaN, NaN];\\n  let minSquaredDistance = Infinity;\\n  const extent = [-Infinity, -Infinity, Infinity, Infinity];\\n  const filter = opt_filter ? opt_filter : TRUE;\\n  this.featuresRtree_.forEachInExtent(extent,\\n    /**\\n     * @param {module:ol/Feature} feature Feature.\\n     */\\n    function(feature) {\\n      if (filter(feature)) {\\n        const geometry = feature.getGeometry();\\n        const previousMinSquaredDistance = minSquaredDistance;\\n        minSquaredDistance = geometry.closestPointXY(\\n          x, y, closestPoint, minSquaredDistance);\\n        if (minSquaredDistance < previousMinSquaredDistance) {\\n          closestFeature = feature;\\n          // This is sneaky.  Reduce the extent that it is currently being\\n          // searched while the R-Tree traversal using this same extent object\\n          // is still in progress.  This is safe because the new extent is\\n          // strictly contained by the old extent.\\n          const minDistance = Math.sqrt(minSquaredDistance);\\n          extent[0] = x - minDistance;\\n          extent[1] = y - minDistance;\\n          extent[2] = x + minDistance;\\n          extent[3] = y + minDistance;\\n        }\\n      }\\n    });\\n  return closestFeature;\\n};\\n\\n\\n/**\\n * Get the extent of the features currently in the source.\\n *\\n * This method is not available when the source is configured with\\n * `useSpatialIndex` set to `false`.\\n * @param {module:ol/extent~Extent=} opt_extent Destination extent. If provided, no new extent\\n *     will be created. Instead, that extent's coordinates will be overwritten.\\n * @return {module:ol/extent~Extent} Extent.\\n * @api\\n */\\nVectorSource.prototype.getExtent = function(opt_extent) {\\n  return this.featuresRtree_.getExtent(opt_extent);\\n};\\n\\n\\n/**\\n * Get a feature by its identifier (the value returned by feature.getId()).\\n * Note that the index treats string and numeric identifiers as the same.  So\\n * `source.getFeatureById(2)` will return a feature with id `'2'` or `2`.\\n *\\n * @param {string|number} id Feature identifier.\\n * @return {module:ol/Feature} The feature (or `null` if not found).\\n * @api\\n */\\nVectorSource.prototype.getFeatureById = function(id) {\\n  const feature = this.idIndex_[id.toString()];\\n  return feature !== undefined ? feature : null;\\n};\\n\\n\\n/**\\n * Get the format associated with this source.\\n *\\n * @return {module:ol/format/Feature|undefined} The feature format.\\n * @api\\n */\\nVectorSource.prototype.getFormat = function() {\\n  return this.format_;\\n};\\n\\n\\n/**\\n * @return {boolean} The source can have overlapping geometries.\\n */\\nVectorSource.prototype.getOverlaps = function() {\\n  return this.overlaps_;\\n};\\n\\n\\n/**\\n * @override\\n */\\nVectorSource.prototype.getResolutions = function() {};\\n\\n\\n/**\\n * Get the url associated with this source.\\n *\\n * @return {string|module:ol/featureloader~FeatureUrlFunction|undefined} The url.\\n * @api\\n */\\nVectorSource.prototype.getUrl = function() {\\n  return this.url_;\\n};\\n\\n\\n/**\\n * @param {module:ol/events/Event} event Event.\\n * @private\\n */\\nVectorSource.prototype.handleFeatureChange_ = function(event) {\\n  const feature = /** @type {module:ol/Feature} */ (event.target);\\n  const featureKey = getUid(feature).toString();\\n  const geometry = feature.getGeometry();\\n  if (!geometry) {\\n    if (!(featureKey in this.nullGeometryFeatures_)) {\\n      if (this.featuresRtree_) {\\n        this.featuresRtree_.remove(feature);\\n      }\\n      this.nullGeometryFeatures_[featureKey] = feature;\\n    }\\n  } else {\\n    const extent = geometry.getExtent();\\n    if (featureKey in this.nullGeometryFeatures_) {\\n      delete this.nullGeometryFeatures_[featureKey];\\n      if (this.featuresRtree_) {\\n        this.featuresRtree_.insert(extent, feature);\\n      }\\n    } else {\\n      if (this.featuresRtree_) {\\n        this.featuresRtree_.update(extent, feature);\\n      }\\n    }\\n  }\\n  const id = feature.getId();\\n  if (id !== undefined) {\\n    const sid = id.toString();\\n    if (featureKey in this.undefIdIndex_) {\\n      delete this.undefIdIndex_[featureKey];\\n      this.idIndex_[sid] = feature;\\n    } else {\\n      if (this.idIndex_[sid] !== feature) {\\n        this.removeFromIdIndex_(feature);\\n        this.idIndex_[sid] = feature;\\n      }\\n    }\\n  } else {\\n    if (!(featureKey in this.undefIdIndex_)) {\\n      this.removeFromIdIndex_(feature);\\n      this.undefIdIndex_[featureKey] = feature;\\n    }\\n  }\\n  this.changed();\\n  this.dispatchEvent(new VectorSourceEvent(\\n    VectorEventType.CHANGEFEATURE, feature));\\n};\\n\\n/**\\n * Returns true if the feature is contained within the source.\\n * @param {module:ol/Feature} feature Feature.\\n * @return {boolean} Has feature.\\n * @api\\n */\\nVectorSource.prototype.hasFeature = function(feature) {\\n  const id = feature.getId();\\n  if (id !== undefined) {\\n    return id in this.idIndex_;\\n  } else {\\n    const featureKey = getUid(feature).toString();\\n    return featureKey in this.undefIdIndex_;\\n  }\\n};\\n\\n/**\\n * @return {boolean} Is empty.\\n */\\nVectorSource.prototype.isEmpty = function() {\\n  return this.featuresRtree_.isEmpty() && isEmpty(this.nullGeometryFeatures_);\\n};\\n\\n\\n/**\\n * @param {module:ol/extent~Extent} extent Extent.\\n * @param {number} resolution Resolution.\\n * @param {module:ol/proj/Projection} projection Projection.\\n */\\nVectorSource.prototype.loadFeatures = function(extent, resolution, projection) {\\n  const loadedExtentsRtree = this.loadedExtentsRtree_;\\n  const extentsToLoad = this.strategy_(extent, resolution);\\n  for (let i = 0, ii = extentsToLoad.length; i < ii; ++i) {\\n    const extentToLoad = extentsToLoad[i];\\n    const alreadyLoaded = loadedExtentsRtree.forEachInExtent(extentToLoad,\\n      /**\\n       * @param {{extent: module:ol/extent~Extent}} object Object.\\n       * @return {boolean} Contains.\\n       */\\n      function(object) {\\n        return containsExtent(object.extent, extentToLoad);\\n      });\\n    if (!alreadyLoaded) {\\n      this.loader_.call(this, extentToLoad, resolution, projection);\\n      loadedExtentsRtree.insert(extentToLoad, {extent: extentToLoad.slice()});\\n    }\\n  }\\n};\\n\\n\\n/**\\n * Remove an extent from the list of loaded extents.\\n * @param {module:ol/extent~Extent} extent Extent.\\n * @api\\n */\\nVectorSource.prototype.removeLoadedExtent = function(extent) {\\n  const loadedExtentsRtree = this.loadedExtentsRtree_;\\n  let obj;\\n  loadedExtentsRtree.forEachInExtent(extent, function(object) {\\n    if (equals(object.extent, extent)) {\\n      obj = object;\\n      return true;\\n    }\\n  });\\n  if (obj) {\\n    loadedExtentsRtree.remove(obj);\\n  }\\n};\\n\\n\\n/**\\n * Remove a single feature from the source.  If you want to remove all features\\n * at once, use the {@link module:ol/source/Vector~VectorSource#clear #clear()} method\\n * instead.\\n * @param {module:ol/Feature} feature Feature to remove.\\n * @api\\n */\\nVectorSource.prototype.removeFeature = function(feature) {\\n  const featureKey = getUid(feature).toString();\\n  if (featureKey in this.nullGeometryFeatures_) {\\n    delete this.nullGeometryFeatures_[featureKey];\\n  } else {\\n    if (this.featuresRtree_) {\\n      this.featuresRtree_.remove(feature);\\n    }\\n  }\\n  this.removeFeatureInternal(feature);\\n  this.changed();\\n};\\n\\n\\n/**\\n * Remove feature without firing a `change` event.\\n * @param {module:ol/Feature} feature Feature.\\n * @protected\\n */\\nVectorSource.prototype.removeFeatureInternal = function(feature) {\\n  const featureKey = getUid(feature).toString();\\n  this.featureChangeKeys_[featureKey].forEach(unlistenByKey);\\n  delete this.featureChangeKeys_[featureKey];\\n  const id = feature.getId();\\n  if (id !== undefined) {\\n    delete this.idIndex_[id.toString()];\\n  } else {\\n    delete this.undefIdIndex_[featureKey];\\n  }\\n  this.dispatchEvent(new VectorSourceEvent(\\n    VectorEventType.REMOVEFEATURE, feature));\\n};\\n\\n\\n/**\\n * Remove a feature from the id index.  Called internally when the feature id\\n * may have changed.\\n * @param {module:ol/Feature} feature The feature.\\n * @return {boolean} Removed the feature from the index.\\n * @private\\n */\\nVectorSource.prototype.removeFromIdIndex_ = function(feature) {\\n  let removed = false;\\n  for (const id in this.idIndex_) {\\n    if (this.idIndex_[id] === feature) {\\n      delete this.idIndex_[id];\\n      removed = true;\\n      break;\\n    }\\n  }\\n  return removed;\\n};\\n\\n\\n/**\\n * Set the new loader of the source. The next loadFeatures call will use the\\n * new loader.\\n * @param {module:ol/featureloader~FeatureLoader} loader The loader to set.\\n * @api\\n */\\nVectorSource.prototype.setLoader = function(loader) {\\n  this.loader_ = loader;\\n};\\n\\nexport default VectorSource;\\n\",\"/**\\n * @module ol/interaction/Draw\\n */\\nimport {inherits} from '../index.js';\\nimport EventType from '../events/EventType.js';\\nimport Feature from '../Feature.js';\\nimport MapBrowserEventType from '../MapBrowserEventType.js';\\nimport MapBrowserPointerEvent from '../MapBrowserPointerEvent.js';\\nimport {getChangeEventType} from '../Object.js';\\nimport {squaredDistance as squaredCoordinateDistance} from '../coordinate.js';\\nimport {listen} from '../events.js';\\nimport Event from '../events/Event.js';\\nimport {noModifierKeys, always, shiftKeyOnly} from '../events/condition.js';\\nimport {boundingExtent, getBottomLeft, getBottomRight, getTopLeft, getTopRight} from '../extent.js';\\nimport {TRUE, FALSE} from '../functions.js';\\nimport Circle from '../geom/Circle.js';\\nimport GeometryType from '../geom/GeometryType.js';\\nimport LineString from '../geom/LineString.js';\\nimport MultiLineString from '../geom/MultiLineString.js';\\nimport MultiPoint from '../geom/MultiPoint.js';\\nimport MultiPolygon from '../geom/MultiPolygon.js';\\nimport {POINTER_TYPE} from '../pointer/MouseSource.js';\\nimport Point from '../geom/Point.js';\\nimport Polygon, {fromCircle, makeRegular} from '../geom/Polygon.js';\\nimport PointerInteraction, {handleEvent as handlePointerEvent} from '../interaction/Pointer.js';\\nimport InteractionProperty from '../interaction/Property.js';\\nimport VectorLayer from '../layer/Vector.js';\\nimport VectorSource from '../source/Vector.js';\\nimport {createEditingStyle} from '../style/Style.js';\\n\\n\\n/**\\n * @typedef {Object} Options\\n * @property {module:ol/geom/GeometryType} type Geometry type of\\n * the geometries being drawn with this instance.\\n * @property {number} [clickTolerance=6] The maximum distance in pixels between\\n * \\\"down\\\" and \\\"up\\\" for a \\\"up\\\" event to be considered a \\\"click\\\" event and\\n * actually add a point/vertex to the geometry being drawn.  The default of `6`\\n * was chosen for the draw interaction to behave correctly on mouse as well as\\n * on touch devices.\\n * @property {module:ol/Collection.<module:ol/Feature>} [features]\\n * Destination collection for the drawn features.\\n * @property {module:ol/source/Vector} [source] Destination source for\\n * the drawn features.\\n * @property {number} [dragVertexDelay=500] Delay in milliseconds after pointerdown\\n * before the current vertex can be dragged to its exact position.\\n * @property {number} [snapTolerance=12] Pixel distance for snapping to the\\n * drawing finish.\\n * @property {boolean} [stopClick=false] Stop click, singleclick, and\\n * doubleclick events from firing during drawing.\\n * @property {number} [maxPoints] The number of points that can be drawn before\\n * a polygon ring or line string is finished. By default there is no\\n * restriction.\\n * @property {number} [minPoints] The number of points that must be drawn\\n * before a polygon ring or line string can be finished. Default is `3` for\\n * polygon rings and `2` for line strings.\\n * @property {module:ol/events/condition~Condition} [finishCondition] A function\\n * that takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a\\n * boolean to indicate whether the drawing can be finished.\\n * @property {module:ol/style/Style|Array.<module:ol/style/Style>|module:ol/style/Style~StyleFunction} [style]\\n * Style for sketch features.\\n * @property {module:ol/interaction/Draw~GeometryFunction} [geometryFunction]\\n * Function that is called when a geometry's coordinates are updated.\\n * @property {string} [geometryName] Geometry name to use for features created\\n * by the draw interaction.\\n * @property {module:ol/events/condition~Condition} [condition] A function that\\n * takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a\\n * boolean to indicate whether that event should be handled.\\n * By default {@link module:ol/events/condition~noModifierKeys}, i.e. a click,\\n * adds a vertex or deactivates freehand drawing.\\n * @property {boolean} [freehand=false] Operate in freehand mode for lines,\\n * polygons, and circles.  This makes the interaction always operate in freehand\\n * mode and takes precedence over any `freehandCondition` option.\\n * @property {module:ol/events/condition~Condition} [freehandCondition]\\n * Condition that activates freehand drawing for lines and polygons. This\\n * function takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and\\n * returns a boolean to indicate whether that event should be handled. The\\n * default is {@link module:ol/events/condition~shiftKeyOnly}, meaning that the\\n * Shift key activates freehand drawing.\\n * @property {boolean} [wrapX=false] Wrap the world horizontally on the sketch\\n * overlay.\\n */\\n\\n\\n/**\\n * Function that takes an array of coordinates and an optional existing geometry as\\n * arguments, and returns a geometry. The optional existing geometry is the\\n * geometry that is returned when the function is called without a second\\n * argument.\\n * @typedef {function(!Array.<module:ol/coordinate~Coordinate>, module:ol/geom/SimpleGeometry=):\\n *     module:ol/geom/SimpleGeometry} GeometryFunction\\n */\\n\\n\\n/**\\n * Draw mode.  This collapses multi-part geometry types with their single-part\\n * cousins.\\n * @enum {string}\\n */\\nconst Mode = {\\n  POINT: 'Point',\\n  LINE_STRING: 'LineString',\\n  POLYGON: 'Polygon',\\n  CIRCLE: 'Circle'\\n};\\n\\n\\n/**\\n * @enum {string}\\n */\\nconst DrawEventType = {\\n  /**\\n   * Triggered upon feature draw start\\n   * @event module:ol/interaction/Draw~DrawEvent#drawstart\\n   * @api\\n   */\\n  DRAWSTART: 'drawstart',\\n  /**\\n   * Triggered upon feature draw end\\n   * @event module:ol/interaction/Draw~DrawEvent#drawend\\n   * @api\\n   */\\n  DRAWEND: 'drawend'\\n};\\n\\n\\n/**\\n * @classdesc\\n * Events emitted by {@link module:ol/interaction/Draw~Draw} instances are\\n * instances of this type.\\n *\\n * @constructor\\n * @extends {module:ol/events/Event}\\n * @param {module:ol/interaction/Draw~DrawEventType} type Type.\\n * @param {module:ol/Feature} feature The feature drawn.\\n */\\nconst DrawEvent = function(type, feature) {\\n\\n  Event.call(this, type);\\n\\n  /**\\n   * The feature being drawn.\\n   * @type {module:ol/Feature}\\n   * @api\\n   */\\n  this.feature = feature;\\n\\n};\\n\\ninherits(DrawEvent, Event);\\n\\n\\n/**\\n * @classdesc\\n * Interaction for drawing feature geometries.\\n *\\n * @constructor\\n * @extends {module:ol/interaction/Pointer}\\n * @fires module:ol/interaction/Draw~DrawEvent\\n * @param {module:ol/interaction/Draw~Options} options Options.\\n * @api\\n */\\nconst Draw = function(options) {\\n\\n  PointerInteraction.call(this, {\\n    handleDownEvent: handleDownEvent,\\n    handleEvent: handleEvent,\\n    handleUpEvent: handleUpEvent\\n  });\\n\\n  /**\\n   * @type {boolean}\\n   * @private\\n   */\\n  this.shouldHandle_ = false;\\n\\n  /**\\n   * @type {module:ol~Pixel}\\n   * @private\\n   */\\n  this.downPx_ = null;\\n\\n  /**\\n   * @type {number|undefined}\\n   * @private\\n   */\\n  this.downTimeout_;\\n\\n  /**\\n   * @type {number|undefined}\\n   * @private\\n   */\\n  this.lastDragTime_;\\n\\n  /**\\n   * @type {boolean}\\n   * @private\\n   */\\n  this.freehand_ = false;\\n\\n  /**\\n   * Target source for drawn features.\\n   * @type {module:ol/source/Vector}\\n   * @private\\n   */\\n  this.source_ = options.source ? options.source : null;\\n\\n  /**\\n   * Target collection for drawn features.\\n   * @type {module:ol/Collection.<module:ol/Feature>}\\n   * @private\\n   */\\n  this.features_ = options.features ? options.features : null;\\n\\n  /**\\n   * Pixel distance for snapping.\\n   * @type {number}\\n   * @private\\n   */\\n  this.snapTolerance_ = options.snapTolerance ? options.snapTolerance : 12;\\n\\n  /**\\n   * Geometry type.\\n   * @type {module:ol/geom/GeometryType}\\n   * @private\\n   */\\n  this.type_ = /** @type {module:ol/geom/GeometryType} */ (options.type);\\n\\n  /**\\n   * Drawing mode (derived from geometry type.\\n   * @type {module:ol/interaction/Draw~Mode}\\n   * @private\\n   */\\n  this.mode_ = getMode(this.type_);\\n\\n  /**\\n   * Stop click, singleclick, and doubleclick events from firing during drawing.\\n   * Default is `false`.\\n   * @type {boolean}\\n   * @private\\n   */\\n  this.stopClick_ = !!options.stopClick;\\n\\n  /**\\n   * The number of points that must be drawn before a polygon ring or line\\n   * string can be finished.  The default is 3 for polygon rings and 2 for\\n   * line strings.\\n   * @type {number}\\n   * @private\\n   */\\n  this.minPoints_ = options.minPoints ?\\n    options.minPoints :\\n    (this.mode_ === Mode.POLYGON ? 3 : 2);\\n\\n  /**\\n   * The number of points that can be drawn before a polygon ring or line string\\n   * is finished. The default is no restriction.\\n   * @type {number}\\n   * @private\\n   */\\n  this.maxPoints_ = options.maxPoints ? options.maxPoints : Infinity;\\n\\n  /**\\n   * A function to decide if a potential finish coordinate is permissible\\n   * @private\\n   * @type {module:ol/events/condition~Condition}\\n   */\\n  this.finishCondition_ = options.finishCondition ? options.finishCondition : TRUE;\\n\\n  let geometryFunction = options.geometryFunction;\\n  if (!geometryFunction) {\\n    if (this.type_ === GeometryType.CIRCLE) {\\n      /**\\n       * @param {!Array.<module:ol/coordinate~Coordinate>} coordinates\\n       *     The coordinates.\\n       * @param {module:ol/geom/SimpleGeometry=} opt_geometry Optional geometry.\\n       * @return {module:ol/geom/SimpleGeometry} A geometry.\\n       */\\n      geometryFunction = function(coordinates, opt_geometry) {\\n        const circle = opt_geometry ? /** @type {module:ol/geom/Circle} */ (opt_geometry) :\\n          new Circle([NaN, NaN]);\\n        const squaredLength = squaredCoordinateDistance(\\n          coordinates[0], coordinates[1]);\\n        circle.setCenterAndRadius(coordinates[0], Math.sqrt(squaredLength));\\n        return circle;\\n      };\\n    } else {\\n      let Constructor;\\n      const mode = this.mode_;\\n      if (mode === Mode.POINT) {\\n        Constructor = Point;\\n      } else if (mode === Mode.LINE_STRING) {\\n        Constructor = LineString;\\n      } else if (mode === Mode.POLYGON) {\\n        Constructor = Polygon;\\n      }\\n      /**\\n       * @param {!Array.<module:ol/coordinate~Coordinate>} coordinates\\n       *     The coordinates.\\n       * @param {module:ol/geom/SimpleGeometry=} opt_geometry Optional geometry.\\n       * @return {module:ol/geom/SimpleGeometry} A geometry.\\n       */\\n      geometryFunction = function(coordinates, opt_geometry) {\\n        let geometry = opt_geometry;\\n        if (geometry) {\\n          if (mode === Mode.POLYGON) {\\n            if (coordinates[0].length) {\\n              // Add a closing coordinate to match the first\\n              geometry.setCoordinates([coordinates[0].concat([coordinates[0][0]])]);\\n            } else {\\n              geometry.setCoordinates([]);\\n            }\\n          } else {\\n            geometry.setCoordinates(coordinates);\\n          }\\n        } else {\\n          geometry = new Constructor(coordinates);\\n        }\\n        return geometry;\\n      };\\n    }\\n  }\\n\\n  /**\\n   * @type {module:ol/interaction/Draw~GeometryFunction}\\n   * @private\\n   */\\n  this.geometryFunction_ = geometryFunction;\\n\\n  /**\\n   * @type {number}\\n   * @private\\n   */\\n  this.dragVertexDelay_ = options.dragVertexDelay !== undefined ? options.dragVertexDelay : 500;\\n\\n  /**\\n   * Finish coordinate for the feature (first point for polygons, last point for\\n   * linestrings).\\n   * @type {module:ol/coordinate~Coordinate}\\n   * @private\\n   */\\n  this.finishCoordinate_ = null;\\n\\n  /**\\n   * Sketch feature.\\n   * @type {module:ol/Feature}\\n   * @private\\n   */\\n  this.sketchFeature_ = null;\\n\\n  /**\\n   * Sketch point.\\n   * @type {module:ol/Feature}\\n   * @private\\n   */\\n  this.sketchPoint_ = null;\\n\\n  /**\\n   * Sketch coordinates. Used when drawing a line or polygon.\\n   * @type {module:ol/coordinate~Coordinate|Array.<module:ol/coordinate~Coordinate>|Array.<Array.<module:ol/coordinate~Coordinate>>}\\n   * @private\\n   */\\n  this.sketchCoords_ = null;\\n\\n  /**\\n   * Sketch line. Used when drawing polygon.\\n   * @type {module:ol/Feature}\\n   * @private\\n   */\\n  this.sketchLine_ = null;\\n\\n  /**\\n   * Sketch line coordinates. Used when drawing a polygon or circle.\\n   * @type {Array.<module:ol/coordinate~Coordinate>}\\n   * @private\\n   */\\n  this.sketchLineCoords_ = null;\\n\\n  /**\\n   * Squared tolerance for handling up events.  If the squared distance\\n   * between a down and up event is greater than this tolerance, up events\\n   * will not be handled.\\n   * @type {number}\\n   * @private\\n   */\\n  this.squaredClickTolerance_ = options.clickTolerance ?\\n    options.clickTolerance * options.clickTolerance : 36;\\n\\n  /**\\n   * Draw overlay where our sketch features are drawn.\\n   * @type {module:ol/layer/Vector}\\n   * @private\\n   */\\n  this.overlay_ = new VectorLayer({\\n    source: new VectorSource({\\n      useSpatialIndex: false,\\n      wrapX: options.wrapX ? options.wrapX : false\\n    }),\\n    style: options.style ? options.style :\\n      getDefaultStyleFunction(),\\n    updateWhileInteracting: true\\n  });\\n\\n  /**\\n   * Name of the geometry attribute for newly created features.\\n   * @type {string|undefined}\\n   * @private\\n   */\\n  this.geometryName_ = options.geometryName;\\n\\n  /**\\n   * @private\\n   * @type {module:ol/events/condition~Condition}\\n   */\\n  this.condition_ = options.condition ? options.condition : noModifierKeys;\\n\\n  /**\\n   * @private\\n   * @type {module:ol/events/condition~Condition}\\n   */\\n  this.freehandCondition_;\\n  if (options.freehand) {\\n    this.freehandCondition_ = always;\\n  } else {\\n    this.freehandCondition_ = options.freehandCondition ?\\n      options.freehandCondition : shiftKeyOnly;\\n  }\\n\\n  listen(this,\\n    getChangeEventType(InteractionProperty.ACTIVE),\\n    this.updateState_, this);\\n\\n};\\n\\ninherits(Draw, PointerInteraction);\\n\\n\\n/**\\n * @return {module:ol/style/Style~StyleFunction} Styles.\\n */\\nfunction getDefaultStyleFunction() {\\n  const styles = createEditingStyle();\\n  return function(feature, resolution) {\\n    return styles[feature.getGeometry().getType()];\\n  };\\n}\\n\\n\\n/**\\n * @inheritDoc\\n */\\nDraw.prototype.setMap = function(map) {\\n  PointerInteraction.prototype.setMap.call(this, map);\\n  this.updateState_();\\n};\\n\\n\\n/**\\n * Handles the {@link module:ol/MapBrowserEvent map browser event} and may actually\\n * draw or finish the drawing.\\n * @param {module:ol/MapBrowserEvent} event Map browser event.\\n * @return {boolean} `false` to stop event propagation.\\n * @this {module:ol/interaction/Draw}\\n * @api\\n */\\nexport function handleEvent(event) {\\n  if (event.originalEvent.type === EventType.CONTEXTMENU) {\\n    // Avoid context menu for long taps when drawing on mobile\\n    event.preventDefault();\\n  }\\n  this.freehand_ = this.mode_ !== Mode.POINT && this.freehandCondition_(event);\\n  let move = event.type === MapBrowserEventType.POINTERMOVE;\\n  let pass = true;\\n  if (this.lastDragTime_ && event.type === MapBrowserEventType.POINTERDRAG) {\\n    const now = Date.now();\\n    if (now - this.lastDragTime_ >= this.dragVertexDelay_) {\\n      this.downPx_ = event.pixel;\\n      this.shouldHandle_ = !this.freehand_;\\n      move = true;\\n    } else {\\n      this.lastDragTime_ = undefined;\\n    }\\n    if (this.shouldHandle_ && this.downTimeout_) {\\n      clearTimeout(this.downTimeout_);\\n      this.downTimeout_ = undefined;\\n    }\\n  }\\n  if (this.freehand_ &&\\n      event.type === MapBrowserEventType.POINTERDRAG &&\\n      this.sketchFeature_ !== null) {\\n    this.addToDrawing_(event);\\n    pass = false;\\n  } else if (this.freehand_ &&\\n      event.type === MapBrowserEventType.POINTERDOWN) {\\n    pass = false;\\n  } else if (move) {\\n    pass = event.type === MapBrowserEventType.POINTERMOVE;\\n    if (pass && this.freehand_) {\\n      pass = this.handlePointerMove_(event);\\n    } else if (event.pointerEvent.pointerType == POINTER_TYPE ||\\n        (event.type === MapBrowserEventType.POINTERDRAG && !this.downTimeout_)) {\\n      this.handlePointerMove_(event);\\n    }\\n  } else if (event.type === MapBrowserEventType.DBLCLICK) {\\n    pass = false;\\n  }\\n\\n  return handlePointerEvent.call(this, event) && pass;\\n}\\n\\n\\n/**\\n * @param {module:ol/MapBrowserPointerEvent} event Event.\\n * @return {boolean} Start drag sequence?\\n * @this {module:ol/interaction/Draw}\\n */\\nfunction handleDownEvent(event) {\\n  this.shouldHandle_ = !this.freehand_;\\n\\n  if (this.freehand_) {\\n    this.downPx_ = event.pixel;\\n    if (!this.finishCoordinate_) {\\n      this.startDrawing_(event);\\n    }\\n    return true;\\n  } else if (this.condition_(event)) {\\n    this.lastDragTime_ = Date.now();\\n    this.downTimeout_ = setTimeout(function() {\\n      this.handlePointerMove_(new MapBrowserPointerEvent(\\n        MapBrowserEventType.POINTERMOVE, event.map, event.pointerEvent, event.frameState));\\n    }.bind(this), this.dragVertexDelay_);\\n    this.downPx_ = event.pixel;\\n    return true;\\n  } else {\\n    return false;\\n  }\\n}\\n\\n\\n/**\\n * @param {module:ol/MapBrowserPointerEvent} event Event.\\n * @return {boolean} Stop drag sequence?\\n * @this {module:ol/interaction/Draw}\\n */\\nfunction handleUpEvent(event) {\\n  let pass = true;\\n\\n  if (this.downTimeout_) {\\n    clearTimeout(this.downTimeout_);\\n    this.downTimeout_ = undefined;\\n  }\\n\\n  this.handlePointerMove_(event);\\n\\n  const circleMode = this.mode_ === Mode.CIRCLE;\\n\\n  if (this.shouldHandle_) {\\n    if (!this.finishCoordinate_) {\\n      this.startDrawing_(event);\\n      if (this.mode_ === Mode.POINT) {\\n        this.finishDrawing();\\n      }\\n    } else if (this.freehand_ || circleMode) {\\n      this.finishDrawing();\\n    } else if (this.atFinish_(event)) {\\n      if (this.finishCondition_(event)) {\\n        this.finishDrawing();\\n      }\\n    } else {\\n      this.addToDrawing_(event);\\n    }\\n    pass = false;\\n  } else if (this.freehand_) {\\n    this.finishCoordinate_ = null;\\n    this.abortDrawing_();\\n  }\\n  if (!pass && this.stopClick_) {\\n    event.stopPropagation();\\n  }\\n  return pass;\\n}\\n\\n\\n/**\\n * Handle move events.\\n * @param {module:ol/MapBrowserEvent} event A move event.\\n * @return {boolean} Pass the event to other interactions.\\n * @private\\n */\\nDraw.prototype.handlePointerMove_ = function(event) {\\n  if (this.downPx_ &&\\n      ((!this.freehand_ && this.shouldHandle_) ||\\n      (this.freehand_ && !this.shouldHandle_))) {\\n    const downPx = this.downPx_;\\n    const clickPx = event.pixel;\\n    const dx = downPx[0] - clickPx[0];\\n    const dy = downPx[1] - clickPx[1];\\n    const squaredDistance = dx * dx + dy * dy;\\n    this.shouldHandle_ = this.freehand_ ?\\n      squaredDistance > this.squaredClickTolerance_ :\\n      squaredDistance <= this.squaredClickTolerance_;\\n    if (!this.shouldHandle_) {\\n      return true;\\n    }\\n  }\\n\\n  if (this.finishCoordinate_) {\\n    this.modifyDrawing_(event);\\n  } else {\\n    this.createOrUpdateSketchPoint_(event);\\n  }\\n  return true;\\n};\\n\\n\\n/**\\n * Determine if an event is within the snapping tolerance of the start coord.\\n * @param {module:ol/MapBrowserEvent} event Event.\\n * @return {boolean} The event is within the snapping tolerance of the start.\\n * @private\\n */\\nDraw.prototype.atFinish_ = function(event) {\\n  let at = false;\\n  if (this.sketchFeature_) {\\n    let potentiallyDone = false;\\n    let potentiallyFinishCoordinates = [this.finishCoordinate_];\\n    if (this.mode_ === Mode.LINE_STRING) {\\n      potentiallyDone = this.sketchCoords_.length > this.minPoints_;\\n    } else if (this.mode_ === Mode.POLYGON) {\\n      potentiallyDone = this.sketchCoords_[0].length >\\n          this.minPoints_;\\n      potentiallyFinishCoordinates = [this.sketchCoords_[0][0],\\n        this.sketchCoords_[0][this.sketchCoords_[0].length - 2]];\\n    }\\n    if (potentiallyDone) {\\n      const map = event.map;\\n      for (let i = 0, ii = potentiallyFinishCoordinates.length; i < ii; i++) {\\n        const finishCoordinate = potentiallyFinishCoordinates[i];\\n        const finishPixel = map.getPixelFromCoordinate(finishCoordinate);\\n        const pixel = event.pixel;\\n        const dx = pixel[0] - finishPixel[0];\\n        const dy = pixel[1] - finishPixel[1];\\n        const snapTolerance = this.freehand_ ? 1 : this.snapTolerance_;\\n        at = Math.sqrt(dx * dx + dy * dy) <= snapTolerance;\\n        if (at) {\\n          this.finishCoordinate_ = finishCoordinate;\\n          break;\\n        }\\n      }\\n    }\\n  }\\n  return at;\\n};\\n\\n\\n/**\\n * @param {module:ol/MapBrowserEvent} event Event.\\n * @private\\n */\\nDraw.prototype.createOrUpdateSketchPoint_ = function(event) {\\n  const coordinates = event.coordinate.slice();\\n  if (!this.sketchPoint_) {\\n    this.sketchPoint_ = new Feature(new Point(coordinates));\\n    this.updateSketchFeatures_();\\n  } else {\\n    const sketchPointGeom = /** @type {module:ol/geom/Point} */ (this.sketchPoint_.getGeometry());\\n    sketchPointGeom.setCoordinates(coordinates);\\n  }\\n};\\n\\n\\n/**\\n * Start the drawing.\\n * @param {module:ol/MapBrowserEvent} event Event.\\n * @private\\n */\\nDraw.prototype.startDrawing_ = function(event) {\\n  const start = event.coordinate;\\n  this.finishCoordinate_ = start;\\n  if (this.mode_ === Mode.POINT) {\\n    this.sketchCoords_ = start.slice();\\n  } else if (this.mode_ === Mode.POLYGON) {\\n    this.sketchCoords_ = [[start.slice(), start.slice()]];\\n    this.sketchLineCoords_ = this.sketchCoords_[0];\\n  } else {\\n    this.sketchCoords_ = [start.slice(), start.slice()];\\n  }\\n  if (this.sketchLineCoords_) {\\n    this.sketchLine_ = new Feature(\\n      new LineString(this.sketchLineCoords_));\\n  }\\n  const geometry = this.geometryFunction_(this.sketchCoords_);\\n  this.sketchFeature_ = new Feature();\\n  if (this.geometryName_) {\\n    this.sketchFeature_.setGeometryName(this.geometryName_);\\n  }\\n  this.sketchFeature_.setGeometry(geometry);\\n  this.updateSketchFeatures_();\\n  this.dispatchEvent(new DrawEvent(DrawEventType.DRAWSTART, this.sketchFeature_));\\n};\\n\\n\\n/**\\n * Modify the drawing.\\n * @param {module:ol/MapBrowserEvent} event Event.\\n * @private\\n */\\nDraw.prototype.modifyDrawing_ = function(event) {\\n  let coordinate = event.coordinate;\\n  const geometry = /** @type {module:ol/geom/SimpleGeometry} */ (this.sketchFeature_.getGeometry());\\n  let coordinates, last;\\n  if (this.mode_ === Mode.POINT) {\\n    last = this.sketchCoords_;\\n  } else if (this.mode_ === Mode.POLYGON) {\\n    coordinates = this.sketchCoords_[0];\\n    last = coordinates[coordinates.length - 1];\\n    if (this.atFinish_(event)) {\\n      // snap to finish\\n      coordinate = this.finishCoordinate_.slice();\\n    }\\n  } else {\\n    coordinates = this.sketchCoords_;\\n    last = coordinates[coordinates.length - 1];\\n  }\\n  last[0] = coordinate[0];\\n  last[1] = coordinate[1];\\n  this.geometryFunction_(/** @type {!Array.<module:ol/coordinate~Coordinate>} */ (this.sketchCoords_), geometry);\\n  if (this.sketchPoint_) {\\n    const sketchPointGeom = /** @type {module:ol/geom/Point} */ (this.sketchPoint_.getGeometry());\\n    sketchPointGeom.setCoordinates(coordinate);\\n  }\\n  let sketchLineGeom;\\n  if (geometry instanceof Polygon &&\\n      this.mode_ !== Mode.POLYGON) {\\n    if (!this.sketchLine_) {\\n      this.sketchLine_ = new Feature(new LineString(null));\\n    }\\n    const ring = geometry.getLinearRing(0);\\n    sketchLineGeom = /** @type {module:ol/geom/LineString} */ (this.sketchLine_.getGeometry());\\n    sketchLineGeom.setFlatCoordinates(\\n      ring.getLayout(), ring.getFlatCoordinates());\\n  } else if (this.sketchLineCoords_) {\\n    sketchLineGeom = /** @type {module:ol/geom/LineString} */ (this.sketchLine_.getGeometry());\\n    sketchLineGeom.setCoordinates(this.sketchLineCoords_);\\n  }\\n  this.updateSketchFeatures_();\\n};\\n\\n\\n/**\\n * Add a new coordinate to the drawing.\\n * @param {module:ol/MapBrowserEvent} event Event.\\n * @private\\n */\\nDraw.prototype.addToDrawing_ = function(event) {\\n  const coordinate = event.coordinate;\\n  const geometry = /** @type {module:ol/geom/SimpleGeometry} */ (this.sketchFeature_.getGeometry());\\n  let done;\\n  let coordinates;\\n  if (this.mode_ === Mode.LINE_STRING) {\\n    this.finishCoordinate_ = coordinate.slice();\\n    coordinates = this.sketchCoords_;\\n    if (coordinates.length >= this.maxPoints_) {\\n      if (this.freehand_) {\\n        coordinates.pop();\\n      } else {\\n        done = true;\\n      }\\n    }\\n    coordinates.push(coordinate.slice());\\n    this.geometryFunction_(coordinates, geometry);\\n  } else if (this.mode_ === Mode.POLYGON) {\\n    coordinates = this.sketchCoords_[0];\\n    if (coordinates.length >= this.maxPoints_) {\\n      if (this.freehand_) {\\n        coordinates.pop();\\n      } else {\\n        done = true;\\n      }\\n    }\\n    coordinates.push(coordinate.slice());\\n    if (done) {\\n      this.finishCoordinate_ = coordinates[0];\\n    }\\n    this.geometryFunction_(this.sketchCoords_, geometry);\\n  }\\n  this.updateSketchFeatures_();\\n  if (done) {\\n    this.finishDrawing();\\n  }\\n};\\n\\n\\n/**\\n * Remove last point of the feature currently being drawn.\\n * @api\\n */\\nDraw.prototype.removeLastPoint = function() {\\n  if (!this.sketchFeature_) {\\n    return;\\n  }\\n  const geometry = /** @type {module:ol/geom/SimpleGeometry} */ (this.sketchFeature_.getGeometry());\\n  let coordinates, sketchLineGeom;\\n  if (this.mode_ === Mode.LINE_STRING) {\\n    coordinates = this.sketchCoords_;\\n    coordinates.splice(-2, 1);\\n    this.geometryFunction_(coordinates, geometry);\\n    if (coordinates.length >= 2) {\\n      this.finishCoordinate_ = coordinates[coordinates.length - 2].slice();\\n    }\\n  } else if (this.mode_ === Mode.POLYGON) {\\n    coordinates = this.sketchCoords_[0];\\n    coordinates.splice(-2, 1);\\n    sketchLineGeom = /** @type {module:ol/geom/LineString} */ (this.sketchLine_.getGeometry());\\n    sketchLineGeom.setCoordinates(coordinates);\\n    this.geometryFunction_(this.sketchCoords_, geometry);\\n  }\\n\\n  if (coordinates.length === 0) {\\n    this.finishCoordinate_ = null;\\n  }\\n\\n  this.updateSketchFeatures_();\\n};\\n\\n\\n/**\\n * Stop drawing and add the sketch feature to the target layer.\\n * The {@link module:ol/interaction/Draw~DrawEventType.DRAWEND} event is\\n * dispatched before inserting the feature.\\n * @api\\n */\\nDraw.prototype.finishDrawing = function() {\\n  const sketchFeature = this.abortDrawing_();\\n  if (!sketchFeature) {\\n    return;\\n  }\\n  let coordinates = this.sketchCoords_;\\n  const geometry = /** @type {module:ol/geom/SimpleGeometry} */ (sketchFeature.getGeometry());\\n  if (this.mode_ === Mode.LINE_STRING) {\\n    // remove the redundant last point\\n    coordinates.pop();\\n    this.geometryFunction_(coordinates, geometry);\\n  } else if (this.mode_ === Mode.POLYGON) {\\n    // remove the redundant last point in ring\\n    coordinates[0].pop();\\n    this.geometryFunction_(coordinates, geometry);\\n    coordinates = geometry.getCoordinates();\\n  }\\n\\n  // cast multi-part geometries\\n  if (this.type_ === GeometryType.MULTI_POINT) {\\n    sketchFeature.setGeometry(new MultiPoint([coordinates]));\\n  } else if (this.type_ === GeometryType.MULTI_LINE_STRING) {\\n    sketchFeature.setGeometry(new MultiLineString([coordinates]));\\n  } else if (this.type_ === GeometryType.MULTI_POLYGON) {\\n    sketchFeature.setGeometry(new MultiPolygon([coordinates]));\\n  }\\n\\n  // First dispatch event to allow full set up of feature\\n  this.dispatchEvent(new DrawEvent(DrawEventType.DRAWEND, sketchFeature));\\n\\n  // Then insert feature\\n  if (this.features_) {\\n    this.features_.push(sketchFeature);\\n  }\\n  if (this.source_) {\\n    this.source_.addFeature(sketchFeature);\\n  }\\n};\\n\\n\\n/**\\n * Stop drawing without adding the sketch feature to the target layer.\\n * @return {module:ol/Feature} The sketch feature (or null if none).\\n * @private\\n */\\nDraw.prototype.abortDrawing_ = function() {\\n  this.finishCoordinate_ = null;\\n  const sketchFeature = this.sketchFeature_;\\n  if (sketchFeature) {\\n    this.sketchFeature_ = null;\\n    this.sketchPoint_ = null;\\n    this.sketchLine_ = null;\\n    this.overlay_.getSource().clear(true);\\n  }\\n  return sketchFeature;\\n};\\n\\n\\n/**\\n * Extend an existing geometry by adding additional points. This only works\\n * on features with `LineString` geometries, where the interaction will\\n * extend lines by adding points to the end of the coordinates array.\\n * @param {!module:ol/Feature} feature Feature to be extended.\\n * @api\\n */\\nDraw.prototype.extend = function(feature) {\\n  const geometry = feature.getGeometry();\\n  const lineString = /** @type {module:ol/geom/LineString} */ (geometry);\\n  this.sketchFeature_ = feature;\\n  this.sketchCoords_ = lineString.getCoordinates();\\n  const last = this.sketchCoords_[this.sketchCoords_.length - 1];\\n  this.finishCoordinate_ = last.slice();\\n  this.sketchCoords_.push(last.slice());\\n  this.updateSketchFeatures_();\\n  this.dispatchEvent(new DrawEvent(DrawEventType.DRAWSTART, this.sketchFeature_));\\n};\\n\\n\\n/**\\n * @inheritDoc\\n */\\nDraw.prototype.shouldStopEvent = FALSE;\\n\\n\\n/**\\n * Redraw the sketch features.\\n * @private\\n */\\nDraw.prototype.updateSketchFeatures_ = function() {\\n  const sketchFeatures = [];\\n  if (this.sketchFeature_) {\\n    sketchFeatures.push(this.sketchFeature_);\\n  }\\n  if (this.sketchLine_) {\\n    sketchFeatures.push(this.sketchLine_);\\n  }\\n  if (this.sketchPoint_) {\\n    sketchFeatures.push(this.sketchPoint_);\\n  }\\n  const overlaySource = this.overlay_.getSource();\\n  overlaySource.clear(true);\\n  overlaySource.addFeatures(sketchFeatures);\\n};\\n\\n\\n/**\\n * @private\\n */\\nDraw.prototype.updateState_ = function() {\\n  const map = this.getMap();\\n  const active = this.getActive();\\n  if (!map || !active) {\\n    this.abortDrawing_();\\n  }\\n  this.overlay_.setMap(active ? map : null);\\n};\\n\\n\\n/**\\n * Create a `geometryFunction` for `type: 'Circle'` that will create a regular\\n * polygon with a user specified number of sides and start angle instead of an\\n * `module:ol/geom/Circle~Circle` geometry.\\n * @param {number=} opt_sides Number of sides of the regular polygon. Default is\\n *     32.\\n * @param {number=} opt_angle Angle of the first point in radians. 0 means East.\\n *     Default is the angle defined by the heading from the center of the\\n *     regular polygon to the current pointer position.\\n * @return {module:ol/interaction/Draw~GeometryFunction} Function that draws a\\n *     polygon.\\n * @api\\n */\\nexport function createRegularPolygon(opt_sides, opt_angle) {\\n  return function(coordinates, opt_geometry) {\\n    const center = coordinates[0];\\n    const end = coordinates[1];\\n    const radius = Math.sqrt(\\n      squaredCoordinateDistance(center, end));\\n    const geometry = opt_geometry ? /** @type {module:ol/geom/Polygon} */ (opt_geometry) :\\n      fromCircle(new Circle(center), opt_sides);\\n    const angle = opt_angle ? opt_angle :\\n      Math.atan((end[1] - center[1]) / (end[0] - center[0]));\\n    makeRegular(geometry, center, radius, angle);\\n    return geometry;\\n  };\\n}\\n\\n\\n/**\\n * Create a `geometryFunction` that will create a box-shaped polygon (aligned\\n * with the coordinate system axes).  Use this with the draw interaction and\\n * `type: 'Circle'` to return a box instead of a circle geometry.\\n * @return {module:ol/interaction/Draw~GeometryFunction} Function that draws a box-shaped polygon.\\n * @api\\n */\\nexport function createBox() {\\n  return (\\n    function(coordinates, opt_geometry) {\\n      const extent = boundingExtent(coordinates);\\n      const geometry = opt_geometry || new Polygon(null);\\n      geometry.setCoordinates([[\\n        getBottomLeft(extent),\\n        getBottomRight(extent),\\n        getTopRight(extent),\\n        getTopLeft(extent),\\n        getBottomLeft(extent)\\n      ]]);\\n      return geometry;\\n    }\\n  );\\n}\\n\\n\\n/**\\n * Get the drawing mode.  The mode for mult-part geometries is the same as for\\n * their single-part cousins.\\n * @param {module:ol/geom/GeometryType} type Geometry type.\\n * @return {module:ol/interaction/Draw~Mode} Drawing mode.\\n */\\nfunction getMode(type) {\\n  let mode;\\n  if (type === GeometryType.POINT ||\\n      type === GeometryType.MULTI_POINT) {\\n    mode = Mode.POINT;\\n  } else if (type === GeometryType.LINE_STRING ||\\n      type === GeometryType.MULTI_LINE_STRING) {\\n    mode = Mode.LINE_STRING;\\n  } else if (type === GeometryType.POLYGON ||\\n      type === GeometryType.MULTI_POLYGON) {\\n    mode = Mode.POLYGON;\\n  } else if (type === GeometryType.CIRCLE) {\\n    mode = Mode.CIRCLE;\\n  }\\n  return (\\n    /** @type {!module:ol/interaction/Draw~Mode} */ (mode)\\n  );\\n}\\n\\n\\nexport default Draw;\\n\",\"/**\\n * @module ol/interaction/Extent\\n */\\nimport {inherits} from '../index.js';\\nimport Feature from '../Feature.js';\\nimport MapBrowserEventType from '../MapBrowserEventType.js';\\nimport MapBrowserPointerEvent from '../MapBrowserPointerEvent.js';\\nimport {squaredDistanceToSegment, closestOnSegment, distance as coordinateDistance, squaredDistance as squaredCoordinateDistance} from '../coordinate.js';\\nimport Event from '../events/Event.js';\\nimport {boundingExtent, getArea} from '../extent.js';\\nimport GeometryType from '../geom/GeometryType.js';\\nimport Point from '../geom/Point.js';\\nimport {fromExtent as polygonFromExtent} from '../geom/Polygon.js';\\nimport PointerInteraction, {handleEvent as handlePointerEvent} from '../interaction/Pointer.js';\\nimport VectorLayer from '../layer/Vector.js';\\nimport VectorSource from '../source/Vector.js';\\nimport {createEditingStyle} from '../style/Style.js';\\n\\n\\n/**\\n * @typedef {Object} Options\\n * @property {module:ol/extent~Extent} [extent] Initial extent. Defaults to no\\n * initial extent.\\n * @property {module:ol/style/Style|Array.<module:ol/style/Style>|module:ol/style/Style~StyleFunction} [boxStyle]\\n * Style for the drawn extent box. Defaults to\\n * {@link module:ol/style/Style~createEditing()['Polygon']}\\n * @property {number} [pixelTolerance=10] Pixel tolerance for considering the\\n * pointer close enough to a segment or vertex for editing.\\n * @property {module:ol/style/Style|Array.<module:ol/style/Style>|module:ol/style/Style~StyleFunction} [pointerStyle]\\n * Style for the cursor used to draw the extent. Defaults to\\n * {@link module:ol/style/Style~createEditing()['Point']}\\n * @property {boolean} [wrapX=false] Wrap the drawn extent across multiple maps\\n * in the X direction? Only affects visuals, not functionality.\\n */\\n\\n\\n/**\\n * @enum {string}\\n */\\nconst ExtentEventType = {\\n  /**\\n   * Triggered after the extent is changed\\n   * @event module:ol/interaction/Extent~ExtentEventType#extentchanged\\n   * @api\\n   */\\n  EXTENTCHANGED: 'extentchanged'\\n};\\n\\n\\n/**\\n * @classdesc\\n * Events emitted by {@link module:ol/interaction/Extent~Extent} instances are\\n * instances of this type.\\n *\\n * @constructor\\n * @param {module:ol/extent~Extent} extent the new extent\\n * @extends {module:ol/events/Event}\\n */\\nconst ExtentInteractionEvent = function(extent) {\\n  Event.call(this, ExtentEventType.EXTENTCHANGED);\\n\\n  /**\\n   * The current extent.\\n   * @type {module:ol/extent~Extent}\\n   * @api\\n   */\\n  this.extent = extent;\\n\\n};\\ninherits(ExtentInteractionEvent, Event);\\n\\n\\n/**\\n * @classdesc\\n * Allows the user to draw a vector box by clicking and dragging on the map.\\n * Once drawn, the vector box can be modified by dragging its vertices or edges.\\n * This interaction is only supported for mouse devices.\\n *\\n * @constructor\\n * @extends {module:ol/interaction/Pointer}\\n * @fires module:ol/interaction/Extent~Event\\n * @param {module:ol/interaction/Extent~Options=} opt_options Options.\\n * @api\\n */\\nconst ExtentInteraction = function(opt_options) {\\n\\n  const options = opt_options || {};\\n\\n  /**\\n   * Extent of the drawn box\\n   * @type {module:ol/extent~Extent}\\n   * @private\\n   */\\n  this.extent_ = null;\\n\\n  /**\\n   * Handler for pointer move events\\n   * @type {function (module:ol/coordinate~Coordinate): module:ol/extent~Extent|null}\\n   * @private\\n   */\\n  this.pointerHandler_ = null;\\n\\n  /**\\n   * Pixel threshold to snap to extent\\n   * @type {number}\\n   * @private\\n   */\\n  this.pixelTolerance_ = options.pixelTolerance !== undefined ?\\n    options.pixelTolerance : 10;\\n\\n  /**\\n   * Is the pointer snapped to an extent vertex\\n   * @type {boolean}\\n   * @private\\n   */\\n  this.snappedToVertex_ = false;\\n\\n  /**\\n   * Feature for displaying the visible extent\\n   * @type {module:ol/Feature}\\n   * @private\\n   */\\n  this.extentFeature_ = null;\\n\\n  /**\\n   * Feature for displaying the visible pointer\\n   * @type {module:ol/Feature}\\n   * @private\\n   */\\n  this.vertexFeature_ = null;\\n\\n  if (!opt_options) {\\n    opt_options = {};\\n  }\\n\\n  PointerInteraction.call(this, {\\n    handleDownEvent: handleDownEvent,\\n    handleDragEvent: handleDragEvent,\\n    handleEvent: handleEvent,\\n    handleUpEvent: handleUpEvent\\n  });\\n\\n  /**\\n   * Layer for the extentFeature\\n   * @type {module:ol/layer/Vector}\\n   * @private\\n   */\\n  this.extentOverlay_ = new VectorLayer({\\n    source: new VectorSource({\\n      useSpatialIndex: false,\\n      wrapX: !!opt_options.wrapX\\n    }),\\n    style: opt_options.boxStyle ? opt_options.boxStyle : getDefaultExtentStyleFunction(),\\n    updateWhileAnimating: true,\\n    updateWhileInteracting: true\\n  });\\n\\n  /**\\n   * Layer for the vertexFeature\\n   * @type {module:ol/layer/Vector}\\n   * @private\\n   */\\n  this.vertexOverlay_ = new VectorLayer({\\n    source: new VectorSource({\\n      useSpatialIndex: false,\\n      wrapX: !!opt_options.wrapX\\n    }),\\n    style: opt_options.pointerStyle ? opt_options.pointerStyle : getDefaultPointerStyleFunction(),\\n    updateWhileAnimating: true,\\n    updateWhileInteracting: true\\n  });\\n\\n  if (opt_options.extent) {\\n    this.setExtent(opt_options.extent);\\n  }\\n};\\n\\ninherits(ExtentInteraction, PointerInteraction);\\n\\n/**\\n * @param {module:ol/MapBrowserEvent} mapBrowserEvent Event.\\n * @return {boolean} Propagate event?\\n * @this {module:ol/interaction/Extent~Extent}\\n */\\nfunction handleEvent(mapBrowserEvent) {\\n  if (!(mapBrowserEvent instanceof MapBrowserPointerEvent)) {\\n    return true;\\n  }\\n  //display pointer (if not dragging)\\n  if (mapBrowserEvent.type == MapBrowserEventType.POINTERMOVE && !this.handlingDownUpSequence) {\\n    this.handlePointerMove_(mapBrowserEvent);\\n  }\\n  //call pointer to determine up/down/drag\\n  handlePointerEvent.call(this, mapBrowserEvent);\\n  //return false to stop propagation\\n  return false;\\n}\\n\\n/**\\n * @param {module:ol/MapBrowserPointerEvent} mapBrowserEvent Event.\\n * @return {boolean} Event handled?\\n * @this {module:ol/interaction/Extent~Extent}\\n */\\nfunction handleDownEvent(mapBrowserEvent) {\\n  const pixel = mapBrowserEvent.pixel;\\n  const map = mapBrowserEvent.map;\\n\\n  const extent = this.getExtent();\\n  let vertex = this.snapToVertex_(pixel, map);\\n\\n  //find the extent corner opposite the passed corner\\n  const getOpposingPoint = function(point) {\\n    let x_ = null;\\n    let y_ = null;\\n    if (point[0] == extent[0]) {\\n      x_ = extent[2];\\n    } else if (point[0] == extent[2]) {\\n      x_ = extent[0];\\n    }\\n    if (point[1] == extent[1]) {\\n      y_ = extent[3];\\n    } else if (point[1] == extent[3]) {\\n      y_ = extent[1];\\n    }\\n    if (x_ !== null && y_ !== null) {\\n      return [x_, y_];\\n    }\\n    return null;\\n  };\\n  if (vertex && extent) {\\n    const x = (vertex[0] == extent[0] || vertex[0] == extent[2]) ? vertex[0] : null;\\n    const y = (vertex[1] == extent[1] || vertex[1] == extent[3]) ? vertex[1] : null;\\n\\n    //snap to point\\n    if (x !== null && y !== null) {\\n      this.pointerHandler_ = getPointHandler(getOpposingPoint(vertex));\\n    //snap to edge\\n    } else if (x !== null) {\\n      this.pointerHandler_ = getEdgeHandler(\\n        getOpposingPoint([x, extent[1]]),\\n        getOpposingPoint([x, extent[3]])\\n      );\\n    } else if (y !== null) {\\n      this.pointerHandler_ = getEdgeHandler(\\n        getOpposingPoint([extent[0], y]),\\n        getOpposingPoint([extent[2], y])\\n      );\\n    }\\n  //no snap - new bbox\\n  } else {\\n    vertex = map.getCoordinateFromPixel(pixel);\\n    this.setExtent([vertex[0], vertex[1], vertex[0], vertex[1]]);\\n    this.pointerHandler_ = getPointHandler(vertex);\\n  }\\n  return true; //event handled; start downup sequence\\n}\\n\\n/**\\n * @param {module:ol/MapBrowserPointerEvent} mapBrowserEvent Event.\\n * @return {boolean} Event handled?\\n * @this {module:ol/interaction/Extent~Extent}\\n */\\nfunction handleDragEvent(mapBrowserEvent) {\\n  if (this.pointerHandler_) {\\n    const pixelCoordinate = mapBrowserEvent.coordinate;\\n    this.setExtent(this.pointerHandler_(pixelCoordinate));\\n    this.createOrUpdatePointerFeature_(pixelCoordinate);\\n  }\\n  return true;\\n}\\n\\n/**\\n * @param {module:ol/MapBrowserPointerEvent} mapBrowserEvent Event.\\n * @return {boolean} Stop drag sequence?\\n * @this {module:ol/interaction/Extent~Extent}\\n */\\nfunction handleUpEvent(mapBrowserEvent) {\\n  this.pointerHandler_ = null;\\n  //If bbox is zero area, set to null;\\n  const extent = this.getExtent();\\n  if (!extent || getArea(extent) === 0) {\\n    this.setExtent(null);\\n  }\\n  return false; //Stop handling downup sequence\\n}\\n\\n/**\\n * Returns the default style for the drawn bbox\\n *\\n * @return {module:ol/style/Style~StyleFunction} Default Extent style\\n */\\nfunction getDefaultExtentStyleFunction() {\\n  const style = createEditingStyle();\\n  return function(feature, resolution) {\\n    return style[GeometryType.POLYGON];\\n  };\\n}\\n\\n/**\\n * Returns the default style for the pointer\\n *\\n * @return {module:ol/style/Style~StyleFunction} Default pointer style\\n */\\nfunction getDefaultPointerStyleFunction() {\\n  const style = createEditingStyle();\\n  return function(feature, resolution) {\\n    return style[GeometryType.POINT];\\n  };\\n}\\n\\n/**\\n * @param {module:ol/coordinate~Coordinate} fixedPoint corner that will be unchanged in the new extent\\n * @returns {function (module:ol/coordinate~Coordinate): module:ol/extent~Extent} event handler\\n */\\nfunction getPointHandler(fixedPoint) {\\n  return function(point) {\\n    return boundingExtent([fixedPoint, point]);\\n  };\\n}\\n\\n/**\\n * @param {module:ol/coordinate~Coordinate} fixedP1 first corner that will be unchanged in the new extent\\n * @param {module:ol/coordinate~Coordinate} fixedP2 second corner that will be unchanged in the new extent\\n * @returns {function (module:ol/coordinate~Coordinate): module:ol/extent~Extent|null} event handler\\n */\\nfunction getEdgeHandler(fixedP1, fixedP2) {\\n  if (fixedP1[0] == fixedP2[0]) {\\n    return function(point) {\\n      return boundingExtent([fixedP1, [point[0], fixedP2[1]]]);\\n    };\\n  } else if (fixedP1[1] == fixedP2[1]) {\\n    return function(point) {\\n      return boundingExtent([fixedP1, [fixedP2[0], point[1]]]);\\n    };\\n  } else {\\n    return null;\\n  }\\n}\\n\\n/**\\n * @param {module:ol/extent~Extent} extent extent\\n * @returns {Array<Array<module:ol/coordinate~Coordinate>>} extent line segments\\n */\\nfunction getSegments(extent) {\\n  return [\\n    [[extent[0], extent[1]], [extent[0], extent[3]]],\\n    [[extent[0], extent[3]], [extent[2], extent[3]]],\\n    [[extent[2], extent[3]], [extent[2], extent[1]]],\\n    [[extent[2], extent[1]], [extent[0], extent[1]]]\\n  ];\\n}\\n\\n/**\\n * @param {module:ol~Pixel} pixel cursor location\\n * @param {module:ol/PluggableMap} map map\\n * @returns {module:ol/coordinate~Coordinate|null} snapped vertex on extent\\n * @private\\n */\\nExtentInteraction.prototype.snapToVertex_ = function(pixel, map) {\\n  const pixelCoordinate = map.getCoordinateFromPixel(pixel);\\n  const sortByDistance = function(a, b) {\\n    return squaredDistanceToSegment(pixelCoordinate, a) -\\n        squaredDistanceToSegment(pixelCoordinate, b);\\n  };\\n  const extent = this.getExtent();\\n  if (extent) {\\n    //convert extents to line segments and find the segment closest to pixelCoordinate\\n    const segments = getSegments(extent);\\n    segments.sort(sortByDistance);\\n    const closestSegment = segments[0];\\n\\n    let vertex = (closestOnSegment(pixelCoordinate,\\n      closestSegment));\\n    const vertexPixel = map.getPixelFromCoordinate(vertex);\\n\\n    //if the distance is within tolerance, snap to the segment\\n    if (coordinateDistance(pixel, vertexPixel) <= this.pixelTolerance_) {\\n      //test if we should further snap to a vertex\\n      const pixel1 = map.getPixelFromCoordinate(closestSegment[0]);\\n      const pixel2 = map.getPixelFromCoordinate(closestSegment[1]);\\n      const squaredDist1 = squaredCoordinateDistance(vertexPixel, pixel1);\\n      const squaredDist2 = squaredCoordinateDistance(vertexPixel, pixel2);\\n      const dist = Math.sqrt(Math.min(squaredDist1, squaredDist2));\\n      this.snappedToVertex_ = dist <= this.pixelTolerance_;\\n      if (this.snappedToVertex_) {\\n        vertex = squaredDist1 > squaredDist2 ?\\n          closestSegment[1] : closestSegment[0];\\n      }\\n      return vertex;\\n    }\\n  }\\n  return null;\\n};\\n\\n/**\\n * @param {module:ol/MapBrowserEvent} mapBrowserEvent pointer move event\\n * @private\\n */\\nExtentInteraction.prototype.handlePointerMove_ = function(mapBrowserEvent) {\\n  const pixel = mapBrowserEvent.pixel;\\n  const map = mapBrowserEvent.map;\\n\\n  let vertex = this.snapToVertex_(pixel, map);\\n  if (!vertex) {\\n    vertex = map.getCoordinateFromPixel(pixel);\\n  }\\n  this.createOrUpdatePointerFeature_(vertex);\\n};\\n\\n/**\\n * @param {module:ol/extent~Extent} extent extent\\n * @returns {module:ol/Feature} extent as featrue\\n * @private\\n */\\nExtentInteraction.prototype.createOrUpdateExtentFeature_ = function(extent) {\\n  let extentFeature = this.extentFeature_;\\n\\n  if (!extentFeature) {\\n    if (!extent) {\\n      extentFeature = new Feature({});\\n    } else {\\n      extentFeature = new Feature(polygonFromExtent(extent));\\n    }\\n    this.extentFeature_ = extentFeature;\\n    this.extentOverlay_.getSource().addFeature(extentFeature);\\n  } else {\\n    if (!extent) {\\n      extentFeature.setGeometry(undefined);\\n    } else {\\n      extentFeature.setGeometry(polygonFromExtent(extent));\\n    }\\n  }\\n  return extentFeature;\\n};\\n\\n\\n/**\\n * @param {module:ol/coordinate~Coordinate} vertex location of feature\\n * @returns {module:ol/Feature} vertex as feature\\n * @private\\n */\\nExtentInteraction.prototype.createOrUpdatePointerFeature_ = function(vertex) {\\n  let vertexFeature = this.vertexFeature_;\\n  if (!vertexFeature) {\\n    vertexFeature = new Feature(new Point(vertex));\\n    this.vertexFeature_ = vertexFeature;\\n    this.vertexOverlay_.getSource().addFeature(vertexFeature);\\n  } else {\\n    const geometry = /** @type {module:ol/geom/Point} */ (vertexFeature.getGeometry());\\n    geometry.setCoordinates(vertex);\\n  }\\n  return vertexFeature;\\n};\\n\\n\\n/**\\n * @inheritDoc\\n */\\nExtentInteraction.prototype.setMap = function(map) {\\n  this.extentOverlay_.setMap(map);\\n  this.vertexOverlay_.setMap(map);\\n  PointerInteraction.prototype.setMap.call(this, map);\\n};\\n\\n/**\\n * Returns the current drawn extent in the view projection\\n *\\n * @return {module:ol/extent~Extent} Drawn extent in the view projection.\\n * @api\\n */\\nExtentInteraction.prototype.getExtent = function() {\\n  return this.extent_;\\n};\\n\\n/**\\n * Manually sets the drawn extent, using the view projection.\\n *\\n * @param {module:ol/extent~Extent} extent Extent\\n * @api\\n */\\nExtentInteraction.prototype.setExtent = function(extent) {\\n  //Null extent means no bbox\\n  this.extent_ = extent ? extent : null;\\n  this.createOrUpdateExtentFeature_(extent);\\n  this.dispatchEvent(new ExtentInteractionEvent(this.extent_));\\n};\\n\\n\\nexport default ExtentInteraction;\\n\",\"/**\\n * @module ol/interaction/Modify\\n */\\nimport {getUid, inherits} from '../index.js';\\nimport Collection from '../Collection.js';\\nimport CollectionEventType from '../CollectionEventType.js';\\nimport Feature from '../Feature.js';\\nimport MapBrowserEventType from '../MapBrowserEventType.js';\\nimport MapBrowserPointerEvent from '../MapBrowserPointerEvent.js';\\nimport {equals} from '../array.js';\\nimport {equals as coordinatesEqual, distance as coordinateDistance, squaredDistance as squaredCoordinateDistance, squaredDistanceToSegment, closestOnSegment} from '../coordinate.js';\\nimport {listen, unlisten} from '../events.js';\\nimport Event from '../events/Event.js';\\nimport EventType from '../events/EventType.js';\\nimport {always, primaryAction, altKeyOnly, singleClick} from '../events/condition.js';\\nimport {boundingExtent, buffer, createOrUpdateFromCoordinate} from '../extent.js';\\nimport GeometryType from '../geom/GeometryType.js';\\nimport Point from '../geom/Point.js';\\nimport PointerInteraction, {handleEvent as handlePointerEvent} from '../interaction/Pointer.js';\\nimport VectorLayer from '../layer/Vector.js';\\nimport VectorSource from '../source/Vector.js';\\nimport VectorEventType from '../source/VectorEventType.js';\\nimport RBush from '../structs/RBush.js';\\nimport {createEditingStyle} from '../style/Style.js';\\n\\n\\n/**\\n * @enum {string}\\n */\\nconst ModifyEventType = {\\n  /**\\n   * Triggered upon feature modification start\\n   * @event ModifyEvent#modifystart\\n   * @api\\n   */\\n  MODIFYSTART: 'modifystart',\\n  /**\\n   * Triggered upon feature modification end\\n   * @event ModifyEvent#modifyend\\n   * @api\\n   */\\n  MODIFYEND: 'modifyend'\\n};\\n\\n\\n/**\\n * @typedef {Object} SegmentData\\n * @property {Array.<number>} [depth]\\n * @property {module:ol/Feature} feature\\n * @property {module:ol/geom/SimpleGeometry} geometry\\n * @property {number} index\\n * @property {Array.<module:ol/extent~Extent>} segment\\n * @property {Array.<module:ol/interaction/Modify~SegmentData>} [featureSegments]\\n */\\n\\n\\n/**\\n * @typedef {Object} Options\\n * @property {module:ol/events/condition~Condition} [condition] A function that\\n * takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a\\n * boolean to indicate whether that event will be considered to add or move a\\n * vertex to the sketch. Default is\\n * {@link module:ol/events/condition~primaryAction}.\\n * @property {module:ol/events/condition~Condition} [deleteCondition] A function\\n * that takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a\\n * boolean to indicate whether that event should be handled. By default,\\n * {@link module:ol/events/condition~singleClick} with\\n * {@link module:ol/events/condition~altKeyOnly} results in a vertex deletion.\\n * @property {module:ol/events/condition~Condition} [insertVertexCondition] A\\n * function that takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and\\n * returns a boolean to indicate whether a new vertex can be added to the sketch\\n * features. Default is {@link module:ol/events/condition~always}.\\n * @property {number} [pixelTolerance=10] Pixel tolerance for considering the\\n * pointer close enough to a segment or vertex for editing.\\n * @property {module:ol/style/Style|Array.<module:ol/style/Style>|module:ol/style/Style~StyleFunction} [style]\\n * Style used for the features being modified. By default the default edit\\n * style is used (see {@link module:ol/style}).\\n * @property {module:ol/source/Vector} [source] The vector source with\\n * features to modify.  If a vector source is not provided, a feature collection\\n * must be provided with the features option.\\n * @property {module:ol/Collection.<module:ol/Feature>} [features]\\n * The features the interaction works on.  If a feature collection is not\\n * provided, a vector source must be provided with the source option.\\n * @property {boolean} [wrapX=false] Wrap the world horizontally on the sketch\\n * overlay.\\n */\\n\\n\\n/**\\n * @classdesc\\n * Events emitted by {@link module:ol/interaction/Modify~Modify} instances are\\n * instances of this type.\\n *\\n * @constructor\\n * @extends {module:ol/events/Event}\\n * @param {ModifyEventType} type Type.\\n * @param {module:ol/Collection.<module:ol/Feature>} features\\n * The features modified.\\n * @param {module:ol/MapBrowserPointerEvent} mapBrowserPointerEvent\\n * Associated {@link module:ol/MapBrowserPointerEvent}.\\n */\\nexport const ModifyEvent = function(type, features, mapBrowserPointerEvent) {\\n\\n  Event.call(this, type);\\n\\n  /**\\n   * The features being modified.\\n   * @type {module:ol/Collection.<module:ol/Feature>}\\n   * @api\\n   */\\n  this.features = features;\\n\\n  /**\\n   * Associated {@link module:ol/MapBrowserEvent}.\\n   * @type {module:ol/MapBrowserEvent}\\n   * @api\\n   */\\n  this.mapBrowserEvent = mapBrowserPointerEvent;\\n};\\n\\ninherits(ModifyEvent, Event);\\n\\n\\n/**\\n * @classdesc\\n * Interaction for modifying feature geometries.  To modify features that have\\n * been added to an existing source, construct the modify interaction with the\\n * `source` option.  If you want to modify features in a collection (for example,\\n * the collection used by a select interaction), construct the interaction with\\n * the `features` option.  The interaction must be constructed with either a\\n * `source` or `features` option.\\n *\\n * By default, the interaction will allow deletion of vertices when the `alt`\\n * key is pressed.  To configure the interaction with a different condition\\n * for deletion, use the `deleteCondition` option.\\n *\\n * @constructor\\n * @extends {module:ol/interaction/Pointer}\\n * @param {module:ol/interaction/Modify~Options} options Options.\\n * @fires module:ol/interaction/Modify~ModifyEvent\\n * @api\\n */\\nconst Modify = function(options) {\\n\\n  PointerInteraction.call(this, {\\n    handleDownEvent: handleDownEvent,\\n    handleDragEvent: handleDragEvent,\\n    handleEvent: handleEvent,\\n    handleUpEvent: handleUpEvent\\n  });\\n\\n  /**\\n   * @private\\n   * @type {module:ol/events/condition~Condition}\\n   */\\n  this.condition_ = options.condition ? options.condition : primaryAction;\\n\\n\\n  /**\\n   * @private\\n   * @param {module:ol/MapBrowserEvent} mapBrowserEvent Browser event.\\n   * @return {boolean} Combined condition result.\\n   */\\n  this.defaultDeleteCondition_ = function(mapBrowserEvent) {\\n    return altKeyOnly(mapBrowserEvent) && singleClick(mapBrowserEvent);\\n  };\\n\\n  /**\\n   * @type {module:ol/events/condition~Condition}\\n   * @private\\n   */\\n  this.deleteCondition_ = options.deleteCondition ?\\n    options.deleteCondition : this.defaultDeleteCondition_;\\n\\n  /**\\n   * @type {module:ol/events/condition~Condition}\\n   * @private\\n   */\\n  this.insertVertexCondition_ = options.insertVertexCondition ?\\n    options.insertVertexCondition : always;\\n\\n  /**\\n   * Editing vertex.\\n   * @type {module:ol/Feature}\\n   * @private\\n   */\\n  this.vertexFeature_ = null;\\n\\n  /**\\n   * Segments intersecting {@link this.vertexFeature_} by segment uid.\\n   * @type {Object.<string, boolean>}\\n   * @private\\n   */\\n  this.vertexSegments_ = null;\\n\\n  /**\\n   * @type {module:ol~Pixel}\\n   * @private\\n   */\\n  this.lastPixel_ = [0, 0];\\n\\n  /**\\n   * Tracks if the next `singleclick` event should be ignored to prevent\\n   * accidental deletion right after vertex creation.\\n   * @type {boolean}\\n   * @private\\n   */\\n  this.ignoreNextSingleClick_ = false;\\n\\n  /**\\n   * @type {boolean}\\n   * @private\\n   */\\n  this.modified_ = false;\\n\\n  /**\\n   * Segment RTree for each layer\\n   * @type {module:ol/structs/RBush.<module:ol/interaction/Modify~SegmentData>}\\n   * @private\\n   */\\n  this.rBush_ = new RBush();\\n\\n  /**\\n   * @type {number}\\n   * @private\\n   */\\n  this.pixelTolerance_ = options.pixelTolerance !== undefined ?\\n    options.pixelTolerance : 10;\\n\\n  /**\\n   * @type {boolean}\\n   * @private\\n   */\\n  this.snappedToVertex_ = false;\\n\\n  /**\\n   * Indicate whether the interaction is currently changing a feature's\\n   * coordinates.\\n   * @type {boolean}\\n   * @private\\n   */\\n  this.changingFeature_ = false;\\n\\n  /**\\n   * @type {Array}\\n   * @private\\n   */\\n  this.dragSegments_ = [];\\n\\n  /**\\n   * Draw overlay where sketch features are drawn.\\n   * @type {module:ol/layer/Vector}\\n   * @private\\n   */\\n  this.overlay_ = new VectorLayer({\\n    source: new VectorSource({\\n      useSpatialIndex: false,\\n      wrapX: !!options.wrapX\\n    }),\\n    style: options.style ? options.style :\\n      getDefaultStyleFunction(),\\n    updateWhileAnimating: true,\\n    updateWhileInteracting: true\\n  });\\n\\n  /**\\n   * @const\\n   * @private\\n   * @type {!Object.<string, function(module:ol/Feature, module:ol/geom/Geometry)>}\\n   */\\n  this.SEGMENT_WRITERS_ = {\\n    'Point': this.writePointGeometry_,\\n    'LineString': this.writeLineStringGeometry_,\\n    'LinearRing': this.writeLineStringGeometry_,\\n    'Polygon': this.writePolygonGeometry_,\\n    'MultiPoint': this.writeMultiPointGeometry_,\\n    'MultiLineString': this.writeMultiLineStringGeometry_,\\n    'MultiPolygon': this.writeMultiPolygonGeometry_,\\n    'Circle': this.writeCircleGeometry_,\\n    'GeometryCollection': this.writeGeometryCollectionGeometry_\\n  };\\n\\n\\n  /**\\n   * @type {module:ol/source/Vector}\\n   * @private\\n   */\\n  this.source_ = null;\\n\\n  let features;\\n  if (options.source) {\\n    this.source_ = options.source;\\n    features = new Collection(this.source_.getFeatures());\\n    listen(this.source_, VectorEventType.ADDFEATURE,\\n      this.handleSourceAdd_, this);\\n    listen(this.source_, VectorEventType.REMOVEFEATURE,\\n      this.handleSourceRemove_, this);\\n  } else {\\n    features = options.features;\\n  }\\n  if (!features) {\\n    throw new Error('The modify interaction requires features or a source');\\n  }\\n\\n  /**\\n   * @type {module:ol/Collection.<module:ol/Feature>}\\n   * @private\\n   */\\n  this.features_ = features;\\n\\n  this.features_.forEach(this.addFeature_.bind(this));\\n  listen(this.features_, CollectionEventType.ADD,\\n    this.handleFeatureAdd_, this);\\n  listen(this.features_, CollectionEventType.REMOVE,\\n    this.handleFeatureRemove_, this);\\n\\n  /**\\n   * @type {module:ol/MapBrowserPointerEvent}\\n   * @private\\n   */\\n  this.lastPointerEvent_ = null;\\n\\n};\\n\\ninherits(Modify, PointerInteraction);\\n\\n\\n/**\\n * The segment index assigned to a circle's center when\\n * breaking up a circle into ModifySegmentDataType segments.\\n * @type {number}\\n */\\nconst CIRCLE_CENTER_INDEX = 0;\\n\\n/**\\n * The segment index assigned to a circle's circumference when\\n * breaking up a circle into ModifySegmentDataType segments.\\n * @type {number}\\n */\\nconst CIRCLE_CIRCUMFERENCE_INDEX = 1;\\n\\n\\n/**\\n * @param {module:ol/Feature} feature Feature.\\n * @private\\n */\\nModify.prototype.addFeature_ = function(feature) {\\n  const geometry = feature.getGeometry();\\n  if (geometry && geometry.getType() in this.SEGMENT_WRITERS_) {\\n    this.SEGMENT_WRITERS_[geometry.getType()].call(this, feature, geometry);\\n  }\\n  const map = this.getMap();\\n  if (map && map.isRendered() && this.getActive()) {\\n    this.handlePointerAtPixel_(this.lastPixel_, map);\\n  }\\n  listen(feature, EventType.CHANGE,\\n    this.handleFeatureChange_, this);\\n};\\n\\n\\n/**\\n * @param {module:ol/MapBrowserPointerEvent} evt Map browser event\\n * @private\\n */\\nModify.prototype.willModifyFeatures_ = function(evt) {\\n  if (!this.modified_) {\\n    this.modified_ = true;\\n    this.dispatchEvent(new ModifyEvent(\\n      ModifyEventType.MODIFYSTART, this.features_, evt));\\n  }\\n};\\n\\n\\n/**\\n * @param {module:ol/Feature} feature Feature.\\n * @private\\n */\\nModify.prototype.removeFeature_ = function(feature) {\\n  this.removeFeatureSegmentData_(feature);\\n  // Remove the vertex feature if the collection of canditate features\\n  // is empty.\\n  if (this.vertexFeature_ && this.features_.getLength() === 0) {\\n    this.overlay_.getSource().removeFeature(this.vertexFeature_);\\n    this.vertexFeature_ = null;\\n  }\\n  unlisten(feature, EventType.CHANGE,\\n    this.handleFeatureChange_, this);\\n};\\n\\n\\n/**\\n * @param {module:ol/Feature} feature Feature.\\n * @private\\n */\\nModify.prototype.removeFeatureSegmentData_ = function(feature) {\\n  const rBush = this.rBush_;\\n  const /** @type {Array.<module:ol/interaction/Modify~SegmentData>} */ nodesToRemove = [];\\n  rBush.forEach(\\n    /**\\n     * @param {module:ol/interaction/Modify~SegmentData} node RTree node.\\n     */\\n    function(node) {\\n      if (feature === node.feature) {\\n        nodesToRemove.push(node);\\n      }\\n    });\\n  for (let i = nodesToRemove.length - 1; i >= 0; --i) {\\n    rBush.remove(nodesToRemove[i]);\\n  }\\n};\\n\\n\\n/**\\n * @inheritDoc\\n */\\nModify.prototype.setActive = function(active) {\\n  if (this.vertexFeature_ && !active) {\\n    this.overlay_.getSource().removeFeature(this.vertexFeature_);\\n    this.vertexFeature_ = null;\\n  }\\n  PointerInteraction.prototype.setActive.call(this, active);\\n};\\n\\n\\n/**\\n * @inheritDoc\\n */\\nModify.prototype.setMap = function(map) {\\n  this.overlay_.setMap(map);\\n  PointerInteraction.prototype.setMap.call(this, map);\\n};\\n\\n\\n/**\\n * @param {module:ol/source/Vector~VectorSourceEvent} event Event.\\n * @private\\n */\\nModify.prototype.handleSourceAdd_ = function(event) {\\n  if (event.feature) {\\n    this.features_.push(event.feature);\\n  }\\n};\\n\\n\\n/**\\n * @param {module:ol/source/Vector~VectorSourceEvent} event Event.\\n * @private\\n */\\nModify.prototype.handleSourceRemove_ = function(event) {\\n  if (event.feature) {\\n    this.features_.remove(event.feature);\\n  }\\n};\\n\\n\\n/**\\n * @param {module:ol/Collection~CollectionEvent} evt Event.\\n * @private\\n */\\nModify.prototype.handleFeatureAdd_ = function(evt) {\\n  this.addFeature_(/** @type {module:ol/Feature} */ (evt.element));\\n};\\n\\n\\n/**\\n * @param {module:ol/events/Event} evt Event.\\n * @private\\n */\\nModify.prototype.handleFeatureChange_ = function(evt) {\\n  if (!this.changingFeature_) {\\n    const feature = /** @type {module:ol/Feature} */ (evt.target);\\n    this.removeFeature_(feature);\\n    this.addFeature_(feature);\\n  }\\n};\\n\\n\\n/**\\n * @param {module:ol/Collection~CollectionEvent} evt Event.\\n * @private\\n */\\nModify.prototype.handleFeatureRemove_ = function(evt) {\\n  const feature = /** @type {module:ol/Feature} */ (evt.element);\\n  this.removeFeature_(feature);\\n};\\n\\n\\n/**\\n * @param {module:ol/Feature} feature Feature\\n * @param {module:ol/geom/Point} geometry Geometry.\\n * @private\\n */\\nModify.prototype.writePointGeometry_ = function(feature, geometry) {\\n  const coordinates = geometry.getCoordinates();\\n  const segmentData = /** @type {module:ol/interaction/Modify~SegmentData} */ ({\\n    feature: feature,\\n    geometry: geometry,\\n    segment: [coordinates, coordinates]\\n  });\\n  this.rBush_.insert(geometry.getExtent(), segmentData);\\n};\\n\\n\\n/**\\n * @param {module:ol/Feature} feature Feature\\n * @param {module:ol/geom/MultiPoint} geometry Geometry.\\n * @private\\n */\\nModify.prototype.writeMultiPointGeometry_ = function(feature, geometry) {\\n  const points = geometry.getCoordinates();\\n  for (let i = 0, ii = points.length; i < ii; ++i) {\\n    const coordinates = points[i];\\n    const segmentData = /** @type {module:ol/interaction/Modify~SegmentData} */ ({\\n      feature: feature,\\n      geometry: geometry,\\n      depth: [i],\\n      index: i,\\n      segment: [coordinates, coordinates]\\n    });\\n    this.rBush_.insert(geometry.getExtent(), segmentData);\\n  }\\n};\\n\\n\\n/**\\n * @param {module:ol/Feature} feature Feature\\n * @param {module:ol/geom/LineString} geometry Geometry.\\n * @private\\n */\\nModify.prototype.writeLineStringGeometry_ = function(feature, geometry) {\\n  const coordinates = geometry.getCoordinates();\\n  for (let i = 0, ii = coordinates.length - 1; i < ii; ++i) {\\n    const segment = coordinates.slice(i, i + 2);\\n    const segmentData = /** @type {module:ol/interaction/Modify~SegmentData} */ ({\\n      feature: feature,\\n      geometry: geometry,\\n      index: i,\\n      segment: segment\\n    });\\n    this.rBush_.insert(boundingExtent(segment), segmentData);\\n  }\\n};\\n\\n\\n/**\\n * @param {module:ol/Feature} feature Feature\\n * @param {module:ol/geom/MultiLineString} geometry Geometry.\\n * @private\\n */\\nModify.prototype.writeMultiLineStringGeometry_ = function(feature, geometry) {\\n  const lines = geometry.getCoordinates();\\n  for (let j = 0, jj = lines.length; j < jj; ++j) {\\n    const coordinates = lines[j];\\n    for (let i = 0, ii = coordinates.length - 1; i < ii; ++i) {\\n      const segment = coordinates.slice(i, i + 2);\\n      const segmentData = /** @type {module:ol/interaction/Modify~SegmentData} */ ({\\n        feature: feature,\\n        geometry: geometry,\\n        depth: [j],\\n        index: i,\\n        segment: segment\\n      });\\n      this.rBush_.insert(boundingExtent(segment), segmentData);\\n    }\\n  }\\n};\\n\\n\\n/**\\n * @param {module:ol/Feature} feature Feature\\n * @param {module:ol/geom/Polygon} geometry Geometry.\\n * @private\\n */\\nModify.prototype.writePolygonGeometry_ = function(feature, geometry) {\\n  const rings = geometry.getCoordinates();\\n  for (let j = 0, jj = rings.length; j < jj; ++j) {\\n    const coordinates = rings[j];\\n    for (let i = 0, ii = coordinates.length - 1; i < ii; ++i) {\\n      const segment = coordinates.slice(i, i + 2);\\n      const segmentData = /** @type {module:ol/interaction/Modify~SegmentData} */ ({\\n        feature: feature,\\n        geometry: geometry,\\n        depth: [j],\\n        index: i,\\n        segment: segment\\n      });\\n      this.rBush_.insert(boundingExtent(segment), segmentData);\\n    }\\n  }\\n};\\n\\n\\n/**\\n * @param {module:ol/Feature} feature Feature\\n * @param {module:ol/geom/MultiPolygon} geometry Geometry.\\n * @private\\n */\\nModify.prototype.writeMultiPolygonGeometry_ = function(feature, geometry) {\\n  const polygons = geometry.getCoordinates();\\n  for (let k = 0, kk = polygons.length; k < kk; ++k) {\\n    const rings = polygons[k];\\n    for (let j = 0, jj = rings.length; j < jj; ++j) {\\n      const coordinates = rings[j];\\n      for (let i = 0, ii = coordinates.length - 1; i < ii; ++i) {\\n        const segment = coordinates.slice(i, i + 2);\\n        const segmentData = /** @type {module:ol/interaction/Modify~SegmentData} */ ({\\n          feature: feature,\\n          geometry: geometry,\\n          depth: [j, k],\\n          index: i,\\n          segment: segment\\n        });\\n        this.rBush_.insert(boundingExtent(segment), segmentData);\\n      }\\n    }\\n  }\\n};\\n\\n\\n/**\\n * We convert a circle into two segments.  The segment at index\\n * {@link CIRCLE_CENTER_INDEX} is the\\n * circle's center (a point).  The segment at index\\n * {@link CIRCLE_CIRCUMFERENCE_INDEX} is\\n * the circumference, and is not a line segment.\\n *\\n * @param {module:ol/Feature} feature Feature.\\n * @param {module:ol/geom/Circle} geometry Geometry.\\n * @private\\n */\\nModify.prototype.writeCircleGeometry_ = function(feature, geometry) {\\n  const coordinates = geometry.getCenter();\\n  const centerSegmentData = /** @type {module:ol/interaction/Modify~SegmentData} */ ({\\n    feature: feature,\\n    geometry: geometry,\\n    index: CIRCLE_CENTER_INDEX,\\n    segment: [coordinates, coordinates]\\n  });\\n  const circumferenceSegmentData = /** @type {module:ol/interaction/Modify~SegmentData} */ ({\\n    feature: feature,\\n    geometry: geometry,\\n    index: CIRCLE_CIRCUMFERENCE_INDEX,\\n    segment: [coordinates, coordinates]\\n  });\\n  const featureSegments = [centerSegmentData, circumferenceSegmentData];\\n  centerSegmentData.featureSegments = circumferenceSegmentData.featureSegments = featureSegments;\\n  this.rBush_.insert(createOrUpdateFromCoordinate(coordinates), centerSegmentData);\\n  this.rBush_.insert(geometry.getExtent(), circumferenceSegmentData);\\n};\\n\\n\\n/**\\n * @param {module:ol/Feature} feature Feature\\n * @param {module:ol/geom/GeometryCollection} geometry Geometry.\\n * @private\\n */\\nModify.prototype.writeGeometryCollectionGeometry_ = function(feature, geometry) {\\n  const geometries = geometry.getGeometriesArray();\\n  for (let i = 0; i < geometries.length; ++i) {\\n    this.SEGMENT_WRITERS_[geometries[i].getType()].call(this, feature, geometries[i]);\\n  }\\n};\\n\\n\\n/**\\n * @param {module:ol/coordinate~Coordinate} coordinates Coordinates.\\n * @return {module:ol/Feature} Vertex feature.\\n * @private\\n */\\nModify.prototype.createOrUpdateVertexFeature_ = function(coordinates) {\\n  let vertexFeature = this.vertexFeature_;\\n  if (!vertexFeature) {\\n    vertexFeature = new Feature(new Point(coordinates));\\n    this.vertexFeature_ = vertexFeature;\\n    this.overlay_.getSource().addFeature(vertexFeature);\\n  } else {\\n    const geometry = /** @type {module:ol/geom/Point} */ (vertexFeature.getGeometry());\\n    geometry.setCoordinates(coordinates);\\n  }\\n  return vertexFeature;\\n};\\n\\n\\n/**\\n * @param {module:ol/interaction/Modify~SegmentData} a The first segment data.\\n * @param {module:ol/interaction/Modify~SegmentData} b The second segment data.\\n * @return {number} The difference in indexes.\\n */\\nfunction compareIndexes(a, b) {\\n  return a.index - b.index;\\n}\\n\\n\\n/**\\n * @param {module:ol/MapBrowserPointerEvent} evt Event.\\n * @return {boolean} Start drag sequence?\\n * @this {module:ol/interaction/Modify}\\n */\\nfunction handleDownEvent(evt) {\\n  if (!this.condition_(evt)) {\\n    return false;\\n  }\\n  this.handlePointerAtPixel_(evt.pixel, evt.map);\\n  const pixelCoordinate = evt.map.getCoordinateFromPixel(evt.pixel);\\n  this.dragSegments_.length = 0;\\n  this.modified_ = false;\\n  const vertexFeature = this.vertexFeature_;\\n  if (vertexFeature) {\\n    const insertVertices = [];\\n    const geometry = /** @type {module:ol/geom/Point} */ (vertexFeature.getGeometry());\\n    const vertex = geometry.getCoordinates();\\n    const vertexExtent = boundingExtent([vertex]);\\n    const segmentDataMatches = this.rBush_.getInExtent(vertexExtent);\\n    const componentSegments = {};\\n    segmentDataMatches.sort(compareIndexes);\\n    for (let i = 0, ii = segmentDataMatches.length; i < ii; ++i) {\\n      const segmentDataMatch = segmentDataMatches[i];\\n      const segment = segmentDataMatch.segment;\\n      let uid = getUid(segmentDataMatch.feature);\\n      const depth = segmentDataMatch.depth;\\n      if (depth) {\\n        uid += '-' + depth.join('-'); // separate feature components\\n      }\\n      if (!componentSegments[uid]) {\\n        componentSegments[uid] = new Array(2);\\n      }\\n      if (segmentDataMatch.geometry.getType() === GeometryType.CIRCLE &&\\n      segmentDataMatch.index === CIRCLE_CIRCUMFERENCE_INDEX) {\\n\\n        const closestVertex = closestOnSegmentData(pixelCoordinate, segmentDataMatch);\\n        if (coordinatesEqual(closestVertex, vertex) && !componentSegments[uid][0]) {\\n          this.dragSegments_.push([segmentDataMatch, 0]);\\n          componentSegments[uid][0] = segmentDataMatch;\\n        }\\n      } else if (coordinatesEqual(segment[0], vertex) &&\\n          !componentSegments[uid][0]) {\\n        this.dragSegments_.push([segmentDataMatch, 0]);\\n        componentSegments[uid][0] = segmentDataMatch;\\n      } else if (coordinatesEqual(segment[1], vertex) &&\\n          !componentSegments[uid][1]) {\\n\\n        // prevent dragging closed linestrings by the connecting node\\n        if ((segmentDataMatch.geometry.getType() ===\\n            GeometryType.LINE_STRING ||\\n            segmentDataMatch.geometry.getType() ===\\n            GeometryType.MULTI_LINE_STRING) &&\\n            componentSegments[uid][0] &&\\n            componentSegments[uid][0].index === 0) {\\n          continue;\\n        }\\n\\n        this.dragSegments_.push([segmentDataMatch, 1]);\\n        componentSegments[uid][1] = segmentDataMatch;\\n      } else if (this.insertVertexCondition_(evt) && getUid(segment) in this.vertexSegments_ &&\\n          (!componentSegments[uid][0] && !componentSegments[uid][1])) {\\n        insertVertices.push([segmentDataMatch, vertex]);\\n      }\\n    }\\n    if (insertVertices.length) {\\n      this.willModifyFeatures_(evt);\\n    }\\n    for (let j = insertVertices.length - 1; j >= 0; --j) {\\n      this.insertVertex_.apply(this, insertVertices[j]);\\n    }\\n  }\\n  return !!this.vertexFeature_;\\n}\\n\\n\\n/**\\n * @param {module:ol/MapBrowserPointerEvent} evt Event.\\n * @this {module:ol/interaction/Modify}\\n */\\nfunction handleDragEvent(evt) {\\n  this.ignoreNextSingleClick_ = false;\\n  this.willModifyFeatures_(evt);\\n\\n  const vertex = evt.coordinate;\\n  for (let i = 0, ii = this.dragSegments_.length; i < ii; ++i) {\\n    const dragSegment = this.dragSegments_[i];\\n    const segmentData = dragSegment[0];\\n    const depth = segmentData.depth;\\n    const geometry = segmentData.geometry;\\n    let coordinates;\\n    const segment = segmentData.segment;\\n    const index = dragSegment[1];\\n\\n    while (vertex.length < geometry.getStride()) {\\n      vertex.push(segment[index][vertex.length]);\\n    }\\n\\n    switch (geometry.getType()) {\\n      case GeometryType.POINT:\\n        coordinates = vertex;\\n        segment[0] = segment[1] = vertex;\\n        break;\\n      case GeometryType.MULTI_POINT:\\n        coordinates = geometry.getCoordinates();\\n        coordinates[segmentData.index] = vertex;\\n        segment[0] = segment[1] = vertex;\\n        break;\\n      case GeometryType.LINE_STRING:\\n        coordinates = geometry.getCoordinates();\\n        coordinates[segmentData.index + index] = vertex;\\n        segment[index] = vertex;\\n        break;\\n      case GeometryType.MULTI_LINE_STRING:\\n        coordinates = geometry.getCoordinates();\\n        coordinates[depth[0]][segmentData.index + index] = vertex;\\n        segment[index] = vertex;\\n        break;\\n      case GeometryType.POLYGON:\\n        coordinates = geometry.getCoordinates();\\n        coordinates[depth[0]][segmentData.index + index] = vertex;\\n        segment[index] = vertex;\\n        break;\\n      case GeometryType.MULTI_POLYGON:\\n        coordinates = geometry.getCoordinates();\\n        coordinates[depth[1]][depth[0]][segmentData.index + index] = vertex;\\n        segment[index] = vertex;\\n        break;\\n      case GeometryType.CIRCLE:\\n        segment[0] = segment[1] = vertex;\\n        if (segmentData.index === CIRCLE_CENTER_INDEX) {\\n          this.changingFeature_ = true;\\n          geometry.setCenter(vertex);\\n          this.changingFeature_ = false;\\n        } else { // We're dragging the circle's circumference:\\n          this.changingFeature_ = true;\\n          geometry.setRadius(coordinateDistance(geometry.getCenter(), vertex));\\n          this.changingFeature_ = false;\\n        }\\n        break;\\n      default:\\n        // pass\\n    }\\n\\n    if (coordinates) {\\n      this.setGeometryCoordinates_(geometry, coordinates);\\n    }\\n  }\\n  this.createOrUpdateVertexFeature_(vertex);\\n}\\n\\n\\n/**\\n * @param {module:ol/MapBrowserPointerEvent} evt Event.\\n * @return {boolean} Stop drag sequence?\\n * @this {module:ol/interaction/Modify}\\n */\\nfunction handleUpEvent(evt) {\\n  for (let i = this.dragSegments_.length - 1; i >= 0; --i) {\\n    const segmentData = this.dragSegments_[i][0];\\n    const geometry = segmentData.geometry;\\n    if (geometry.getType() === GeometryType.CIRCLE) {\\n      // Update a circle object in the R* bush:\\n      const coordinates = geometry.getCenter();\\n      const centerSegmentData = segmentData.featureSegments[0];\\n      const circumferenceSegmentData = segmentData.featureSegments[1];\\n      centerSegmentData.segment[0] = centerSegmentData.segment[1] = coordinates;\\n      circumferenceSegmentData.segment[0] = circumferenceSegmentData.segment[1] = coordinates;\\n      this.rBush_.update(createOrUpdateFromCoordinate(coordinates), centerSegmentData);\\n      this.rBush_.update(geometry.getExtent(), circumferenceSegmentData);\\n    } else {\\n      this.rBush_.update(boundingExtent(segmentData.segment), segmentData);\\n    }\\n  }\\n  if (this.modified_) {\\n    this.dispatchEvent(new ModifyEvent(ModifyEventType.MODIFYEND, this.features_, evt));\\n    this.modified_ = false;\\n  }\\n  return false;\\n}\\n\\n\\n/**\\n * Handles the {@link module:ol/MapBrowserEvent map browser event} and may modify the\\n * geometry.\\n * @param {module:ol/MapBrowserEvent} mapBrowserEvent Map browser event.\\n * @return {boolean} `false` to stop event propagation.\\n * @this {module:ol/interaction/Modify}\\n */\\nfunction handleEvent(mapBrowserEvent) {\\n  if (!(mapBrowserEvent instanceof MapBrowserPointerEvent)) {\\n    return true;\\n  }\\n  this.lastPointerEvent_ = mapBrowserEvent;\\n\\n  let handled;\\n  if (!mapBrowserEvent.map.getView().getInteracting() &&\\n      mapBrowserEvent.type == MapBrowserEventType.POINTERMOVE &&\\n      !this.handlingDownUpSequence) {\\n    this.handlePointerMove_(mapBrowserEvent);\\n  }\\n  if (this.vertexFeature_ && this.deleteCondition_(mapBrowserEvent)) {\\n    if (mapBrowserEvent.type != MapBrowserEventType.SINGLECLICK || !this.ignoreNextSingleClick_) {\\n      handled = this.removePoint();\\n    } else {\\n      handled = true;\\n    }\\n  }\\n\\n  if (mapBrowserEvent.type == MapBrowserEventType.SINGLECLICK) {\\n    this.ignoreNextSingleClick_ = false;\\n  }\\n\\n  return handlePointerEvent.call(this, mapBrowserEvent) && !handled;\\n}\\n\\n\\n/**\\n * @param {module:ol/MapBrowserEvent} evt Event.\\n * @private\\n */\\nModify.prototype.handlePointerMove_ = function(evt) {\\n  this.lastPixel_ = evt.pixel;\\n  this.handlePointerAtPixel_(evt.pixel, evt.map);\\n};\\n\\n\\n/**\\n * @param {module:ol~Pixel} pixel Pixel\\n * @param {module:ol/PluggableMap} map Map.\\n * @private\\n */\\nModify.prototype.handlePointerAtPixel_ = function(pixel, map) {\\n  const pixelCoordinate = map.getCoordinateFromPixel(pixel);\\n  const sortByDistance = function(a, b) {\\n    return pointDistanceToSegmentDataSquared(pixelCoordinate, a) -\\n        pointDistanceToSegmentDataSquared(pixelCoordinate, b);\\n  };\\n\\n  const box = buffer(createOrUpdateFromCoordinate(pixelCoordinate),\\n    map.getView().getResolution() * this.pixelTolerance_);\\n\\n  const rBush = this.rBush_;\\n  const nodes = rBush.getInExtent(box);\\n  if (nodes.length > 0) {\\n    nodes.sort(sortByDistance);\\n    const node = nodes[0];\\n    const closestSegment = node.segment;\\n    let vertex = closestOnSegmentData(pixelCoordinate, node);\\n    const vertexPixel = map.getPixelFromCoordinate(vertex);\\n    let dist = coordinateDistance(pixel, vertexPixel);\\n    if (dist <= this.pixelTolerance_) {\\n      const vertexSegments = {};\\n\\n      if (node.geometry.getType() === GeometryType.CIRCLE &&\\n      node.index === CIRCLE_CIRCUMFERENCE_INDEX) {\\n\\n        this.snappedToVertex_ = true;\\n        this.createOrUpdateVertexFeature_(vertex);\\n      } else {\\n        const pixel1 = map.getPixelFromCoordinate(closestSegment[0]);\\n        const pixel2 = map.getPixelFromCoordinate(closestSegment[1]);\\n        const squaredDist1 = squaredCoordinateDistance(vertexPixel, pixel1);\\n        const squaredDist2 = squaredCoordinateDistance(vertexPixel, pixel2);\\n        dist = Math.sqrt(Math.min(squaredDist1, squaredDist2));\\n        this.snappedToVertex_ = dist <= this.pixelTolerance_;\\n        if (this.snappedToVertex_) {\\n          vertex = squaredDist1 > squaredDist2 ? closestSegment[1] : closestSegment[0];\\n        }\\n        this.createOrUpdateVertexFeature_(vertex);\\n        for (let i = 1, ii = nodes.length; i < ii; ++i) {\\n          const segment = nodes[i].segment;\\n          if ((coordinatesEqual(closestSegment[0], segment[0]) &&\\n              coordinatesEqual(closestSegment[1], segment[1]) ||\\n              (coordinatesEqual(closestSegment[0], segment[1]) &&\\n              coordinatesEqual(closestSegment[1], segment[0])))) {\\n            vertexSegments[getUid(segment)] = true;\\n          } else {\\n            break;\\n          }\\n        }\\n      }\\n\\n      vertexSegments[getUid(closestSegment)] = true;\\n      this.vertexSegments_ = vertexSegments;\\n      return;\\n    }\\n  }\\n  if (this.vertexFeature_) {\\n    this.overlay_.getSource().removeFeature(this.vertexFeature_);\\n    this.vertexFeature_ = null;\\n  }\\n};\\n\\n\\n/**\\n * Returns the distance from a point to a line segment.\\n *\\n * @param {module:ol/coordinate~Coordinate} pointCoordinates The coordinates of the point from\\n *        which to calculate the distance.\\n * @param {module:ol/interaction/Modify~SegmentData} segmentData The object describing the line\\n *        segment we are calculating the distance to.\\n * @return {number} The square of the distance between a point and a line segment.\\n */\\nfunction pointDistanceToSegmentDataSquared(pointCoordinates, segmentData) {\\n  const geometry = segmentData.geometry;\\n\\n  if (geometry.getType() === GeometryType.CIRCLE) {\\n    const circleGeometry = /** @type {module:ol/geom/Circle} */ (geometry);\\n\\n    if (segmentData.index === CIRCLE_CIRCUMFERENCE_INDEX) {\\n      const distanceToCenterSquared =\\n            squaredCoordinateDistance(circleGeometry.getCenter(), pointCoordinates);\\n      const distanceToCircumference =\\n            Math.sqrt(distanceToCenterSquared) - circleGeometry.getRadius();\\n      return distanceToCircumference * distanceToCircumference;\\n    }\\n  }\\n  return squaredDistanceToSegment(pointCoordinates, segmentData.segment);\\n}\\n\\n/**\\n * Returns the point closest to a given line segment.\\n *\\n * @param {module:ol/coordinate~Coordinate} pointCoordinates The point to which a closest point\\n *        should be found.\\n * @param {module:ol/interaction/Modify~SegmentData} segmentData The object describing the line\\n *        segment which should contain the closest point.\\n * @return {module:ol/coordinate~Coordinate} The point closest to the specified line segment.\\n */\\nfunction closestOnSegmentData(pointCoordinates, segmentData) {\\n  const geometry = segmentData.geometry;\\n\\n  if (geometry.getType() === GeometryType.CIRCLE &&\\n  segmentData.index === CIRCLE_CIRCUMFERENCE_INDEX) {\\n    return geometry.getClosestPoint(pointCoordinates);\\n  }\\n  return closestOnSegment(pointCoordinates, segmentData.segment);\\n}\\n\\n\\n/**\\n * @param {module:ol/interaction/Modify~SegmentData} segmentData Segment data.\\n * @param {module:ol/coordinate~Coordinate} vertex Vertex.\\n * @private\\n */\\nModify.prototype.insertVertex_ = function(segmentData, vertex) {\\n  const segment = segmentData.segment;\\n  const feature = segmentData.feature;\\n  const geometry = segmentData.geometry;\\n  const depth = segmentData.depth;\\n  const index = /** @type {number} */ (segmentData.index);\\n  let coordinates;\\n\\n  while (vertex.length < geometry.getStride()) {\\n    vertex.push(0);\\n  }\\n\\n  switch (geometry.getType()) {\\n    case GeometryType.MULTI_LINE_STRING:\\n      coordinates = geometry.getCoordinates();\\n      coordinates[depth[0]].splice(index + 1, 0, vertex);\\n      break;\\n    case GeometryType.POLYGON:\\n      coordinates = geometry.getCoordinates();\\n      coordinates[depth[0]].splice(index + 1, 0, vertex);\\n      break;\\n    case GeometryType.MULTI_POLYGON:\\n      coordinates = geometry.getCoordinates();\\n      coordinates[depth[1]][depth[0]].splice(index + 1, 0, vertex);\\n      break;\\n    case GeometryType.LINE_STRING:\\n      coordinates = geometry.getCoordinates();\\n      coordinates.splice(index + 1, 0, vertex);\\n      break;\\n    default:\\n      return;\\n  }\\n\\n  this.setGeometryCoordinates_(geometry, coordinates);\\n  const rTree = this.rBush_;\\n  rTree.remove(segmentData);\\n  this.updateSegmentIndices_(geometry, index, depth, 1);\\n  const newSegmentData = /** @type {module:ol/interaction/Modify~SegmentData} */ ({\\n    segment: [segment[0], vertex],\\n    feature: feature,\\n    geometry: geometry,\\n    depth: depth,\\n    index: index\\n  });\\n  rTree.insert(boundingExtent(newSegmentData.segment),\\n    newSegmentData);\\n  this.dragSegments_.push([newSegmentData, 1]);\\n\\n  const newSegmentData2 = /** @type {module:ol/interaction/Modify~SegmentData} */ ({\\n    segment: [vertex, segment[1]],\\n    feature: feature,\\n    geometry: geometry,\\n    depth: depth,\\n    index: index + 1\\n  });\\n  rTree.insert(boundingExtent(newSegmentData2.segment), newSegmentData2);\\n  this.dragSegments_.push([newSegmentData2, 0]);\\n  this.ignoreNextSingleClick_ = true;\\n};\\n\\n/**\\n * Removes the vertex currently being pointed.\\n * @return {boolean} True when a vertex was removed.\\n * @api\\n */\\nModify.prototype.removePoint = function() {\\n  if (this.lastPointerEvent_ && this.lastPointerEvent_.type != MapBrowserEventType.POINTERDRAG) {\\n    const evt = this.lastPointerEvent_;\\n    this.willModifyFeatures_(evt);\\n    this.removeVertex_();\\n    this.dispatchEvent(new ModifyEvent(ModifyEventType.MODIFYEND, this.features_, evt));\\n    this.modified_ = false;\\n    return true;\\n  }\\n  return false;\\n};\\n\\n/**\\n * Removes a vertex from all matching features.\\n * @return {boolean} True when a vertex was removed.\\n * @private\\n */\\nModify.prototype.removeVertex_ = function() {\\n  const dragSegments = this.dragSegments_;\\n  const segmentsByFeature = {};\\n  let deleted = false;\\n  let component, coordinates, dragSegment, geometry, i, index, left;\\n  let newIndex, right, segmentData, uid;\\n  for (i = dragSegments.length - 1; i >= 0; --i) {\\n    dragSegment = dragSegments[i];\\n    segmentData = dragSegment[0];\\n    uid = getUid(segmentData.feature);\\n    if (segmentData.depth) {\\n      // separate feature components\\n      uid += '-' + segmentData.depth.join('-');\\n    }\\n    if (!(uid in segmentsByFeature)) {\\n      segmentsByFeature[uid] = {};\\n    }\\n    if (dragSegment[1] === 0) {\\n      segmentsByFeature[uid].right = segmentData;\\n      segmentsByFeature[uid].index = segmentData.index;\\n    } else if (dragSegment[1] == 1) {\\n      segmentsByFeature[uid].left = segmentData;\\n      segmentsByFeature[uid].index = segmentData.index + 1;\\n    }\\n\\n  }\\n  for (uid in segmentsByFeature) {\\n    right = segmentsByFeature[uid].right;\\n    left = segmentsByFeature[uid].left;\\n    index = segmentsByFeature[uid].index;\\n    newIndex = index - 1;\\n    if (left !== undefined) {\\n      segmentData = left;\\n    } else {\\n      segmentData = right;\\n    }\\n    if (newIndex < 0) {\\n      newIndex = 0;\\n    }\\n    geometry = segmentData.geometry;\\n    coordinates = geometry.getCoordinates();\\n    component = coordinates;\\n    deleted = false;\\n    switch (geometry.getType()) {\\n      case GeometryType.MULTI_LINE_STRING:\\n        if (coordinates[segmentData.depth[0]].length > 2) {\\n          coordinates[segmentData.depth[0]].splice(index, 1);\\n          deleted = true;\\n        }\\n        break;\\n      case GeometryType.LINE_STRING:\\n        if (coordinates.length > 2) {\\n          coordinates.splice(index, 1);\\n          deleted = true;\\n        }\\n        break;\\n      case GeometryType.MULTI_POLYGON:\\n        component = component[segmentData.depth[1]];\\n        /* falls through */\\n      case GeometryType.POLYGON:\\n        component = component[segmentData.depth[0]];\\n        if (component.length > 4) {\\n          if (index == component.length - 1) {\\n            index = 0;\\n          }\\n          component.splice(index, 1);\\n          deleted = true;\\n          if (index === 0) {\\n            // close the ring again\\n            component.pop();\\n            component.push(component[0]);\\n            newIndex = component.length - 1;\\n          }\\n        }\\n        break;\\n      default:\\n        // pass\\n    }\\n\\n    if (deleted) {\\n      this.setGeometryCoordinates_(geometry, coordinates);\\n      const segments = [];\\n      if (left !== undefined) {\\n        this.rBush_.remove(left);\\n        segments.push(left.segment[0]);\\n      }\\n      if (right !== undefined) {\\n        this.rBush_.remove(right);\\n        segments.push(right.segment[1]);\\n      }\\n      if (left !== undefined && right !== undefined) {\\n        const newSegmentData = /** @type {module:ol/interaction/Modify~SegmentData} */ ({\\n          depth: segmentData.depth,\\n          feature: segmentData.feature,\\n          geometry: segmentData.geometry,\\n          index: newIndex,\\n          segment: segments\\n        });\\n        this.rBush_.insert(boundingExtent(newSegmentData.segment),\\n          newSegmentData);\\n      }\\n      this.updateSegmentIndices_(geometry, index, segmentData.depth, -1);\\n      if (this.vertexFeature_) {\\n        this.overlay_.getSource().removeFeature(this.vertexFeature_);\\n        this.vertexFeature_ = null;\\n      }\\n      dragSegments.length = 0;\\n    }\\n\\n  }\\n  return deleted;\\n};\\n\\n\\n/**\\n * @param {module:ol/geom/SimpleGeometry} geometry Geometry.\\n * @param {Array} coordinates Coordinates.\\n * @private\\n */\\nModify.prototype.setGeometryCoordinates_ = function(geometry, coordinates) {\\n  this.changingFeature_ = true;\\n  geometry.setCoordinates(coordinates);\\n  this.changingFeature_ = false;\\n};\\n\\n\\n/**\\n * @param {module:ol/geom/SimpleGeometry} geometry Geometry.\\n * @param {number} index Index.\\n * @param {Array.<number>|undefined} depth Depth.\\n * @param {number} delta Delta (1 or -1).\\n * @private\\n */\\nModify.prototype.updateSegmentIndices_ = function(\\n  geometry, index, depth, delta) {\\n  this.rBush_.forEachInExtent(geometry.getExtent(), function(segmentDataMatch) {\\n    if (segmentDataMatch.geometry === geometry &&\\n        (depth === undefined || segmentDataMatch.depth === undefined ||\\n        equals(segmentDataMatch.depth, depth)) &&\\n        segmentDataMatch.index > index) {\\n      segmentDataMatch.index += delta;\\n    }\\n  });\\n};\\n\\n\\n/**\\n * @return {module:ol/style/Style~StyleFunction} Styles.\\n */\\nfunction getDefaultStyleFunction() {\\n  const style = createEditingStyle();\\n  return function(feature, resolution) {\\n    return style[GeometryType.POINT];\\n  };\\n}\\n\\n\\nexport default Modify;\\n\",\"/**\\n * @module ol/interaction/Select\\n */\\nimport {getUid, inherits} from '../index.js';\\nimport CollectionEventType from '../CollectionEventType.js';\\nimport {extend, includes} from '../array.js';\\nimport {listen} from '../events.js';\\nimport Event from '../events/Event.js';\\nimport {singleClick, never, shiftKeyOnly, pointerMove} from '../events/condition.js';\\nimport {TRUE} from '../functions.js';\\nimport GeometryType from '../geom/GeometryType.js';\\nimport Interaction from '../interaction/Interaction.js';\\nimport VectorLayer from '../layer/Vector.js';\\nimport {clear} from '../obj.js';\\nimport VectorSource from '../source/Vector.js';\\nimport {createEditingStyle} from '../style/Style.js';\\n\\n\\n/**\\n * @enum {string}\\n */\\nconst SelectEventType = {\\n  /**\\n   * Triggered when feature(s) has been (de)selected.\\n   * @event SelectEvent#select\\n   * @api\\n   */\\n  SELECT: 'select'\\n};\\n\\n\\n/**\\n * A function that takes an {@link module:ol/Feature} or\\n * {@link module:ol/render/Feature} and an\\n * {@link module:ol/layer/Layer} and returns `true` if the feature may be\\n * selected or `false` otherwise.\\n * @typedef {function((module:ol/Feature|module:ol/render/Feature), module:ol/layer/Layer):\\n *     boolean} FilterFunction\\n */\\n\\n\\n/**\\n * @typedef {Object} Options\\n * @property {module:ol/events/condition~Condition} [addCondition] A function\\n * that takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a\\n * boolean to indicate whether that event should be handled.\\n * By default, this is {@link module:ol/events/condition~never}. Use this if you\\n * want to use different events for add and remove instead of `toggle`.\\n * @property {module:ol/events/condition~Condition} [condition] A function that\\n * takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a\\n * boolean to indicate whether that event should be handled. This is the event\\n * for the selected features as a whole. By default, this is\\n * {@link module:ol/events/condition~singleClick}. Clicking on a feature selects that\\n * feature and removes any that were in the selection. Clicking outside any\\n * feature removes all from the selection.\\n * See `toggle`, `add`, `remove` options for adding/removing extra features to/\\n * from the selection.\\n * @property {Array.<module:ol/layer/Layer>|function(module:ol/layer/Layer): boolean} [layers]\\n * A list of layers from which features should be selected. Alternatively, a\\n * filter function can be provided. The function will be called for each layer\\n * in the map and should return `true` for layers that you want to be\\n * selectable. If the option is absent, all visible layers will be considered\\n * selectable.\\n * @property {module:ol/style/Style|Array.<module:ol/style/Style>|module:ol/style/Style~StyleFunction} [style]\\n * Style for the selected features. By default the default edit style is used\\n * (see {@link module:ol/style}).\\n * @property {module:ol/events/condition~Condition} [removeCondition] A function\\n * that takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a\\n * boolean to indicate whether that event should be handled.\\n * By default, this is {@link module:ol/events/condition~never}. Use this if you\\n * want to use different events for add and remove instead of `toggle`.\\n * @property {module:ol/events/condition~Condition} [toggleCondition] A function\\n * that takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a\\n * boolean to indicate whether that event should be handled. This is in addition\\n * to the `condition` event. By default,\\n * {@link module:ol/events/condition~shiftKeyOnly}, i.e. pressing `shift` as\\n * well as the `condition` event, adds that feature to the current selection if\\n * it is not currently selected, and removes it if it is. See `add` and `remove`\\n * if you want to use different events instead of a toggle.\\n * @property {boolean} [multi=false] A boolean that determines if the default\\n * behaviour should select only single features or all (overlapping) features at\\n * the clicked map position. The default of `false` means single select.\\n * @property {module:ol/Collection.<module:ol/Feature>} [features]\\n * Collection where the interaction will place selected features. Optional. If\\n * not set the interaction will create a collection. In any case the collection\\n * used by the interaction is returned by\\n * {@link module:ol/interaction/Select~Select#getFeatures}.\\n * @property {module:ol/interaction/Select~FilterFunction} [filter] A function\\n * that takes an {@link module:ol/Feature} and an\\n * {@link module:ol/layer/Layer} and returns `true` if the feature may be\\n * selected or `false` otherwise.\\n * @property {boolean} [wrapX=true] Wrap the world horizontally on the selection\\n * overlay.\\n * @property {number} [hitTolerance=0] Hit-detection tolerance. Pixels inside\\n * the radius around the given position will be checked for features. This only\\n * works for the canvas renderer and not for WebGL.\\n */\\n\\n\\n/**\\n * @classdesc\\n * Events emitted by {@link module:ol/interaction/Select~Select} instances are instances of\\n * this type.\\n *\\n * @param {SelectEventType} type The event type.\\n * @param {Array.<module:ol/Feature>} selected Selected features.\\n * @param {Array.<module:ol/Feature>} deselected Deselected features.\\n * @param {module:ol/MapBrowserEvent} mapBrowserEvent Associated\\n *     {@link module:ol/MapBrowserEvent}.\\n * @extends {module:ol/events/Event}\\n * @constructor\\n */\\nconst SelectEvent = function(type, selected, deselected, mapBrowserEvent) {\\n  Event.call(this, type);\\n\\n  /**\\n   * Selected features array.\\n   * @type {Array.<module:ol/Feature>}\\n   * @api\\n   */\\n  this.selected = selected;\\n\\n  /**\\n   * Deselected features array.\\n   * @type {Array.<module:ol/Feature>}\\n   * @api\\n   */\\n  this.deselected = deselected;\\n\\n  /**\\n   * Associated {@link module:ol/MapBrowserEvent}.\\n   * @type {module:ol/MapBrowserEvent}\\n   * @api\\n   */\\n  this.mapBrowserEvent = mapBrowserEvent;\\n};\\n\\ninherits(SelectEvent, Event);\\n\\n\\n/**\\n * @classdesc\\n * Interaction for selecting vector features. By default, selected features are\\n * styled differently, so this interaction can be used for visual highlighting,\\n * as well as selecting features for other actions, such as modification or\\n * output. There are three ways of controlling which features are selected:\\n * using the browser event as defined by the `condition` and optionally the\\n * `toggle`, `add`/`remove`, and `multi` options; a `layers` filter; and a\\n * further feature filter using the `filter` option.\\n *\\n * Selected features are added to an internal unmanaged layer.\\n *\\n * @constructor\\n * @extends {module:ol/interaction/Interaction}\\n * @param {module:ol/interaction/Select~Options=} opt_options Options.\\n * @fires SelectEvent\\n * @api\\n */\\nconst Select = function(opt_options) {\\n\\n  Interaction.call(this, {\\n    handleEvent: handleEvent\\n  });\\n\\n  const options = opt_options ? opt_options : {};\\n\\n  /**\\n   * @private\\n   * @type {module:ol/events/condition~Condition}\\n   */\\n  this.condition_ = options.condition ? options.condition : singleClick;\\n\\n  /**\\n   * @private\\n   * @type {module:ol/events/condition~Condition}\\n   */\\n  this.addCondition_ = options.addCondition ? options.addCondition : never;\\n\\n  /**\\n   * @private\\n   * @type {module:ol/events/condition~Condition}\\n   */\\n  this.removeCondition_ = options.removeCondition ? options.removeCondition : never;\\n\\n  /**\\n   * @private\\n   * @type {module:ol/events/condition~Condition}\\n   */\\n  this.toggleCondition_ = options.toggleCondition ? options.toggleCondition : shiftKeyOnly;\\n\\n  /**\\n   * @private\\n   * @type {boolean}\\n   */\\n  this.multi_ = options.multi ? options.multi : false;\\n\\n  /**\\n   * @private\\n   * @type {module:ol/interaction/Select~FilterFunction}\\n   */\\n  this.filter_ = options.filter ? options.filter : TRUE;\\n\\n  /**\\n   * @private\\n   * @type {number}\\n   */\\n  this.hitTolerance_ = options.hitTolerance ? options.hitTolerance : 0;\\n\\n  const featureOverlay = new VectorLayer({\\n    source: new VectorSource({\\n      useSpatialIndex: false,\\n      features: options.features,\\n      wrapX: options.wrapX\\n    }),\\n    style: options.style ? options.style :\\n      getDefaultStyleFunction(),\\n    updateWhileAnimating: true,\\n    updateWhileInteracting: true\\n  });\\n\\n  /**\\n   * @private\\n   * @type {module:ol/layer/Vector}\\n   */\\n  this.featureOverlay_ = featureOverlay;\\n\\n  /** @type {function(module:ol/layer/Layer): boolean} */\\n  let layerFilter;\\n  if (options.layers) {\\n    if (typeof options.layers === 'function') {\\n      layerFilter = options.layers;\\n    } else {\\n      const layers = options.layers;\\n      layerFilter = function(layer) {\\n        return includes(layers, layer);\\n      };\\n    }\\n  } else {\\n    layerFilter = TRUE;\\n  }\\n\\n  /**\\n   * @private\\n   * @type {function(module:ol/layer/Layer): boolean}\\n   */\\n  this.layerFilter_ = layerFilter;\\n\\n  /**\\n   * An association between selected feature (key)\\n   * and layer (value)\\n   * @private\\n   * @type {Object.<number, module:ol/layer/Layer>}\\n   */\\n  this.featureLayerAssociation_ = {};\\n\\n  const features = this.featureOverlay_.getSource().getFeaturesCollection();\\n  listen(features, CollectionEventType.ADD,\\n    this.addFeature_, this);\\n  listen(features, CollectionEventType.REMOVE,\\n    this.removeFeature_, this);\\n\\n};\\n\\ninherits(Select, Interaction);\\n\\n\\n/**\\n * @param {module:ol/Feature|module:ol/render/Feature} feature Feature.\\n * @param {module:ol/layer/Layer} layer Layer.\\n * @private\\n */\\nSelect.prototype.addFeatureLayerAssociation_ = function(feature, layer) {\\n  const key = getUid(feature);\\n  this.featureLayerAssociation_[key] = layer;\\n};\\n\\n\\n/**\\n * Get the selected features.\\n * @return {module:ol/Collection.<module:ol/Feature>} Features collection.\\n * @api\\n */\\nSelect.prototype.getFeatures = function() {\\n  return this.featureOverlay_.getSource().getFeaturesCollection();\\n};\\n\\n\\n/**\\n * Returns the Hit-detection tolerance.\\n * @returns {number} Hit tolerance in pixels.\\n * @api\\n */\\nSelect.prototype.getHitTolerance = function() {\\n  return this.hitTolerance_;\\n};\\n\\n\\n/**\\n * Returns the associated {@link module:ol/layer/Vector~Vector vectorlayer} of\\n * the (last) selected feature. Note that this will not work with any\\n * programmatic method like pushing features to\\n * {@link module:ol/interaction/Select~Select#getFeatures collection}.\\n * @param {module:ol/Feature|module:ol/render/Feature} feature Feature\\n * @return {module:ol/layer/Vector} Layer.\\n * @api\\n */\\nSelect.prototype.getLayer = function(feature) {\\n  const key = getUid(feature);\\n  return (\\n    /** @type {module:ol/layer/Vector} */ (this.featureLayerAssociation_[key])\\n  );\\n};\\n\\n\\n/**\\n * Handles the {@link module:ol/MapBrowserEvent map browser event} and may change the\\n * selected state of features.\\n * @param {module:ol/MapBrowserEvent} mapBrowserEvent Map browser event.\\n * @return {boolean} `false` to stop event propagation.\\n * @this {module:ol/interaction/Select}\\n */\\nfunction handleEvent(mapBrowserEvent) {\\n  if (!this.condition_(mapBrowserEvent)) {\\n    return true;\\n  }\\n  const add = this.addCondition_(mapBrowserEvent);\\n  const remove = this.removeCondition_(mapBrowserEvent);\\n  const toggle = this.toggleCondition_(mapBrowserEvent);\\n  const set = !add && !remove && !toggle;\\n  const map = mapBrowserEvent.map;\\n  const features = this.featureOverlay_.getSource().getFeaturesCollection();\\n  const deselected = [];\\n  const selected = [];\\n  if (set) {\\n    // Replace the currently selected feature(s) with the feature(s) at the\\n    // pixel, or clear the selected feature(s) if there is no feature at\\n    // the pixel.\\n    clear(this.featureLayerAssociation_);\\n    map.forEachFeatureAtPixel(mapBrowserEvent.pixel,\\n      (\\n        /**\\n         * @param {module:ol/Feature|module:ol/render/Feature} feature Feature.\\n         * @param {module:ol/layer/Layer} layer Layer.\\n         * @return {boolean|undefined} Continue to iterate over the features.\\n         */\\n        function(feature, layer) {\\n          if (this.filter_(feature, layer)) {\\n            selected.push(feature);\\n            this.addFeatureLayerAssociation_(feature, layer);\\n            return !this.multi_;\\n          }\\n        }).bind(this), {\\n        layerFilter: this.layerFilter_,\\n        hitTolerance: this.hitTolerance_\\n      });\\n    for (let i = features.getLength() - 1; i >= 0; --i) {\\n      const feature = features.item(i);\\n      const index = selected.indexOf(feature);\\n      if (index > -1) {\\n        // feature is already selected\\n        selected.splice(index, 1);\\n      } else {\\n        features.remove(feature);\\n        deselected.push(feature);\\n      }\\n    }\\n    if (selected.length !== 0) {\\n      features.extend(selected);\\n    }\\n  } else {\\n    // Modify the currently selected feature(s).\\n    map.forEachFeatureAtPixel(mapBrowserEvent.pixel,\\n      (\\n        /**\\n         * @param {module:ol/Feature|module:ol/render/Feature} feature Feature.\\n         * @param {module:ol/layer/Layer} layer Layer.\\n         * @return {boolean|undefined} Continue to iterate over the features.\\n         */\\n        function(feature, layer) {\\n          if (this.filter_(feature, layer)) {\\n            if ((add || toggle) && !includes(features.getArray(), feature)) {\\n              selected.push(feature);\\n              this.addFeatureLayerAssociation_(feature, layer);\\n            } else if ((remove || toggle) && includes(features.getArray(), feature)) {\\n              deselected.push(feature);\\n              this.removeFeatureLayerAssociation_(feature);\\n            }\\n            return !this.multi_;\\n          }\\n        }).bind(this), {\\n        layerFilter: this.layerFilter_,\\n        hitTolerance: this.hitTolerance_\\n      });\\n    for (let j = deselected.length - 1; j >= 0; --j) {\\n      features.remove(deselected[j]);\\n    }\\n    features.extend(selected);\\n  }\\n  if (selected.length > 0 || deselected.length > 0) {\\n    this.dispatchEvent(\\n      new SelectEvent(SelectEventType.SELECT,\\n        selected, deselected, mapBrowserEvent));\\n  }\\n  return pointerMove(mapBrowserEvent);\\n}\\n\\n\\n/**\\n * Hit-detection tolerance. Pixels inside the radius around the given position\\n * will be checked for features. This only works for the canvas renderer and\\n * not for WebGL.\\n * @param {number} hitTolerance Hit tolerance in pixels.\\n * @api\\n */\\nSelect.prototype.setHitTolerance = function(hitTolerance) {\\n  this.hitTolerance_ = hitTolerance;\\n};\\n\\n\\n/**\\n * Remove the interaction from its current map, if any,  and attach it to a new\\n * map, if any. Pass `null` to just remove the interaction from the current map.\\n * @param {module:ol/PluggableMap} map Map.\\n * @override\\n * @api\\n */\\nSelect.prototype.setMap = function(map) {\\n  const currentMap = this.getMap();\\n  const selectedFeatures =\\n      this.featureOverlay_.getSource().getFeaturesCollection();\\n  if (currentMap) {\\n    selectedFeatures.forEach(currentMap.unskipFeature.bind(currentMap));\\n  }\\n  Interaction.prototype.setMap.call(this, map);\\n  this.featureOverlay_.setMap(map);\\n  if (map) {\\n    selectedFeatures.forEach(map.skipFeature.bind(map));\\n  }\\n};\\n\\n\\n/**\\n * @return {module:ol/style/Style~StyleFunction} Styles.\\n */\\nfunction getDefaultStyleFunction() {\\n  const styles = createEditingStyle();\\n  extend(styles[GeometryType.POLYGON], styles[GeometryType.LINE_STRING]);\\n  extend(styles[GeometryType.GEOMETRY_COLLECTION], styles[GeometryType.LINE_STRING]);\\n\\n  return function(feature, resolution) {\\n    if (!feature.getGeometry()) {\\n      return null;\\n    }\\n    return styles[feature.getGeometry().getType()];\\n  };\\n}\\n\\n\\n/**\\n * @param {module:ol/Collection~CollectionEvent} evt Event.\\n * @private\\n */\\nSelect.prototype.addFeature_ = function(evt) {\\n  const map = this.getMap();\\n  if (map) {\\n    map.skipFeature(/** @type {module:ol/Feature} */ (evt.element));\\n  }\\n};\\n\\n\\n/**\\n * @param {module:ol/Collection~CollectionEvent} evt Event.\\n * @private\\n */\\nSelect.prototype.removeFeature_ = function(evt) {\\n  const map = this.getMap();\\n  if (map) {\\n    map.unskipFeature(/** @type {module:ol/Feature} */ (evt.element));\\n  }\\n};\\n\\n\\n/**\\n * @param {module:ol/Feature|module:ol/render/Feature} feature Feature.\\n * @private\\n */\\nSelect.prototype.removeFeatureLayerAssociation_ = function(feature) {\\n  const key = getUid(feature);\\n  delete this.featureLayerAssociation_[key];\\n};\\n\\n\\nexport default Select;\\n\",\"/**\\n * @module ol/interaction/Snap\\n */\\nimport {getUid, inherits} from '../index.js';\\nimport {CollectionEvent} from '../Collection.js';\\nimport CollectionEventType from '../CollectionEventType.js';\\nimport {distance as coordinateDistance, squaredDistance as squaredCoordinateDistance, closestOnCircle, closestOnSegment, squaredDistanceToSegment} from '../coordinate.js';\\nimport {listen, unlistenByKey} from '../events.js';\\nimport EventType from '../events/EventType.js';\\nimport {boundingExtent, createEmpty} from '../extent.js';\\nimport {TRUE, FALSE} from '../functions.js';\\nimport GeometryType from '../geom/GeometryType.js';\\nimport {fromCircle} from '../geom/Polygon.js';\\nimport PointerInteraction, {handleEvent as handlePointerEvent} from '../interaction/Pointer.js';\\nimport {getValues} from '../obj.js';\\nimport {VectorSourceEvent} from '../source/Vector.js';\\nimport VectorEventType from '../source/VectorEventType.js';\\nimport RBush from '../structs/RBush.js';\\n\\n\\n/**\\n * @typedef {Object} Result\\n * @property {boolean} snapped\\n * @property {module:ol/coordinate~Coordinate|null} vertex\\n * @property {module:ol~Pixel|null} vertexPixel\\n */\\n\\n\\n/**\\n * @typedef {Object} SegmentData\\n * @property {module:ol/Feature} feature\\n * @property {Array.<module:ol/coordinate~Coordinate>} segment\\n */\\n\\n\\n/**\\n * @typedef {Object} Options\\n * @property {module:ol/Collection.<module:ol/Feature>} [features] Snap to these features. Either this option or source should be provided.\\n * @property {boolean} [edge=true] Snap to edges.\\n * @property {boolean} [vertex=true] Snap to vertices.\\n * @property {number} [pixelTolerance=10] Pixel tolerance for considering the pointer close enough to a segment or\\n * vertex for snapping.\\n * @property {module:ol/source/Vector} [source] Snap to features from this source. Either this option or features should be provided\\n */\\n\\n\\n/**\\n * @classdesc\\n * Handles snapping of vector features while modifying or drawing them.  The\\n * features can come from a {@link module:ol/source/Vector} or {@link module:ol/Collection~Collection}\\n * Any interaction object that allows the user to interact\\n * with the features using the mouse can benefit from the snapping, as long\\n * as it is added before.\\n *\\n * The snap interaction modifies map browser event `coordinate` and `pixel`\\n * properties to force the snap to occur to any interaction that them.\\n *\\n * Example:\\n *\\n *     import Snap from 'ol/interaction/Snap';\\n *\\n *     var snap = new Snap({\\n *       source: source\\n *     });\\n *\\n * @constructor\\n * @extends {module:ol/interaction/Pointer}\\n * @param {module:ol/interaction/Snap~Options=} opt_options Options.\\n * @api\\n */\\nconst Snap = function(opt_options) {\\n\\n  PointerInteraction.call(this, {\\n    handleEvent: handleEvent,\\n    handleDownEvent: TRUE,\\n    handleUpEvent: handleUpEvent\\n  });\\n\\n  const options = opt_options ? opt_options : {};\\n\\n  /**\\n   * @type {module:ol/source/Vector}\\n   * @private\\n   */\\n  this.source_ = options.source ? options.source : null;\\n\\n  /**\\n   * @private\\n   * @type {boolean}\\n   */\\n  this.vertex_ = options.vertex !== undefined ? options.vertex : true;\\n\\n  /**\\n   * @private\\n   * @type {boolean}\\n   */\\n  this.edge_ = options.edge !== undefined ? options.edge : true;\\n\\n  /**\\n   * @type {module:ol/Collection.<module:ol/Feature>}\\n   * @private\\n   */\\n  this.features_ = options.features ? options.features : null;\\n\\n  /**\\n   * @type {Array.<module:ol/events~EventsKey>}\\n   * @private\\n   */\\n  this.featuresListenerKeys_ = [];\\n\\n  /**\\n   * @type {Object.<number, module:ol/events~EventsKey>}\\n   * @private\\n   */\\n  this.featureChangeListenerKeys_ = {};\\n\\n  /**\\n   * Extents are preserved so indexed segment can be quickly removed\\n   * when its feature geometry changes\\n   * @type {Object.<number, module:ol/extent~Extent>}\\n   * @private\\n   */\\n  this.indexedFeaturesExtents_ = {};\\n\\n  /**\\n   * If a feature geometry changes while a pointer drag|move event occurs, the\\n   * feature doesn't get updated right away.  It will be at the next 'pointerup'\\n   * event fired.\\n   * @type {!Object.<number, module:ol/Feature>}\\n   * @private\\n   */\\n  this.pendingFeatures_ = {};\\n\\n  /**\\n   * Used for distance sorting in sortByDistance_\\n   * @type {module:ol/coordinate~Coordinate}\\n   * @private\\n   */\\n  this.pixelCoordinate_ = null;\\n\\n  /**\\n   * @type {number}\\n   * @private\\n   */\\n  this.pixelTolerance_ = options.pixelTolerance !== undefined ?\\n    options.pixelTolerance : 10;\\n\\n  /**\\n   * @type {function(module:ol/interaction/Snap~SegmentData, module:ol/interaction/Snap~SegmentData): number}\\n   * @private\\n   */\\n  this.sortByDistance_ = sortByDistance.bind(this);\\n\\n\\n  /**\\n  * Segment RTree for each layer\\n  * @type {module:ol/structs/RBush.<module:ol/interaction/Snap~SegmentData>}\\n  * @private\\n  */\\n  this.rBush_ = new RBush();\\n\\n\\n  /**\\n  * @const\\n  * @private\\n  * @type {Object.<string, function(module:ol/Feature, module:ol/geom/Geometry)>}\\n  */\\n  this.SEGMENT_WRITERS_ = {\\n    'Point': this.writePointGeometry_,\\n    'LineString': this.writeLineStringGeometry_,\\n    'LinearRing': this.writeLineStringGeometry_,\\n    'Polygon': this.writePolygonGeometry_,\\n    'MultiPoint': this.writeMultiPointGeometry_,\\n    'MultiLineString': this.writeMultiLineStringGeometry_,\\n    'MultiPolygon': this.writeMultiPolygonGeometry_,\\n    'GeometryCollection': this.writeGeometryCollectionGeometry_,\\n    'Circle': this.writeCircleGeometry_\\n  };\\n};\\n\\ninherits(Snap, PointerInteraction);\\n\\n\\n/**\\n * Add a feature to the collection of features that we may snap to.\\n * @param {module:ol/Feature} feature Feature.\\n * @param {boolean=} opt_listen Whether to listen to the feature change or not\\n *     Defaults to `true`.\\n * @api\\n */\\nSnap.prototype.addFeature = function(feature, opt_listen) {\\n  const register = opt_listen !== undefined ? opt_listen : true;\\n  const feature_uid = getUid(feature);\\n  const geometry = feature.getGeometry();\\n  if (geometry) {\\n    const segmentWriter = this.SEGMENT_WRITERS_[geometry.getType()];\\n    if (segmentWriter) {\\n      this.indexedFeaturesExtents_[feature_uid] = geometry.getExtent(createEmpty());\\n      segmentWriter.call(this, feature, geometry);\\n    }\\n  }\\n\\n  if (register) {\\n    this.featureChangeListenerKeys_[feature_uid] = listen(\\n      feature,\\n      EventType.CHANGE,\\n      this.handleFeatureChange_, this);\\n  }\\n};\\n\\n\\n/**\\n * @param {module:ol/Feature} feature Feature.\\n * @private\\n */\\nSnap.prototype.forEachFeatureAdd_ = function(feature) {\\n  this.addFeature(feature);\\n};\\n\\n\\n/**\\n * @param {module:ol/Feature} feature Feature.\\n * @private\\n */\\nSnap.prototype.forEachFeatureRemove_ = function(feature) {\\n  this.removeFeature(feature);\\n};\\n\\n\\n/**\\n * @return {module:ol/Collection.<module:ol/Feature>|Array.<module:ol/Feature>} Features.\\n * @private\\n */\\nSnap.prototype.getFeatures_ = function() {\\n  let features;\\n  if (this.features_) {\\n    features = this.features_;\\n  } else if (this.source_) {\\n    features = this.source_.getFeatures();\\n  }\\n  return (\\n    /** @type {!Array.<module:ol/Feature>|!module:ol/Collection.<module:ol/Feature>} */ (features)\\n  );\\n};\\n\\n\\n/**\\n * @param {module:ol/source/Vector|module:ol/Collection~CollectionEvent} evt Event.\\n * @private\\n */\\nSnap.prototype.handleFeatureAdd_ = function(evt) {\\n  let feature;\\n  if (evt instanceof VectorSourceEvent) {\\n    feature = evt.feature;\\n  } else if (evt instanceof CollectionEvent) {\\n    feature = evt.element;\\n  }\\n  this.addFeature(/** @type {module:ol/Feature} */ (feature));\\n};\\n\\n\\n/**\\n * @param {module:ol/source/Vector|module:ol/Collection~CollectionEvent} evt Event.\\n * @private\\n */\\nSnap.prototype.handleFeatureRemove_ = function(evt) {\\n  let feature;\\n  if (evt instanceof VectorSourceEvent) {\\n    feature = evt.feature;\\n  } else if (evt instanceof CollectionEvent) {\\n    feature = evt.element;\\n  }\\n  this.removeFeature(/** @type {module:ol/Feature} */ (feature));\\n};\\n\\n\\n/**\\n * @param {module:ol/events/Event} evt Event.\\n * @private\\n */\\nSnap.prototype.handleFeatureChange_ = function(evt) {\\n  const feature = /** @type {module:ol/Feature} */ (evt.target);\\n  if (this.handlingDownUpSequence) {\\n    const uid = getUid(feature);\\n    if (!(uid in this.pendingFeatures_)) {\\n      this.pendingFeatures_[uid] = feature;\\n    }\\n  } else {\\n    this.updateFeature_(feature);\\n  }\\n};\\n\\n\\n/**\\n * Remove a feature from the collection of features that we may snap to.\\n * @param {module:ol/Feature} feature Feature\\n * @param {boolean=} opt_unlisten Whether to unlisten to the feature change\\n *     or not. Defaults to `true`.\\n * @api\\n */\\nSnap.prototype.removeFeature = function(feature, opt_unlisten) {\\n  const unregister = opt_unlisten !== undefined ? opt_unlisten : true;\\n  const feature_uid = getUid(feature);\\n  const extent = this.indexedFeaturesExtents_[feature_uid];\\n  if (extent) {\\n    const rBush = this.rBush_;\\n    const nodesToRemove = [];\\n    rBush.forEachInExtent(extent, function(node) {\\n      if (feature === node.feature) {\\n        nodesToRemove.push(node);\\n      }\\n    });\\n    for (let i = nodesToRemove.length - 1; i >= 0; --i) {\\n      rBush.remove(nodesToRemove[i]);\\n    }\\n  }\\n\\n  if (unregister) {\\n    unlistenByKey(this.featureChangeListenerKeys_[feature_uid]);\\n    delete this.featureChangeListenerKeys_[feature_uid];\\n  }\\n};\\n\\n\\n/**\\n * @inheritDoc\\n */\\nSnap.prototype.setMap = function(map) {\\n  const currentMap = this.getMap();\\n  const keys = this.featuresListenerKeys_;\\n  const features = this.getFeatures_();\\n\\n  if (currentMap) {\\n    keys.forEach(unlistenByKey);\\n    keys.length = 0;\\n    features.forEach(this.forEachFeatureRemove_.bind(this));\\n  }\\n  PointerInteraction.prototype.setMap.call(this, map);\\n\\n  if (map) {\\n    if (this.features_) {\\n      keys.push(\\n        listen(this.features_, CollectionEventType.ADD,\\n          this.handleFeatureAdd_, this),\\n        listen(this.features_, CollectionEventType.REMOVE,\\n          this.handleFeatureRemove_, this)\\n      );\\n    } else if (this.source_) {\\n      keys.push(\\n        listen(this.source_, VectorEventType.ADDFEATURE,\\n          this.handleFeatureAdd_, this),\\n        listen(this.source_, VectorEventType.REMOVEFEATURE,\\n          this.handleFeatureRemove_, this)\\n      );\\n    }\\n    features.forEach(this.forEachFeatureAdd_.bind(this));\\n  }\\n};\\n\\n\\n/**\\n * @inheritDoc\\n */\\nSnap.prototype.shouldStopEvent = FALSE;\\n\\n\\n/**\\n * @param {module:ol~Pixel} pixel Pixel\\n * @param {module:ol/coordinate~Coordinate} pixelCoordinate Coordinate\\n * @param {module:ol/PluggableMap} map Map.\\n * @return {module:ol/interaction/Snap~Result} Snap result\\n */\\nSnap.prototype.snapTo = function(pixel, pixelCoordinate, map) {\\n\\n  const lowerLeft = map.getCoordinateFromPixel(\\n    [pixel[0] - this.pixelTolerance_, pixel[1] + this.pixelTolerance_]);\\n  const upperRight = map.getCoordinateFromPixel(\\n    [pixel[0] + this.pixelTolerance_, pixel[1] - this.pixelTolerance_]);\\n  const box = boundingExtent([lowerLeft, upperRight]);\\n\\n  let segments = this.rBush_.getInExtent(box);\\n\\n  // If snapping on vertices only, don't consider circles\\n  if (this.vertex_ && !this.edge_) {\\n    segments = segments.filter(function(segment) {\\n      return segment.feature.getGeometry().getType() !==\\n          GeometryType.CIRCLE;\\n    });\\n  }\\n\\n  let snappedToVertex = false;\\n  let snapped = false;\\n  let vertex = null;\\n  let vertexPixel = null;\\n  let dist, pixel1, pixel2, squaredDist1, squaredDist2;\\n  if (segments.length > 0) {\\n    this.pixelCoordinate_ = pixelCoordinate;\\n    segments.sort(this.sortByDistance_);\\n    const closestSegment = segments[0].segment;\\n    const isCircle = segments[0].feature.getGeometry().getType() ===\\n        GeometryType.CIRCLE;\\n    if (this.vertex_ && !this.edge_) {\\n      pixel1 = map.getPixelFromCoordinate(closestSegment[0]);\\n      pixel2 = map.getPixelFromCoordinate(closestSegment[1]);\\n      squaredDist1 = squaredCoordinateDistance(pixel, pixel1);\\n      squaredDist2 = squaredCoordinateDistance(pixel, pixel2);\\n      dist = Math.sqrt(Math.min(squaredDist1, squaredDist2));\\n      snappedToVertex = dist <= this.pixelTolerance_;\\n      if (snappedToVertex) {\\n        snapped = true;\\n        vertex = squaredDist1 > squaredDist2 ? closestSegment[1] : closestSegment[0];\\n        vertexPixel = map.getPixelFromCoordinate(vertex);\\n      }\\n    } else if (this.edge_) {\\n      if (isCircle) {\\n        vertex = closestOnCircle(pixelCoordinate,\\n          /** @type {module:ol/geom/Circle} */ (segments[0].feature.getGeometry()));\\n      } else {\\n        vertex = closestOnSegment(pixelCoordinate, closestSegment);\\n      }\\n      vertexPixel = map.getPixelFromCoordinate(vertex);\\n      if (coordinateDistance(pixel, vertexPixel) <= this.pixelTolerance_) {\\n        snapped = true;\\n        if (this.vertex_ && !isCircle) {\\n          pixel1 = map.getPixelFromCoordinate(closestSegment[0]);\\n          pixel2 = map.getPixelFromCoordinate(closestSegment[1]);\\n          squaredDist1 = squaredCoordinateDistance(vertexPixel, pixel1);\\n          squaredDist2 = squaredCoordinateDistance(vertexPixel, pixel2);\\n          dist = Math.sqrt(Math.min(squaredDist1, squaredDist2));\\n          snappedToVertex = dist <= this.pixelTolerance_;\\n          if (snappedToVertex) {\\n            vertex = squaredDist1 > squaredDist2 ? closestSegment[1] : closestSegment[0];\\n            vertexPixel = map.getPixelFromCoordinate(vertex);\\n          }\\n        }\\n      }\\n    }\\n    if (snapped) {\\n      vertexPixel = [Math.round(vertexPixel[0]), Math.round(vertexPixel[1])];\\n    }\\n  }\\n  return (\\n    /** @type {module:ol/interaction/Snap~Result} */ ({\\n      snapped: snapped,\\n      vertex: vertex,\\n      vertexPixel: vertexPixel\\n    })\\n  );\\n};\\n\\n\\n/**\\n * @param {module:ol/Feature} feature Feature\\n * @private\\n */\\nSnap.prototype.updateFeature_ = function(feature) {\\n  this.removeFeature(feature, false);\\n  this.addFeature(feature, false);\\n};\\n\\n\\n/**\\n * @param {module:ol/Feature} feature Feature\\n * @param {module:ol/geom/Circle} geometry Geometry.\\n * @private\\n */\\nSnap.prototype.writeCircleGeometry_ = function(feature, geometry) {\\n  const polygon = fromCircle(geometry);\\n  const coordinates = polygon.getCoordinates()[0];\\n  for (let i = 0, ii = coordinates.length - 1; i < ii; ++i) {\\n    const segment = coordinates.slice(i, i + 2);\\n    const segmentData = /** @type {module:ol/interaction/Snap~SegmentData} */ ({\\n      feature: feature,\\n      segment: segment\\n    });\\n    this.rBush_.insert(boundingExtent(segment), segmentData);\\n  }\\n};\\n\\n\\n/**\\n * @param {module:ol/Feature} feature Feature\\n * @param {module:ol/geom/GeometryCollection} geometry Geometry.\\n * @private\\n */\\nSnap.prototype.writeGeometryCollectionGeometry_ = function(feature, geometry) {\\n  const geometries = geometry.getGeometriesArray();\\n  for (let i = 0; i < geometries.length; ++i) {\\n    const segmentWriter = this.SEGMENT_WRITERS_[geometries[i].getType()];\\n    if (segmentWriter) {\\n      segmentWriter.call(this, feature, geometries[i]);\\n    }\\n  }\\n};\\n\\n\\n/**\\n * @param {module:ol/Feature} feature Feature\\n * @param {module:ol/geom/LineString} geometry Geometry.\\n * @private\\n */\\nSnap.prototype.writeLineStringGeometry_ = function(feature, geometry) {\\n  const coordinates = geometry.getCoordinates();\\n  for (let i = 0, ii = coordinates.length - 1; i < ii; ++i) {\\n    const segment = coordinates.slice(i, i + 2);\\n    const segmentData = /** @type {module:ol/interaction/Snap~SegmentData} */ ({\\n      feature: feature,\\n      segment: segment\\n    });\\n    this.rBush_.insert(boundingExtent(segment), segmentData);\\n  }\\n};\\n\\n\\n/**\\n * @param {module:ol/Feature} feature Feature\\n * @param {module:ol/geom/MultiLineString} geometry Geometry.\\n * @private\\n */\\nSnap.prototype.writeMultiLineStringGeometry_ = function(feature, geometry) {\\n  const lines = geometry.getCoordinates();\\n  for (let j = 0, jj = lines.length; j < jj; ++j) {\\n    const coordinates = lines[j];\\n    for (let i = 0, ii = coordinates.length - 1; i < ii; ++i) {\\n      const segment = coordinates.slice(i, i + 2);\\n      const segmentData = /** @type {module:ol/interaction/Snap~SegmentData} */ ({\\n        feature: feature,\\n        segment: segment\\n      });\\n      this.rBush_.insert(boundingExtent(segment), segmentData);\\n    }\\n  }\\n};\\n\\n\\n/**\\n * @param {module:ol/Feature} feature Feature\\n * @param {module:ol/geom/MultiPoint} geometry Geometry.\\n * @private\\n */\\nSnap.prototype.writeMultiPointGeometry_ = function(feature, geometry) {\\n  const points = geometry.getCoordinates();\\n  for (let i = 0, ii = points.length; i < ii; ++i) {\\n    const coordinates = points[i];\\n    const segmentData = /** @type {module:ol/interaction/Snap~SegmentData} */ ({\\n      feature: feature,\\n      segment: [coordinates, coordinates]\\n    });\\n    this.rBush_.insert(geometry.getExtent(), segmentData);\\n  }\\n};\\n\\n\\n/**\\n * @param {module:ol/Feature} feature Feature\\n * @param {module:ol/geom/MultiPolygon} geometry Geometry.\\n * @private\\n */\\nSnap.prototype.writeMultiPolygonGeometry_ = function(feature, geometry) {\\n  const polygons = geometry.getCoordinates();\\n  for (let k = 0, kk = polygons.length; k < kk; ++k) {\\n    const rings = polygons[k];\\n    for (let j = 0, jj = rings.length; j < jj; ++j) {\\n      const coordinates = rings[j];\\n      for (let i = 0, ii = coordinates.length - 1; i < ii; ++i) {\\n        const segment = coordinates.slice(i, i + 2);\\n        const segmentData = /** @type {module:ol/interaction/Snap~SegmentData} */ ({\\n          feature: feature,\\n          segment: segment\\n        });\\n        this.rBush_.insert(boundingExtent(segment), segmentData);\\n      }\\n    }\\n  }\\n};\\n\\n\\n/**\\n * @param {module:ol/Feature} feature Feature\\n * @param {module:ol/geom/Point} geometry Geometry.\\n * @private\\n */\\nSnap.prototype.writePointGeometry_ = function(feature, geometry) {\\n  const coordinates = geometry.getCoordinates();\\n  const segmentData = /** @type {module:ol/interaction/Snap~SegmentData} */ ({\\n    feature: feature,\\n    segment: [coordinates, coordinates]\\n  });\\n  this.rBush_.insert(geometry.getExtent(), segmentData);\\n};\\n\\n\\n/**\\n * @param {module:ol/Feature} feature Feature\\n * @param {module:ol/geom/Polygon} geometry Geometry.\\n * @private\\n */\\nSnap.prototype.writePolygonGeometry_ = function(feature, geometry) {\\n  const rings = geometry.getCoordinates();\\n  for (let j = 0, jj = rings.length; j < jj; ++j) {\\n    const coordinates = rings[j];\\n    for (let i = 0, ii = coordinates.length - 1; i < ii; ++i) {\\n      const segment = coordinates.slice(i, i + 2);\\n      const segmentData = /** @type {module:ol/interaction/Snap~SegmentData} */ ({\\n        feature: feature,\\n        segment: segment\\n      });\\n      this.rBush_.insert(boundingExtent(segment), segmentData);\\n    }\\n  }\\n};\\n\\n\\n/**\\n * Handle all pointer events events.\\n * @param {module:ol/MapBrowserEvent} evt A move event.\\n * @return {boolean} Pass the event to other interactions.\\n * @this {module:ol/interaction/Snap}\\n */\\nexport function handleEvent(evt) {\\n  const result = this.snapTo(evt.pixel, evt.coordinate, evt.map);\\n  if (result.snapped) {\\n    evt.coordinate = result.vertex.slice(0, 2);\\n    evt.pixel = result.vertexPixel;\\n  }\\n  return handlePointerEvent.call(this, evt);\\n}\\n\\n\\n/**\\n * @param {module:ol/MapBrowserPointerEvent} evt Event.\\n * @return {boolean} Stop drag sequence?\\n * @this {module:ol/interaction/Snap}\\n */\\nfunction handleUpEvent(evt) {\\n  const featuresToUpdate = getValues(this.pendingFeatures_);\\n  if (featuresToUpdate.length) {\\n    featuresToUpdate.forEach(this.updateFeature_.bind(this));\\n    this.pendingFeatures_ = {};\\n  }\\n  return false;\\n}\\n\\n\\n/**\\n * Sort segments by distance, helper function\\n * @param {module:ol/interaction/Snap~SegmentData} a The first segment data.\\n * @param {module:ol/interaction/Snap~SegmentData} b The second segment data.\\n * @return {number} The difference in distance.\\n * @this {module:ol/interaction/Snap}\\n */\\nfunction sortByDistance(a, b) {\\n  const deltaA = squaredDistanceToSegment(this.pixelCoordinate_, a.segment);\\n  const deltaB = squaredDistanceToSegment(this.pixelCoordinate_, b.segment);\\n  return deltaA - deltaB;\\n}\\n\\nexport default Snap;\\n\",\"/**\\n * @module ol/interaction/Translate\\n */\\nimport {inherits} from '../index.js';\\nimport Collection from '../Collection.js';\\nimport {getChangeEventType} from '../Object.js';\\nimport {listen} from '../events.js';\\nimport Event from '../events/Event.js';\\nimport {TRUE} from '../functions.js';\\nimport {includes} from '../array.js';\\nimport PointerInteraction from '../interaction/Pointer.js';\\nimport InteractionProperty from '../interaction/Property.js';\\n\\n\\n/**\\n * @enum {string}\\n */\\nconst TranslateEventType = {\\n  /**\\n   * Triggered upon feature translation start.\\n   * @event TranslateEvent#translatestart\\n   * @api\\n   */\\n  TRANSLATESTART: 'translatestart',\\n  /**\\n   * Triggered upon feature translation.\\n   * @event TranslateEvent#translating\\n   * @api\\n   */\\n  TRANSLATING: 'translating',\\n  /**\\n   * Triggered upon feature translation end.\\n   * @event TranslateEvent#translateend\\n   * @api\\n   */\\n  TRANSLATEEND: 'translateend'\\n};\\n\\n\\n/**\\n * @typedef {Object} Options\\n * @property {module:ol/Collection.<module:ol/Feature>} [features] Only features contained in this collection will be able to be translated. If\\n * not specified, all features on the map will be able to be translated.\\n * @property {Array.<module:ol/layer/Layer>|function(module:ol/layer/Layer): boolean} [layers] A list of layers from which features should be\\n * translated. Alternatively, a filter function can be provided. The\\n * function will be called for each layer in the map and should return\\n * `true` for layers that you want to be translatable. If the option is\\n * absent, all visible layers will be considered translatable.\\n * @property {number} [hitTolerance=0] Hit-detection tolerance. Pixels inside the radius around the given position\\n * will be checked for features. This only works for the canvas renderer and\\n * not for WebGL.\\n */\\n\\n\\n/**\\n * @classdesc\\n * Events emitted by {@link module:ol/interaction/Translate~Translate} instances\\n * are instances of this type.\\n *\\n * @constructor\\n * @extends {module:ol/events/Event}\\n * @param {module:ol/interaction/Translate~TranslateEventType} type Type.\\n * @param {module:ol/Collection.<module:ol/Feature>} features The features translated.\\n * @param {module:ol/coordinate~Coordinate} coordinate The event coordinate.\\n */\\nexport const TranslateEvent = function(type, features, coordinate) {\\n\\n  Event.call(this, type);\\n\\n  /**\\n   * The features being translated.\\n   * @type {module:ol/Collection.<module:ol/Feature>}\\n   * @api\\n   */\\n  this.features = features;\\n\\n  /**\\n   * The coordinate of the drag event.\\n   * @const\\n   * @type {module:ol/coordinate~Coordinate}\\n   * @api\\n   */\\n  this.coordinate = coordinate;\\n};\\n\\ninherits(TranslateEvent, Event);\\n\\n\\n/**\\n * @classdesc\\n * Interaction for translating (moving) features.\\n *\\n * @constructor\\n * @extends {module:ol/interaction/Pointer}\\n * @fires module:ol/interaction/Translate~TranslateEvent\\n * @param {module:ol/interaction/Translate~Options=} opt_options Options.\\n * @api\\n */\\nconst Translate = function(opt_options) {\\n  PointerInteraction.call(this, {\\n    handleDownEvent: handleDownEvent,\\n    handleDragEvent: handleDragEvent,\\n    handleMoveEvent: handleMoveEvent,\\n    handleUpEvent: handleUpEvent\\n  });\\n\\n  const options = opt_options ? opt_options : {};\\n\\n  /**\\n   * The last position we translated to.\\n   * @type {module:ol/coordinate~Coordinate}\\n   * @private\\n   */\\n  this.lastCoordinate_ = null;\\n\\n\\n  /**\\n   * @type {module:ol/Collection.<module:ol/Feature>}\\n   * @private\\n   */\\n  this.features_ = options.features !== undefined ? options.features : null;\\n\\n  /** @type {function(module:ol/layer/Layer): boolean} */\\n  let layerFilter;\\n  if (options.layers) {\\n    if (typeof options.layers === 'function') {\\n      layerFilter = options.layers;\\n    } else {\\n      const layers = options.layers;\\n      layerFilter = function(layer) {\\n        return includes(layers, layer);\\n      };\\n    }\\n  } else {\\n    layerFilter = TRUE;\\n  }\\n\\n  /**\\n   * @private\\n   * @type {function(module:ol/layer/Layer): boolean}\\n   */\\n  this.layerFilter_ = layerFilter;\\n\\n  /**\\n   * @private\\n   * @type {number}\\n   */\\n  this.hitTolerance_ = options.hitTolerance ? options.hitTolerance : 0;\\n\\n  /**\\n   * @type {module:ol/Feature}\\n   * @private\\n   */\\n  this.lastFeature_ = null;\\n\\n  listen(this,\\n    getChangeEventType(InteractionProperty.ACTIVE),\\n    this.handleActiveChanged_, this);\\n\\n};\\n\\ninherits(Translate, PointerInteraction);\\n\\n\\n/**\\n * @param {module:ol/MapBrowserPointerEvent} event Event.\\n * @return {boolean} Start drag sequence?\\n * @this {module:ol/interaction/Translate}\\n */\\nfunction handleDownEvent(event) {\\n  this.lastFeature_ = this.featuresAtPixel_(event.pixel, event.map);\\n  if (!this.lastCoordinate_ && this.lastFeature_) {\\n    this.lastCoordinate_ = event.coordinate;\\n    handleMoveEvent.call(this, event);\\n\\n    const features = this.features_ || new Collection([this.lastFeature_]);\\n\\n    this.dispatchEvent(\\n      new TranslateEvent(\\n        TranslateEventType.TRANSLATESTART, features,\\n        event.coordinate));\\n    return true;\\n  }\\n  return false;\\n}\\n\\n\\n/**\\n * @param {module:ol/MapBrowserPointerEvent} event Event.\\n * @return {boolean} Stop drag sequence?\\n * @this {module:ol/interaction/Translate}\\n */\\nfunction handleUpEvent(event) {\\n  if (this.lastCoordinate_) {\\n    this.lastCoordinate_ = null;\\n    handleMoveEvent.call(this, event);\\n\\n    const features = this.features_ || new Collection([this.lastFeature_]);\\n\\n    this.dispatchEvent(\\n      new TranslateEvent(\\n        TranslateEventType.TRANSLATEEND, features,\\n        event.coordinate));\\n    return true;\\n  }\\n  return false;\\n}\\n\\n\\n/**\\n * @param {module:ol/MapBrowserPointerEvent} event Event.\\n * @this {module:ol/interaction/Translate}\\n */\\nfunction handleDragEvent(event) {\\n  if (this.lastCoordinate_) {\\n    const newCoordinate = event.coordinate;\\n    const deltaX = newCoordinate[0] - this.lastCoordinate_[0];\\n    const deltaY = newCoordinate[1] - this.lastCoordinate_[1];\\n\\n    const features = this.features_ || new Collection([this.lastFeature_]);\\n\\n    features.forEach(function(feature) {\\n      const geom = feature.getGeometry();\\n      geom.translate(deltaX, deltaY);\\n      feature.setGeometry(geom);\\n    });\\n\\n    this.lastCoordinate_ = newCoordinate;\\n    this.dispatchEvent(\\n      new TranslateEvent(\\n        TranslateEventType.TRANSLATING, features,\\n        newCoordinate));\\n  }\\n}\\n\\n\\n/**\\n * @param {module:ol/MapBrowserEvent} event Event.\\n * @this {module:ol/interaction/Translate}\\n */\\nfunction handleMoveEvent(event) {\\n  const elem = event.map.getViewport();\\n\\n  // Change the cursor to grab/grabbing if hovering any of the features managed\\n  // by the interaction\\n  if (this.featuresAtPixel_(event.pixel, event.map)) {\\n    elem.classList.remove(this.lastCoordinate_ ? 'ol-grab' : 'ol-grabbing');\\n    elem.classList.add(this.lastCoordinate_ ? 'ol-grabbing' : 'ol-grab');\\n  } else {\\n    elem.classList.remove('ol-grab', 'ol-grabbing');\\n  }\\n}\\n\\n\\n/**\\n * Tests to see if the given coordinates intersects any of our selected\\n * features.\\n * @param {module:ol~Pixel} pixel Pixel coordinate to test for intersection.\\n * @param {module:ol/PluggableMap} map Map to test the intersection on.\\n * @return {module:ol/Feature} Returns the feature found at the specified pixel\\n * coordinates.\\n * @private\\n */\\nTranslate.prototype.featuresAtPixel_ = function(pixel, map) {\\n  return map.forEachFeatureAtPixel(pixel,\\n    function(feature) {\\n      if (!this.features_ || includes(this.features_.getArray(), feature)) {\\n        return feature;\\n      }\\n    }.bind(this), {\\n      layerFilter: this.layerFilter_,\\n      hitTolerance: this.hitTolerance_\\n    });\\n};\\n\\n\\n/**\\n * Returns the Hit-detection tolerance.\\n * @returns {number} Hit tolerance in pixels.\\n * @api\\n */\\nTranslate.prototype.getHitTolerance = function() {\\n  return this.hitTolerance_;\\n};\\n\\n\\n/**\\n * Hit-detection tolerance. Pixels inside the radius around the given position\\n * will be checked for features. This only works for the canvas renderer and\\n * not for WebGL.\\n * @param {number} hitTolerance Hit tolerance in pixels.\\n * @api\\n */\\nTranslate.prototype.setHitTolerance = function(hitTolerance) {\\n  this.hitTolerance_ = hitTolerance;\\n};\\n\\n\\n/**\\n * @inheritDoc\\n */\\nTranslate.prototype.setMap = function(map) {\\n  const oldMap = this.getMap();\\n  PointerInteraction.prototype.setMap.call(this, map);\\n  this.updateState_(oldMap);\\n};\\n\\n\\n/**\\n * @private\\n */\\nTranslate.prototype.handleActiveChanged_ = function() {\\n  this.updateState_(null);\\n};\\n\\n\\n/**\\n * @param {module:ol/PluggableMap} oldMap Old map.\\n * @private\\n */\\nTranslate.prototype.updateState_ = function(oldMap) {\\n  let map = this.getMap();\\n  const active = this.getActive();\\n  if (!map || !active) {\\n    map = map || oldMap;\\n    if (map) {\\n      const elem = map.getViewport();\\n      elem.classList.remove('ol-grab', 'ol-grabbing');\\n    }\\n  }\\n};\\n\\n\\nexport default Translate;\\n\",\"/**\\n * Default maximum allowed threshold  (in pixels) for reprojection\\n * triangulation.\\n * @type {number}\\n */\\nexport const ERROR_THRESHOLD = 0.5;\\n\\n/**\\n * Enable automatic reprojection of raster sources. Default is `true`.\\n * TODO: decide if we want to expose this as a build flag or remove it\\n * @type {boolean}\\n */\\nexport const ENABLE_RASTER_REPROJECTION = true;\\n\",\"/**\\n * @module ol/ImageBase\\n */\\nimport {inherits} from './index.js';\\nimport EventTarget from './events/EventTarget.js';\\nimport EventType from './events/EventType.js';\\n\\n/**\\n * @constructor\\n * @abstract\\n * @extends {module:ol/events/EventTarget}\\n * @param {module:ol/extent~Extent} extent Extent.\\n * @param {number|undefined} resolution Resolution.\\n * @param {number} pixelRatio Pixel ratio.\\n * @param {module:ol/ImageState} state State.\\n */\\nconst ImageBase = function(extent, resolution, pixelRatio, state) {\\n\\n  EventTarget.call(this);\\n\\n  /**\\n   * @protected\\n   * @type {module:ol/extent~Extent}\\n   */\\n  this.extent = extent;\\n\\n  /**\\n   * @private\\n   * @type {number}\\n   */\\n  this.pixelRatio_ = pixelRatio;\\n\\n  /**\\n   * @protected\\n   * @type {number|undefined}\\n   */\\n  this.resolution = resolution;\\n\\n  /**\\n   * @protected\\n   * @type {module:ol/ImageState}\\n   */\\n  this.state = state;\\n\\n};\\n\\ninherits(ImageBase, EventTarget);\\n\\n\\n/**\\n * @protected\\n */\\nImageBase.prototype.changed = function() {\\n  this.dispatchEvent(EventType.CHANGE);\\n};\\n\\n\\n/**\\n * @return {module:ol/extent~Extent} Extent.\\n */\\nImageBase.prototype.getExtent = function() {\\n  return this.extent;\\n};\\n\\n\\n/**\\n * @abstract\\n * @return {HTMLCanvasElement|Image|HTMLVideoElement} Image.\\n */\\nImageBase.prototype.getImage = function() {};\\n\\n\\n/**\\n * @return {number} PixelRatio.\\n */\\nImageBase.prototype.getPixelRatio = function() {\\n  return this.pixelRatio_;\\n};\\n\\n\\n/**\\n * @return {number} Resolution.\\n */\\nImageBase.prototype.getResolution = function() {\\n  return /** @type {number} */ (this.resolution);\\n};\\n\\n\\n/**\\n * @return {module:ol/ImageState} State.\\n */\\nImageBase.prototype.getState = function() {\\n  return this.state;\\n};\\n\\n\\n/**\\n * Load not yet loaded URI.\\n * @abstract\\n */\\nImageBase.prototype.load = function() {};\\n\\nexport default ImageBase;\\n\",\"/**\\n * @module ol/ImageCanvas\\n */\\nimport {inherits} from './index.js';\\nimport ImageBase from './ImageBase.js';\\nimport ImageState from './ImageState.js';\\n\\n\\n/**\\n * A function that is called to trigger asynchronous canvas drawing.  It is\\n * called with a \\\"done\\\" callback that should be called when drawing is done.\\n * If any error occurs during drawing, the \\\"done\\\" callback should be called with\\n * that error.\\n *\\n * @typedef {function(function(Error))} Loader\\n */\\n\\n\\n/**\\n * @constructor\\n * @extends {module:ol/ImageBase}\\n * @param {module:ol/extent~Extent} extent Extent.\\n * @param {number} resolution Resolution.\\n * @param {number} pixelRatio Pixel ratio.\\n * @param {HTMLCanvasElement} canvas Canvas.\\n * @param {module:ol/ImageCanvas~Loader=} opt_loader Optional loader function to\\n *     support asynchronous canvas drawing.\\n */\\nconst ImageCanvas = function(extent, resolution, pixelRatio, canvas, opt_loader) {\\n\\n  /**\\n   * Optional canvas loader function.\\n   * @type {?module:ol/ImageCanvas~Loader}\\n   * @private\\n   */\\n  this.loader_ = opt_loader !== undefined ? opt_loader : null;\\n\\n  const state = opt_loader !== undefined ? ImageState.IDLE : ImageState.LOADED;\\n\\n  ImageBase.call(this, extent, resolution, pixelRatio, state);\\n\\n  /**\\n   * @private\\n   * @type {HTMLCanvasElement}\\n   */\\n  this.canvas_ = canvas;\\n\\n  /**\\n   * @private\\n   * @type {Error}\\n   */\\n  this.error_ = null;\\n\\n};\\n\\ninherits(ImageCanvas, ImageBase);\\n\\n\\n/**\\n * Get any error associated with asynchronous rendering.\\n * @return {Error} Any error that occurred during rendering.\\n */\\nImageCanvas.prototype.getError = function() {\\n  return this.error_;\\n};\\n\\n\\n/**\\n * Handle async drawing complete.\\n * @param {Error} err Any error during drawing.\\n * @private\\n */\\nImageCanvas.prototype.handleLoad_ = function(err) {\\n  if (err) {\\n    this.error_ = err;\\n    this.state = ImageState.ERROR;\\n  } else {\\n    this.state = ImageState.LOADED;\\n  }\\n  this.changed();\\n};\\n\\n\\n/**\\n * @inheritDoc\\n */\\nImageCanvas.prototype.load = function() {\\n  if (this.state == ImageState.IDLE) {\\n    this.state = ImageState.LOADING;\\n    this.changed();\\n    this.loader_(this.handleLoad_.bind(this));\\n  }\\n};\\n\\n\\n/**\\n * @return {HTMLCanvasElement} Canvas element.\\n */\\nImageCanvas.prototype.getImage = function() {\\n  return this.canvas_;\\n};\\nexport default ImageCanvas;\\n\",\"/**\\n * @module ol/render/Event\\n */\\nimport {inherits} from '../index.js';\\nimport Event from '../events/Event.js';\\n\\n/**\\n * @constructor\\n * @extends {module:ol/events/Event}\\n * @param {module:ol/render/EventType} type Type.\\n * @param {module:ol/render/VectorContext=} opt_vectorContext Vector context.\\n * @param {module:ol/PluggableMap~FrameState=} opt_frameState Frame state.\\n * @param {?CanvasRenderingContext2D=} opt_context Context.\\n * @param {?module:ol/webgl/Context=} opt_glContext WebGL Context.\\n */\\nconst RenderEvent = function(\\n  type, opt_vectorContext, opt_frameState, opt_context,\\n  opt_glContext) {\\n\\n  Event.call(this, type);\\n\\n  /**\\n   * For canvas, this is an instance of {@link module:ol/render/canvas/Immediate}.\\n   * @type {module:ol/render/VectorContext|undefined}\\n   * @api\\n   */\\n  this.vectorContext = opt_vectorContext;\\n\\n  /**\\n   * An object representing the current render frame state.\\n   * @type {module:ol/PluggableMap~FrameState|undefined}\\n   * @api\\n   */\\n  this.frameState = opt_frameState;\\n\\n  /**\\n   * Canvas context. Only available when a Canvas renderer is used, null\\n   * otherwise.\\n   * @type {CanvasRenderingContext2D|null|undefined}\\n   * @api\\n   */\\n  this.context = opt_context;\\n\\n  /**\\n   * WebGL context. Only available when a WebGL renderer is used, null\\n   * otherwise.\\n   * @type {module:ol/webgl/Context|null|undefined}\\n   * @api\\n   */\\n  this.glContext = opt_glContext;\\n\\n};\\n\\ninherits(RenderEvent, Event);\\nexport default RenderEvent;\\n\",\"/**\\n * @module ol/render/VectorContext\\n */\\n/**\\n * Context for drawing geometries.  A vector context is available on render\\n * events and does not need to be constructed directly.\\n * @constructor\\n * @abstract\\n * @struct\\n * @api\\n */\\nconst VectorContext = function() {\\n};\\n\\n\\n/**\\n * Render a geometry with a custom renderer.\\n *\\n * @param {module:ol/geom/SimpleGeometry} geometry Geometry.\\n * @param {module:ol/Feature|module:ol/render/Feature} feature Feature.\\n * @param {Function} renderer Renderer.\\n */\\nVectorContext.prototype.drawCustom = function(geometry, feature, renderer) {};\\n\\n\\n/**\\n * Render a geometry.\\n *\\n * @param {module:ol/geom/Geometry} geometry The geometry to render.\\n */\\nVectorContext.prototype.drawGeometry = function(geometry) {};\\n\\n\\n/**\\n * Set the rendering style.\\n *\\n * @param {module:ol/style/Style} style The rendering style.\\n */\\nVectorContext.prototype.setStyle = function(style) {};\\n\\n\\n/**\\n * @param {module:ol/geom/Circle} circleGeometry Circle geometry.\\n * @param {module:ol/Feature} feature Feature.\\n */\\nVectorContext.prototype.drawCircle = function(circleGeometry, feature) {};\\n\\n\\n/**\\n * @param {module:ol/Feature} feature Feature.\\n * @param {module:ol/style/Style} style Style.\\n */\\nVectorContext.prototype.drawFeature = function(feature, style) {};\\n\\n\\n/**\\n * @param {module:ol/geom/GeometryCollection} geometryCollectionGeometry Geometry\\n *     collection.\\n * @param {module:ol/Feature} feature Feature.\\n */\\nVectorContext.prototype.drawGeometryCollection = function(geometryCollectionGeometry, feature) {};\\n\\n\\n/**\\n * @param {module:ol/geom/LineString|module:ol/render/Feature} lineStringGeometry Line string geometry.\\n * @param {module:ol/Feature|module:ol/render/Feature} feature Feature.\\n */\\nVectorContext.prototype.drawLineString = function(lineStringGeometry, feature) {};\\n\\n\\n/**\\n * @param {module:ol/geom/MultiLineString|module:ol/render/Feature} multiLineStringGeometry MultiLineString geometry.\\n * @param {module:ol/Feature|module:ol/render/Feature} feature Feature.\\n */\\nVectorContext.prototype.drawMultiLineString = function(multiLineStringGeometry, feature) {};\\n\\n\\n/**\\n * @param {module:ol/geom/MultiPoint|module:ol/render/Feature} multiPointGeometry MultiPoint geometry.\\n * @param {module:ol/Feature|module:ol/render/Feature} feature Feature.\\n */\\nVectorContext.prototype.drawMultiPoint = function(multiPointGeometry, feature) {};\\n\\n\\n/**\\n * @param {module:ol/geom/MultiPolygon} multiPolygonGeometry MultiPolygon geometry.\\n * @param {module:ol/Feature|module:ol/render/Feature} feature Feature.\\n */\\nVectorContext.prototype.drawMultiPolygon = function(multiPolygonGeometry, feature) {};\\n\\n\\n/**\\n * @param {module:ol/geom/Point|module:ol/render/Feature} pointGeometry Point geometry.\\n * @param {module:ol/Feature|module:ol/render/Feature} feature Feature.\\n */\\nVectorContext.prototype.drawPoint = function(pointGeometry, feature) {};\\n\\n\\n/**\\n * @param {module:ol/geom/Polygon|module:ol/render/Feature} polygonGeometry Polygon geometry.\\n * @param {module:ol/Feature|module:ol/render/Feature} feature Feature.\\n */\\nVectorContext.prototype.drawPolygon = function(polygonGeometry, feature) {};\\n\\n\\n/**\\n * @param {module:ol/geom/Geometry|module:ol/render/Feature} geometry Geometry.\\n * @param {module:ol/Feature|module:ol/render/Feature} feature Feature.\\n */\\nVectorContext.prototype.drawText = function(geometry, feature) {};\\n\\n\\n/**\\n * @param {module:ol/style/Fill} fillStyle Fill style.\\n * @param {module:ol/style/Stroke} strokeStyle Stroke style.\\n */\\nVectorContext.prototype.setFillStrokeStyle = function(fillStyle, strokeStyle) {};\\n\\n\\n/**\\n * @param {module:ol/style/Image} imageStyle Image style.\\n * @param {module:ol/render/canvas~DeclutterGroup=} opt_declutterGroup Declutter.\\n */\\nVectorContext.prototype.setImageStyle = function(imageStyle, opt_declutterGroup) {};\\n\\n\\n/**\\n * @param {module:ol/style/Text} textStyle Text style.\\n * @param {module:ol/render/canvas~DeclutterGroup=} opt_declutterGroup Declutter.\\n */\\nVectorContext.prototype.setTextStyle = function(textStyle, opt_declutterGroup) {};\\nexport default VectorContext;\\n\",\"/**\\n * @module ol/render/canvas/Immediate\\n */\\n// FIXME test, especially polygons with holes and multipolygons\\n// FIXME need to handle large thick features (where pixel size matters)\\n// FIXME add offset and end to ol/geom/flat/transform~transform2D?\\n\\nimport {inherits} from '../../index.js';\\nimport {equals} from '../../array.js';\\nimport {asColorLike} from '../../colorlike.js';\\nimport {intersects} from '../../extent.js';\\nimport GeometryType from '../../geom/GeometryType.js';\\nimport {transformGeom2D} from '../../geom/SimpleGeometry.js';\\nimport {transform2D} from '../../geom/flat/transform.js';\\nimport {CANVAS_LINE_DASH} from '../../has.js';\\nimport VectorContext from '../VectorContext.js';\\nimport {defaultTextAlign, defaultFillStyle, defaultLineCap, defaultLineDash, defaultLineDashOffset, defaultLineJoin, defaultLineWidth, defaultMiterLimit, defaultStrokeStyle, defaultTextBaseline, defaultFont} from '../canvas.js';\\nimport {create as createTransform, compose as composeTransform} from '../../transform.js';\\n\\n/**\\n * @classdesc\\n * A concrete subclass of {@link module:ol/render/VectorContext} that implements\\n * direct rendering of features and geometries to an HTML5 Canvas context.\\n * Instances of this class are created internally by the library and\\n * provided to application code as vectorContext member of the\\n * {@link module:ol/render/Event~RenderEvent} object associated with postcompose, precompose and\\n * render events emitted by layers and maps.\\n *\\n * @constructor\\n * @extends {module:ol/render/VectorContext}\\n * @param {CanvasRenderingContext2D} context Context.\\n * @param {number} pixelRatio Pixel ratio.\\n * @param {module:ol/extent~Extent} extent Extent.\\n * @param {module:ol/transform~Transform} transform Transform.\\n * @param {number} viewRotation View rotation.\\n * @struct\\n */\\nconst CanvasImmediateRenderer = function(context, pixelRatio, extent, transform, viewRotation) {\\n  VectorContext.call(this);\\n\\n  /**\\n   * @private\\n   * @type {CanvasRenderingContext2D}\\n   */\\n  this.context_ = context;\\n\\n  /**\\n   * @private\\n   * @type {number}\\n   */\\n  this.pixelRatio_ = pixelRatio;\\n\\n  /**\\n   * @private\\n   * @type {module:ol/extent~Extent}\\n   */\\n  this.extent_ = extent;\\n\\n  /**\\n   * @private\\n   * @type {module:ol/transform~Transform}\\n   */\\n  this.transform_ = transform;\\n\\n  /**\\n   * @private\\n   * @type {number}\\n   */\\n  this.viewRotation_ = viewRotation;\\n\\n  /**\\n   * @private\\n   * @type {?module:ol/render/canvas~FillState}\\n   */\\n  this.contextFillState_ = null;\\n\\n  /**\\n   * @private\\n   * @type {?module:ol/render/canvas~StrokeState}\\n   */\\n  this.contextStrokeState_ = null;\\n\\n  /**\\n   * @private\\n   * @type {?module:ol/render/canvas~TextState}\\n   */\\n  this.contextTextState_ = null;\\n\\n  /**\\n   * @private\\n   * @type {?module:ol/render/canvas~FillState}\\n   */\\n  this.fillState_ = null;\\n\\n  /**\\n   * @private\\n   * @type {?module:ol/render/canvas~StrokeState}\\n   */\\n  this.strokeState_ = null;\\n\\n  /**\\n   * @private\\n   * @type {HTMLCanvasElement|HTMLVideoElement|Image}\\n   */\\n  this.image_ = null;\\n\\n  /**\\n   * @private\\n   * @type {number}\\n   */\\n  this.imageAnchorX_ = 0;\\n\\n  /**\\n   * @private\\n   * @type {number}\\n   */\\n  this.imageAnchorY_ = 0;\\n\\n  /**\\n   * @private\\n   * @type {number}\\n   */\\n  this.imageHeight_ = 0;\\n\\n  /**\\n   * @private\\n   * @type {number}\\n   */\\n  this.imageOpacity_ = 0;\\n\\n  /**\\n   * @private\\n   * @type {number}\\n   */\\n  this.imageOriginX_ = 0;\\n\\n  /**\\n   * @private\\n   * @type {number}\\n   */\\n  this.imageOriginY_ = 0;\\n\\n  /**\\n   * @private\\n   * @type {boolean}\\n   */\\n  this.imageRotateWithView_ = false;\\n\\n  /**\\n   * @private\\n   * @type {number}\\n   */\\n  this.imageRotation_ = 0;\\n\\n  /**\\n   * @private\\n   * @type {number}\\n   */\\n  this.imageScale_ = 0;\\n\\n  /**\\n   * @private\\n   * @type {boolean}\\n   */\\n  this.imageSnapToPixel_ = false;\\n\\n  /**\\n   * @private\\n   * @type {number}\\n   */\\n  this.imageWidth_ = 0;\\n\\n  /**\\n   * @private\\n   * @type {string}\\n   */\\n  this.text_ = '';\\n\\n  /**\\n   * @private\\n   * @type {number}\\n   */\\n  this.textOffsetX_ = 0;\\n\\n  /**\\n   * @private\\n   * @type {number}\\n   */\\n  this.textOffsetY_ = 0;\\n\\n  /**\\n   * @private\\n   * @type {boolean}\\n   */\\n  this.textRotateWithView_ = false;\\n\\n  /**\\n   * @private\\n   * @type {number}\\n   */\\n  this.textRotation_ = 0;\\n\\n  /**\\n   * @private\\n   * @type {number}\\n   */\\n  this.textScale_ = 0;\\n\\n  /**\\n   * @private\\n   * @type {?module:ol/render/canvas~FillState}\\n   */\\n  this.textFillState_ = null;\\n\\n  /**\\n   * @private\\n   * @type {?module:ol/render/canvas~StrokeState}\\n   */\\n  this.textStrokeState_ = null;\\n\\n  /**\\n   * @private\\n   * @type {?module:ol/render/canvas~TextState}\\n   */\\n  this.textState_ = null;\\n\\n  /**\\n   * @private\\n   * @type {Array.<number>}\\n   */\\n  this.pixelCoordinates_ = [];\\n\\n  /**\\n   * @private\\n   * @type {module:ol/transform~Transform}\\n   */\\n  this.tmpLocalTransform_ = createTransform();\\n\\n};\\n\\ninherits(CanvasImmediateRenderer, VectorContext);\\n\\n\\n/**\\n * @param {Array.<number>} flatCoordinates Flat coordinates.\\n * @param {number} offset Offset.\\n * @param {number} end End.\\n * @param {number} stride Stride.\\n * @private\\n */\\nCanvasImmediateRenderer.prototype.drawImages_ = function(flatCoordinates, offset, end, stride) {\\n  if (!this.image_) {\\n    return;\\n  }\\n  const pixelCoordinates = transform2D(\\n    flatCoordinates, offset, end, 2, this.transform_,\\n    this.pixelCoordinates_);\\n  const context = this.context_;\\n  const localTransform = this.tmpLocalTransform_;\\n  const alpha = context.globalAlpha;\\n  if (this.imageOpacity_ != 1) {\\n    context.globalAlpha = alpha * this.imageOpacity_;\\n  }\\n  let rotation = this.imageRotation_;\\n  if (this.imageRotateWithView_) {\\n    rotation += this.viewRotation_;\\n  }\\n  for (let i = 0, ii = pixelCoordinates.length; i < ii; i += 2) {\\n    let x = pixelCoordinates[i] - this.imageAnchorX_;\\n    let y = pixelCoordinates[i + 1] - this.imageAnchorY_;\\n    if (this.imageSnapToPixel_) {\\n      x = Math.round(x);\\n      y = Math.round(y);\\n    }\\n    if (rotation !== 0 || this.imageScale_ != 1) {\\n      const centerX = x + this.imageAnchorX_;\\n      const centerY = y + this.imageAnchorY_;\\n      composeTransform(localTransform,\\n        centerX, centerY,\\n        this.imageScale_, this.imageScale_,\\n        rotation,\\n        -centerX, -centerY);\\n      context.setTransform.apply(context, localTransform);\\n    }\\n    context.drawImage(this.image_, this.imageOriginX_, this.imageOriginY_,\\n      this.imageWidth_, this.imageHeight_, x, y,\\n      this.imageWidth_, this.imageHeight_);\\n  }\\n  if (rotation !== 0 || this.imageScale_ != 1) {\\n    context.setTransform(1, 0, 0, 1, 0, 0);\\n  }\\n  if (this.imageOpacity_ != 1) {\\n    context.globalAlpha = alpha;\\n  }\\n};\\n\\n\\n/**\\n * @param {Array.<number>} flatCoordinates Flat coordinates.\\n * @param {number} offset Offset.\\n * @param {number} end End.\\n * @param {number} stride Stride.\\n * @private\\n */\\nCanvasImmediateRenderer.prototype.drawText_ = function(flatCoordinates, offset, end, stride) {\\n  if (!this.textState_ || this.text_ === '') {\\n    return;\\n  }\\n  if (this.textFillState_) {\\n    this.setContextFillState_(this.textFillState_);\\n  }\\n  if (this.textStrokeState_) {\\n    this.setContextStrokeState_(this.textStrokeState_);\\n  }\\n  this.setContextTextState_(this.textState_);\\n  const pixelCoordinates = transform2D(\\n    flatCoordinates, offset, end, stride, this.transform_,\\n    this.pixelCoordinates_);\\n  const context = this.context_;\\n  let rotation = this.textRotation_;\\n  if (this.textRotateWithView_) {\\n    rotation += this.viewRotation_;\\n  }\\n  for (; offset < end; offset += stride) {\\n    const x = pixelCoordinates[offset] + this.textOffsetX_;\\n    const y = pixelCoordinates[offset + 1] + this.textOffsetY_;\\n    if (rotation !== 0 || this.textScale_ != 1) {\\n      const localTransform = composeTransform(this.tmpLocalTransform_,\\n        x, y,\\n        this.textScale_, this.textScale_,\\n        rotation,\\n        -x, -y);\\n      context.setTransform.apply(context, localTransform);\\n    }\\n    if (this.textStrokeState_) {\\n      context.strokeText(this.text_, x, y);\\n    }\\n    if (this.textFillState_) {\\n      context.fillText(this.text_, x, y);\\n    }\\n  }\\n  if (rotation !== 0 || this.textScale_ != 1) {\\n    context.setTransform(1, 0, 0, 1, 0, 0);\\n  }\\n};\\n\\n\\n/**\\n * @param {Array.<number>} flatCoordinates Flat coordinates.\\n * @param {number} offset Offset.\\n * @param {number} end End.\\n * @param {number} stride Stride.\\n * @param {boolean} close Close.\\n * @private\\n * @return {number} end End.\\n */\\nCanvasImmediateRenderer.prototype.moveToLineTo_ = function(flatCoordinates, offset, end, stride, close) {\\n  const context = this.context_;\\n  const pixelCoordinates = transform2D(\\n    flatCoordinates, offset, end, stride, this.transform_,\\n    this.pixelCoordinates_);\\n  context.moveTo(pixelCoordinates[0], pixelCoordinates[1]);\\n  let length = pixelCoordinates.length;\\n  if (close) {\\n    length -= 2;\\n  }\\n  for (let i = 2; i < length; i += 2) {\\n    context.lineTo(pixelCoordinates[i], pixelCoordinates[i + 1]);\\n  }\\n  if (close) {\\n    context.closePath();\\n  }\\n  return end;\\n};\\n\\n\\n/**\\n * @param {Array.<number>} flatCoordinates Flat coordinates.\\n * @param {number} offset Offset.\\n * @param {Array.<number>} ends Ends.\\n * @param {number} stride Stride.\\n * @private\\n * @return {number} End.\\n */\\nCanvasImmediateRenderer.prototype.drawRings_ = function(flatCoordinates, offset, ends, stride) {\\n  for (let i = 0, ii = ends.length; i < ii; ++i) {\\n    offset = this.moveToLineTo_(flatCoordinates, offset, ends[i], stride, true);\\n  }\\n  return offset;\\n};\\n\\n\\n/**\\n * Render a circle geometry into the canvas.  Rendering is immediate and uses\\n * the current fill and stroke styles.\\n *\\n * @param {module:ol/geom/Circle} geometry Circle geometry.\\n * @override\\n * @api\\n */\\nCanvasImmediateRenderer.prototype.drawCircle = function(geometry) {\\n  if (!intersects(this.extent_, geometry.getExtent())) {\\n    return;\\n  }\\n  if (this.fillState_ || this.strokeState_) {\\n    if (this.fillState_) {\\n      this.setContextFillState_(this.fillState_);\\n    }\\n    if (this.strokeState_) {\\n      this.setContextStrokeState_(this.strokeState_);\\n    }\\n    const pixelCoordinates = transformGeom2D(\\n      geometry, this.transform_, this.pixelCoordinates_);\\n    const dx = pixelCoordinates[2] - pixelCoordinates[0];\\n    const dy = pixelCoordinates[3] - pixelCoordinates[1];\\n    const radius = Math.sqrt(dx * dx + dy * dy);\\n    const context = this.context_;\\n    context.beginPath();\\n    context.arc(\\n      pixelCoordinates[0], pixelCoordinates[1], radius, 0, 2 * Math.PI);\\n    if (this.fillState_) {\\n      context.fill();\\n    }\\n    if (this.strokeState_) {\\n      context.stroke();\\n    }\\n  }\\n  if (this.text_ !== '') {\\n    this.drawText_(geometry.getCenter(), 0, 2, 2);\\n  }\\n};\\n\\n\\n/**\\n * Set the rendering style.  Note that since this is an immediate rendering API,\\n * any `zIndex` on the provided style will be ignored.\\n *\\n * @param {module:ol/style/Style} style The rendering style.\\n * @override\\n * @api\\n */\\nCanvasImmediateRenderer.prototype.setStyle = function(style) {\\n  this.setFillStrokeStyle(style.getFill(), style.getStroke());\\n  this.setImageStyle(style.getImage());\\n  this.setTextStyle(style.getText());\\n};\\n\\n\\n/**\\n * Render a geometry into the canvas.  Call\\n * {@link module:ol/render/canvas/Immediate#setStyle} first to set the rendering style.\\n *\\n * @param {module:ol/geom/Geometry|module:ol/render/Feature} geometry The geometry to render.\\n * @override\\n * @api\\n */\\nCanvasImmediateRenderer.prototype.drawGeometry = function(geometry) {\\n  const type = geometry.getType();\\n  switch (type) {\\n    case GeometryType.POINT:\\n      this.drawPoint(/** @type {module:ol/geom/Point} */ (geometry));\\n      break;\\n    case GeometryType.LINE_STRING:\\n      this.drawLineString(/** @type {module:ol/geom/LineString} */ (geometry));\\n      break;\\n    case GeometryType.POLYGON:\\n      this.drawPolygon(/** @type {module:ol/geom/Polygon} */ (geometry));\\n      break;\\n    case GeometryType.MULTI_POINT:\\n      this.drawMultiPoint(/** @type {module:ol/geom/MultiPoint} */ (geometry));\\n      break;\\n    case GeometryType.MULTI_LINE_STRING:\\n      this.drawMultiLineString(/** @type {module:ol/geom/MultiLineString} */ (geometry));\\n      break;\\n    case GeometryType.MULTI_POLYGON:\\n      this.drawMultiPolygon(/** @type {module:ol/geom/MultiPolygon} */ (geometry));\\n      break;\\n    case GeometryType.GEOMETRY_COLLECTION:\\n      this.drawGeometryCollection(/** @type {module:ol/geom/GeometryCollection} */ (geometry));\\n      break;\\n    case GeometryType.CIRCLE:\\n      this.drawCircle(/** @type {module:ol/geom/Circle} */ (geometry));\\n      break;\\n    default:\\n  }\\n};\\n\\n\\n/**\\n * Render a feature into the canvas.  Note that any `zIndex` on the provided\\n * style will be ignored - features are rendered immediately in the order that\\n * this method is called.  If you need `zIndex` support, you should be using an\\n * {@link module:ol/layer/Vector~VectorLayer} instead.\\n *\\n * @param {module:ol/Feature} feature Feature.\\n * @param {module:ol/style/Style} style Style.\\n * @override\\n * @api\\n */\\nCanvasImmediateRenderer.prototype.drawFeature = function(feature, style) {\\n  const geometry = style.getGeometryFunction()(feature);\\n  if (!geometry || !intersects(this.extent_, geometry.getExtent())) {\\n    return;\\n  }\\n  this.setStyle(style);\\n  this.drawGeometry(geometry);\\n};\\n\\n\\n/**\\n * Render a GeometryCollection to the canvas.  Rendering is immediate and\\n * uses the current styles appropriate for each geometry in the collection.\\n *\\n * @param {module:ol/geom/GeometryCollection} geometry Geometry collection.\\n * @override\\n */\\nCanvasImmediateRenderer.prototype.drawGeometryCollection = function(geometry) {\\n  const geometries = geometry.getGeometriesArray();\\n  for (let i = 0, ii = geometries.length; i < ii; ++i) {\\n    this.drawGeometry(geometries[i]);\\n  }\\n};\\n\\n\\n/**\\n * Render a Point geometry into the canvas.  Rendering is immediate and uses\\n * the current style.\\n *\\n * @param {module:ol/geom/Point|module:ol/render/Feature} geometry Point geometry.\\n * @override\\n */\\nCanvasImmediateRenderer.prototype.drawPoint = function(geometry) {\\n  const flatCoordinates = geometry.getFlatCoordinates();\\n  const stride = geometry.getStride();\\n  if (this.image_) {\\n    this.drawImages_(flatCoordinates, 0, flatCoordinates.length, stride);\\n  }\\n  if (this.text_ !== '') {\\n    this.drawText_(flatCoordinates, 0, flatCoordinates.length, stride);\\n  }\\n};\\n\\n\\n/**\\n * Render a MultiPoint geometry  into the canvas.  Rendering is immediate and\\n * uses the current style.\\n *\\n * @param {module:ol/geom/MultiPoint|module:ol/render/Feature} geometry MultiPoint geometry.\\n * @override\\n */\\nCanvasImmediateRenderer.prototype.drawMultiPoint = function(geometry) {\\n  const flatCoordinates = geometry.getFlatCoordinates();\\n  const stride = geometry.getStride();\\n  if (this.image_) {\\n    this.drawImages_(flatCoordinates, 0, flatCoordinates.length, stride);\\n  }\\n  if (this.text_ !== '') {\\n    this.drawText_(flatCoordinates, 0, flatCoordinates.length, stride);\\n  }\\n};\\n\\n\\n/**\\n * Render a LineString into the canvas.  Rendering is immediate and uses\\n * the current style.\\n *\\n * @param {module:ol/geom/LineString|module:ol/render/Feature} geometry LineString geometry.\\n * @override\\n */\\nCanvasImmediateRenderer.prototype.drawLineString = function(geometry) {\\n  if (!intersects(this.extent_, geometry.getExtent())) {\\n    return;\\n  }\\n  if (this.strokeState_) {\\n    this.setContextStrokeState_(this.strokeState_);\\n    const context = this.context_;\\n    const flatCoordinates = geometry.getFlatCoordinates();\\n    context.beginPath();\\n    this.moveToLineTo_(flatCoordinates, 0, flatCoordinates.length,\\n      geometry.getStride(), false);\\n    context.stroke();\\n  }\\n  if (this.text_ !== '') {\\n    const flatMidpoint = geometry.getFlatMidpoint();\\n    this.drawText_(flatMidpoint, 0, 2, 2);\\n  }\\n};\\n\\n\\n/**\\n * Render a MultiLineString geometry into the canvas.  Rendering is immediate\\n * and uses the current style.\\n *\\n * @param {module:ol/geom/MultiLineString|module:ol/render/Feature} geometry MultiLineString geometry.\\n * @override\\n */\\nCanvasImmediateRenderer.prototype.drawMultiLineString = function(geometry) {\\n  const geometryExtent = geometry.getExtent();\\n  if (!intersects(this.extent_, geometryExtent)) {\\n    return;\\n  }\\n  if (this.strokeState_) {\\n    this.setContextStrokeState_(this.strokeState_);\\n    const context = this.context_;\\n    const flatCoordinates = geometry.getFlatCoordinates();\\n    let offset = 0;\\n    const ends = geometry.getEnds();\\n    const stride = geometry.getStride();\\n    context.beginPath();\\n    for (let i = 0, ii = ends.length; i < ii; ++i) {\\n      offset = this.moveToLineTo_(flatCoordinates, offset, ends[i], stride, false);\\n    }\\n    context.stroke();\\n  }\\n  if (this.text_ !== '') {\\n    const flatMidpoints = geometry.getFlatMidpoints();\\n    this.drawText_(flatMidpoints, 0, flatMidpoints.length, 2);\\n  }\\n};\\n\\n\\n/**\\n * Render a Polygon geometry into the canvas.  Rendering is immediate and uses\\n * the current style.\\n *\\n * @param {module:ol/geom/Polygon|module:ol/render/Feature} geometry Polygon geometry.\\n * @override\\n */\\nCanvasImmediateRenderer.prototype.drawPolygon = function(geometry) {\\n  if (!intersects(this.extent_, geometry.getExtent())) {\\n    return;\\n  }\\n  if (this.strokeState_ || this.fillState_) {\\n    if (this.fillState_) {\\n      this.setContextFillState_(this.fillState_);\\n    }\\n    if (this.strokeState_) {\\n      this.setContextStrokeState_(this.strokeState_);\\n    }\\n    const context = this.context_;\\n    context.beginPath();\\n    this.drawRings_(geometry.getOrientedFlatCoordinates(),\\n      0, geometry.getEnds(), geometry.getStride());\\n    if (this.fillState_) {\\n      context.fill();\\n    }\\n    if (this.strokeState_) {\\n      context.stroke();\\n    }\\n  }\\n  if (this.text_ !== '') {\\n    const flatInteriorPoint = geometry.getFlatInteriorPoint();\\n    this.drawText_(flatInteriorPoint, 0, 2, 2);\\n  }\\n};\\n\\n\\n/**\\n * Render MultiPolygon geometry into the canvas.  Rendering is immediate and\\n * uses the current style.\\n * @param {module:ol/geom/MultiPolygon} geometry MultiPolygon geometry.\\n * @override\\n */\\nCanvasImmediateRenderer.prototype.drawMultiPolygon = function(geometry) {\\n  if (!intersects(this.extent_, geometry.getExtent())) {\\n    return;\\n  }\\n  if (this.strokeState_ || this.fillState_) {\\n    if (this.fillState_) {\\n      this.setContextFillState_(this.fillState_);\\n    }\\n    if (this.strokeState_) {\\n      this.setContextStrokeState_(this.strokeState_);\\n    }\\n    const context = this.context_;\\n    const flatCoordinates = geometry.getOrientedFlatCoordinates();\\n    let offset = 0;\\n    const endss = geometry.getEndss();\\n    const stride = geometry.getStride();\\n    context.beginPath();\\n    for (let i = 0, ii = endss.length; i < ii; ++i) {\\n      const ends = endss[i];\\n      offset = this.drawRings_(flatCoordinates, offset, ends, stride);\\n    }\\n    if (this.fillState_) {\\n      context.fill();\\n    }\\n    if (this.strokeState_) {\\n      context.stroke();\\n    }\\n  }\\n  if (this.text_ !== '') {\\n    const flatInteriorPoints = geometry.getFlatInteriorPoints();\\n    this.drawText_(flatInteriorPoints, 0, flatInteriorPoints.length, 2);\\n  }\\n};\\n\\n\\n/**\\n * @param {module:ol/render/canvas~FillState} fillState Fill state.\\n * @private\\n */\\nCanvasImmediateRenderer.prototype.setContextFillState_ = function(fillState) {\\n  const context = this.context_;\\n  const contextFillState = this.contextFillState_;\\n  if (!contextFillState) {\\n    context.fillStyle = fillState.fillStyle;\\n    this.contextFillState_ = {\\n      fillStyle: fillState.fillStyle\\n    };\\n  } else {\\n    if (contextFillState.fillStyle != fillState.fillStyle) {\\n      contextFillState.fillStyle = context.fillStyle = fillState.fillStyle;\\n    }\\n  }\\n};\\n\\n\\n/**\\n * @param {module:ol/render/canvas~StrokeState} strokeState Stroke state.\\n * @private\\n */\\nCanvasImmediateRenderer.prototype.setContextStrokeState_ = function(strokeState) {\\n  const context = this.context_;\\n  const contextStrokeState = this.contextStrokeState_;\\n  if (!contextStrokeState) {\\n    context.lineCap = strokeState.lineCap;\\n    if (CANVAS_LINE_DASH) {\\n      context.setLineDash(strokeState.lineDash);\\n      context.lineDashOffset = strokeState.lineDashOffset;\\n    }\\n    context.lineJoin = strokeState.lineJoin;\\n    context.lineWidth = strokeState.lineWidth;\\n    context.miterLimit = strokeState.miterLimit;\\n    context.strokeStyle = strokeState.strokeStyle;\\n    this.contextStrokeState_ = {\\n      lineCap: strokeState.lineCap,\\n      lineDash: strokeState.lineDash,\\n      lineDashOffset: strokeState.lineDashOffset,\\n      lineJoin: strokeState.lineJoin,\\n      lineWidth: strokeState.lineWidth,\\n      miterLimit: strokeState.miterLimit,\\n      strokeStyle: strokeState.strokeStyle\\n    };\\n  } else {\\n    if (contextStrokeState.lineCap != strokeState.lineCap) {\\n      contextStrokeState.lineCap = context.lineCap = strokeState.lineCap;\\n    }\\n    if (CANVAS_LINE_DASH) {\\n      if (!equals(contextStrokeState.lineDash, strokeState.lineDash)) {\\n        context.setLineDash(contextStrokeState.lineDash = strokeState.lineDash);\\n      }\\n      if (contextStrokeState.lineDashOffset != strokeState.lineDashOffset) {\\n        contextStrokeState.lineDashOffset = context.lineDashOffset =\\n            strokeState.lineDashOffset;\\n      }\\n    }\\n    if (contextStrokeState.lineJoin != strokeState.lineJoin) {\\n      contextStrokeState.lineJoin = context.lineJoin = strokeState.lineJoin;\\n    }\\n    if (contextStrokeState.lineWidth != strokeState.lineWidth) {\\n      contextStrokeState.lineWidth = context.lineWidth = strokeState.lineWidth;\\n    }\\n    if (contextStrokeState.miterLimit != strokeState.miterLimit) {\\n      contextStrokeState.miterLimit = context.miterLimit =\\n          strokeState.miterLimit;\\n    }\\n    if (contextStrokeState.strokeStyle != strokeState.strokeStyle) {\\n      contextStrokeState.strokeStyle = context.strokeStyle =\\n          strokeState.strokeStyle;\\n    }\\n  }\\n};\\n\\n\\n/**\\n * @param {module:ol/render/canvas~TextState} textState Text state.\\n * @private\\n */\\nCanvasImmediateRenderer.prototype.setContextTextState_ = function(textState) {\\n  const context = this.context_;\\n  const contextTextState = this.contextTextState_;\\n  const textAlign = textState.textAlign ?\\n    textState.textAlign : defaultTextAlign;\\n  if (!contextTextState) {\\n    context.font = textState.font;\\n    context.textAlign = textAlign;\\n    context.textBaseline = textState.textBaseline;\\n    this.contextTextState_ = {\\n      font: textState.font,\\n      textAlign: textAlign,\\n      textBaseline: textState.textBaseline\\n    };\\n  } else {\\n    if (contextTextState.font != textState.font) {\\n      contextTextState.font = context.font = textState.font;\\n    }\\n    if (contextTextState.textAlign != textAlign) {\\n      contextTextState.textAlign = context.textAlign = textAlign;\\n    }\\n    if (contextTextState.textBaseline != textState.textBaseline) {\\n      contextTextState.textBaseline = context.textBaseline =\\n          textState.textBaseline;\\n    }\\n  }\\n};\\n\\n\\n/**\\n * Set the fill and stroke style for subsequent draw operations.  To clear\\n * either fill or stroke styles, pass null for the appropriate parameter.\\n *\\n * @param {module:ol/style/Fill} fillStyle Fill style.\\n * @param {module:ol/style/Stroke} strokeStyle Stroke style.\\n * @override\\n */\\nCanvasImmediateRenderer.prototype.setFillStrokeStyle = function(fillStyle, strokeStyle) {\\n  if (!fillStyle) {\\n    this.fillState_ = null;\\n  } else {\\n    const fillStyleColor = fillStyle.getColor();\\n    this.fillState_ = {\\n      fillStyle: asColorLike(fillStyleColor ?\\n        fillStyleColor : defaultFillStyle)\\n    };\\n  }\\n  if (!strokeStyle) {\\n    this.strokeState_ = null;\\n  } else {\\n    const strokeStyleColor = strokeStyle.getColor();\\n    const strokeStyleLineCap = strokeStyle.getLineCap();\\n    const strokeStyleLineDash = strokeStyle.getLineDash();\\n    const strokeStyleLineDashOffset = strokeStyle.getLineDashOffset();\\n    const strokeStyleLineJoin = strokeStyle.getLineJoin();\\n    const strokeStyleWidth = strokeStyle.getWidth();\\n    const strokeStyleMiterLimit = strokeStyle.getMiterLimit();\\n    this.strokeState_ = {\\n      lineCap: strokeStyleLineCap !== undefined ?\\n        strokeStyleLineCap : defaultLineCap,\\n      lineDash: strokeStyleLineDash ?\\n        strokeStyleLineDash : defaultLineDash,\\n      lineDashOffset: strokeStyleLineDashOffset ?\\n        strokeStyleLineDashOffset : defaultLineDashOffset,\\n      lineJoin: strokeStyleLineJoin !== undefined ?\\n        strokeStyleLineJoin : defaultLineJoin,\\n      lineWidth: this.pixelRatio_ * (strokeStyleWidth !== undefined ?\\n        strokeStyleWidth : defaultLineWidth),\\n      miterLimit: strokeStyleMiterLimit !== undefined ?\\n        strokeStyleMiterLimit : defaultMiterLimit,\\n      strokeStyle: asColorLike(strokeStyleColor ?\\n        strokeStyleColor : defaultStrokeStyle)\\n    };\\n  }\\n};\\n\\n\\n/**\\n * Set the image style for subsequent draw operations.  Pass null to remove\\n * the image style.\\n *\\n * @param {module:ol/style/Image} imageStyle Image style.\\n * @override\\n */\\nCanvasImmediateRenderer.prototype.setImageStyle = function(imageStyle) {\\n  if (!imageStyle) {\\n    this.image_ = null;\\n  } else {\\n    const imageAnchor = imageStyle.getAnchor();\\n    // FIXME pixel ratio\\n    const imageImage = imageStyle.getImage(1);\\n    const imageOrigin = imageStyle.getOrigin();\\n    const imageSize = imageStyle.getSize();\\n    this.imageAnchorX_ = imageAnchor[0];\\n    this.imageAnchorY_ = imageAnchor[1];\\n    this.imageHeight_ = imageSize[1];\\n    this.image_ = imageImage;\\n    this.imageOpacity_ = imageStyle.getOpacity();\\n    this.imageOriginX_ = imageOrigin[0];\\n    this.imageOriginY_ = imageOrigin[1];\\n    this.imageRotateWithView_ = imageStyle.getRotateWithView();\\n    this.imageRotation_ = imageStyle.getRotation();\\n    this.imageScale_ = imageStyle.getScale() * this.pixelRatio_;\\n    this.imageSnapToPixel_ = imageStyle.getSnapToPixel();\\n    this.imageWidth_ = imageSize[0];\\n  }\\n};\\n\\n\\n/**\\n * Set the text style for subsequent draw operations.  Pass null to\\n * remove the text style.\\n *\\n * @param {module:ol/style/Text} textStyle Text style.\\n * @override\\n */\\nCanvasImmediateRenderer.prototype.setTextStyle = function(textStyle) {\\n  if (!textStyle) {\\n    this.text_ = '';\\n  } else {\\n    const textFillStyle = textStyle.getFill();\\n    if (!textFillStyle) {\\n      this.textFillState_ = null;\\n    } else {\\n      const textFillStyleColor = textFillStyle.getColor();\\n      this.textFillState_ = {\\n        fillStyle: asColorLike(textFillStyleColor ?\\n          textFillStyleColor : defaultFillStyle)\\n      };\\n    }\\n    const textStrokeStyle = textStyle.getStroke();\\n    if (!textStrokeStyle) {\\n      this.textStrokeState_ = null;\\n    } else {\\n      const textStrokeStyleColor = textStrokeStyle.getColor();\\n      const textStrokeStyleLineCap = textStrokeStyle.getLineCap();\\n      const textStrokeStyleLineDash = textStrokeStyle.getLineDash();\\n      const textStrokeStyleLineDashOffset = textStrokeStyle.getLineDashOffset();\\n      const textStrokeStyleLineJoin = textStrokeStyle.getLineJoin();\\n      const textStrokeStyleWidth = textStrokeStyle.getWidth();\\n      const textStrokeStyleMiterLimit = textStrokeStyle.getMiterLimit();\\n      this.textStrokeState_ = {\\n        lineCap: textStrokeStyleLineCap !== undefined ?\\n          textStrokeStyleLineCap : defaultLineCap,\\n        lineDash: textStrokeStyleLineDash ?\\n          textStrokeStyleLineDash : defaultLineDash,\\n        lineDashOffset: textStrokeStyleLineDashOffset ?\\n          textStrokeStyleLineDashOffset : defaultLineDashOffset,\\n        lineJoin: textStrokeStyleLineJoin !== undefined ?\\n          textStrokeStyleLineJoin : defaultLineJoin,\\n        lineWidth: textStrokeStyleWidth !== undefined ?\\n          textStrokeStyleWidth : defaultLineWidth,\\n        miterLimit: textStrokeStyleMiterLimit !== undefined ?\\n          textStrokeStyleMiterLimit : defaultMiterLimit,\\n        strokeStyle: asColorLike(textStrokeStyleColor ?\\n          textStrokeStyleColor : defaultStrokeStyle)\\n      };\\n    }\\n    const textFont = textStyle.getFont();\\n    const textOffsetX = textStyle.getOffsetX();\\n    const textOffsetY = textStyle.getOffsetY();\\n    const textRotateWithView = textStyle.getRotateWithView();\\n    const textRotation = textStyle.getRotation();\\n    const textScale = textStyle.getScale();\\n    const textText = textStyle.getText();\\n    const textTextAlign = textStyle.getTextAlign();\\n    const textTextBaseline = textStyle.getTextBaseline();\\n    this.textState_ = {\\n      font: textFont !== undefined ?\\n        textFont : defaultFont,\\n      textAlign: textTextAlign !== undefined ?\\n        textTextAlign : defaultTextAlign,\\n      textBaseline: textTextBaseline !== undefined ?\\n        textTextBaseline : defaultTextBaseline\\n    };\\n    this.text_ = textText !== undefined ? textText : '';\\n    this.textOffsetX_ =\\n        textOffsetX !== undefined ? (this.pixelRatio_ * textOffsetX) : 0;\\n    this.textOffsetY_ =\\n        textOffsetY !== undefined ? (this.pixelRatio_ * textOffsetY) : 0;\\n    this.textRotateWithView_ = textRotateWithView !== undefined ? textRotateWithView : false;\\n    this.textRotation_ = textRotation !== undefined ? textRotation : 0;\\n    this.textScale_ = this.pixelRatio_ * (textScale !== undefined ?\\n      textScale : 1);\\n  }\\n};\\nexport default CanvasImmediateRenderer;\\n\",\"/**\\n * @module ol/style/IconImageCache\\n */\\nimport {asString} from '../color.js';\\n\\n/**\\n * Singleton class. Available through {@link module:ol/style/IconImageCache~shared}.\\n * @constructor\\n */\\nconst IconImageCache = function() {\\n\\n  /**\\n   * @type {!Object.<string, module:ol/style/IconImage>}\\n   * @private\\n   */\\n  this.cache_ = {};\\n\\n  /**\\n   * @type {number}\\n   * @private\\n   */\\n  this.cacheSize_ = 0;\\n\\n  /**\\n   * @type {number}\\n   * @private\\n   */\\n  this.maxCacheSize_ = 32;\\n};\\n\\n\\n/**\\n * @param {string} src Src.\\n * @param {?string} crossOrigin Cross origin.\\n * @param {module:ol/color~Color} color Color.\\n * @return {string} Cache key.\\n */\\nfunction getKey(src, crossOrigin, color) {\\n  const colorString = color ? asString(color) : 'null';\\n  return crossOrigin + ':' + src + ':' + colorString;\\n}\\n\\n\\n/**\\n * FIXME empty description for jsdoc\\n */\\nIconImageCache.prototype.clear = function() {\\n  this.cache_ = {};\\n  this.cacheSize_ = 0;\\n};\\n\\n\\n/**\\n * FIXME empty description for jsdoc\\n */\\nIconImageCache.prototype.expire = function() {\\n  if (this.cacheSize_ > this.maxCacheSize_) {\\n    let i = 0;\\n    for (const key in this.cache_) {\\n      const iconImage = this.cache_[key];\\n      if ((i++ & 3) === 0 && !iconImage.hasListener()) {\\n        delete this.cache_[key];\\n        --this.cacheSize_;\\n      }\\n    }\\n  }\\n};\\n\\n\\n/**\\n * @param {string} src Src.\\n * @param {?string} crossOrigin Cross origin.\\n * @param {module:ol/color~Color} color Color.\\n * @return {module:ol/style/IconImage} Icon image.\\n */\\nIconImageCache.prototype.get = function(src, crossOrigin, color) {\\n  const key = getKey(src, crossOrigin, color);\\n  return key in this.cache_ ? this.cache_[key] : null;\\n};\\n\\n\\n/**\\n * @param {string} src Src.\\n * @param {?string} crossOrigin Cross origin.\\n * @param {module:ol/color~Color} color Color.\\n * @param {module:ol/style/IconImage} iconImage Icon image.\\n */\\nIconImageCache.prototype.set = function(src, crossOrigin, color, iconImage) {\\n  const key = getKey(src, crossOrigin, color);\\n  this.cache_[key] = iconImage;\\n  ++this.cacheSize_;\\n};\\n\\n\\n/**\\n * Set the cache size of the icon cache. Default is `32`. Change this value when\\n * your map uses more than 32 different icon images and you are not caching icon\\n * styles on the application level.\\n * @param {number} maxCacheSize Cache max size.\\n * @api\\n */\\nIconImageCache.prototype.setSize = function(maxCacheSize) {\\n  this.maxCacheSize_ = maxCacheSize;\\n  this.expire();\\n};\\nexport default IconImageCache;\\n\\n\\n/**\\n * The {@link module:ol/style/IconImageCache~IconImageCache} for\\n * {@link module:ol/style/Icon~Icon} images.\\n * @api\\n */\\nexport const shared = new IconImageCache();\\n\",\"/**\\n * @module ol/renderer/Map\\n */\\nimport {getUid, inherits} from '../index.js';\\nimport Disposable from '../Disposable.js';\\nimport {listen, unlistenByKey} from '../events.js';\\nimport EventType from '../events/EventType.js';\\nimport {getWidth} from '../extent.js';\\nimport {TRUE, UNDEFINED} from '../functions.js';\\nimport {visibleAtResolution} from '../layer/Layer.js';\\nimport {shared as iconImageCache} from '../style/IconImageCache.js';\\nimport {compose as composeTransform, invert as invertTransform, setFromArray as transformSetFromArray} from '../transform.js';\\n\\n\\n/**\\n * @constructor\\n * @abstract\\n * @extends {module:ol/Disposable}\\n * @param {module:ol/PluggableMap} map Map.\\n * @struct\\n */\\nconst MapRenderer = function(map) {\\n  Disposable.call(this);\\n\\n  /**\\n   * @private\\n   * @type {module:ol/PluggableMap}\\n   */\\n  this.map_ = map;\\n\\n  /**\\n   * @private\\n   * @type {!Object.<string, module:ol/renderer/Layer>}\\n   */\\n  this.layerRenderers_ = {};\\n\\n  /**\\n   * @private\\n   * @type {Object.<string, module:ol/events~EventsKey>}\\n   */\\n  this.layerRendererListeners_ = {};\\n\\n  /**\\n   * @private\\n   * @type {Array.<module:ol/renderer/Layer>}\\n   */\\n  this.layerRendererConstructors_ = [];\\n\\n};\\n\\ninherits(MapRenderer, Disposable);\\n\\n\\n/**\\n * Register layer renderer constructors.\\n * @param {Array.<module:ol/renderer/Layer>} constructors Layer renderers.\\n */\\nMapRenderer.prototype.registerLayerRenderers = function(constructors) {\\n  this.layerRendererConstructors_.push.apply(this.layerRendererConstructors_, constructors);\\n};\\n\\n\\n/**\\n * Get the registered layer renderer constructors.\\n * @return {Array.<module:ol/renderer/Layer>} Registered layer renderers.\\n */\\nMapRenderer.prototype.getLayerRendererConstructors = function() {\\n  return this.layerRendererConstructors_;\\n};\\n\\n\\n/**\\n * @param {module:ol/PluggableMap~FrameState} frameState FrameState.\\n * @protected\\n */\\nMapRenderer.prototype.calculateMatrices2D = function(frameState) {\\n  const viewState = frameState.viewState;\\n  const coordinateToPixelTransform = frameState.coordinateToPixelTransform;\\n  const pixelToCoordinateTransform = frameState.pixelToCoordinateTransform;\\n\\n  composeTransform(coordinateToPixelTransform,\\n    frameState.size[0] / 2, frameState.size[1] / 2,\\n    1 / viewState.resolution, -1 / viewState.resolution,\\n    -viewState.rotation,\\n    -viewState.center[0], -viewState.center[1]);\\n\\n  invertTransform(\\n    transformSetFromArray(pixelToCoordinateTransform, coordinateToPixelTransform));\\n};\\n\\n\\n/**\\n * Removes all layer renderers.\\n */\\nMapRenderer.prototype.removeLayerRenderers = function() {\\n  for (const key in this.layerRenderers_) {\\n    this.removeLayerRendererByKey_(key).dispose();\\n  }\\n};\\n\\n\\n/**\\n * @param {module:ol/PluggableMap} map Map.\\n * @param {module:ol/PluggableMap~FrameState} frameState Frame state.\\n */\\nfunction expireIconCache(map, frameState) {\\n  iconImageCache.expire();\\n}\\n\\n\\n/**\\n * @param {module:ol/coordinate~Coordinate} coordinate Coordinate.\\n * @param {module:ol/PluggableMap~FrameState} frameState FrameState.\\n * @param {number} hitTolerance Hit tolerance in pixels.\\n * @param {function(this: S, (module:ol/Feature|module:ol/render/Feature),\\n *     module:ol/layer/Layer): T} callback Feature callback.\\n * @param {S} thisArg Value to use as `this` when executing `callback`.\\n * @param {function(this: U, module:ol/layer/Layer): boolean} layerFilter Layer filter\\n *     function, only layers which are visible and for which this function\\n *     returns `true` will be tested for features.  By default, all visible\\n *     layers will be tested.\\n * @param {U} thisArg2 Value to use as `this` when executing `layerFilter`.\\n * @return {T|undefined} Callback result.\\n * @template S,T,U\\n */\\nMapRenderer.prototype.forEachFeatureAtCoordinate = function(coordinate, frameState, hitTolerance, callback, thisArg,\\n  layerFilter, thisArg2) {\\n  let result;\\n  const viewState = frameState.viewState;\\n  const viewResolution = viewState.resolution;\\n\\n  /**\\n   * @param {module:ol/Feature|module:ol/render/Feature} feature Feature.\\n   * @param {module:ol/layer/Layer} layer Layer.\\n   * @return {?} Callback result.\\n   */\\n  function forEachFeatureAtCoordinate(feature, layer) {\\n    const key = getUid(feature).toString();\\n    const managed = frameState.layerStates[getUid(layer)].managed;\\n    if (!(key in frameState.skippedFeatureUids && !managed)) {\\n      return callback.call(thisArg, feature, managed ? layer : null);\\n    }\\n  }\\n\\n  const projection = viewState.projection;\\n\\n  let translatedCoordinate = coordinate;\\n  if (projection.canWrapX()) {\\n    const projectionExtent = projection.getExtent();\\n    const worldWidth = getWidth(projectionExtent);\\n    const x = coordinate[0];\\n    if (x < projectionExtent[0] || x > projectionExtent[2]) {\\n      const worldsAway = Math.ceil((projectionExtent[0] - x) / worldWidth);\\n      translatedCoordinate = [x + worldWidth * worldsAway, coordinate[1]];\\n    }\\n  }\\n\\n  const layerStates = frameState.layerStatesArray;\\n  const numLayers = layerStates.length;\\n  let i;\\n  for (i = numLayers - 1; i >= 0; --i) {\\n    const layerState = layerStates[i];\\n    const layer = layerState.layer;\\n    if (visibleAtResolution(layerState, viewResolution) && layerFilter.call(thisArg2, layer)) {\\n      const layerRenderer = this.getLayerRenderer(layer);\\n      if (layer.getSource()) {\\n        result = layerRenderer.forEachFeatureAtCoordinate(\\n          layer.getSource().getWrapX() ? translatedCoordinate : coordinate,\\n          frameState, hitTolerance, forEachFeatureAtCoordinate, thisArg);\\n      }\\n      if (result) {\\n        return result;\\n      }\\n    }\\n  }\\n  return undefined;\\n};\\n\\n\\n/**\\n * @abstract\\n * @param {module:ol~Pixel} pixel Pixel.\\n * @param {module:ol/PluggableMap~FrameState} frameState FrameState.\\n * @param {function(this: S, module:ol/layer/Layer, (Uint8ClampedArray|Uint8Array)): T} callback Layer\\n *     callback.\\n * @param {S} thisArg Value to use as `this` when executing `callback`.\\n * @param {function(this: U, module:ol/layer/Layer): boolean} layerFilter Layer filter\\n *     function, only layers which are visible and for which this function\\n *     returns `true` will be tested for features.  By default, all visible\\n *     layers will be tested.\\n * @param {U} thisArg2 Value to use as `this` when executing `layerFilter`.\\n * @return {T|undefined} Callback result.\\n * @template S,T,U\\n */\\nMapRenderer.prototype.forEachLayerAtPixel = function(pixel, frameState, callback, thisArg,\\n  layerFilter, thisArg2) {};\\n\\n\\n/**\\n * @param {module:ol/coordinate~Coordinate} coordinate Coordinate.\\n * @param {module:ol/PluggableMap~FrameState} frameState FrameState.\\n * @param {number} hitTolerance Hit tolerance in pixels.\\n * @param {function(this: U, module:ol/layer/Layer): boolean} layerFilter Layer filter\\n *     function, only layers which are visible and for which this function\\n *     returns `true` will be tested for features.  By default, all visible\\n *     layers will be tested.\\n * @param {U} thisArg Value to use as `this` when executing `layerFilter`.\\n * @return {boolean} Is there a feature at the given coordinate?\\n * @template U\\n */\\nMapRenderer.prototype.hasFeatureAtCoordinate = function(coordinate, frameState, hitTolerance, layerFilter, thisArg) {\\n  const hasFeature = this.forEachFeatureAtCoordinate(\\n    coordinate, frameState, hitTolerance, TRUE, this, layerFilter, thisArg);\\n\\n  return hasFeature !== undefined;\\n};\\n\\n\\n/**\\n * @param {module:ol/layer/Layer} layer Layer.\\n * @protected\\n * @return {module:ol/renderer/Layer} Layer renderer.\\n */\\nMapRenderer.prototype.getLayerRenderer = function(layer) {\\n  const layerKey = getUid(layer).toString();\\n  if (layerKey in this.layerRenderers_) {\\n    return this.layerRenderers_[layerKey];\\n  } else {\\n    let renderer;\\n    for (let i = 0, ii = this.layerRendererConstructors_.length; i < ii; ++i) {\\n      const candidate = this.layerRendererConstructors_[i];\\n      if (candidate['handles'](layer)) {\\n        renderer = candidate['create'](this, layer);\\n        break;\\n      }\\n    }\\n    if (renderer) {\\n      this.layerRenderers_[layerKey] = renderer;\\n      this.layerRendererListeners_[layerKey] = listen(renderer,\\n        EventType.CHANGE, this.handleLayerRendererChange_, this);\\n    } else {\\n      throw new Error('Unable to create renderer for layer: ' + layer.getType());\\n    }\\n    return renderer;\\n  }\\n};\\n\\n\\n/**\\n * @param {string} layerKey Layer key.\\n * @protected\\n * @return {module:ol/renderer/Layer} Layer renderer.\\n */\\nMapRenderer.prototype.getLayerRendererByKey = function(layerKey) {\\n  return this.layerRenderers_[layerKey];\\n};\\n\\n\\n/**\\n * @protected\\n * @return {Object.<string, module:ol/renderer/Layer>} Layer renderers.\\n */\\nMapRenderer.prototype.getLayerRenderers = function() {\\n  return this.layerRenderers_;\\n};\\n\\n\\n/**\\n * @return {module:ol/PluggableMap} Map.\\n */\\nMapRenderer.prototype.getMap = function() {\\n  return this.map_;\\n};\\n\\n\\n/**\\n * Handle changes in a layer renderer.\\n * @private\\n */\\nMapRenderer.prototype.handleLayerRendererChange_ = function() {\\n  this.map_.render();\\n};\\n\\n\\n/**\\n * @param {string} layerKey Layer key.\\n * @return {module:ol/renderer/Layer} Layer renderer.\\n * @private\\n */\\nMapRenderer.prototype.removeLayerRendererByKey_ = function(layerKey) {\\n  const layerRenderer = this.layerRenderers_[layerKey];\\n  delete this.layerRenderers_[layerKey];\\n\\n  unlistenByKey(this.layerRendererListeners_[layerKey]);\\n  delete this.layerRendererListeners_[layerKey];\\n\\n  return layerRenderer;\\n};\\n\\n\\n/**\\n * Render.\\n * @param {?module:ol/PluggableMap~FrameState} frameState Frame state.\\n */\\nMapRenderer.prototype.renderFrame = UNDEFINED;\\n\\n\\n/**\\n * @param {module:ol/PluggableMap} map Map.\\n * @param {module:ol/PluggableMap~FrameState} frameState Frame state.\\n * @private\\n */\\nMapRenderer.prototype.removeUnusedLayerRenderers_ = function(map, frameState) {\\n  for (const layerKey in this.layerRenderers_) {\\n    if (!frameState || !(layerKey in frameState.layerStates)) {\\n      this.removeLayerRendererByKey_(layerKey).dispose();\\n    }\\n  }\\n};\\n\\n\\n/**\\n * @param {module:ol/PluggableMap~FrameState} frameState Frame state.\\n * @protected\\n */\\nMapRenderer.prototype.scheduleExpireIconCache = function(frameState) {\\n  frameState.postRenderFunctions.push(/** @type {module:ol/PluggableMap~PostRenderFunction} */ (expireIconCache));\\n};\\n\\n\\n/**\\n * @param {!module:ol/PluggableMap~FrameState} frameState Frame state.\\n * @protected\\n */\\nMapRenderer.prototype.scheduleRemoveUnusedLayerRenderers = function(frameState) {\\n  for (const layerKey in this.layerRenderers_) {\\n    if (!(layerKey in frameState.layerStates)) {\\n      frameState.postRenderFunctions.push(\\n        /** @type {module:ol/PluggableMap~PostRenderFunction} */ (this.removeUnusedLayerRenderers_.bind(this))\\n      );\\n      return;\\n    }\\n  }\\n};\\n\\n\\n/**\\n * @param {module:ol/layer/Layer~State} state1 First layer state.\\n * @param {module:ol/layer/Layer~State} state2 Second layer state.\\n * @return {number} The zIndex difference.\\n */\\nexport function sortByZIndex(state1, state2) {\\n  return state1.zIndex - state2.zIndex;\\n}\\nexport default MapRenderer;\\n\",\"/**\\n * @module ol/renderer/canvas/Map\\n */\\nimport {create as createTransform, apply as applyTransform, compose as composeTransform} from '../../transform.js';\\nimport {inherits} from '../../index.js';\\nimport {includes, stableSort} from '../../array.js';\\nimport {CLASS_UNSELECTABLE} from '../../css.js';\\nimport {createCanvasContext2D} from '../../dom.js';\\nimport {visibleAtResolution} from '../../layer/Layer.js';\\nimport RenderEvent from '../../render/Event.js';\\nimport RenderEventType from '../../render/EventType.js';\\nimport {rotateAtOffset} from '../../render/canvas.js';\\nimport CanvasImmediateRenderer from '../../render/canvas/Immediate.js';\\nimport MapRenderer, {sortByZIndex} from '../Map.js';\\nimport SourceState from '../../source/State.js';\\n\\n\\n/**\\n * @type {Array.<module:ol/renderer/Layer>}\\n */\\nexport const layerRendererConstructors = [];\\n\\n\\n/**\\n * @constructor\\n * @extends {module:ol/renderer/Map}\\n * @param {module:ol/PluggableMap} map Map.\\n * @api\\n */\\nconst CanvasMapRenderer = function(map) {\\n  MapRenderer.call(this, map);\\n\\n  const container = map.getViewport();\\n\\n  /**\\n   * @private\\n   * @type {CanvasRenderingContext2D}\\n   */\\n  this.context_ = createCanvasContext2D();\\n\\n  /**\\n   * @private\\n   * @type {HTMLCanvasElement}\\n   */\\n  this.canvas_ = this.context_.canvas;\\n\\n  this.canvas_.style.width = '100%';\\n  this.canvas_.style.height = '100%';\\n  this.canvas_.style.display = 'block';\\n  this.canvas_.className = CLASS_UNSELECTABLE;\\n  container.insertBefore(this.canvas_, container.childNodes[0] || null);\\n\\n  /**\\n   * @private\\n   * @type {boolean}\\n   */\\n  this.renderedVisible_ = true;\\n\\n  /**\\n   * @private\\n   * @type {module:ol/transform~Transform}\\n   */\\n  this.transform_ = createTransform();\\n\\n};\\n\\ninherits(CanvasMapRenderer, MapRenderer);\\n\\n\\n/**\\n * @param {module:ol/render/EventType} type Event type.\\n * @param {module:ol/PluggableMap~FrameState} frameState Frame state.\\n * @private\\n */\\nCanvasMapRenderer.prototype.dispatchComposeEvent_ = function(type, frameState) {\\n  const map = this.getMap();\\n  const context = this.context_;\\n  if (map.hasListener(type)) {\\n    const extent = frameState.extent;\\n    const pixelRatio = frameState.pixelRatio;\\n    const viewState = frameState.viewState;\\n    const rotation = viewState.rotation;\\n\\n    const transform = this.getTransform(frameState);\\n\\n    const vectorContext = new CanvasImmediateRenderer(context, pixelRatio,\\n      extent, transform, rotation);\\n    const composeEvent = new RenderEvent(type, vectorContext,\\n      frameState, context, null);\\n    map.dispatchEvent(composeEvent);\\n  }\\n};\\n\\n\\n/**\\n * @param {module:ol/PluggableMap~FrameState} frameState Frame state.\\n * @protected\\n * @return {!module:ol/transform~Transform} Transform.\\n */\\nCanvasMapRenderer.prototype.getTransform = function(frameState) {\\n  const viewState = frameState.viewState;\\n  const dx1 = this.canvas_.width / 2;\\n  const dy1 = this.canvas_.height / 2;\\n  const sx = frameState.pixelRatio / viewState.resolution;\\n  const sy = -sx;\\n  const angle = -viewState.rotation;\\n  const dx2 = -viewState.center[0];\\n  const dy2 = -viewState.center[1];\\n  return composeTransform(this.transform_, dx1, dy1, sx, sy, angle, dx2, dy2);\\n};\\n\\n\\n/**\\n * @inheritDoc\\n */\\nCanvasMapRenderer.prototype.renderFrame = function(frameState) {\\n\\n  if (!frameState) {\\n    if (this.renderedVisible_) {\\n      this.canvas_.style.display = 'none';\\n      this.renderedVisible_ = false;\\n    }\\n    return;\\n  }\\n\\n  const context = this.context_;\\n  const pixelRatio = frameState.pixelRatio;\\n  const width = Math.round(frameState.size[0] * pixelRatio);\\n  const height = Math.round(frameState.size[1] * pixelRatio);\\n  if (this.canvas_.width != width || this.canvas_.height != height) {\\n    this.canvas_.width = width;\\n    this.canvas_.height = height;\\n  } else {\\n    context.clearRect(0, 0, width, height);\\n  }\\n\\n  const rotation = frameState.viewState.rotation;\\n\\n  this.calculateMatrices2D(frameState);\\n\\n  this.dispatchComposeEvent_(RenderEventType.PRECOMPOSE, frameState);\\n\\n  const layerStatesArray = frameState.layerStatesArray;\\n  stableSort(layerStatesArray, sortByZIndex);\\n\\n  if (rotation) {\\n    context.save();\\n    rotateAtOffset(context, rotation, width / 2, height / 2);\\n  }\\n\\n  const viewResolution = frameState.viewState.resolution;\\n  let i, ii, layer, layerRenderer, layerState;\\n  for (i = 0, ii = layerStatesArray.length; i < ii; ++i) {\\n    layerState = layerStatesArray[i];\\n    layer = layerState.layer;\\n    layerRenderer = /** @type {module:ol/renderer/canvas/Layer} */ (this.getLayerRenderer(layer));\\n    if (!visibleAtResolution(layerState, viewResolution) ||\\n        layerState.sourceState != SourceState.READY) {\\n      continue;\\n    }\\n    if (layerRenderer.prepareFrame(frameState, layerState)) {\\n      layerRenderer.composeFrame(frameState, layerState, context);\\n    }\\n  }\\n\\n  if (rotation) {\\n    context.restore();\\n  }\\n\\n  this.dispatchComposeEvent_(RenderEventType.POSTCOMPOSE, frameState);\\n\\n  if (!this.renderedVisible_) {\\n    this.canvas_.style.display = '';\\n    this.renderedVisible_ = true;\\n  }\\n\\n  this.scheduleRemoveUnusedLayerRenderers(frameState);\\n  this.scheduleExpireIconCache(frameState);\\n};\\n\\n\\n/**\\n * @inheritDoc\\n */\\nCanvasMapRenderer.prototype.forEachLayerAtPixel = function(pixel, frameState, callback, thisArg,\\n  layerFilter, thisArg2) {\\n  let result;\\n  const viewState = frameState.viewState;\\n  const viewResolution = viewState.resolution;\\n\\n  const layerStates = frameState.layerStatesArray;\\n  const numLayers = layerStates.length;\\n\\n  const coordinate = applyTransform(\\n    frameState.pixelToCoordinateTransform, pixel.slice());\\n\\n  let i;\\n  for (i = numLayers - 1; i >= 0; --i) {\\n    const layerState = layerStates[i];\\n    const layer = layerState.layer;\\n    if (visibleAtResolution(layerState, viewResolution) && layerFilter.call(thisArg2, layer)) {\\n      const layerRenderer = /** @type {module:ol/renderer/canvas/Layer} */ (this.getLayerRenderer(layer));\\n      result = layerRenderer.forEachLayerAtCoordinate(\\n        coordinate, frameState, callback, thisArg);\\n      if (result) {\\n        return result;\\n      }\\n    }\\n  }\\n  return undefined;\\n};\\n\\n\\n/**\\n * @inheritDoc\\n */\\nCanvasMapRenderer.prototype.registerLayerRenderers = function(constructors) {\\n  MapRenderer.prototype.registerLayerRenderers.call(this, constructors);\\n  for (let i = 0, ii = constructors.length; i < ii; ++i) {\\n    const ctor = constructors[i];\\n    if (!includes(layerRendererConstructors, ctor)) {\\n      layerRendererConstructors.push(ctor);\\n    }\\n  }\\n};\\n\\nexport default CanvasMapRenderer;\\n\",\"/**\\n * @module ol/renderer/Layer\\n */\\nimport {getUid, inherits} from '../index.js';\\nimport ImageState from '../ImageState.js';\\nimport Observable from '../Observable.js';\\nimport TileState from '../TileState.js';\\nimport {listen} from '../events.js';\\nimport EventType from '../events/EventType.js';\\nimport {FALSE, UNDEFINED} from '../functions.js';\\nimport SourceState from '../source/State.js';\\n\\n/**\\n * @constructor\\n * @extends {module:ol/Observable}\\n * @param {module:ol/layer/Layer} layer Layer.\\n * @struct\\n */\\nconst LayerRenderer = function(layer) {\\n\\n  Observable.call(this);\\n\\n  /**\\n   * @private\\n   * @type {module:ol/layer/Layer}\\n   */\\n  this.layer_ = layer;\\n\\n\\n};\\n\\ninherits(LayerRenderer, Observable);\\n\\n\\n/**\\n * @param {module:ol/coordinate~Coordinate} coordinate Coordinate.\\n * @param {module:ol/PluggableMap~FrameState} frameState Frame state.\\n * @param {number} hitTolerance Hit tolerance in pixels.\\n * @param {function(this: S, (module:ol/Feature|module:ol/render/Feature), module:ol/layer/Layer): T}\\n *     callback Feature callback.\\n * @param {S} thisArg Value to use as `this` when executing `callback`.\\n * @return {T|undefined} Callback result.\\n * @template S,T\\n */\\nLayerRenderer.prototype.forEachFeatureAtCoordinate = UNDEFINED;\\n\\n\\n/**\\n * @param {module:ol/coordinate~Coordinate} coordinate Coordinate.\\n * @param {module:ol/PluggableMap~FrameState} frameState Frame state.\\n * @return {boolean} Is there a feature at the given coordinate?\\n */\\nLayerRenderer.prototype.hasFeatureAtCoordinate = FALSE;\\n\\n\\n/**\\n * Create a function that adds loaded tiles to the tile lookup.\\n * @param {module:ol/source/Tile} source Tile source.\\n * @param {module:ol/proj/Projection} projection Projection of the tiles.\\n * @param {Object.<number, Object.<string, module:ol/Tile>>} tiles Lookup of loaded tiles by zoom level.\\n * @return {function(number, module:ol/TileRange):boolean} A function that can be\\n *     called with a zoom level and a tile range to add loaded tiles to the lookup.\\n * @protected\\n */\\nLayerRenderer.prototype.createLoadedTileFinder = function(source, projection, tiles) {\\n  return (\\n    /**\\n     * @param {number} zoom Zoom level.\\n     * @param {module:ol/TileRange} tileRange Tile range.\\n     * @return {boolean} The tile range is fully loaded.\\n     */\\n    function(zoom, tileRange) {\\n      function callback(tile) {\\n        if (!tiles[zoom]) {\\n          tiles[zoom] = {};\\n        }\\n        tiles[zoom][tile.tileCoord.toString()] = tile;\\n      }\\n      return source.forEachLoadedTile(projection, zoom, tileRange, callback);\\n    }\\n  );\\n};\\n\\n\\n/**\\n * @return {module:ol/layer/Layer} Layer.\\n */\\nLayerRenderer.prototype.getLayer = function() {\\n  return this.layer_;\\n};\\n\\n\\n/**\\n * Handle changes in image state.\\n * @param {module:ol/events/Event} event Image change event.\\n * @private\\n */\\nLayerRenderer.prototype.handleImageChange_ = function(event) {\\n  const image = /** @type {module:ol/Image} */ (event.target);\\n  if (image.getState() === ImageState.LOADED) {\\n    this.renderIfReadyAndVisible();\\n  }\\n};\\n\\n\\n/**\\n * Load the image if not already loaded, and register the image change\\n * listener if needed.\\n * @param {module:ol/ImageBase} image Image.\\n * @return {boolean} `true` if the image is already loaded, `false` otherwise.\\n * @protected\\n */\\nLayerRenderer.prototype.loadImage = function(image) {\\n  let imageState = image.getState();\\n  if (imageState != ImageState.LOADED && imageState != ImageState.ERROR) {\\n    listen(image, EventType.CHANGE, this.handleImageChange_, this);\\n  }\\n  if (imageState == ImageState.IDLE) {\\n    image.load();\\n    imageState = image.getState();\\n  }\\n  return imageState == ImageState.LOADED;\\n};\\n\\n\\n/**\\n * @protected\\n */\\nLayerRenderer.prototype.renderIfReadyAndVisible = function() {\\n  const layer = this.getLayer();\\n  if (layer.getVisible() && layer.getSourceState() == SourceState.READY) {\\n    this.changed();\\n  }\\n};\\n\\n\\n/**\\n * @param {module:ol/PluggableMap~FrameState} frameState Frame state.\\n * @param {module:ol/source/Tile} tileSource Tile source.\\n * @protected\\n */\\nLayerRenderer.prototype.scheduleExpireCache = function(frameState, tileSource) {\\n  if (tileSource.canExpireCache()) {\\n    /**\\n     * @param {module:ol/source/Tile} tileSource Tile source.\\n     * @param {module:ol/PluggableMap} map Map.\\n     * @param {module:ol/PluggableMap~FrameState} frameState Frame state.\\n     */\\n    const postRenderFunction = function(tileSource, map, frameState) {\\n      const tileSourceKey = getUid(tileSource).toString();\\n      if (tileSourceKey in frameState.usedTiles) {\\n        tileSource.expireCache(frameState.viewState.projection,\\n          frameState.usedTiles[tileSourceKey]);\\n      }\\n    }.bind(null, tileSource);\\n\\n    frameState.postRenderFunctions.push(\\n      /** @type {module:ol/PluggableMap~PostRenderFunction} */ (postRenderFunction)\\n    );\\n  }\\n};\\n\\n\\n/**\\n * @param {!Object.<string, !Object.<string, module:ol/TileRange>>} usedTiles Used tiles.\\n * @param {module:ol/source/Tile} tileSource Tile source.\\n * @param {number} z Z.\\n * @param {module:ol/TileRange} tileRange Tile range.\\n * @protected\\n */\\nLayerRenderer.prototype.updateUsedTiles = function(usedTiles, tileSource, z, tileRange) {\\n  // FIXME should we use tilesToDrawByZ instead?\\n  const tileSourceKey = getUid(tileSource).toString();\\n  const zKey = z.toString();\\n  if (tileSourceKey in usedTiles) {\\n    if (zKey in usedTiles[tileSourceKey]) {\\n      usedTiles[tileSourceKey][zKey].extend(tileRange);\\n    } else {\\n      usedTiles[tileSourceKey][zKey] = tileRange;\\n    }\\n  } else {\\n    usedTiles[tileSourceKey] = {};\\n    usedTiles[tileSourceKey][zKey] = tileRange;\\n  }\\n};\\n\\n\\n/**\\n * Manage tile pyramid.\\n * This function performs a number of functions related to the tiles at the\\n * current zoom and lower zoom levels:\\n * - registers idle tiles in frameState.wantedTiles so that they are not\\n *   discarded by the tile queue\\n * - enqueues missing tiles\\n * @param {module:ol/PluggableMap~FrameState} frameState Frame state.\\n * @param {module:ol/source/Tile} tileSource Tile source.\\n * @param {module:ol/tilegrid/TileGrid} tileGrid Tile grid.\\n * @param {number} pixelRatio Pixel ratio.\\n * @param {module:ol/proj/Projection} projection Projection.\\n * @param {module:ol/extent~Extent} extent Extent.\\n * @param {number} currentZ Current Z.\\n * @param {number} preload Load low resolution tiles up to 'preload' levels.\\n * @param {function(this: T, module:ol/Tile)=} opt_tileCallback Tile callback.\\n * @param {T=} opt_this Object to use as `this` in `opt_tileCallback`.\\n * @protected\\n * @template T\\n */\\nLayerRenderer.prototype.manageTilePyramid = function(\\n  frameState, tileSource, tileGrid, pixelRatio, projection, extent,\\n  currentZ, preload, opt_tileCallback, opt_this) {\\n  const tileSourceKey = getUid(tileSource).toString();\\n  if (!(tileSourceKey in frameState.wantedTiles)) {\\n    frameState.wantedTiles[tileSourceKey] = {};\\n  }\\n  const wantedTiles = frameState.wantedTiles[tileSourceKey];\\n  const tileQueue = frameState.tileQueue;\\n  const minZoom = tileGrid.getMinZoom();\\n  let tile, tileRange, tileResolution, x, y, z;\\n  for (z = minZoom; z <= currentZ; ++z) {\\n    tileRange = tileGrid.getTileRangeForExtentAndZ(extent, z, tileRange);\\n    tileResolution = tileGrid.getResolution(z);\\n    for (x = tileRange.minX; x <= tileRange.maxX; ++x) {\\n      for (y = tileRange.minY; y <= tileRange.maxY; ++y) {\\n        if (currentZ - z <= preload) {\\n          tile = tileSource.getTile(z, x, y, pixelRatio, projection);\\n          if (tile.getState() == TileState.IDLE) {\\n            wantedTiles[tile.getKey()] = true;\\n            if (!tileQueue.isKeyQueued(tile.getKey())) {\\n              tileQueue.enqueue([tile, tileSourceKey,\\n                tileGrid.getTileCoordCenter(tile.tileCoord), tileResolution]);\\n            }\\n          }\\n          if (opt_tileCallback !== undefined) {\\n            opt_tileCallback.call(opt_this, tile);\\n          }\\n        } else {\\n          tileSource.useTile(z, x, y, projection);\\n        }\\n      }\\n    }\\n  }\\n};\\nexport default LayerRenderer;\\n\",\"/**\\n * @module ol/renderer/canvas/Layer\\n */\\nimport {inherits} from '../../index.js';\\nimport {getBottomLeft, getBottomRight, getTopLeft, getTopRight} from '../../extent.js';\\nimport {TRUE} from '../../functions.js';\\nimport RenderEvent from '../../render/Event.js';\\nimport RenderEventType from '../../render/EventType.js';\\nimport {rotateAtOffset} from '../../render/canvas.js';\\nimport CanvasImmediateRenderer from '../../render/canvas/Immediate.js';\\nimport LayerRenderer from '../Layer.js';\\nimport {create as createTransform, apply as applyTransform, compose as composeTransform} from '../../transform.js';\\n\\n/**\\n * @constructor\\n * @abstract\\n * @extends {module:ol/renderer/Layer}\\n * @param {module:ol/layer/Layer} layer Layer.\\n */\\nconst CanvasLayerRenderer = function(layer) {\\n\\n  LayerRenderer.call(this, layer);\\n\\n  /**\\n   * @protected\\n   * @type {number}\\n   */\\n  this.renderedResolution;\\n\\n  /**\\n   * @private\\n   * @type {module:ol/transform~Transform}\\n   */\\n  this.transform_ = createTransform();\\n\\n};\\n\\ninherits(CanvasLayerRenderer, LayerRenderer);\\n\\n\\n/**\\n * @param {CanvasRenderingContext2D} context Context.\\n * @param {module:ol/PluggableMap~FrameState} frameState Frame state.\\n * @param {module:ol/extent~Extent} extent Clip extent.\\n * @protected\\n */\\nCanvasLayerRenderer.prototype.clip = function(context, frameState, extent) {\\n  const pixelRatio = frameState.pixelRatio;\\n  const width = frameState.size[0] * pixelRatio;\\n  const height = frameState.size[1] * pixelRatio;\\n  const rotation = frameState.viewState.rotation;\\n  const topLeft = getTopLeft(/** @type {module:ol/extent~Extent} */ (extent));\\n  const topRight = getTopRight(/** @type {module:ol/extent~Extent} */ (extent));\\n  const bottomRight = getBottomRight(/** @type {module:ol/extent~Extent} */ (extent));\\n  const bottomLeft = getBottomLeft(/** @type {module:ol/extent~Extent} */ (extent));\\n\\n  applyTransform(frameState.coordinateToPixelTransform, topLeft);\\n  applyTransform(frameState.coordinateToPixelTransform, topRight);\\n  applyTransform(frameState.coordinateToPixelTransform, bottomRight);\\n  applyTransform(frameState.coordinateToPixelTransform, bottomLeft);\\n\\n  context.save();\\n  rotateAtOffset(context, -rotation, width / 2, height / 2);\\n  context.beginPath();\\n  context.moveTo(topLeft[0] * pixelRatio, topLeft[1] * pixelRatio);\\n  context.lineTo(topRight[0] * pixelRatio, topRight[1] * pixelRatio);\\n  context.lineTo(bottomRight[0] * pixelRatio, bottomRight[1] * pixelRatio);\\n  context.lineTo(bottomLeft[0] * pixelRatio, bottomLeft[1] * pixelRatio);\\n  context.clip();\\n  rotateAtOffset(context, rotation, width / 2, height / 2);\\n};\\n\\n\\n/**\\n * @param {module:ol/render/EventType} type Event type.\\n * @param {CanvasRenderingContext2D} context Context.\\n * @param {module:ol/PluggableMap~FrameState} frameState Frame state.\\n * @param {module:ol/transform~Transform=} opt_transform Transform.\\n * @private\\n */\\nCanvasLayerRenderer.prototype.dispatchComposeEvent_ = function(type, context, frameState, opt_transform) {\\n  const layer = this.getLayer();\\n  if (layer.hasListener(type)) {\\n    const width = frameState.size[0] * frameState.pixelRatio;\\n    const height = frameState.size[1] * frameState.pixelRatio;\\n    const rotation = frameState.viewState.rotation;\\n    rotateAtOffset(context, -rotation, width / 2, height / 2);\\n    const transform = opt_transform !== undefined ?\\n      opt_transform : this.getTransform(frameState, 0);\\n    const render = new CanvasImmediateRenderer(\\n      context, frameState.pixelRatio, frameState.extent, transform,\\n      frameState.viewState.rotation);\\n    const composeEvent = new RenderEvent(type, render, frameState,\\n      context, null);\\n    layer.dispatchEvent(composeEvent);\\n    rotateAtOffset(context, rotation, width / 2, height / 2);\\n  }\\n};\\n\\n\\n/**\\n * @param {module:ol/coordinate~Coordinate} coordinate Coordinate.\\n * @param {module:ol/PluggableMap~FrameState} frameState FrameState.\\n * @param {function(this: S, module:ol/layer/Layer, (Uint8ClampedArray|Uint8Array)): T} callback Layer\\n *     callback.\\n * @param {S} thisArg Value to use as `this` when executing `callback`.\\n * @return {T|undefined} Callback result.\\n * @template S,T,U\\n */\\nCanvasLayerRenderer.prototype.forEachLayerAtCoordinate = function(coordinate, frameState, callback, thisArg) {\\n  const hasFeature = this.forEachFeatureAtCoordinate(coordinate, frameState, 0, TRUE, this);\\n\\n  if (hasFeature) {\\n    return callback.call(thisArg, this.getLayer(), null);\\n  } else {\\n    return undefined;\\n  }\\n};\\n\\n\\n/**\\n * @param {CanvasRenderingContext2D} context Context.\\n * @param {module:ol/PluggableMap~FrameState} frameState Frame state.\\n * @param {module:ol/layer/Layer~State} layerState Layer state.\\n * @param {module:ol/transform~Transform=} opt_transform Transform.\\n * @protected\\n */\\nCanvasLayerRenderer.prototype.postCompose = function(context, frameState, layerState, opt_transform) {\\n  this.dispatchComposeEvent_(RenderEventType.POSTCOMPOSE, context, frameState, opt_transform);\\n};\\n\\n\\n/**\\n * @param {CanvasRenderingContext2D} context Context.\\n * @param {module:ol/PluggableMap~FrameState} frameState Frame state.\\n * @param {module:ol/transform~Transform=} opt_transform Transform.\\n * @protected\\n */\\nCanvasLayerRenderer.prototype.preCompose = function(context, frameState, opt_transform) {\\n  this.dispatchComposeEvent_(RenderEventType.PRECOMPOSE, context, frameState, opt_transform);\\n};\\n\\n\\n/**\\n * @param {CanvasRenderingContext2D} context Context.\\n * @param {module:ol/PluggableMap~FrameState} frameState Frame state.\\n * @param {module:ol/transform~Transform=} opt_transform Transform.\\n * @protected\\n */\\nCanvasLayerRenderer.prototype.dispatchRenderEvent = function(context, frameState, opt_transform) {\\n  this.dispatchComposeEvent_(RenderEventType.RENDER, context, frameState, opt_transform);\\n};\\n\\n\\n/**\\n * @param {module:ol/PluggableMap~FrameState} frameState Frame state.\\n * @param {number} offsetX Offset on the x-axis in view coordinates.\\n * @protected\\n * @return {!module:ol/transform~Transform} Transform.\\n */\\nCanvasLayerRenderer.prototype.getTransform = function(frameState, offsetX) {\\n  const viewState = frameState.viewState;\\n  const pixelRatio = frameState.pixelRatio;\\n  const dx1 = pixelRatio * frameState.size[0] / 2;\\n  const dy1 = pixelRatio * frameState.size[1] / 2;\\n  const sx = pixelRatio / viewState.resolution;\\n  const sy = -sx;\\n  const angle = -viewState.rotation;\\n  const dx2 = -viewState.center[0] + offsetX;\\n  const dy2 = -viewState.center[1];\\n  return composeTransform(this.transform_, dx1, dy1, sx, sy, angle, dx2, dy2);\\n};\\n\\n\\n/**\\n * @abstract\\n * @param {module:ol/PluggableMap~FrameState} frameState Frame state.\\n * @param {module:ol/layer/Layer~State} layerState Layer state.\\n * @param {CanvasRenderingContext2D} context Context.\\n */\\nCanvasLayerRenderer.prototype.composeFrame = function(frameState, layerState, context) {};\\n\\n/**\\n * @abstract\\n * @param {module:ol/PluggableMap~FrameState} frameState Frame state.\\n * @param {module:ol/layer/Layer~State} layerState Layer state.\\n * @return {boolean} whether composeFrame should be called.\\n */\\nCanvasLayerRenderer.prototype.prepareFrame = function(frameState, layerState) {};\\nexport default CanvasLayerRenderer;\\n\",\"/**\\n * @module ol/renderer/canvas/IntermediateCanvas\\n */\\nimport {inherits} from '../../index.js';\\nimport {scale as scaleCoordinate} from '../../coordinate.js';\\nimport {createCanvasContext2D} from '../../dom.js';\\nimport {containsExtent, intersects} from '../../extent.js';\\nimport {UNDEFINED} from '../../functions.js';\\nimport CanvasLayerRenderer from '../canvas/Layer.js';\\nimport {create as createTransform, apply as applyTransform} from '../../transform.js';\\n\\n/**\\n * @constructor\\n * @abstract\\n * @extends {module:ol/renderer/canvas/Layer}\\n * @param {module:ol/layer/Layer} layer Layer.\\n */\\nconst IntermediateCanvasRenderer = function(layer) {\\n\\n  CanvasLayerRenderer.call(this, layer);\\n\\n  /**\\n   * @protected\\n   * @type {module:ol/transform~Transform}\\n   */\\n  this.coordinateToCanvasPixelTransform = createTransform();\\n\\n  /**\\n   * @private\\n   * @type {CanvasRenderingContext2D}\\n   */\\n  this.hitCanvasContext_ = null;\\n\\n};\\n\\ninherits(IntermediateCanvasRenderer, CanvasLayerRenderer);\\n\\n\\n/**\\n * @inheritDoc\\n */\\nIntermediateCanvasRenderer.prototype.composeFrame = function(frameState, layerState, context) {\\n\\n  this.preCompose(context, frameState);\\n\\n  const image = this.getImage();\\n  if (image) {\\n\\n    // clipped rendering if layer extent is set\\n    const extent = layerState.extent;\\n    const clipped = extent !== undefined &&\\n        !containsExtent(extent, frameState.extent) &&\\n        intersects(extent, frameState.extent);\\n    if (clipped) {\\n      this.clip(context, frameState, /** @type {module:ol/extent~Extent} */ (extent));\\n    }\\n\\n    const imageTransform = this.getImageTransform();\\n    // for performance reasons, context.save / context.restore is not used\\n    // to save and restore the transformation matrix and the opacity.\\n    // see http://jsperf.com/context-save-restore-versus-variable\\n    const alpha = context.globalAlpha;\\n    context.globalAlpha = layerState.opacity;\\n\\n    // for performance reasons, context.setTransform is only used\\n    // when the view is rotated. see http://jsperf.com/canvas-transform\\n    const dx = imageTransform[4];\\n    const dy = imageTransform[5];\\n    const dw = image.width * imageTransform[0];\\n    const dh = image.height * imageTransform[3];\\n    context.drawImage(image, 0, 0, +image.width, +image.height,\\n      Math.round(dx), Math.round(dy), Math.round(dw), Math.round(dh));\\n    context.globalAlpha = alpha;\\n\\n    if (clipped) {\\n      context.restore();\\n    }\\n  }\\n\\n  this.postCompose(context, frameState, layerState);\\n};\\n\\n\\n/**\\n * @abstract\\n * @return {HTMLCanvasElement|HTMLVideoElement|Image} Canvas.\\n */\\nIntermediateCanvasRenderer.prototype.getImage = function() {};\\n\\n\\n/**\\n * @abstract\\n * @return {!module:ol/transform~Transform} Image transform.\\n */\\nIntermediateCanvasRenderer.prototype.getImageTransform = function() {};\\n\\n\\n/**\\n * @inheritDoc\\n */\\nIntermediateCanvasRenderer.prototype.forEachFeatureAtCoordinate = function(coordinate, frameState, hitTolerance, callback, thisArg) {\\n  const layer = this.getLayer();\\n  const source = layer.getSource();\\n  const resolution = frameState.viewState.resolution;\\n  const rotation = frameState.viewState.rotation;\\n  const skippedFeatureUids = frameState.skippedFeatureUids;\\n  return source.forEachFeatureAtCoordinate(\\n    coordinate, resolution, rotation, hitTolerance, skippedFeatureUids,\\n    /**\\n     * @param {module:ol/Feature|module:ol/render/Feature} feature Feature.\\n     * @return {?} Callback result.\\n     */\\n    function(feature) {\\n      return callback.call(thisArg, feature, layer);\\n    });\\n};\\n\\n\\n/**\\n * @inheritDoc\\n */\\nIntermediateCanvasRenderer.prototype.forEachLayerAtCoordinate = function(coordinate, frameState, callback, thisArg) {\\n  if (!this.getImage()) {\\n    return undefined;\\n  }\\n\\n  if (this.getLayer().getSource().forEachFeatureAtCoordinate !== UNDEFINED) {\\n    // for ImageCanvas sources use the original hit-detection logic,\\n    // so that for example also transparent polygons are detected\\n    return CanvasLayerRenderer.prototype.forEachLayerAtCoordinate.apply(this, arguments);\\n  } else {\\n    const pixel = applyTransform(this.coordinateToCanvasPixelTransform, coordinate.slice());\\n    scaleCoordinate(pixel, frameState.viewState.resolution / this.renderedResolution);\\n\\n    if (!this.hitCanvasContext_) {\\n      this.hitCanvasContext_ = createCanvasContext2D(1, 1);\\n    }\\n\\n    this.hitCanvasContext_.clearRect(0, 0, 1, 1);\\n    this.hitCanvasContext_.drawImage(this.getImage(), pixel[0], pixel[1], 1, 1, 0, 0, 1, 1);\\n\\n    const imageData = this.hitCanvasContext_.getImageData(0, 0, 1, 1).data;\\n    if (imageData[3] > 0) {\\n      return callback.call(thisArg, this.getLayer(),  imageData);\\n    } else {\\n      return undefined;\\n    }\\n  }\\n};\\nexport default IntermediateCanvasRenderer;\\n\",\"/**\\n * @module ol/renderer/canvas/ImageLayer\\n */\\nimport {ENABLE_RASTER_REPROJECTION} from '../../reproj/common.js';\\nimport {inherits} from '../../index.js';\\nimport ImageCanvas from '../../ImageCanvas.js';\\nimport LayerType from '../../LayerType.js';\\nimport ViewHint from '../../ViewHint.js';\\nimport {equals} from '../../array.js';\\nimport {getHeight, getIntersection, getWidth, isEmpty} from '../../extent.js';\\nimport VectorRenderType from '../../layer/VectorRenderType.js';\\nimport {assign} from '../../obj.js';\\nimport {layerRendererConstructors} from './Map.js';\\nimport IntermediateCanvasRenderer from '../canvas/IntermediateCanvas.js';\\nimport {create as createTransform, compose as composeTransform} from '../../transform.js';\\n\\n/**\\n * @constructor\\n * @extends {module:ol/renderer/canvas/IntermediateCanvas}\\n * @param {module:ol/layer/Image|module:ol/layer/Vector} imageLayer Image or vector layer.\\n * @api\\n */\\nconst CanvasImageLayerRenderer = function(imageLayer) {\\n\\n  IntermediateCanvasRenderer.call(this, imageLayer);\\n\\n  /**\\n   * @private\\n   * @type {?module:ol/ImageBase}\\n   */\\n  this.image_ = null;\\n\\n  /**\\n   * @private\\n   * @type {module:ol/transform~Transform}\\n   */\\n  this.imageTransform_ = createTransform();\\n\\n  /**\\n   * @type {!Array.<string>}\\n   */\\n  this.skippedFeatures_ = [];\\n\\n  /**\\n   * @private\\n   * @type {module:ol/renderer/canvas/VectorLayer}\\n   */\\n  this.vectorRenderer_ = null;\\n\\n  if (imageLayer.getType() === LayerType.VECTOR) {\\n    for (let i = 0, ii = layerRendererConstructors.length; i < ii; ++i) {\\n      const ctor = layerRendererConstructors[i];\\n      if (ctor !== CanvasImageLayerRenderer && ctor['handles'](imageLayer)) {\\n        this.vectorRenderer_ = new ctor(imageLayer);\\n        break;\\n      }\\n    }\\n  }\\n\\n};\\n\\ninherits(CanvasImageLayerRenderer, IntermediateCanvasRenderer);\\n\\n\\n/**\\n * Determine if this renderer handles the provided layer.\\n * @param {module:ol/layer/Layer} layer The candidate layer.\\n * @return {boolean} The renderer can render the layer.\\n */\\nCanvasImageLayerRenderer['handles'] = function(layer) {\\n  return layer.getType() === LayerType.IMAGE ||\\n    layer.getType() === LayerType.VECTOR &&\\n    /** @type {module:ol/layer/Vector} */ (layer).getRenderMode() === VectorRenderType.IMAGE;\\n};\\n\\n\\n/**\\n * Create a layer renderer.\\n * @param {module:ol/renderer/Map} mapRenderer The map renderer.\\n * @param {module:ol/layer/Layer} layer The layer to be rendererd.\\n * @return {module:ol/renderer/canvas/ImageLayer} The layer renderer.\\n */\\nCanvasImageLayerRenderer['create'] = function(mapRenderer, layer) {\\n  return new CanvasImageLayerRenderer(/** @type {module:ol/layer/Image} */ (layer));\\n};\\n\\n\\n/**\\n * @inheritDoc\\n */\\nCanvasImageLayerRenderer.prototype.disposeInternal = function() {\\n  if (this.vectorRenderer_) {\\n    this.vectorRenderer_.dispose();\\n  }\\n  IntermediateCanvasRenderer.prototype.disposeInternal.call(this);\\n};\\n\\n\\n/**\\n * @inheritDoc\\n */\\nCanvasImageLayerRenderer.prototype.getImage = function() {\\n  return !this.image_ ? null : this.image_.getImage();\\n};\\n\\n\\n/**\\n * @inheritDoc\\n */\\nCanvasImageLayerRenderer.prototype.getImageTransform = function() {\\n  return this.imageTransform_;\\n};\\n\\n\\n/**\\n * @inheritDoc\\n */\\nCanvasImageLayerRenderer.prototype.prepareFrame = function(frameState, layerState) {\\n\\n  const pixelRatio = frameState.pixelRatio;\\n  const size = frameState.size;\\n  const viewState = frameState.viewState;\\n  const viewCenter = viewState.center;\\n  const viewResolution = viewState.resolution;\\n\\n  let image;\\n  const imageLayer = /** @type {module:ol/layer/Image} */ (this.getLayer());\\n  const imageSource = imageLayer.getSource();\\n\\n  const hints = frameState.viewHints;\\n\\n  const vectorRenderer = this.vectorRenderer_;\\n  let renderedExtent = frameState.extent;\\n  if (!vectorRenderer && layerState.extent !== undefined) {\\n    renderedExtent = getIntersection(renderedExtent, layerState.extent);\\n  }\\n\\n  if (!hints[ViewHint.ANIMATING] && !hints[ViewHint.INTERACTING] &&\\n      !isEmpty(renderedExtent)) {\\n    let projection = viewState.projection;\\n    if (!ENABLE_RASTER_REPROJECTION) {\\n      const sourceProjection = imageSource.getProjection();\\n      if (sourceProjection) {\\n        projection = sourceProjection;\\n      }\\n    }\\n    let skippedFeatures = this.skippedFeatures_;\\n    if (vectorRenderer) {\\n      const context = vectorRenderer.context;\\n      const imageFrameState = /** @type {module:ol/PluggableMap~FrameState} */ (assign({}, frameState, {\\n        size: [\\n          getWidth(renderedExtent) / viewResolution,\\n          getHeight(renderedExtent) / viewResolution\\n        ],\\n        viewState: /** @type {module:ol/View~State} */ (assign({}, frameState.viewState, {\\n          rotation: 0\\n        }))\\n      }));\\n      const newSkippedFeatures = Object.keys(imageFrameState.skippedFeatureUids).sort();\\n      image = new ImageCanvas(renderedExtent, viewResolution, pixelRatio, context.canvas, function(callback) {\\n        if (vectorRenderer.prepareFrame(imageFrameState, layerState) &&\\n            (vectorRenderer.replayGroupChanged ||\\n            !equals(skippedFeatures, newSkippedFeatures))) {\\n          context.canvas.width = imageFrameState.size[0] * pixelRatio;\\n          context.canvas.height = imageFrameState.size[1] * pixelRatio;\\n          vectorRenderer.compose(context, imageFrameState, layerState);\\n          skippedFeatures = newSkippedFeatures;\\n          callback();\\n        }\\n      });\\n    } else {\\n      image = imageSource.getImage(\\n        renderedExtent, viewResolution, pixelRatio, projection);\\n    }\\n    if (image && this.loadImage(image)) {\\n      this.image_ = image;\\n      this.skippedFeatures_ = skippedFeatures;\\n    }\\n  }\\n\\n  if (this.image_) {\\n    image = this.image_;\\n    const imageExtent = image.getExtent();\\n    const imageResolution = image.getResolution();\\n    const imagePixelRatio = image.getPixelRatio();\\n    const scale = pixelRatio * imageResolution /\\n        (viewResolution * imagePixelRatio);\\n    const transform = composeTransform(this.imageTransform_,\\n      pixelRatio * size[0] / 2, pixelRatio * size[1] / 2,\\n      scale, scale,\\n      0,\\n      imagePixelRatio * (imageExtent[0] - viewCenter[0]) / imageResolution,\\n      imagePixelRatio * (viewCenter[1] - imageExtent[3]) / imageResolution);\\n    composeTransform(this.coordinateToCanvasPixelTransform,\\n      pixelRatio * size[0] / 2 - transform[4], pixelRatio * size[1] / 2 - transform[5],\\n      pixelRatio / viewResolution, -pixelRatio / viewResolution,\\n      0,\\n      -viewCenter[0], -viewCenter[1]);\\n\\n    this.renderedResolution = imageResolution * pixelRatio / imagePixelRatio;\\n  }\\n\\n  return !!this.image_;\\n};\\n\\n\\n/**\\n * @inheritDoc\\n */\\nCanvasImageLayerRenderer.prototype.forEachFeatureAtCoordinate = function(coordinate, frameState, hitTolerance, callback, thisArg) {\\n  if (this.vectorRenderer_) {\\n    return this.vectorRenderer_.forEachFeatureAtCoordinate(coordinate, frameState, hitTolerance, callback, thisArg);\\n  } else {\\n    return IntermediateCanvasRenderer.prototype.forEachFeatureAtCoordinate.call(this, coordinate, frameState, hitTolerance, callback, thisArg);\\n  }\\n};\\n\\n\\nexport default CanvasImageLayerRenderer;\\n\",\"/**\\n * @module ol/TileRange\\n */\\n/**\\n * A representation of a contiguous block of tiles.  A tile range is specified\\n * by its min/max tile coordinates and is inclusive of coordinates.\\n *\\n * @constructor\\n * @param {number} minX Minimum X.\\n * @param {number} maxX Maximum X.\\n * @param {number} minY Minimum Y.\\n * @param {number} maxY Maximum Y.\\n * @struct\\n */\\nconst TileRange = function(minX, maxX, minY, maxY) {\\n\\n  /**\\n   * @type {number}\\n   */\\n  this.minX = minX;\\n\\n  /**\\n   * @type {number}\\n   */\\n  this.maxX = maxX;\\n\\n  /**\\n   * @type {number}\\n   */\\n  this.minY = minY;\\n\\n  /**\\n   * @type {number}\\n   */\\n  this.maxY = maxY;\\n\\n};\\n\\n\\n/**\\n * @param {number} minX Minimum X.\\n * @param {number} maxX Maximum X.\\n * @param {number} minY Minimum Y.\\n * @param {number} maxY Maximum Y.\\n * @param {module:ol/TileRange=} tileRange TileRange.\\n * @return {module:ol/TileRange} Tile range.\\n */\\nexport function createOrUpdate(minX, maxX, minY, maxY, tileRange) {\\n  if (tileRange !== undefined) {\\n    tileRange.minX = minX;\\n    tileRange.maxX = maxX;\\n    tileRange.minY = minY;\\n    tileRange.maxY = maxY;\\n    return tileRange;\\n  } else {\\n    return new TileRange(minX, maxX, minY, maxY);\\n  }\\n}\\n\\n\\n/**\\n * @param {module:ol/tilecoord~TileCoord} tileCoord Tile coordinate.\\n * @return {boolean} Contains tile coordinate.\\n */\\nTileRange.prototype.contains = function(tileCoord) {\\n  return this.containsXY(tileCoord[1], tileCoord[2]);\\n};\\n\\n\\n/**\\n * @param {module:ol/TileRange} tileRange Tile range.\\n * @return {boolean} Contains.\\n */\\nTileRange.prototype.containsTileRange = function(tileRange) {\\n  return this.minX <= tileRange.minX && tileRange.maxX <= this.maxX &&\\n      this.minY <= tileRange.minY && tileRange.maxY <= this.maxY;\\n};\\n\\n\\n/**\\n * @param {number} x Tile coordinate x.\\n * @param {number} y Tile coordinate y.\\n * @return {boolean} Contains coordinate.\\n */\\nTileRange.prototype.containsXY = function(x, y) {\\n  return this.minX <= x && x <= this.maxX && this.minY <= y && y <= this.maxY;\\n};\\n\\n\\n/**\\n * @param {module:ol/TileRange} tileRange Tile range.\\n * @return {boolean} Equals.\\n */\\nTileRange.prototype.equals = function(tileRange) {\\n  return this.minX == tileRange.minX && this.minY == tileRange.minY &&\\n      this.maxX == tileRange.maxX && this.maxY == tileRange.maxY;\\n};\\n\\n\\n/**\\n * @param {module:ol/TileRange} tileRange Tile range.\\n */\\nTileRange.prototype.extend = function(tileRange) {\\n  if (tileRange.minX < this.minX) {\\n    this.minX = tileRange.minX;\\n  }\\n  if (tileRange.maxX > this.maxX) {\\n    this.maxX = tileRange.maxX;\\n  }\\n  if (tileRange.minY < this.minY) {\\n    this.minY = tileRange.minY;\\n  }\\n  if (tileRange.maxY > this.maxY) {\\n    this.maxY = tileRange.maxY;\\n  }\\n};\\n\\n\\n/**\\n * @return {number} Height.\\n */\\nTileRange.prototype.getHeight = function() {\\n  return this.maxY - this.minY + 1;\\n};\\n\\n\\n/**\\n * @return {module:ol/size~Size} Size.\\n */\\nTileRange.prototype.getSize = function() {\\n  return [this.getWidth(), this.getHeight()];\\n};\\n\\n\\n/**\\n * @return {number} Width.\\n */\\nTileRange.prototype.getWidth = function() {\\n  return this.maxX - this.minX + 1;\\n};\\n\\n\\n/**\\n * @param {module:ol/TileRange} tileRange Tile range.\\n * @return {boolean} Intersects.\\n */\\nTileRange.prototype.intersects = function(tileRange) {\\n  return this.minX <= tileRange.maxX &&\\n      this.maxX >= tileRange.minX &&\\n      this.minY <= tileRange.maxY &&\\n      this.maxY >= tileRange.minY;\\n};\\nexport default TileRange;\\n\",\"/**\\n * @module ol/renderer/canvas/TileLayer\\n */\\nimport {getUid, inherits} from '../../index.js';\\nimport LayerType from '../../LayerType.js';\\nimport TileRange from '../../TileRange.js';\\nimport TileState from '../../TileState.js';\\nimport ViewHint from '../../ViewHint.js';\\nimport {createCanvasContext2D} from '../../dom.js';\\nimport {containsExtent, createEmpty, equals, getIntersection, isEmpty} from '../../extent.js';\\nimport IntermediateCanvasRenderer from '../canvas/IntermediateCanvas.js';\\nimport {create as createTransform, compose as composeTransform} from '../../transform.js';\\n\\n/**\\n * @constructor\\n * @extends {module:ol/renderer/canvas/IntermediateCanvas}\\n * @param {module:ol/layer/Tile|module:ol/layer/VectorTile} tileLayer Tile layer.\\n * @api\\n */\\nconst CanvasTileLayerRenderer = function(tileLayer) {\\n\\n  IntermediateCanvasRenderer.call(this, tileLayer);\\n\\n  /**\\n   * @protected\\n   * @type {CanvasRenderingContext2D}\\n   */\\n  this.context = this.context === null ? null : createCanvasContext2D();\\n\\n  /**\\n   * @private\\n   * @type {number}\\n   */\\n  this.oversampling_;\\n\\n  /**\\n   * @private\\n   * @type {module:ol/extent~Extent}\\n   */\\n  this.renderedExtent_ = null;\\n\\n  /**\\n   * @protected\\n   * @type {number}\\n   */\\n  this.renderedRevision;\\n\\n  /**\\n   * @protected\\n   * @type {!Array.<module:ol/Tile>}\\n   */\\n  this.renderedTiles = [];\\n\\n  /**\\n   * @private\\n   * @type {boolean}\\n   */\\n  this.newTiles_ = false;\\n\\n  /**\\n   * @protected\\n   * @type {module:ol/extent~Extent}\\n   */\\n  this.tmpExtent = createEmpty();\\n\\n  /**\\n   * @private\\n   * @type {module:ol/TileRange}\\n   */\\n  this.tmpTileRange_ = new TileRange(0, 0, 0, 0);\\n\\n  /**\\n   * @private\\n   * @type {module:ol/transform~Transform}\\n   */\\n  this.imageTransform_ = createTransform();\\n\\n  /**\\n   * @protected\\n   * @type {number}\\n   */\\n  this.zDirection = 0;\\n\\n};\\n\\ninherits(CanvasTileLayerRenderer, IntermediateCanvasRenderer);\\n\\n\\n/**\\n * Determine if this renderer handles the provided layer.\\n * @param {module:ol/layer/Layer} layer The candidate layer.\\n * @return {boolean} The renderer can render the layer.\\n */\\nCanvasTileLayerRenderer['handles'] = function(layer) {\\n  return layer.getType() === LayerType.TILE;\\n};\\n\\n\\n/**\\n * Create a layer renderer.\\n * @param {module:ol/renderer/Map} mapRenderer The map renderer.\\n * @param {module:ol/layer/Layer} layer The layer to be rendererd.\\n * @return {module:ol/renderer/canvas/TileLayer} The layer renderer.\\n */\\nCanvasTileLayerRenderer['create'] = function(mapRenderer, layer) {\\n  return new CanvasTileLayerRenderer(/** @type {module:ol/layer/Tile} */ (layer));\\n};\\n\\n\\n/**\\n * @private\\n * @param {module:ol/Tile} tile Tile.\\n * @return {boolean} Tile is drawable.\\n */\\nCanvasTileLayerRenderer.prototype.isDrawableTile_ = function(tile) {\\n  const tileState = tile.getState();\\n  const useInterimTilesOnError = this.getLayer().getUseInterimTilesOnError();\\n  return tileState == TileState.LOADED ||\\n      tileState == TileState.EMPTY ||\\n      tileState == TileState.ERROR && !useInterimTilesOnError;\\n};\\n\\n\\n/**\\n * @param {number} z Tile coordinate z.\\n * @param {number} x Tile coordinate x.\\n * @param {number} y Tile coordinate y.\\n * @param {number} pixelRatio Pixel ratio.\\n * @param {module:ol/proj/Projection} projection Projection.\\n * @return {!module:ol/Tile} Tile.\\n */\\nCanvasTileLayerRenderer.prototype.getTile = function(z, x, y, pixelRatio, projection) {\\n  const layer = this.getLayer();\\n  const source = /** @type {module:ol/source/Tile} */ (layer.getSource());\\n  let tile = source.getTile(z, x, y, pixelRatio, projection);\\n  if (tile.getState() == TileState.ERROR) {\\n    if (!layer.getUseInterimTilesOnError()) {\\n      // When useInterimTilesOnError is false, we consider the error tile as loaded.\\n      tile.setState(TileState.LOADED);\\n    } else if (layer.getPreload() > 0) {\\n      // Preloaded tiles for lower resolutions might have finished loading.\\n      this.newTiles_ = true;\\n    }\\n  }\\n  if (!this.isDrawableTile_(tile)) {\\n    tile = tile.getInterimTile();\\n  }\\n  return tile;\\n};\\n\\n/**\\n * @inheritDoc\\n */\\nCanvasTileLayerRenderer.prototype.prepareFrame = function(frameState, layerState) {\\n\\n  const pixelRatio = frameState.pixelRatio;\\n  const size = frameState.size;\\n  const viewState = frameState.viewState;\\n  const projection = viewState.projection;\\n  const viewResolution = viewState.resolution;\\n  const viewCenter = viewState.center;\\n\\n  const tileLayer = this.getLayer();\\n  const tileSource = /** @type {module:ol/source/Tile} */ (tileLayer.getSource());\\n  const sourceRevision = tileSource.getRevision();\\n  const tileGrid = tileSource.getTileGridForProjection(projection);\\n  const z = tileGrid.getZForResolution(viewResolution, this.zDirection);\\n  const tileResolution = tileGrid.getResolution(z);\\n  let oversampling = Math.round(viewResolution / tileResolution) || 1;\\n  let extent = frameState.extent;\\n\\n  if (layerState.extent !== undefined) {\\n    extent = getIntersection(extent, layerState.extent);\\n  }\\n  if (isEmpty(extent)) {\\n    // Return false to prevent the rendering of the layer.\\n    return false;\\n  }\\n\\n  const tileRange = tileGrid.getTileRangeForExtentAndZ(extent, z);\\n  const imageExtent = tileGrid.getTileRangeExtent(z, tileRange);\\n\\n  const tilePixelRatio = tileSource.getTilePixelRatio(pixelRatio);\\n\\n  /**\\n   * @type {Object.<number, Object.<string, module:ol/Tile>>}\\n   */\\n  const tilesToDrawByZ = {};\\n  tilesToDrawByZ[z] = {};\\n\\n  const findLoadedTiles = this.createLoadedTileFinder(\\n    tileSource, projection, tilesToDrawByZ);\\n\\n  const hints = frameState.viewHints;\\n  const animatingOrInteracting = hints[ViewHint.ANIMATING] || hints[ViewHint.INTERACTING];\\n\\n  const tmpExtent = this.tmpExtent;\\n  const tmpTileRange = this.tmpTileRange_;\\n  this.newTiles_ = false;\\n  let tile, x, y;\\n  for (x = tileRange.minX; x <= tileRange.maxX; ++x) {\\n    for (y = tileRange.minY; y <= tileRange.maxY; ++y) {\\n      if (Date.now() - frameState.time > 16 && animatingOrInteracting) {\\n        continue;\\n      }\\n      tile = this.getTile(z, x, y, pixelRatio, projection);\\n      if (this.isDrawableTile_(tile)) {\\n        const uid = getUid(this);\\n        if (tile.getState() == TileState.LOADED) {\\n          tilesToDrawByZ[z][tile.tileCoord.toString()] = tile;\\n          const inTransition = tile.inTransition(uid);\\n          if (!this.newTiles_ && (inTransition || this.renderedTiles.indexOf(tile) === -1)) {\\n            this.newTiles_ = true;\\n          }\\n        }\\n        if (tile.getAlpha(uid, frameState.time) === 1) {\\n          // don't look for alt tiles if alpha is 1\\n          continue;\\n        }\\n      }\\n\\n      const childTileRange = tileGrid.getTileCoordChildTileRange(\\n        tile.tileCoord, tmpTileRange, tmpExtent);\\n      let covered = false;\\n      if (childTileRange) {\\n        covered = findLoadedTiles(z + 1, childTileRange);\\n      }\\n      if (!covered) {\\n        tileGrid.forEachTileCoordParentTileRange(\\n          tile.tileCoord, findLoadedTiles, null, tmpTileRange, tmpExtent);\\n      }\\n\\n    }\\n  }\\n\\n  const renderedResolution = tileResolution * pixelRatio / tilePixelRatio * oversampling;\\n  if (!(this.renderedResolution && Date.now() - frameState.time > 16 && animatingOrInteracting) && (\\n    this.newTiles_ ||\\n        !(this.renderedExtent_ && containsExtent(this.renderedExtent_, extent)) ||\\n        this.renderedRevision != sourceRevision ||\\n        oversampling != this.oversampling_ ||\\n        !animatingOrInteracting && renderedResolution != this.renderedResolution\\n  )) {\\n\\n    const context = this.context;\\n    if (context) {\\n      const tilePixelSize = tileSource.getTilePixelSize(z, pixelRatio, projection);\\n      const width = Math.round(tileRange.getWidth() * tilePixelSize[0] / oversampling);\\n      const height = Math.round(tileRange.getHeight() * tilePixelSize[1] / oversampling);\\n      const canvas = context.canvas;\\n      if (canvas.width != width || canvas.height != height) {\\n        this.oversampling_ = oversampling;\\n        canvas.width = width;\\n        canvas.height = height;\\n      } else {\\n        if (this.renderedExtent_ && !equals(imageExtent, this.renderedExtent_)) {\\n          context.clearRect(0, 0, width, height);\\n        }\\n        oversampling = this.oversampling_;\\n      }\\n    }\\n\\n    this.renderedTiles.length = 0;\\n    /** @type {Array.<number>} */\\n    const zs = Object.keys(tilesToDrawByZ).map(Number);\\n    zs.sort(function(a, b) {\\n      if (a === z) {\\n        return 1;\\n      } else if (b === z) {\\n        return -1;\\n      } else {\\n        return a > b ? 1 : a < b ? -1 : 0;\\n      }\\n    });\\n    let currentResolution, currentScale, currentTilePixelSize, currentZ, i, ii;\\n    let tileExtent, tileGutter, tilesToDraw, w, h;\\n    for (i = 0, ii = zs.length; i < ii; ++i) {\\n      currentZ = zs[i];\\n      currentTilePixelSize = tileSource.getTilePixelSize(currentZ, pixelRatio, projection);\\n      currentResolution = tileGrid.getResolution(currentZ);\\n      currentScale = currentResolution / tileResolution;\\n      tileGutter = tilePixelRatio * tileSource.getGutter(projection);\\n      tilesToDraw = tilesToDrawByZ[currentZ];\\n      for (const tileCoordKey in tilesToDraw) {\\n        tile = tilesToDraw[tileCoordKey];\\n        tileExtent = tileGrid.getTileCoordExtent(tile.getTileCoord(), tmpExtent);\\n        x = (tileExtent[0] - imageExtent[0]) / tileResolution * tilePixelRatio / oversampling;\\n        y = (imageExtent[3] - tileExtent[3]) / tileResolution * tilePixelRatio / oversampling;\\n        w = currentTilePixelSize[0] * currentScale / oversampling;\\n        h = currentTilePixelSize[1] * currentScale / oversampling;\\n        this.drawTileImage(tile, frameState, layerState, x, y, w, h, tileGutter, z === currentZ);\\n        this.renderedTiles.push(tile);\\n      }\\n    }\\n\\n    this.renderedRevision = sourceRevision;\\n    this.renderedResolution = tileResolution * pixelRatio / tilePixelRatio * oversampling;\\n    this.renderedExtent_ = imageExtent;\\n  }\\n\\n  const scale = this.renderedResolution / viewResolution;\\n  const transform = composeTransform(this.imageTransform_,\\n    pixelRatio * size[0] / 2, pixelRatio * size[1] / 2,\\n    scale, scale,\\n    0,\\n    (this.renderedExtent_[0] - viewCenter[0]) / this.renderedResolution * pixelRatio,\\n    (viewCenter[1] - this.renderedExtent_[3]) / this.renderedResolution * pixelRatio);\\n  composeTransform(this.coordinateToCanvasPixelTransform,\\n    pixelRatio * size[0] / 2 - transform[4], pixelRatio * size[1] / 2 - transform[5],\\n    pixelRatio / viewResolution, -pixelRatio / viewResolution,\\n    0,\\n    -viewCenter[0], -viewCenter[1]);\\n\\n\\n  this.updateUsedTiles(frameState.usedTiles, tileSource, z, tileRange);\\n  this.manageTilePyramid(frameState, tileSource, tileGrid, pixelRatio,\\n    projection, extent, z, tileLayer.getPreload());\\n  this.scheduleExpireCache(frameState, tileSource);\\n\\n  return this.renderedTiles.length > 0;\\n};\\n\\n\\n/**\\n * @param {module:ol/Tile} tile Tile.\\n * @param {module:ol/PluggableMap~FrameState} frameState Frame state.\\n * @param {module:ol/layer/Layer~State} layerState Layer state.\\n * @param {number} x Left of the tile.\\n * @param {number} y Top of the tile.\\n * @param {number} w Width of the tile.\\n * @param {number} h Height of the tile.\\n * @param {number} gutter Tile gutter.\\n * @param {boolean} transition Apply an alpha transition.\\n */\\nCanvasTileLayerRenderer.prototype.drawTileImage = function(tile, frameState, layerState, x, y, w, h, gutter, transition) {\\n  const image = tile.getImage(this.getLayer());\\n  if (!image) {\\n    return;\\n  }\\n  const uid = getUid(this);\\n  const alpha = transition ? tile.getAlpha(uid, frameState.time) : 1;\\n  if (alpha === 1 && !this.getLayer().getSource().getOpaque(frameState.viewState.projection)) {\\n    this.context.clearRect(x, y, w, h);\\n  }\\n  const alphaChanged = alpha !== this.context.globalAlpha;\\n  if (alphaChanged) {\\n    this.context.save();\\n    this.context.globalAlpha = alpha;\\n  }\\n  this.context.drawImage(image, gutter, gutter,\\n    image.width - 2 * gutter, image.height - 2 * gutter, x, y, w, h);\\n\\n  if (alphaChanged) {\\n    this.context.restore();\\n  }\\n  if (alpha !== 1) {\\n    frameState.animate = true;\\n  } else if (transition) {\\n    tile.endTransition(uid);\\n  }\\n};\\n\\n\\n/**\\n * @inheritDoc\\n */\\nCanvasTileLayerRenderer.prototype.getImage = function() {\\n  const context = this.context;\\n  return context ? context.canvas : null;\\n};\\n\\n\\n/**\\n * @function\\n * @return {module:ol/layer/Tile|module:ol/layer/VectorTile}\\n */\\nCanvasTileLayerRenderer.prototype.getLayer;\\n\\n\\n/**\\n * @inheritDoc\\n */\\nCanvasTileLayerRenderer.prototype.getImageTransform = function() {\\n  return this.imageTransform_;\\n};\\nexport default CanvasTileLayerRenderer;\\n\",\"/**\\n * @module ol/render/ReplayGroup\\n */\\n/**\\n * Base class for replay groups.\\n * @constructor\\n * @abstract\\n */\\nconst ReplayGroup = function() {};\\n\\n\\n/**\\n * @abstract\\n * @param {number|undefined} zIndex Z index.\\n * @param {module:ol/render/ReplayType} replayType Replay type.\\n * @return {module:ol/render/VectorContext} Replay.\\n */\\nReplayGroup.prototype.getReplay = function(zIndex, replayType) {};\\n\\n\\n/**\\n * @abstract\\n * @return {boolean} Is empty.\\n */\\nReplayGroup.prototype.isEmpty = function() {};\\nexport default ReplayGroup;\\n\",\"/**\\n * @module ol/render/ReplayType\\n */\\n\\n/**\\n * @enum {string}\\n */\\nexport default {\\n  CIRCLE: 'Circle',\\n  DEFAULT: 'Default',\\n  IMAGE: 'Image',\\n  LINE_STRING: 'LineString',\\n  POLYGON: 'Polygon',\\n  TEXT: 'Text'\\n};\\n\",\"/**\\n * @module ol/geom/flat/textpath\\n */\\nimport {lerp} from '../../math.js';\\n\\n\\n/**\\n * @param {Array.<number>} flatCoordinates Path to put text on.\\n * @param {number} offset Start offset of the `flatCoordinates`.\\n * @param {number} end End offset of the `flatCoordinates`.\\n * @param {number} stride Stride.\\n * @param {string} text Text to place on the path.\\n * @param {function(string):number} measure Measure function returning the\\n * width of the character passed as 1st argument.\\n * @param {number} startM m along the path where the text starts.\\n * @param {number} maxAngle Max angle between adjacent chars in radians.\\n * @return {Array.<Array.<*>>} The result array of null if `maxAngle` was\\n * exceeded. Entries of the array are x, y, anchorX, angle, chunk.\\n */\\nexport function drawTextOnPath(\\n  flatCoordinates, offset, end, stride, text, measure, startM, maxAngle) {\\n  const result = [];\\n\\n  // Keep text upright\\n  const reverse = flatCoordinates[offset] > flatCoordinates[end - stride];\\n\\n  const numChars = text.length;\\n\\n  let x1 = flatCoordinates[offset];\\n  let y1 = flatCoordinates[offset + 1];\\n  offset += stride;\\n  let x2 = flatCoordinates[offset];\\n  let y2 = flatCoordinates[offset + 1];\\n  let segmentM = 0;\\n  let segmentLength = Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));\\n\\n  let chunk = '';\\n  let chunkLength = 0;\\n  let data, index, previousAngle;\\n  for (let i = 0; i < numChars; ++i) {\\n    index = reverse ? numChars - i - 1 : i;\\n    const char = text.charAt(index);\\n    chunk = reverse ? char + chunk : chunk + char;\\n    const charLength = measure(chunk) - chunkLength;\\n    chunkLength += charLength;\\n    const charM = startM + charLength / 2;\\n    while (offset < end - stride && segmentM + segmentLength < charM) {\\n      x1 = x2;\\n      y1 = y2;\\n      offset += stride;\\n      x2 = flatCoordinates[offset];\\n      y2 = flatCoordinates[offset + 1];\\n      segmentM += segmentLength;\\n      segmentLength = Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));\\n    }\\n    const segmentPos = charM - segmentM;\\n    let angle = Math.atan2(y2 - y1, x2 - x1);\\n    if (reverse) {\\n      angle += angle > 0 ? -Math.PI : Math.PI;\\n    }\\n    if (previousAngle !== undefined) {\\n      let delta = angle - previousAngle;\\n      delta += (delta > Math.PI) ? -2 * Math.PI : (delta < -Math.PI) ? 2 * Math.PI : 0;\\n      if (Math.abs(delta) > maxAngle) {\\n        return null;\\n      }\\n    }\\n    const interpolate = segmentPos / segmentLength;\\n    const x = lerp(x1, x2, interpolate);\\n    const y = lerp(y1, y2, interpolate);\\n    if (previousAngle == angle) {\\n      if (reverse) {\\n        data[0] = x;\\n        data[1] = y;\\n        data[2] = charLength / 2;\\n      }\\n      data[4] = chunk;\\n    } else {\\n      chunk = char;\\n      chunkLength = charLength;\\n      data = [x, y, charLength / 2, angle, chunk];\\n      if (reverse) {\\n        result.unshift(data);\\n      } else {\\n        result.push(data);\\n      }\\n      previousAngle = angle;\\n    }\\n    startM += charLength;\\n  }\\n  return result;\\n}\\n\",\"/**\\n * @module ol/render/canvas/Instruction\\n */\\n\\n/**\\n * @enum {number}\\n */\\nconst Instruction = {\\n  BEGIN_GEOMETRY: 0,\\n  BEGIN_PATH: 1,\\n  CIRCLE: 2,\\n  CLOSE_PATH: 3,\\n  CUSTOM: 4,\\n  DRAW_CHARS: 5,\\n  DRAW_IMAGE: 6,\\n  END_GEOMETRY: 7,\\n  FILL: 8,\\n  MOVE_TO_LINE_TO: 9,\\n  SET_FILL_STYLE: 10,\\n  SET_STROKE_STYLE: 11,\\n  STROKE: 12\\n};\\n\\n\\n/**\\n * @type {Array.<Instruction>}\\n */\\nexport const fillInstruction = [Instruction.FILL];\\n\\n\\n/**\\n * @type {Array.<Instruction>}\\n */\\nexport const strokeInstruction = [Instruction.STROKE];\\n\\n\\n/**\\n * @type {Array.<Instruction>}\\n */\\nexport const beginPathInstruction = [Instruction.BEGIN_PATH];\\n\\n\\n/**\\n * @type {Array.<Instruction>}\\n */\\nexport const closePathInstruction = [Instruction.CLOSE_PATH];\\n\\n\\nexport default Instruction;\\n\",\"/**\\n * @module ol/render/replay\\n */\\nimport ReplayType from '../render/ReplayType.js';\\n\\n\\n/**\\n * @const\\n * @type {Array.<module:ol/render/ReplayType>}\\n */\\nexport const ORDER = [\\n  ReplayType.POLYGON,\\n  ReplayType.CIRCLE,\\n  ReplayType.LINE_STRING,\\n  ReplayType.IMAGE,\\n  ReplayType.TEXT,\\n  ReplayType.DEFAULT\\n];\\n\\n/**\\n * @const\\n * @enum {number}\\n */\\nexport const TEXT_ALIGN = {};\\nTEXT_ALIGN['left'] = 0;\\nTEXT_ALIGN['end'] = 0;\\nTEXT_ALIGN['center'] = 0.5;\\nTEXT_ALIGN['right'] = 1;\\nTEXT_ALIGN['start'] = 1;\\nTEXT_ALIGN['top'] = 0;\\nTEXT_ALIGN['middle'] = 0.5;\\nTEXT_ALIGN['hanging'] = 0.2;\\nTEXT_ALIGN['alphabetic'] = 0.8;\\nTEXT_ALIGN['ideographic'] = 0.8;\\nTEXT_ALIGN['bottom'] = 1;\\n\",\"/**\\n * @module ol/render/canvas/Replay\\n */\\nimport {getUid, inherits} from '../../index.js';\\nimport {UNDEFINED} from '../../functions.js';\\nimport {equals, reverseSubArray} from '../../array.js';\\nimport {asColorLike} from '../../colorlike.js';\\nimport {buffer, clone, coordinateRelationship, createEmpty, createOrUpdate,\\n  createOrUpdateEmpty, extend, extendCoordinate, intersects} from '../../extent.js';\\nimport Relationship from '../../extent/Relationship.js';\\nimport GeometryType from '../../geom/GeometryType.js';\\nimport {inflateCoordinates, inflateCoordinatesArray, inflateMultiCoordinatesArray} from '../../geom/flat/inflate.js';\\nimport {lineStringLength} from '../../geom/flat/length.js';\\nimport {drawTextOnPath} from '../../geom/flat/textpath.js';\\nimport {transform2D} from '../../geom/flat/transform.js';\\nimport {CANVAS_LINE_DASH} from '../../has.js';\\nimport {isEmpty} from '../../obj.js';\\nimport VectorContext from '../VectorContext.js';\\nimport {drawImage, resetTransform, defaultPadding, defaultFillStyle, defaultStrokeStyle,\\n  defaultMiterLimit, defaultLineWidth, defaultLineJoin, defaultLineDashOffset,\\n  defaultLineDash, defaultLineCap} from '../canvas.js';\\nimport CanvasInstruction from '../canvas/Instruction.js';\\nimport {TEXT_ALIGN} from '../replay.js';\\nimport {\\n  create as createTransform,\\n  compose as composeTransform,\\n  apply as applyTransform,\\n  setFromArray as transformSetFromArray\\n} from '../../transform.js';\\n\\n/**\\n * @constructor\\n * @extends {module:ol/render/VectorContext}\\n * @param {number} tolerance Tolerance.\\n * @param {module:ol/extent~Extent} maxExtent Maximum extent.\\n * @param {number} resolution Resolution.\\n * @param {number} pixelRatio Pixel ratio.\\n * @param {boolean} overlaps The replay can have overlapping geometries.\\n * @param {?} declutterTree Declutter tree.\\n * @struct\\n */\\nconst CanvasReplay = function(tolerance, maxExtent, resolution, pixelRatio, overlaps, declutterTree) {\\n  VectorContext.call(this);\\n\\n  /**\\n   * @type {?}\\n   */\\n  this.declutterTree = declutterTree;\\n\\n  /**\\n   * @protected\\n   * @type {number}\\n   */\\n  this.tolerance = tolerance;\\n\\n  /**\\n   * @protected\\n   * @const\\n   * @type {module:ol/extent~Extent}\\n   */\\n  this.maxExtent = maxExtent;\\n\\n  /**\\n   * @protected\\n   * @type {boolean}\\n   */\\n  this.overlaps = overlaps;\\n\\n  /**\\n   * @protected\\n   * @type {number}\\n   */\\n  this.pixelRatio = pixelRatio;\\n\\n  /**\\n   * @protected\\n   * @type {number}\\n   */\\n  this.maxLineWidth = 0;\\n\\n  /**\\n   * @protected\\n   * @const\\n   * @type {number}\\n   */\\n  this.resolution = resolution;\\n\\n  /**\\n   * @private\\n   * @type {boolean}\\n   */\\n  this.alignFill_;\\n\\n  /**\\n   * @private\\n   * @type {Array.<*>}\\n   */\\n  this.beginGeometryInstruction1_ = null;\\n\\n  /**\\n   * @private\\n   * @type {Array.<*>}\\n   */\\n  this.beginGeometryInstruction2_ = null;\\n\\n  /**\\n   * @private\\n   * @type {module:ol/extent~Extent}\\n   */\\n  this.bufferedMaxExtent_ = null;\\n\\n  /**\\n   * @protected\\n   * @type {Array.<*>}\\n   */\\n  this.instructions = [];\\n\\n  /**\\n   * @protected\\n   * @type {Array.<number>}\\n   */\\n  this.coordinates = [];\\n\\n  /**\\n   * @private\\n   * @type {!Object.<number,module:ol/coordinate~Coordinate|Array.<module:ol/coordinate~Coordinate>|Array.<Array.<module:ol/coordinate~Coordinate>>>}\\n   */\\n  this.coordinateCache_ = {};\\n\\n  /**\\n   * @private\\n   * @type {!module:ol/transform~Transform}\\n   */\\n  this.renderedTransform_ = createTransform();\\n\\n  /**\\n   * @protected\\n   * @type {Array.<*>}\\n   */\\n  this.hitDetectionInstructions = [];\\n\\n  /**\\n   * @private\\n   * @type {Array.<number>}\\n   */\\n  this.pixelCoordinates_ = null;\\n\\n  /**\\n   * @protected\\n   * @type {module:ol/render/canvas~FillStrokeState}\\n   */\\n  this.state = /** @type {module:ol/render/canvas~FillStrokeState} */ ({});\\n\\n  /**\\n   * @private\\n   * @type {number}\\n   */\\n  this.viewRotation_ = 0;\\n\\n};\\n\\ninherits(CanvasReplay, VectorContext);\\n\\n\\n/**\\n * @type {module:ol/extent~Extent}\\n */\\nconst tmpExtent = createEmpty();\\n\\n\\n/**\\n * @type {!module:ol/transform~Transform}\\n */\\nconst tmpTransform = createTransform();\\n\\n/**\\n * @param {CanvasRenderingContext2D} context Context.\\n * @param {module:ol/coordinate~Coordinate} p1 1st point of the background box.\\n * @param {module:ol/coordinate~Coordinate} p2 2nd point of the background box.\\n * @param {module:ol/coordinate~Coordinate} p3 3rd point of the background box.\\n * @param {module:ol/coordinate~Coordinate} p4 4th point of the background box.\\n * @param {Array.<*>} fillInstruction Fill instruction.\\n * @param {Array.<*>} strokeInstruction Stroke instruction.\\n */\\nCanvasReplay.prototype.replayTextBackground_ = function(context, p1, p2, p3, p4,\\n  fillInstruction, strokeInstruction) {\\n  context.beginPath();\\n  context.moveTo.apply(context, p1);\\n  context.lineTo.apply(context, p2);\\n  context.lineTo.apply(context, p3);\\n  context.lineTo.apply(context, p4);\\n  context.lineTo.apply(context, p1);\\n  if (fillInstruction) {\\n    this.alignFill_ = /** @type {boolean} */ (fillInstruction[2]);\\n    this.fill_(context);\\n  }\\n  if (strokeInstruction) {\\n    this.setStrokeStyle_(context, /** @type {Array.<*>} */ (strokeInstruction));\\n    context.stroke();\\n  }\\n};\\n\\n\\n/**\\n * @param {CanvasRenderingContext2D} context Context.\\n * @param {number} x X.\\n * @param {number} y Y.\\n * @param {HTMLImageElement|HTMLCanvasElement|HTMLVideoElement} image Image.\\n * @param {number} anchorX Anchor X.\\n * @param {number} anchorY Anchor Y.\\n * @param {module:ol/render/canvas~DeclutterGroup} declutterGroup Declutter group.\\n * @param {number} height Height.\\n * @param {number} opacity Opacity.\\n * @param {number} originX Origin X.\\n * @param {number} originY Origin Y.\\n * @param {number} rotation Rotation.\\n * @param {number} scale Scale.\\n * @param {boolean} snapToPixel Snap to pixel.\\n * @param {number} width Width.\\n * @param {Array.<number>} padding Padding.\\n * @param {Array.<*>} fillInstruction Fill instruction.\\n * @param {Array.<*>} strokeInstruction Stroke instruction.\\n */\\nCanvasReplay.prototype.replayImage_ = function(context, x, y, image,\\n  anchorX, anchorY, declutterGroup, height, opacity, originX, originY,\\n  rotation, scale, snapToPixel, width, padding, fillInstruction, strokeInstruction) {\\n  const fillStroke = fillInstruction || strokeInstruction;\\n  anchorX *= scale;\\n  anchorY *= scale;\\n  x -= anchorX;\\n  y -= anchorY;\\n\\n  const w = (width + originX > image.width) ? image.width - originX : width;\\n  const h = (height + originY > image.height) ? image.height - originY : height;\\n  const boxW = padding[3] + w * scale + padding[1];\\n  const boxH = padding[0] + h * scale + padding[2];\\n  const boxX = x - padding[3];\\n  const boxY = y - padding[0];\\n\\n  /** @type {module:ol/coordinate~Coordinate} */\\n  let p1;\\n  /** @type {module:ol/coordinate~Coordinate} */\\n  let p2;\\n  /** @type {module:ol/coordinate~Coordinate} */\\n  let p3;\\n  /** @type {module:ol/coordinate~Coordinate} */\\n  let p4;\\n  if (fillStroke || rotation !== 0) {\\n    p1 = [boxX, boxY];\\n    p2 = [boxX + boxW, boxY];\\n    p3 = [boxX + boxW, boxY + boxH];\\n    p4 = [boxX, boxY + boxH];\\n  }\\n\\n  let transform = null;\\n  if (rotation !== 0) {\\n    const centerX = x + anchorX;\\n    const centerY = y + anchorY;\\n    transform = composeTransform(tmpTransform, centerX, centerY, 1, 1, rotation, -centerX, -centerY);\\n\\n    createOrUpdateEmpty(tmpExtent);\\n    extendCoordinate(tmpExtent, applyTransform(tmpTransform, p1));\\n    extendCoordinate(tmpExtent, applyTransform(tmpTransform, p2));\\n    extendCoordinate(tmpExtent, applyTransform(tmpTransform, p3));\\n    extendCoordinate(tmpExtent, applyTransform(tmpTransform, p4));\\n  } else {\\n    createOrUpdate(boxX, boxY, boxX + boxW, boxY + boxH, tmpExtent);\\n  }\\n  const canvas = context.canvas;\\n  const strokePadding = strokeInstruction ? (strokeInstruction[2] * scale / 2) : 0;\\n  const intersects =\\n      tmpExtent[0] - strokePadding <= canvas.width && tmpExtent[2] + strokePadding >= 0 &&\\n      tmpExtent[1] - strokePadding <= canvas.height && tmpExtent[3] + strokePadding >= 0;\\n\\n  if (snapToPixel) {\\n    x = Math.round(x);\\n    y = Math.round(y);\\n  }\\n\\n  if (declutterGroup) {\\n    if (!intersects && declutterGroup[4] == 1) {\\n      return;\\n    }\\n    extend(declutterGroup, tmpExtent);\\n    const declutterArgs = intersects ?\\n      [context, transform ? transform.slice(0) : null, opacity, image, originX, originY, w, h, x, y, scale] :\\n      null;\\n    if (declutterArgs && fillStroke) {\\n      declutterArgs.push(fillInstruction, strokeInstruction, p1, p2, p3, p4);\\n    }\\n    declutterGroup.push(declutterArgs);\\n  } else if (intersects) {\\n    if (fillStroke) {\\n      this.replayTextBackground_(context, p1, p2, p3, p4,\\n        /** @type {Array.<*>} */ (fillInstruction),\\n        /** @type {Array.<*>} */ (strokeInstruction));\\n    }\\n    drawImage(context, transform, opacity, image, originX, originY, w, h, x, y, scale);\\n  }\\n};\\n\\n\\n/**\\n * @protected\\n * @param {Array.<number>} dashArray Dash array.\\n * @return {Array.<number>} Dash array with pixel ratio applied\\n */\\nCanvasReplay.prototype.applyPixelRatio = function(dashArray) {\\n  const pixelRatio = this.pixelRatio;\\n  return pixelRatio == 1 ? dashArray : dashArray.map(function(dash) {\\n    return dash * pixelRatio;\\n  });\\n};\\n\\n\\n/**\\n * @param {Array.<number>} flatCoordinates Flat coordinates.\\n * @param {number} offset Offset.\\n * @param {number} end End.\\n * @param {number} stride Stride.\\n * @param {boolean} closed Last input coordinate equals first.\\n * @param {boolean} skipFirst Skip first coordinate.\\n * @protected\\n * @return {number} My end.\\n */\\nCanvasReplay.prototype.appendFlatCoordinates = function(flatCoordinates, offset, end, stride, closed, skipFirst) {\\n\\n  let myEnd = this.coordinates.length;\\n  const extent = this.getBufferedMaxExtent();\\n  if (skipFirst) {\\n    offset += stride;\\n  }\\n  const lastCoord = [flatCoordinates[offset], flatCoordinates[offset + 1]];\\n  const nextCoord = [NaN, NaN];\\n  let skipped = true;\\n\\n  let i, lastRel, nextRel;\\n  for (i = offset + stride; i < end; i += stride) {\\n    nextCoord[0] = flatCoordinates[i];\\n    nextCoord[1] = flatCoordinates[i + 1];\\n    nextRel = coordinateRelationship(extent, nextCoord);\\n    if (nextRel !== lastRel) {\\n      if (skipped) {\\n        this.coordinates[myEnd++] = lastCoord[0];\\n        this.coordinates[myEnd++] = lastCoord[1];\\n      }\\n      this.coordinates[myEnd++] = nextCoord[0];\\n      this.coordinates[myEnd++] = nextCoord[1];\\n      skipped = false;\\n    } else if (nextRel === Relationship.INTERSECTING) {\\n      this.coordinates[myEnd++] = nextCoord[0];\\n      this.coordinates[myEnd++] = nextCoord[1];\\n      skipped = false;\\n    } else {\\n      skipped = true;\\n    }\\n    lastCoord[0] = nextCoord[0];\\n    lastCoord[1] = nextCoord[1];\\n    lastRel = nextRel;\\n  }\\n\\n  // Last coordinate equals first or only one point to append:\\n  if ((closed && skipped) || i === offset + stride) {\\n    this.coordinates[myEnd++] = lastCoord[0];\\n    this.coordinates[myEnd++] = lastCoord[1];\\n  }\\n  return myEnd;\\n};\\n\\n\\n/**\\n * @param {Array.<number>} flatCoordinates Flat coordinates.\\n * @param {number} offset Offset.\\n * @param {Array.<number>} ends Ends.\\n * @param {number} stride Stride.\\n * @param {Array.<number>} replayEnds Replay ends.\\n * @return {number} Offset.\\n */\\nCanvasReplay.prototype.drawCustomCoordinates_ = function(flatCoordinates, offset, ends, stride, replayEnds) {\\n  for (let i = 0, ii = ends.length; i < ii; ++i) {\\n    const end = ends[i];\\n    const replayEnd = this.appendFlatCoordinates(flatCoordinates, offset, end, stride, false, false);\\n    replayEnds.push(replayEnd);\\n    offset = end;\\n  }\\n  return offset;\\n};\\n\\n\\n/**\\n * @inheritDoc.\\n */\\nCanvasReplay.prototype.drawCustom = function(geometry, feature, renderer) {\\n  this.beginGeometry(geometry, feature);\\n  const type = geometry.getType();\\n  const stride = geometry.getStride();\\n  const replayBegin = this.coordinates.length;\\n  let flatCoordinates, replayEnd, replayEnds, replayEndss;\\n  let offset;\\n  if (type == GeometryType.MULTI_POLYGON) {\\n    geometry = /** @type {module:ol/geom/MultiPolygon} */ (geometry);\\n    flatCoordinates = geometry.getOrientedFlatCoordinates();\\n    replayEndss = [];\\n    const endss = geometry.getEndss();\\n    offset = 0;\\n    for (let i = 0, ii = endss.length; i < ii; ++i) {\\n      const myEnds = [];\\n      offset = this.drawCustomCoordinates_(flatCoordinates, offset, endss[i], stride, myEnds);\\n      replayEndss.push(myEnds);\\n    }\\n    this.instructions.push([CanvasInstruction.CUSTOM,\\n      replayBegin, replayEndss, geometry, renderer, inflateMultiCoordinatesArray]);\\n  } else if (type == GeometryType.POLYGON || type == GeometryType.MULTI_LINE_STRING) {\\n    replayEnds = [];\\n    flatCoordinates = (type == GeometryType.POLYGON) ?\\n      /** @type {module:ol/geom/Polygon} */ (geometry).getOrientedFlatCoordinates() :\\n      geometry.getFlatCoordinates();\\n    offset = this.drawCustomCoordinates_(flatCoordinates, 0,\\n      /** @type {module:ol/geom/Polygon|module:ol/geom/MultiLineString} */ (geometry).getEnds(),\\n      stride, replayEnds);\\n    this.instructions.push([CanvasInstruction.CUSTOM,\\n      replayBegin, replayEnds, geometry, renderer, inflateCoordinatesArray]);\\n  } else if (type == GeometryType.LINE_STRING || type == GeometryType.MULTI_POINT) {\\n    flatCoordinates = geometry.getFlatCoordinates();\\n    replayEnd = this.appendFlatCoordinates(\\n      flatCoordinates, 0, flatCoordinates.length, stride, false, false);\\n    this.instructions.push([CanvasInstruction.CUSTOM,\\n      replayBegin, replayEnd, geometry, renderer, inflateCoordinates]);\\n  } else if (type == GeometryType.POINT) {\\n    flatCoordinates = geometry.getFlatCoordinates();\\n    this.coordinates.push(flatCoordinates[0], flatCoordinates[1]);\\n    replayEnd = this.coordinates.length;\\n    this.instructions.push([CanvasInstruction.CUSTOM,\\n      replayBegin, replayEnd, geometry, renderer]);\\n  }\\n  this.endGeometry(geometry, feature);\\n};\\n\\n\\n/**\\n * @protected\\n * @param {module:ol/geom/Geometry|module:ol/render/Feature} geometry Geometry.\\n * @param {module:ol/Feature|module:ol/render/Feature} feature Feature.\\n */\\nCanvasReplay.prototype.beginGeometry = function(geometry, feature) {\\n  this.beginGeometryInstruction1_ = [CanvasInstruction.BEGIN_GEOMETRY, feature, 0];\\n  this.instructions.push(this.beginGeometryInstruction1_);\\n  this.beginGeometryInstruction2_ = [CanvasInstruction.BEGIN_GEOMETRY, feature, 0];\\n  this.hitDetectionInstructions.push(this.beginGeometryInstruction2_);\\n};\\n\\n\\n/**\\n * @private\\n * @param {CanvasRenderingContext2D} context Context.\\n */\\nCanvasReplay.prototype.fill_ = function(context) {\\n  if (this.alignFill_) {\\n    const origin = applyTransform(this.renderedTransform_, [0, 0]);\\n    const repeatSize = 512 * this.pixelRatio;\\n    context.translate(origin[0] % repeatSize, origin[1] % repeatSize);\\n    context.rotate(this.viewRotation_);\\n  }\\n  context.fill();\\n  if (this.alignFill_) {\\n    context.setTransform.apply(context, resetTransform);\\n  }\\n};\\n\\n\\n/**\\n * @private\\n * @param {CanvasRenderingContext2D} context Context.\\n * @param {Array.<*>} instruction Instruction.\\n */\\nCanvasReplay.prototype.setStrokeStyle_ = function(context, instruction) {\\n  context.strokeStyle = /** @type {module:ol/colorlike~ColorLike} */ (instruction[1]);\\n  context.lineWidth = /** @type {number} */ (instruction[2]);\\n  context.lineCap = /** @type {string} */ (instruction[3]);\\n  context.lineJoin = /** @type {string} */ (instruction[4]);\\n  context.miterLimit = /** @type {number} */ (instruction[5]);\\n  if (CANVAS_LINE_DASH) {\\n    context.lineDashOffset = /** @type {number} */ (instruction[7]);\\n    context.setLineDash(/** @type {Array.<number>} */ (instruction[6]));\\n  }\\n};\\n\\n\\n/**\\n * @param {module:ol/render/canvas~DeclutterGroup} declutterGroup Declutter group.\\n * @param {module:ol/Feature|module:ol/render/Feature} feature Feature.\\n */\\nCanvasReplay.prototype.renderDeclutter_ = function(declutterGroup, feature) {\\n  if (declutterGroup && declutterGroup.length > 5) {\\n    const groupCount = declutterGroup[4];\\n    if (groupCount == 1 || groupCount == declutterGroup.length - 5) {\\n      /** @type {module:ol/structs/RBush~Entry} */\\n      const box = {\\n        minX: /** @type {number} */ (declutterGroup[0]),\\n        minY: /** @type {number} */ (declutterGroup[1]),\\n        maxX: /** @type {number} */ (declutterGroup[2]),\\n        maxY: /** @type {number} */ (declutterGroup[3]),\\n        value: feature\\n      };\\n      if (!this.declutterTree.collides(box)) {\\n        this.declutterTree.insert(box);\\n        for (let j = 5, jj = declutterGroup.length; j < jj; ++j) {\\n          const declutterData = /** @type {Array} */ (declutterGroup[j]);\\n          if (declutterData) {\\n            if (declutterData.length > 11) {\\n              this.replayTextBackground_(declutterData[0],\\n                declutterData[13], declutterData[14], declutterData[15], declutterData[16],\\n                declutterData[11], declutterData[12]);\\n            }\\n            drawImage.apply(undefined, declutterData);\\n          }\\n        }\\n      }\\n      declutterGroup.length = 5;\\n      createOrUpdateEmpty(declutterGroup);\\n    }\\n  }\\n};\\n\\n\\n/**\\n * @private\\n * @param {CanvasRenderingContext2D} context Context.\\n * @param {module:ol/transform~Transform} transform Transform.\\n * @param {Object.<string, boolean>} skippedFeaturesHash Ids of features\\n *     to skip.\\n * @param {Array.<*>} instructions Instructions array.\\n * @param {function((module:ol/Feature|module:ol/render/Feature)): T|undefined}\\n *     featureCallback Feature callback.\\n * @param {module:ol/extent~Extent=} opt_hitExtent Only check features that intersect this\\n *     extent.\\n * @return {T|undefined} Callback result.\\n * @template T\\n */\\nCanvasReplay.prototype.replay_ = function(\\n  context, transform, skippedFeaturesHash,\\n  instructions, featureCallback, opt_hitExtent) {\\n  /** @type {Array.<number>} */\\n  let pixelCoordinates;\\n  if (this.pixelCoordinates_ && equals(transform, this.renderedTransform_)) {\\n    pixelCoordinates = this.pixelCoordinates_;\\n  } else {\\n    if (!this.pixelCoordinates_) {\\n      this.pixelCoordinates_ = [];\\n    }\\n    pixelCoordinates = transform2D(\\n      this.coordinates, 0, this.coordinates.length, 2,\\n      transform, this.pixelCoordinates_);\\n    transformSetFromArray(this.renderedTransform_, transform);\\n  }\\n  const skipFeatures = !isEmpty(skippedFeaturesHash);\\n  let i = 0; // instruction index\\n  const ii = instructions.length; // end of instructions\\n  let d = 0; // data index\\n  let dd; // end of per-instruction data\\n  let anchorX, anchorY, prevX, prevY, roundX, roundY, declutterGroup, image;\\n  let pendingFill = 0;\\n  let pendingStroke = 0;\\n  let lastFillInstruction = null;\\n  let lastStrokeInstruction = null;\\n  const coordinateCache = this.coordinateCache_;\\n  const viewRotation = this.viewRotation_;\\n\\n  const state = /** @type {module:ol/render~State} */ ({\\n    context: context,\\n    pixelRatio: this.pixelRatio,\\n    resolution: this.resolution,\\n    rotation: viewRotation\\n  });\\n\\n  // When the batch size gets too big, performance decreases. 200 is a good\\n  // balance between batch size and number of fill/stroke instructions.\\n  const batchSize = this.instructions != instructions || this.overlaps ? 0 : 200;\\n  let /** @type {module:ol/Feature|module:ol/render/Feature} */ feature;\\n  let x, y;\\n  while (i < ii) {\\n    const instruction = instructions[i];\\n    const type = /** @type {module:ol/render/canvas/Instruction} */ (instruction[0]);\\n    switch (type) {\\n      case CanvasInstruction.BEGIN_GEOMETRY:\\n        feature = /** @type {module:ol/Feature|module:ol/render/Feature} */ (instruction[1]);\\n        if ((skipFeatures &&\\n            skippedFeaturesHash[getUid(feature).toString()]) ||\\n            !feature.getGeometry()) {\\n          i = /** @type {number} */ (instruction[2]);\\n        } else if (opt_hitExtent !== undefined && !intersects(\\n          opt_hitExtent, feature.getGeometry().getExtent())) {\\n          i = /** @type {number} */ (instruction[2]) + 1;\\n        } else {\\n          ++i;\\n        }\\n        break;\\n      case CanvasInstruction.BEGIN_PATH:\\n        if (pendingFill > batchSize) {\\n          this.fill_(context);\\n          pendingFill = 0;\\n        }\\n        if (pendingStroke > batchSize) {\\n          context.stroke();\\n          pendingStroke = 0;\\n        }\\n        if (!pendingFill && !pendingStroke) {\\n          context.beginPath();\\n          prevX = prevY = NaN;\\n        }\\n        ++i;\\n        break;\\n      case CanvasInstruction.CIRCLE:\\n        d = /** @type {number} */ (instruction[1]);\\n        const x1 = pixelCoordinates[d];\\n        const y1 = pixelCoordinates[d + 1];\\n        const x2 = pixelCoordinates[d + 2];\\n        const y2 = pixelCoordinates[d + 3];\\n        const dx = x2 - x1;\\n        const dy = y2 - y1;\\n        const r = Math.sqrt(dx * dx + dy * dy);\\n        context.moveTo(x1 + r, y1);\\n        context.arc(x1, y1, r, 0, 2 * Math.PI, true);\\n        ++i;\\n        break;\\n      case CanvasInstruction.CLOSE_PATH:\\n        context.closePath();\\n        ++i;\\n        break;\\n      case CanvasInstruction.CUSTOM:\\n        d = /** @type {number} */ (instruction[1]);\\n        dd = instruction[2];\\n        const geometry = /** @type {module:ol/geom/SimpleGeometry} */ (instruction[3]);\\n        const renderer = instruction[4];\\n        const fn = instruction.length == 6 ? instruction[5] : undefined;\\n        state.geometry = geometry;\\n        state.feature = feature;\\n        if (!(i in coordinateCache)) {\\n          coordinateCache[i] = [];\\n        }\\n        const coords = coordinateCache[i];\\n        if (fn) {\\n          fn(pixelCoordinates, d, dd, 2, coords);\\n        } else {\\n          coords[0] = pixelCoordinates[d];\\n          coords[1] = pixelCoordinates[d + 1];\\n          coords.length = 2;\\n        }\\n        renderer(coords, state);\\n        ++i;\\n        break;\\n      case CanvasInstruction.DRAW_IMAGE:\\n        d = /** @type {number} */ (instruction[1]);\\n        dd = /** @type {number} */ (instruction[2]);\\n        image =  /** @type {HTMLCanvasElement|HTMLVideoElement|Image} */\\n            (instruction[3]);\\n        // Remaining arguments in DRAW_IMAGE are in alphabetical order\\n        anchorX = /** @type {number} */ (instruction[4]);\\n        anchorY = /** @type {number} */ (instruction[5]);\\n        declutterGroup = featureCallback ? null : /** @type {module:ol/render/canvas~DeclutterGroup} */ (instruction[6]);\\n        const height = /** @type {number} */ (instruction[7]);\\n        const opacity = /** @type {number} */ (instruction[8]);\\n        const originX = /** @type {number} */ (instruction[9]);\\n        const originY = /** @type {number} */ (instruction[10]);\\n        const rotateWithView = /** @type {boolean} */ (instruction[11]);\\n        let rotation = /** @type {number} */ (instruction[12]);\\n        const scale = /** @type {number} */ (instruction[13]);\\n        const snapToPixel = /** @type {boolean} */ (instruction[14]);\\n        const width = /** @type {number} */ (instruction[15]);\\n\\n        let padding, backgroundFill, backgroundStroke;\\n        if (instruction.length > 16) {\\n          padding = /** @type {Array.<number>} */ (instruction[16]);\\n          backgroundFill = /** @type {boolean} */ (instruction[17]);\\n          backgroundStroke = /** @type {boolean} */ (instruction[18]);\\n        } else {\\n          padding = defaultPadding;\\n          backgroundFill = backgroundStroke = false;\\n        }\\n\\n        if (rotateWithView) {\\n          rotation += viewRotation;\\n        }\\n        for (; d < dd; d += 2) {\\n          this.replayImage_(context,\\n            pixelCoordinates[d], pixelCoordinates[d + 1], image, anchorX, anchorY,\\n            declutterGroup, height, opacity, originX, originY, rotation, scale,\\n            snapToPixel, width, padding,\\n            backgroundFill ? /** @type {Array.<*>} */ (lastFillInstruction) : null,\\n            backgroundStroke ? /** @type {Array.<*>} */ (lastStrokeInstruction) : null);\\n        }\\n        this.renderDeclutter_(declutterGroup, feature);\\n        ++i;\\n        break;\\n      case CanvasInstruction.DRAW_CHARS:\\n        const begin = /** @type {number} */ (instruction[1]);\\n        const end = /** @type {number} */ (instruction[2]);\\n        const baseline = /** @type {number} */ (instruction[3]);\\n        declutterGroup = featureCallback ? null : /** @type {module:ol/render/canvas~DeclutterGroup} */ (instruction[4]);\\n        const overflow = /** @type {number} */ (instruction[5]);\\n        const fillKey = /** @type {string} */ (instruction[6]);\\n        const maxAngle = /** @type {number} */ (instruction[7]);\\n        const measure = /** @type {function(string):number} */ (instruction[8]);\\n        const offsetY = /** @type {number} */ (instruction[9]);\\n        const strokeKey = /** @type {string} */ (instruction[10]);\\n        const strokeWidth =  /** @type {number} */ (instruction[11]);\\n        const text = /** @type {string} */ (instruction[12]);\\n        const textKey = /** @type {string} */ (instruction[13]);\\n        const textScale = /** @type {number} */ (instruction[14]);\\n\\n        const pathLength = lineStringLength(pixelCoordinates, begin, end, 2);\\n        const textLength = measure(text);\\n        if (overflow || textLength <= pathLength) {\\n          const textAlign = /** @type {module:ol~render} */ (this).textStates[textKey].textAlign;\\n          const startM = (pathLength - textLength) * TEXT_ALIGN[textAlign];\\n          const parts = drawTextOnPath(\\n            pixelCoordinates, begin, end, 2, text, measure, startM, maxAngle);\\n          if (parts) {\\n            let c, cc, chars, label, part;\\n            if (strokeKey) {\\n              for (c = 0, cc = parts.length; c < cc; ++c) {\\n                part = parts[c]; // x, y, anchorX, rotation, chunk\\n                chars = /** @type {string} */ (part[4]);\\n                label = /** @type {module:ol~render} */ (this).getImage(chars, textKey, '', strokeKey);\\n                anchorX = /** @type {number} */ (part[2]) + strokeWidth;\\n                anchorY = baseline * label.height + (0.5 - baseline) * 2 * strokeWidth - offsetY;\\n                this.replayImage_(context,\\n                  /** @type {number} */ (part[0]), /** @type {number} */ (part[1]), label,\\n                  anchorX, anchorY, declutterGroup, label.height, 1, 0, 0,\\n                  /** @type {number} */ (part[3]), textScale, false, label.width,\\n                  defaultPadding, null, null);\\n              }\\n            }\\n            if (fillKey) {\\n              for (c = 0, cc = parts.length; c < cc; ++c) {\\n                part = parts[c]; // x, y, anchorX, rotation, chunk\\n                chars = /** @type {string} */ (part[4]);\\n                label = /** @type {module:ol~render} */ (this).getImage(chars, textKey, fillKey, '');\\n                anchorX = /** @type {number} */ (part[2]);\\n                anchorY = baseline * label.height - offsetY;\\n                this.replayImage_(context,\\n                  /** @type {number} */ (part[0]), /** @type {number} */ (part[1]), label,\\n                  anchorX, anchorY, declutterGroup, label.height, 1, 0, 0,\\n                  /** @type {number} */ (part[3]), textScale, false, label.width,\\n                  defaultPadding, null, null);\\n              }\\n            }\\n          }\\n        }\\n        this.renderDeclutter_(declutterGroup, feature);\\n        ++i;\\n        break;\\n      case CanvasInstruction.END_GEOMETRY:\\n        if (featureCallback !== undefined) {\\n          feature = /** @type {module:ol/Feature|module:ol/render/Feature} */ (instruction[1]);\\n          const result = featureCallback(feature);\\n          if (result) {\\n            return result;\\n          }\\n        }\\n        ++i;\\n        break;\\n      case CanvasInstruction.FILL:\\n        if (batchSize) {\\n          pendingFill++;\\n        } else {\\n          this.fill_(context);\\n        }\\n        ++i;\\n        break;\\n      case CanvasInstruction.MOVE_TO_LINE_TO:\\n        d = /** @type {number} */ (instruction[1]);\\n        dd = /** @type {number} */ (instruction[2]);\\n        x = pixelCoordinates[d];\\n        y = pixelCoordinates[d + 1];\\n        roundX = (x + 0.5) | 0;\\n        roundY = (y + 0.5) | 0;\\n        if (roundX !== prevX || roundY !== prevY) {\\n          context.moveTo(x, y);\\n          prevX = roundX;\\n          prevY = roundY;\\n        }\\n        for (d += 2; d < dd; d += 2) {\\n          x = pixelCoordinates[d];\\n          y = pixelCoordinates[d + 1];\\n          roundX = (x + 0.5) | 0;\\n          roundY = (y + 0.5) | 0;\\n          if (d == dd - 2 || roundX !== prevX || roundY !== prevY) {\\n            context.lineTo(x, y);\\n            prevX = roundX;\\n            prevY = roundY;\\n          }\\n        }\\n        ++i;\\n        break;\\n      case CanvasInstruction.SET_FILL_STYLE:\\n        lastFillInstruction = instruction;\\n        this.alignFill_ = instruction[2];\\n\\n        if (pendingFill) {\\n          this.fill_(context);\\n          pendingFill = 0;\\n          if (pendingStroke) {\\n            context.stroke();\\n            pendingStroke = 0;\\n          }\\n        }\\n\\n        context.fillStyle = /** @type {module:ol/colorlike~ColorLike} */ (instruction[1]);\\n        ++i;\\n        break;\\n      case CanvasInstruction.SET_STROKE_STYLE:\\n        lastStrokeInstruction = instruction;\\n        if (pendingStroke) {\\n          context.stroke();\\n          pendingStroke = 0;\\n        }\\n        this.setStrokeStyle_(context, /** @type {Array.<*>} */ (instruction));\\n        ++i;\\n        break;\\n      case CanvasInstruction.STROKE:\\n        if (batchSize) {\\n          pendingStroke++;\\n        } else {\\n          context.stroke();\\n        }\\n        ++i;\\n        break;\\n      default:\\n        ++i; // consume the instruction anyway, to avoid an infinite loop\\n        break;\\n    }\\n  }\\n  if (pendingFill) {\\n    this.fill_(context);\\n  }\\n  if (pendingStroke) {\\n    context.stroke();\\n  }\\n  return undefined;\\n};\\n\\n\\n/**\\n * @param {CanvasRenderingContext2D} context Context.\\n * @param {module:ol/transform~Transform} transform Transform.\\n * @param {number} viewRotation View rotation.\\n * @param {Object.<string, boolean>} skippedFeaturesHash Ids of features\\n *     to skip.\\n */\\nCanvasReplay.prototype.replay = function(\\n  context, transform, viewRotation, skippedFeaturesHash) {\\n  this.viewRotation_ = viewRotation;\\n  this.replay_(context, transform,\\n    skippedFeaturesHash, this.instructions, undefined, undefined);\\n};\\n\\n\\n/**\\n * @param {CanvasRenderingContext2D} context Context.\\n * @param {module:ol/transform~Transform} transform Transform.\\n * @param {number} viewRotation View rotation.\\n * @param {Object.<string, boolean>} skippedFeaturesHash Ids of features\\n *     to skip.\\n * @param {function((module:ol/Feature|module:ol/render/Feature)): T=} opt_featureCallback\\n *     Feature callback.\\n * @param {module:ol/extent~Extent=} opt_hitExtent Only check features that intersect this\\n *     extent.\\n * @return {T|undefined} Callback result.\\n * @template T\\n */\\nCanvasReplay.prototype.replayHitDetection = function(\\n  context, transform, viewRotation, skippedFeaturesHash,\\n  opt_featureCallback, opt_hitExtent) {\\n  this.viewRotation_ = viewRotation;\\n  return this.replay_(context, transform, skippedFeaturesHash,\\n    this.hitDetectionInstructions, opt_featureCallback, opt_hitExtent);\\n};\\n\\n\\n/**\\n * Reverse the hit detection instructions.\\n */\\nCanvasReplay.prototype.reverseHitDetectionInstructions = function() {\\n  const hitDetectionInstructions = this.hitDetectionInstructions;\\n  // step 1 - reverse array\\n  hitDetectionInstructions.reverse();\\n  // step 2 - reverse instructions within geometry blocks\\n  let i;\\n  const n = hitDetectionInstructions.length;\\n  let instruction;\\n  let type;\\n  let begin = -1;\\n  for (i = 0; i < n; ++i) {\\n    instruction = hitDetectionInstructions[i];\\n    type = /** @type {module:ol/render/canvas/Instruction} */ (instruction[0]);\\n    if (type == CanvasInstruction.END_GEOMETRY) {\\n      begin = i;\\n    } else if (type == CanvasInstruction.BEGIN_GEOMETRY) {\\n      instruction[2] = i;\\n      reverseSubArray(this.hitDetectionInstructions, begin, i);\\n      begin = -1;\\n    }\\n  }\\n};\\n\\n\\n/**\\n * @inheritDoc\\n */\\nCanvasReplay.prototype.setFillStrokeStyle = function(fillStyle, strokeStyle) {\\n  const state = this.state;\\n  if (fillStyle) {\\n    const fillStyleColor = fillStyle.getColor();\\n    state.fillStyle = asColorLike(fillStyleColor ?\\n      fillStyleColor : defaultFillStyle);\\n  } else {\\n    state.fillStyle = undefined;\\n  }\\n  if (strokeStyle) {\\n    const strokeStyleColor = strokeStyle.getColor();\\n    state.strokeStyle = asColorLike(strokeStyleColor ?\\n      strokeStyleColor : defaultStrokeStyle);\\n    const strokeStyleLineCap = strokeStyle.getLineCap();\\n    state.lineCap = strokeStyleLineCap !== undefined ?\\n      strokeStyleLineCap : defaultLineCap;\\n    const strokeStyleLineDash = strokeStyle.getLineDash();\\n    state.lineDash = strokeStyleLineDash ?\\n      strokeStyleLineDash.slice() : defaultLineDash;\\n    const strokeStyleLineDashOffset = strokeStyle.getLineDashOffset();\\n    state.lineDashOffset = strokeStyleLineDashOffset ?\\n      strokeStyleLineDashOffset : defaultLineDashOffset;\\n    const strokeStyleLineJoin = strokeStyle.getLineJoin();\\n    state.lineJoin = strokeStyleLineJoin !== undefined ?\\n      strokeStyleLineJoin : defaultLineJoin;\\n    const strokeStyleWidth = strokeStyle.getWidth();\\n    state.lineWidth = strokeStyleWidth !== undefined ?\\n      strokeStyleWidth : defaultLineWidth;\\n    const strokeStyleMiterLimit = strokeStyle.getMiterLimit();\\n    state.miterLimit = strokeStyleMiterLimit !== undefined ?\\n      strokeStyleMiterLimit : defaultMiterLimit;\\n\\n    if (state.lineWidth > this.maxLineWidth) {\\n      this.maxLineWidth = state.lineWidth;\\n      // invalidate the buffered max extent cache\\n      this.bufferedMaxExtent_ = null;\\n    }\\n  } else {\\n    state.strokeStyle = undefined;\\n    state.lineCap = undefined;\\n    state.lineDash = null;\\n    state.lineDashOffset = undefined;\\n    state.lineJoin = undefined;\\n    state.lineWidth = undefined;\\n    state.miterLimit = undefined;\\n  }\\n};\\n\\n\\n/**\\n * @param {module:ol/render/canvas~FillStrokeState} state State.\\n * @param {module:ol/geom/Geometry|module:ol/render/Feature} geometry Geometry.\\n * @return {Array.<*>} Fill instruction.\\n */\\nCanvasReplay.prototype.createFill = function(state, geometry) {\\n  const fillStyle = state.fillStyle;\\n  const fillInstruction = [CanvasInstruction.SET_FILL_STYLE, fillStyle];\\n  if (typeof fillStyle !== 'string') {\\n    // Fill is a pattern or gradient - align it!\\n    fillInstruction.push(true);\\n  }\\n  return fillInstruction;\\n};\\n\\n\\n/**\\n * @param {module:ol/render/canvas~FillStrokeState} state State.\\n */\\nCanvasReplay.prototype.applyStroke = function(state) {\\n  this.instructions.push(this.createStroke(state));\\n};\\n\\n\\n/**\\n * @param {module:ol/render/canvas~FillStrokeState} state State.\\n * @return {Array.<*>} Stroke instruction.\\n */\\nCanvasReplay.prototype.createStroke = function(state) {\\n  return [\\n    CanvasInstruction.SET_STROKE_STYLE,\\n    state.strokeStyle, state.lineWidth * this.pixelRatio, state.lineCap,\\n    state.lineJoin, state.miterLimit,\\n    this.applyPixelRatio(state.lineDash), state.lineDashOffset * this.pixelRatio\\n  ];\\n};\\n\\n\\n/**\\n * @param {module:ol/render/canvas~FillStrokeState} state State.\\n * @param {function(this:module:ol/render/canvas/Replay, module:ol/render/canvas~FillStrokeState, (module:ol/geom/Geometry|module:ol/render/Feature)):Array.<*>} createFill Create fill.\\n * @param {module:ol/geom/Geometry|module:ol/render/Feature} geometry Geometry.\\n */\\nCanvasReplay.prototype.updateFillStyle = function(state, createFill, geometry) {\\n  const fillStyle = state.fillStyle;\\n  if (typeof fillStyle !== 'string' || state.currentFillStyle != fillStyle) {\\n    if (fillStyle !== undefined) {\\n      this.instructions.push(createFill.call(this, state, geometry));\\n    }\\n    state.currentFillStyle = fillStyle;\\n  }\\n};\\n\\n\\n/**\\n * @param {module:ol/render/canvas~FillStrokeState} state State.\\n * @param {function(this:module:ol/render/canvas/Replay, module:ol/render/canvas~FillStrokeState)} applyStroke Apply stroke.\\n */\\nCanvasReplay.prototype.updateStrokeStyle = function(state, applyStroke) {\\n  const strokeStyle = state.strokeStyle;\\n  const lineCap = state.lineCap;\\n  const lineDash = state.lineDash;\\n  const lineDashOffset = state.lineDashOffset;\\n  const lineJoin = state.lineJoin;\\n  const lineWidth = state.lineWidth;\\n  const miterLimit = state.miterLimit;\\n  if (state.currentStrokeStyle != strokeStyle ||\\n      state.currentLineCap != lineCap ||\\n      (lineDash != state.currentLineDash && !equals(state.currentLineDash, lineDash)) ||\\n      state.currentLineDashOffset != lineDashOffset ||\\n      state.currentLineJoin != lineJoin ||\\n      state.currentLineWidth != lineWidth ||\\n      state.currentMiterLimit != miterLimit) {\\n    if (strokeStyle !== undefined) {\\n      applyStroke.call(this, state);\\n    }\\n    state.currentStrokeStyle = strokeStyle;\\n    state.currentLineCap = lineCap;\\n    state.currentLineDash = lineDash;\\n    state.currentLineDashOffset = lineDashOffset;\\n    state.currentLineJoin = lineJoin;\\n    state.currentLineWidth = lineWidth;\\n    state.currentMiterLimit = miterLimit;\\n  }\\n};\\n\\n\\n/**\\n * @param {module:ol/geom/Geometry|module:ol/render/Feature} geometry Geometry.\\n * @param {module:ol/Feature|module:ol/render/Feature} feature Feature.\\n */\\nCanvasReplay.prototype.endGeometry = function(geometry, feature) {\\n  this.beginGeometryInstruction1_[2] = this.instructions.length;\\n  this.beginGeometryInstruction1_ = null;\\n  this.beginGeometryInstruction2_[2] = this.hitDetectionInstructions.length;\\n  this.beginGeometryInstruction2_ = null;\\n  const endGeometryInstruction = [CanvasInstruction.END_GEOMETRY, feature];\\n  this.instructions.push(endGeometryInstruction);\\n  this.hitDetectionInstructions.push(endGeometryInstruction);\\n};\\n\\n\\n/**\\n * FIXME empty description for jsdoc\\n */\\nCanvasReplay.prototype.finish = UNDEFINED;\\n\\n\\n/**\\n * Get the buffered rendering extent.  Rendering will be clipped to the extent\\n * provided to the constructor.  To account for symbolizers that may intersect\\n * this extent, we calculate a buffered extent (e.g. based on stroke width).\\n * @return {module:ol/extent~Extent} The buffered rendering extent.\\n * @protected\\n */\\nCanvasReplay.prototype.getBufferedMaxExtent = function() {\\n  if (!this.bufferedMaxExtent_) {\\n    this.bufferedMaxExtent_ = clone(this.maxExtent);\\n    if (this.maxLineWidth > 0) {\\n      const width = this.resolution * (this.maxLineWidth + 1) / 2;\\n      buffer(this.bufferedMaxExtent_, width, this.bufferedMaxExtent_);\\n    }\\n  }\\n  return this.bufferedMaxExtent_;\\n};\\nexport default CanvasReplay;\\n\",\"/**\\n * @module ol/render/canvas/ImageReplay\\n */\\nimport {inherits} from '../../index.js';\\nimport CanvasInstruction from '../canvas/Instruction.js';\\nimport CanvasReplay from '../canvas/Replay.js';\\n\\n/**\\n * @constructor\\n * @extends {module:ol/render/canvas/Replay}\\n * @param {number} tolerance Tolerance.\\n * @param {module:ol/extent~Extent} maxExtent Maximum extent.\\n * @param {number} resolution Resolution.\\n * @param {number} pixelRatio Pixel ratio.\\n * @param {boolean} overlaps The replay can have overlapping geometries.\\n * @param {?} declutterTree Declutter tree.\\n * @struct\\n */\\nconst CanvasImageReplay = function(\\n  tolerance, maxExtent, resolution, pixelRatio, overlaps, declutterTree) {\\n  CanvasReplay.call(this,\\n    tolerance, maxExtent, resolution, pixelRatio, overlaps, declutterTree);\\n\\n  /**\\n   * @private\\n   * @type {module:ol/render/canvas~DeclutterGroup}\\n   */\\n  this.declutterGroup_ = null;\\n\\n  /**\\n   * @private\\n   * @type {HTMLCanvasElement|HTMLVideoElement|Image}\\n   */\\n  this.hitDetectionImage_ = null;\\n\\n  /**\\n   * @private\\n   * @type {HTMLCanvasElement|HTMLVideoElement|Image}\\n   */\\n  this.image_ = null;\\n\\n  /**\\n   * @private\\n   * @type {number|undefined}\\n   */\\n  this.anchorX_ = undefined;\\n\\n  /**\\n   * @private\\n   * @type {number|undefined}\\n   */\\n  this.anchorY_ = undefined;\\n\\n  /**\\n   * @private\\n   * @type {number|undefined}\\n   */\\n  this.height_ = undefined;\\n\\n  /**\\n   * @private\\n   * @type {number|undefined}\\n   */\\n  this.opacity_ = undefined;\\n\\n  /**\\n   * @private\\n   * @type {number|undefined}\\n   */\\n  this.originX_ = undefined;\\n\\n  /**\\n   * @private\\n   * @type {number|undefined}\\n   */\\n  this.originY_ = undefined;\\n\\n  /**\\n   * @private\\n   * @type {boolean|undefined}\\n   */\\n  this.rotateWithView_ = undefined;\\n\\n  /**\\n   * @private\\n   * @type {number|undefined}\\n   */\\n  this.rotation_ = undefined;\\n\\n  /**\\n   * @private\\n   * @type {number|undefined}\\n   */\\n  this.scale_ = undefined;\\n\\n  /**\\n   * @private\\n   * @type {boolean|undefined}\\n   */\\n  this.snapToPixel_ = undefined;\\n\\n  /**\\n   * @private\\n   * @type {number|undefined}\\n   */\\n  this.width_ = undefined;\\n\\n};\\n\\ninherits(CanvasImageReplay, CanvasReplay);\\n\\n\\n/**\\n * @param {Array.<number>} flatCoordinates Flat coordinates.\\n * @param {number} offset Offset.\\n * @param {number} end End.\\n * @param {number} stride Stride.\\n * @private\\n * @return {number} My end.\\n */\\nCanvasImageReplay.prototype.drawCoordinates_ = function(flatCoordinates, offset, end, stride) {\\n  return this.appendFlatCoordinates(flatCoordinates, offset, end, stride, false, false);\\n};\\n\\n\\n/**\\n * @inheritDoc\\n */\\nCanvasImageReplay.prototype.drawPoint = function(pointGeometry, feature) {\\n  if (!this.image_) {\\n    return;\\n  }\\n  this.beginGeometry(pointGeometry, feature);\\n  const flatCoordinates = pointGeometry.getFlatCoordinates();\\n  const stride = pointGeometry.getStride();\\n  const myBegin = this.coordinates.length;\\n  const myEnd = this.drawCoordinates_(flatCoordinates, 0, flatCoordinates.length, stride);\\n  this.instructions.push([\\n    CanvasInstruction.DRAW_IMAGE, myBegin, myEnd, this.image_,\\n    // Remaining arguments to DRAW_IMAGE are in alphabetical order\\n    this.anchorX_, this.anchorY_, this.declutterGroup_, this.height_, this.opacity_,\\n    this.originX_, this.originY_, this.rotateWithView_, this.rotation_,\\n    this.scale_ * this.pixelRatio, this.snapToPixel_, this.width_\\n  ]);\\n  this.hitDetectionInstructions.push([\\n    CanvasInstruction.DRAW_IMAGE, myBegin, myEnd, this.hitDetectionImage_,\\n    // Remaining arguments to DRAW_IMAGE are in alphabetical order\\n    this.anchorX_, this.anchorY_, this.declutterGroup_, this.height_, this.opacity_,\\n    this.originX_, this.originY_, this.rotateWithView_, this.rotation_,\\n    this.scale_, this.snapToPixel_, this.width_\\n  ]);\\n  this.endGeometry(pointGeometry, feature);\\n};\\n\\n\\n/**\\n * @inheritDoc\\n */\\nCanvasImageReplay.prototype.drawMultiPoint = function(multiPointGeometry, feature) {\\n  if (!this.image_) {\\n    return;\\n  }\\n  this.beginGeometry(multiPointGeometry, feature);\\n  const flatCoordinates = multiPointGeometry.getFlatCoordinates();\\n  const stride = multiPointGeometry.getStride();\\n  const myBegin = this.coordinates.length;\\n  const myEnd = this.drawCoordinates_(\\n    flatCoordinates, 0, flatCoordinates.length, stride);\\n  this.instructions.push([\\n    CanvasInstruction.DRAW_IMAGE, myBegin, myEnd, this.image_,\\n    // Remaining arguments to DRAW_IMAGE are in alphabetical order\\n    this.anchorX_, this.anchorY_, this.declutterGroup_, this.height_, this.opacity_,\\n    this.originX_, this.originY_, this.rotateWithView_, this.rotation_,\\n    this.scale_ * this.pixelRatio, this.snapToPixel_, this.width_\\n  ]);\\n  this.hitDetectionInstructions.push([\\n    CanvasInstruction.DRAW_IMAGE, myBegin, myEnd, this.hitDetectionImage_,\\n    // Remaining arguments to DRAW_IMAGE are in alphabetical order\\n    this.anchorX_, this.anchorY_, this.declutterGroup_, this.height_, this.opacity_,\\n    this.originX_, this.originY_, this.rotateWithView_, this.rotation_,\\n    this.scale_, this.snapToPixel_, this.width_\\n  ]);\\n  this.endGeometry(multiPointGeometry, feature);\\n};\\n\\n\\n/**\\n * @inheritDoc\\n */\\nCanvasImageReplay.prototype.finish = function() {\\n  this.reverseHitDetectionInstructions();\\n  // FIXME this doesn't really protect us against further calls to draw*Geometry\\n  this.anchorX_ = undefined;\\n  this.anchorY_ = undefined;\\n  this.hitDetectionImage_ = null;\\n  this.image_ = null;\\n  this.height_ = undefined;\\n  this.scale_ = undefined;\\n  this.opacity_ = undefined;\\n  this.originX_ = undefined;\\n  this.originY_ = undefined;\\n  this.rotateWithView_ = undefined;\\n  this.rotation_ = undefined;\\n  this.snapToPixel_ = undefined;\\n  this.width_ = undefined;\\n};\\n\\n\\n/**\\n * @inheritDoc\\n */\\nCanvasImageReplay.prototype.setImageStyle = function(imageStyle, declutterGroup) {\\n  const anchor = imageStyle.getAnchor();\\n  const size = imageStyle.getSize();\\n  const hitDetectionImage = imageStyle.getHitDetectionImage(1);\\n  const image = imageStyle.getImage(1);\\n  const origin = imageStyle.getOrigin();\\n  this.anchorX_ = anchor[0];\\n  this.anchorY_ = anchor[1];\\n  this.declutterGroup_ = /** @type {module:ol/render/canvas~DeclutterGroup} */ (declutterGroup);\\n  this.hitDetectionImage_ = hitDetectionImage;\\n  this.image_ = image;\\n  this.height_ = size[1];\\n  this.opacity_ = imageStyle.getOpacity();\\n  this.originX_ = origin[0];\\n  this.originY_ = origin[1];\\n  this.rotateWithView_ = imageStyle.getRotateWithView();\\n  this.rotation_ = imageStyle.getRotation();\\n  this.scale_ = imageStyle.getScale();\\n  this.snapToPixel_ = imageStyle.getSnapToPixel();\\n  this.width_ = size[0];\\n};\\nexport default CanvasImageReplay;\\n\",\"/**\\n * @module ol/render/canvas/LineStringReplay\\n */\\nimport {inherits} from '../../index.js';\\nimport CanvasInstruction, {strokeInstruction, beginPathInstruction} from '../canvas/Instruction.js';\\nimport CanvasReplay from '../canvas/Replay.js';\\n\\n/**\\n * @constructor\\n * @extends {module:ol/render/canvas/Replay}\\n * @param {number} tolerance Tolerance.\\n * @param {module:ol/extent~Extent} maxExtent Maximum extent.\\n * @param {number} resolution Resolution.\\n * @param {number} pixelRatio Pixel ratio.\\n * @param {boolean} overlaps The replay can have overlapping geometries.\\n * @param {?} declutterTree Declutter tree.\\n * @struct\\n */\\nconst CanvasLineStringReplay = function(\\n  tolerance, maxExtent, resolution, pixelRatio, overlaps, declutterTree) {\\n  CanvasReplay.call(this,\\n    tolerance, maxExtent, resolution, pixelRatio, overlaps, declutterTree);\\n};\\n\\ninherits(CanvasLineStringReplay, CanvasReplay);\\n\\n\\n/**\\n * @param {Array.<number>} flatCoordinates Flat coordinates.\\n * @param {number} offset Offset.\\n * @param {number} end End.\\n * @param {number} stride Stride.\\n * @private\\n * @return {number} end.\\n */\\nCanvasLineStringReplay.prototype.drawFlatCoordinates_ = function(flatCoordinates, offset, end, stride) {\\n  const myBegin = this.coordinates.length;\\n  const myEnd = this.appendFlatCoordinates(\\n    flatCoordinates, offset, end, stride, false, false);\\n  const moveToLineToInstruction = [CanvasInstruction.MOVE_TO_LINE_TO, myBegin, myEnd];\\n  this.instructions.push(moveToLineToInstruction);\\n  this.hitDetectionInstructions.push(moveToLineToInstruction);\\n  return end;\\n};\\n\\n\\n/**\\n * @inheritDoc\\n */\\nCanvasLineStringReplay.prototype.drawLineString = function(lineStringGeometry, feature) {\\n  const state = this.state;\\n  const strokeStyle = state.strokeStyle;\\n  const lineWidth = state.lineWidth;\\n  if (strokeStyle === undefined || lineWidth === undefined) {\\n    return;\\n  }\\n  this.updateStrokeStyle(state, this.applyStroke);\\n  this.beginGeometry(lineStringGeometry, feature);\\n  this.hitDetectionInstructions.push([\\n    CanvasInstruction.SET_STROKE_STYLE,\\n    state.strokeStyle, state.lineWidth, state.lineCap, state.lineJoin,\\n    state.miterLimit, state.lineDash, state.lineDashOffset\\n  ], beginPathInstruction);\\n  const flatCoordinates = lineStringGeometry.getFlatCoordinates();\\n  const stride = lineStringGeometry.getStride();\\n  this.drawFlatCoordinates_(flatCoordinates, 0, flatCoordinates.length, stride);\\n  this.hitDetectionInstructions.push(strokeInstruction);\\n  this.endGeometry(lineStringGeometry, feature);\\n};\\n\\n\\n/**\\n * @inheritDoc\\n */\\nCanvasLineStringReplay.prototype.drawMultiLineString = function(multiLineStringGeometry, feature) {\\n  const state = this.state;\\n  const strokeStyle = state.strokeStyle;\\n  const lineWidth = state.lineWidth;\\n  if (strokeStyle === undefined || lineWidth === undefined) {\\n    return;\\n  }\\n  this.updateStrokeStyle(state, this.applyStroke);\\n  this.beginGeometry(multiLineStringGeometry, feature);\\n  this.hitDetectionInstructions.push([\\n    CanvasInstruction.SET_STROKE_STYLE,\\n    state.strokeStyle, state.lineWidth, state.lineCap, state.lineJoin,\\n    state.miterLimit, state.lineDash, state.lineDashOffset\\n  ], beginPathInstruction);\\n  const ends = multiLineStringGeometry.getEnds();\\n  const flatCoordinates = multiLineStringGeometry.getFlatCoordinates();\\n  const stride = multiLineStringGeometry.getStride();\\n  let offset = 0;\\n  for (let i = 0, ii = ends.length; i < ii; ++i) {\\n    offset = this.drawFlatCoordinates_(flatCoordinates, offset, ends[i], stride);\\n  }\\n  this.hitDetectionInstructions.push(strokeInstruction);\\n  this.endGeometry(multiLineStringGeometry, feature);\\n};\\n\\n\\n/**\\n * @inheritDoc\\n */\\nCanvasLineStringReplay.prototype.finish = function() {\\n  const state = this.state;\\n  if (state.lastStroke != undefined && state.lastStroke != this.coordinates.length) {\\n    this.instructions.push(strokeInstruction);\\n  }\\n  this.reverseHitDetectionInstructions();\\n  this.state = null;\\n};\\n\\n\\n/**\\n * @inheritDoc.\\n */\\nCanvasLineStringReplay.prototype.applyStroke = function(state) {\\n  if (state.lastStroke != undefined && state.lastStroke != this.coordinates.length) {\\n    this.instructions.push(strokeInstruction);\\n    state.lastStroke = this.coordinates.length;\\n  }\\n  state.lastStroke = 0;\\n  CanvasReplay.prototype.applyStroke.call(this, state);\\n  this.instructions.push(beginPathInstruction);\\n};\\nexport default CanvasLineStringReplay;\\n\",\"/**\\n * @module ol/render/canvas/PolygonReplay\\n */\\nimport {inherits} from '../../index.js';\\nimport {asString} from '../../color.js';\\nimport {snap} from '../../geom/flat/simplify.js';\\nimport {defaultFillStyle} from '../canvas.js';\\nimport CanvasInstruction, {\\n  fillInstruction, strokeInstruction, beginPathInstruction, closePathInstruction\\n} from '../canvas/Instruction.js';\\nimport CanvasReplay from '../canvas/Replay.js';\\n\\n\\n/**\\n * @constructor\\n * @extends {module:ol/render/canvas/Replay}\\n * @param {number} tolerance Tolerance.\\n * @param {module:ol/extent~Extent} maxExtent Maximum extent.\\n * @param {number} resolution Resolution.\\n * @param {number} pixelRatio Pixel ratio.\\n * @param {boolean} overlaps The replay can have overlapping geometries.\\n * @param {?} declutterTree Declutter tree.\\n * @struct\\n */\\nconst CanvasPolygonReplay = function(\\n  tolerance, maxExtent, resolution, pixelRatio, overlaps, declutterTree) {\\n  CanvasReplay.call(this,\\n    tolerance, maxExtent, resolution, pixelRatio, overlaps, declutterTree);\\n};\\n\\ninherits(CanvasPolygonReplay, CanvasReplay);\\n\\n\\n/**\\n * @param {Array.<number>} flatCoordinates Flat coordinates.\\n * @param {number} offset Offset.\\n * @param {Array.<number>} ends Ends.\\n * @param {number} stride Stride.\\n * @private\\n * @return {number} End.\\n */\\nCanvasPolygonReplay.prototype.drawFlatCoordinatess_ = function(flatCoordinates, offset, ends, stride) {\\n  const state = this.state;\\n  const fill = state.fillStyle !== undefined;\\n  const stroke = state.strokeStyle != undefined;\\n  const numEnds = ends.length;\\n  this.instructions.push(beginPathInstruction);\\n  this.hitDetectionInstructions.push(beginPathInstruction);\\n  for (let i = 0; i < numEnds; ++i) {\\n    const end = ends[i];\\n    const myBegin = this.coordinates.length;\\n    const myEnd = this.appendFlatCoordinates(flatCoordinates, offset, end, stride, true, !stroke);\\n    const moveToLineToInstruction = [CanvasInstruction.MOVE_TO_LINE_TO, myBegin, myEnd];\\n    this.instructions.push(moveToLineToInstruction);\\n    this.hitDetectionInstructions.push(moveToLineToInstruction);\\n    if (stroke) {\\n      // Performance optimization: only call closePath() when we have a stroke.\\n      // Otherwise the ring is closed already (see appendFlatCoordinates above).\\n      this.instructions.push(closePathInstruction);\\n      this.hitDetectionInstructions.push(closePathInstruction);\\n    }\\n    offset = end;\\n  }\\n  this.hitDetectionInstructions.push(fillInstruction);\\n  if (fill) {\\n    this.instructions.push(fillInstruction);\\n  }\\n  if (stroke) {\\n    this.instructions.push(strokeInstruction);\\n    this.hitDetectionInstructions.push(strokeInstruction);\\n  }\\n  return offset;\\n};\\n\\n\\n/**\\n * @inheritDoc\\n */\\nCanvasPolygonReplay.prototype.drawCircle = function(circleGeometry, feature) {\\n  const state = this.state;\\n  const fillStyle = state.fillStyle;\\n  const strokeStyle = state.strokeStyle;\\n  if (fillStyle === undefined && strokeStyle === undefined) {\\n    return;\\n  }\\n  this.setFillStrokeStyles_(circleGeometry);\\n  this.beginGeometry(circleGeometry, feature);\\n  // always fill the circle for hit detection\\n  this.hitDetectionInstructions.push([\\n    CanvasInstruction.SET_FILL_STYLE,\\n    asString(defaultFillStyle)\\n  ]);\\n  if (state.strokeStyle !== undefined) {\\n    this.hitDetectionInstructions.push([\\n      CanvasInstruction.SET_STROKE_STYLE,\\n      state.strokeStyle, state.lineWidth, state.lineCap, state.lineJoin,\\n      state.miterLimit, state.lineDash, state.lineDashOffset\\n    ]);\\n  }\\n  const flatCoordinates = circleGeometry.getFlatCoordinates();\\n  const stride = circleGeometry.getStride();\\n  const myBegin = this.coordinates.length;\\n  this.appendFlatCoordinates(\\n    flatCoordinates, 0, flatCoordinates.length, stride, false, false);\\n  const circleInstruction = [CanvasInstruction.CIRCLE, myBegin];\\n  this.instructions.push(beginPathInstruction, circleInstruction);\\n  this.hitDetectionInstructions.push(beginPathInstruction, circleInstruction);\\n  this.hitDetectionInstructions.push(fillInstruction);\\n  if (state.fillStyle !== undefined) {\\n    this.instructions.push(fillInstruction);\\n  }\\n  if (state.strokeStyle !== undefined) {\\n    this.instructions.push(strokeInstruction);\\n    this.hitDetectionInstructions.push(strokeInstruction);\\n  }\\n  this.endGeometry(circleGeometry, feature);\\n};\\n\\n\\n/**\\n * @inheritDoc\\n */\\nCanvasPolygonReplay.prototype.drawPolygon = function(polygonGeometry, feature) {\\n  const state = this.state;\\n  this.setFillStrokeStyles_(polygonGeometry);\\n  this.beginGeometry(polygonGeometry, feature);\\n  // always fill the polygon for hit detection\\n  this.hitDetectionInstructions.push([\\n    CanvasInstruction.SET_FILL_STYLE,\\n    asString(defaultFillStyle)]\\n  );\\n  if (state.strokeStyle !== undefined) {\\n    this.hitDetectionInstructions.push([\\n      CanvasInstruction.SET_STROKE_STYLE,\\n      state.strokeStyle, state.lineWidth, state.lineCap, state.lineJoin,\\n      state.miterLimit, state.lineDash, state.lineDashOffset\\n    ]);\\n  }\\n  const ends = polygonGeometry.getEnds();\\n  const flatCoordinates = polygonGeometry.getOrientedFlatCoordinates();\\n  const stride = polygonGeometry.getStride();\\n  this.drawFlatCoordinatess_(flatCoordinates, 0, ends, stride);\\n  this.endGeometry(polygonGeometry, feature);\\n};\\n\\n\\n/**\\n * @inheritDoc\\n */\\nCanvasPolygonReplay.prototype.drawMultiPolygon = function(multiPolygonGeometry, feature) {\\n  const state = this.state;\\n  const fillStyle = state.fillStyle;\\n  const strokeStyle = state.strokeStyle;\\n  if (fillStyle === undefined && strokeStyle === undefined) {\\n    return;\\n  }\\n  this.setFillStrokeStyles_(multiPolygonGeometry);\\n  this.beginGeometry(multiPolygonGeometry, feature);\\n  // always fill the multi-polygon for hit detection\\n  this.hitDetectionInstructions.push([\\n    CanvasInstruction.SET_FILL_STYLE,\\n    asString(defaultFillStyle)\\n  ]);\\n  if (state.strokeStyle !== undefined) {\\n    this.hitDetectionInstructions.push([\\n      CanvasInstruction.SET_STROKE_STYLE,\\n      state.strokeStyle, state.lineWidth, state.lineCap, state.lineJoin,\\n      state.miterLimit, state.lineDash, state.lineDashOffset\\n    ]);\\n  }\\n  const endss = multiPolygonGeometry.getEndss();\\n  const flatCoordinates = multiPolygonGeometry.getOrientedFlatCoordinates();\\n  const stride = multiPolygonGeometry.getStride();\\n  let offset = 0;\\n  for (let i = 0, ii = endss.length; i < ii; ++i) {\\n    offset = this.drawFlatCoordinatess_(flatCoordinates, offset, endss[i], stride);\\n  }\\n  this.endGeometry(multiPolygonGeometry, feature);\\n};\\n\\n\\n/**\\n * @inheritDoc\\n */\\nCanvasPolygonReplay.prototype.finish = function() {\\n  this.reverseHitDetectionInstructions();\\n  this.state = null;\\n  // We want to preserve topology when drawing polygons.  Polygons are\\n  // simplified using quantization and point elimination. However, we might\\n  // have received a mix of quantized and non-quantized geometries, so ensure\\n  // that all are quantized by quantizing all coordinates in the batch.\\n  const tolerance = this.tolerance;\\n  if (tolerance !== 0) {\\n    const coordinates = this.coordinates;\\n    for (let i = 0, ii = coordinates.length; i < ii; ++i) {\\n      coordinates[i] = snap(coordinates[i], tolerance);\\n    }\\n  }\\n};\\n\\n\\n/**\\n * @private\\n * @param {module:ol/geom/Geometry|module:ol/render/Feature} geometry Geometry.\\n */\\nCanvasPolygonReplay.prototype.setFillStrokeStyles_ = function(geometry) {\\n  const state = this.state;\\n  const fillStyle = state.fillStyle;\\n  if (fillStyle !== undefined) {\\n    this.updateFillStyle(state, this.createFill, geometry);\\n  }\\n  if (state.strokeStyle !== undefined) {\\n    this.updateStrokeStyle(state, this.applyStroke);\\n  }\\n};\\nexport default CanvasPolygonReplay;\\n\",\"/**\\n * @module ol/geom/flat/straightchunk\\n */\\n\\n\\n/**\\n * @param {number} maxAngle Maximum acceptable angle delta between segments.\\n * @param {Array.<number>} flatCoordinates Flat coordinates.\\n * @param {number} offset Offset.\\n * @param {number} end End.\\n * @param {number} stride Stride.\\n * @return {Array.<number>} Start and end of the first suitable chunk of the\\n * given `flatCoordinates`.\\n */\\nexport function matchingChunk(maxAngle, flatCoordinates, offset, end, stride) {\\n  let chunkStart = offset;\\n  let chunkEnd = offset;\\n  let chunkM = 0;\\n  let m = 0;\\n  let start = offset;\\n  let acos, i, m12, m23, x1, y1, x12, y12, x23, y23;\\n  for (i = offset; i < end; i += stride) {\\n    const x2 = flatCoordinates[i];\\n    const y2 = flatCoordinates[i + 1];\\n    if (x1 !== undefined) {\\n      x23 = x2 - x1;\\n      y23 = y2 - y1;\\n      m23 = Math.sqrt(x23 * x23 + y23 * y23);\\n      if (x12 !== undefined) {\\n        m += m12;\\n        acos = Math.acos((x12 * x23 + y12 * y23) / (m12 * m23));\\n        if (acos > maxAngle) {\\n          if (m > chunkM) {\\n            chunkM = m;\\n            chunkStart = start;\\n            chunkEnd = i;\\n          }\\n          m = 0;\\n          start = i - stride;\\n        }\\n      }\\n      m12 = m23;\\n      x12 = x23;\\n      y12 = y23;\\n    }\\n    x1 = x2;\\n    y1 = y2;\\n  }\\n  m += m23;\\n  return m > chunkM ? [start, i] : [chunkStart, chunkEnd];\\n}\\n\",\"/**\\n * @module ol/style/TextPlacement\\n */\\n\\n/**\\n * Text placement. One of `'point'`, `'line'`. Default is `'point'`. Note that\\n * `'line'` requires the underlying geometry to be a {@link module:ol/geom/LineString~LineString},\\n * {@link module:ol/geom/Polygon~Polygon}, {@link module:ol/geom/MultiLineString~MultiLineString} or\\n * {@link module:ol/geom/MultiPolygon~MultiPolygon}.\\n * @enum {string}\\n */\\nexport default {\\n  POINT: 'point',\\n  LINE: 'line'\\n};\\n\",\"/**\\n * @module ol/render/canvas/TextReplay\\n */\\nimport {getUid, inherits} from '../../index.js';\\nimport {asColorLike} from '../../colorlike.js';\\nimport {createCanvasContext2D} from '../../dom.js';\\nimport {intersects} from '../../extent.js';\\nimport {matchingChunk} from '../../geom/flat/straightchunk.js';\\nimport GeometryType from '../../geom/GeometryType.js';\\nimport {CANVAS_LINE_DASH} from '../../has.js';\\nimport {labelCache, measureTextWidth, defaultTextAlign, measureTextHeight, defaultPadding, defaultLineCap, defaultLineDashOffset, defaultLineDash, defaultLineJoin, defaultFillStyle, checkFont, defaultFont, defaultLineWidth, defaultMiterLimit, defaultStrokeStyle, defaultTextBaseline} from '../canvas.js';\\nimport CanvasInstruction from '../canvas/Instruction.js';\\nimport CanvasReplay from '../canvas/Replay.js';\\nimport {TEXT_ALIGN} from '../replay.js';\\nimport TextPlacement from '../../style/TextPlacement.js';\\n\\n/**\\n * @constructor\\n * @extends {module:ol/render/canvas/Replay}\\n * @param {number} tolerance Tolerance.\\n * @param {module:ol/extent~Extent} maxExtent Maximum extent.\\n * @param {number} resolution Resolution.\\n * @param {number} pixelRatio Pixel ratio.\\n * @param {boolean} overlaps The replay can have overlapping geometries.\\n * @param {?} declutterTree Declutter tree.\\n * @struct\\n */\\nconst CanvasTextReplay = function(\\n  tolerance, maxExtent, resolution, pixelRatio, overlaps, declutterTree) {\\n  CanvasReplay.call(this,\\n    tolerance, maxExtent, resolution, pixelRatio, overlaps, declutterTree);\\n\\n  /**\\n   * @private\\n   * @type {module:ol/render/canvas~DeclutterGroup}\\n   */\\n  this.declutterGroup_;\\n\\n  /**\\n   * @private\\n   * @type {Array.<HTMLCanvasElement>}\\n   */\\n  this.labels_ = null;\\n\\n  /**\\n   * @private\\n   * @type {string}\\n   */\\n  this.text_ = '';\\n\\n  /**\\n   * @private\\n   * @type {number}\\n   */\\n  this.textOffsetX_ = 0;\\n\\n  /**\\n   * @private\\n   * @type {number}\\n   */\\n  this.textOffsetY_ = 0;\\n\\n  /**\\n   * @private\\n   * @type {boolean|undefined}\\n   */\\n  this.textRotateWithView_ = undefined;\\n\\n  /**\\n   * @private\\n   * @type {number}\\n   */\\n  this.textRotation_ = 0;\\n\\n  /**\\n   * @private\\n   * @type {?module:ol/render/canvas~FillState}\\n   */\\n  this.textFillState_ = null;\\n\\n  /**\\n   * @type {!Object.<string, module:ol/render/canvas~FillState>}\\n   */\\n  this.fillStates = {};\\n\\n  /**\\n   * @private\\n   * @type {?module:ol/render/canvas~StrokeState}\\n   */\\n  this.textStrokeState_ = null;\\n\\n  /**\\n   * @type {!Object.<string, module:ol/render/canvas~StrokeState>}\\n   */\\n  this.strokeStates = {};\\n\\n  /**\\n   * @private\\n   * @type {module:ol/render/canvas~TextState}\\n   */\\n  this.textState_ = /** @type {module:ol/render/canvas~TextState} */ ({});\\n\\n  /**\\n   * @type {!Object.<string, module:ol/render/canvas~TextState>}\\n   */\\n  this.textStates = {};\\n\\n  /**\\n   * @private\\n   * @type {string}\\n   */\\n  this.textKey_ = '';\\n\\n  /**\\n   * @private\\n   * @type {string}\\n   */\\n  this.fillKey_ = '';\\n\\n  /**\\n   * @private\\n   * @type {string}\\n   */\\n  this.strokeKey_ = '';\\n\\n  /**\\n   * @private\\n   * @type {Object.<string, Object.<string, number>>}\\n   */\\n  this.widths_ = {};\\n\\n  labelCache.prune();\\n\\n};\\n\\ninherits(CanvasTextReplay, CanvasReplay);\\n\\n\\n/**\\n * @param {string} font Font to use for measuring.\\n * @param {Array.<string>} lines Lines to measure.\\n * @param {Array.<number>} widths Array will be populated with the widths of\\n * each line.\\n * @return {number} Width of the whole text.\\n */\\nexport function measureTextWidths(font, lines, widths) {\\n  const numLines = lines.length;\\n  let width = 0;\\n  for (let i = 0; i < numLines; ++i) {\\n    const currentWidth = measureTextWidth(font, lines[i]);\\n    width = Math.max(width, currentWidth);\\n    widths.push(currentWidth);\\n  }\\n  return width;\\n}\\n\\n\\n/**\\n * @inheritDoc\\n */\\nCanvasTextReplay.prototype.drawText = function(geometry, feature) {\\n  const fillState = this.textFillState_;\\n  const strokeState = this.textStrokeState_;\\n  const textState = this.textState_;\\n  if (this.text_ === '' || !textState || (!fillState && !strokeState)) {\\n    return;\\n  }\\n\\n  let begin = this.coordinates.length;\\n\\n  const geometryType = geometry.getType();\\n  let flatCoordinates = null;\\n  let end = 2;\\n  let stride = 2;\\n  let i, ii;\\n\\n  if (textState.placement === TextPlacement.LINE) {\\n    if (!intersects(this.getBufferedMaxExtent(), geometry.getExtent())) {\\n      return;\\n    }\\n    let ends;\\n    flatCoordinates = geometry.getFlatCoordinates();\\n    stride = geometry.getStride();\\n    if (geometryType == GeometryType.LINE_STRING) {\\n      ends = [flatCoordinates.length];\\n    } else if (geometryType == GeometryType.MULTI_LINE_STRING) {\\n      ends = geometry.getEnds();\\n    } else if (geometryType == GeometryType.POLYGON) {\\n      ends = geometry.getEnds().slice(0, 1);\\n    } else if (geometryType == GeometryType.MULTI_POLYGON) {\\n      const endss = geometry.getEndss();\\n      ends = [];\\n      for (i = 0, ii = endss.length; i < ii; ++i) {\\n        ends.push(endss[i][0]);\\n      }\\n    }\\n    this.beginGeometry(geometry, feature);\\n    const textAlign = textState.textAlign;\\n    let flatOffset = 0;\\n    let flatEnd;\\n    for (let o = 0, oo = ends.length; o < oo; ++o) {\\n      if (textAlign == undefined) {\\n        const range = matchingChunk(textState.maxAngle, flatCoordinates, flatOffset, ends[o], stride);\\n        flatOffset = range[0];\\n        flatEnd = range[1];\\n      } else {\\n        flatEnd = ends[o];\\n      }\\n      for (i = flatOffset; i < flatEnd; i += stride) {\\n        this.coordinates.push(flatCoordinates[i], flatCoordinates[i + 1]);\\n      }\\n      end = this.coordinates.length;\\n      flatOffset = ends[o];\\n      this.drawChars_(begin, end, this.declutterGroup_);\\n      begin = end;\\n    }\\n    this.endGeometry(geometry, feature);\\n\\n  } else {\\n    const label = this.getImage(this.text_, this.textKey_, this.fillKey_, this.strokeKey_);\\n    const width = label.width / this.pixelRatio;\\n    switch (geometryType) {\\n      case GeometryType.POINT:\\n      case GeometryType.MULTI_POINT:\\n        flatCoordinates = geometry.getFlatCoordinates();\\n        end = flatCoordinates.length;\\n        break;\\n      case GeometryType.LINE_STRING:\\n        flatCoordinates = /** @type {module:ol/geom/LineString} */ (geometry).getFlatMidpoint();\\n        break;\\n      case GeometryType.CIRCLE:\\n        flatCoordinates = /** @type {module:ol/geom/Circle} */ (geometry).getCenter();\\n        break;\\n      case GeometryType.MULTI_LINE_STRING:\\n        flatCoordinates = /** @type {module:ol/geom/MultiLineString} */ (geometry).getFlatMidpoints();\\n        end = flatCoordinates.length;\\n        break;\\n      case GeometryType.POLYGON:\\n        flatCoordinates = /** @type {module:ol/geom/Polygon} */ (geometry).getFlatInteriorPoint();\\n        if (!textState.overflow && flatCoordinates[2] / this.resolution < width) {\\n          return;\\n        }\\n        stride = 3;\\n        break;\\n      case GeometryType.MULTI_POLYGON:\\n        const interiorPoints = /** @type {module:ol/geom/MultiPolygon} */ (geometry).getFlatInteriorPoints();\\n        flatCoordinates = [];\\n        for (i = 0, ii = interiorPoints.length; i < ii; i += 3) {\\n          if (textState.overflow || interiorPoints[i + 2] / this.resolution >= width) {\\n            flatCoordinates.push(interiorPoints[i], interiorPoints[i + 1]);\\n          }\\n        }\\n        end = flatCoordinates.length;\\n        if (end == 0) {\\n          return;\\n        }\\n        break;\\n      default:\\n    }\\n    end = this.appendFlatCoordinates(flatCoordinates, 0, end, stride, false, false);\\n    if (textState.backgroundFill || textState.backgroundStroke) {\\n      this.setFillStrokeStyle(textState.backgroundFill, textState.backgroundStroke);\\n      if (textState.backgroundFill) {\\n        this.updateFillStyle(this.state, this.createFill, geometry);\\n        this.hitDetectionInstructions.push(this.createFill(this.state, geometry));\\n      }\\n      if (textState.backgroundStroke) {\\n        this.updateStrokeStyle(this.state, this.applyStroke);\\n        this.hitDetectionInstructions.push(this.createStroke(this.state));\\n      }\\n    }\\n    this.beginGeometry(geometry, feature);\\n    this.drawTextImage_(label, begin, end);\\n    this.endGeometry(geometry, feature);\\n  }\\n};\\n\\n\\n/**\\n * @param {string} text Text.\\n * @param {string} textKey Text style key.\\n * @param {string} fillKey Fill style key.\\n * @param {string} strokeKey Stroke style key.\\n * @return {HTMLCanvasElement} Image.\\n */\\nCanvasTextReplay.prototype.getImage = function(text, textKey, fillKey, strokeKey) {\\n  let label;\\n  const key = strokeKey + textKey + text + fillKey + this.pixelRatio;\\n\\n  if (!labelCache.containsKey(key)) {\\n    const strokeState = strokeKey ? this.strokeStates[strokeKey] || this.textStrokeState_ : null;\\n    const fillState = fillKey ? this.fillStates[fillKey] || this.textFillState_ : null;\\n    const textState = this.textStates[textKey] || this.textState_;\\n    const pixelRatio = this.pixelRatio;\\n    const scale = textState.scale * pixelRatio;\\n    const align =  TEXT_ALIGN[textState.textAlign || defaultTextAlign];\\n    const strokeWidth = strokeKey && strokeState.lineWidth ? strokeState.lineWidth : 0;\\n\\n    const lines = text.split('\\\\n');\\n    const numLines = lines.length;\\n    const widths = [];\\n    const width = measureTextWidths(textState.font, lines, widths);\\n    const lineHeight = measureTextHeight(textState.font);\\n    const height = lineHeight * numLines;\\n    const renderWidth = (width + strokeWidth);\\n    const context = createCanvasContext2D(\\n      Math.ceil(renderWidth * scale),\\n      Math.ceil((height + strokeWidth) * scale));\\n    label = context.canvas;\\n    labelCache.set(key, label);\\n    if (scale != 1) {\\n      context.scale(scale, scale);\\n    }\\n    context.font = textState.font;\\n    if (strokeKey) {\\n      context.strokeStyle = strokeState.strokeStyle;\\n      context.lineWidth = strokeWidth;\\n      context.lineCap = strokeState.lineCap;\\n      context.lineJoin = strokeState.lineJoin;\\n      context.miterLimit = strokeState.miterLimit;\\n      if (CANVAS_LINE_DASH && strokeState.lineDash.length) {\\n        context.setLineDash(strokeState.lineDash);\\n        context.lineDashOffset = strokeState.lineDashOffset;\\n      }\\n    }\\n    if (fillKey) {\\n      context.fillStyle = fillState.fillStyle;\\n    }\\n    context.textBaseline = 'middle';\\n    context.textAlign = 'center';\\n    const leftRight = (0.5 - align);\\n    const x = align * label.width / scale + leftRight * strokeWidth;\\n    let i;\\n    if (strokeKey) {\\n      for (i = 0; i < numLines; ++i) {\\n        context.strokeText(lines[i], x + leftRight * widths[i], 0.5 * (strokeWidth + lineHeight) + i * lineHeight);\\n      }\\n    }\\n    if (fillKey) {\\n      for (i = 0; i < numLines; ++i) {\\n        context.fillText(lines[i], x + leftRight * widths[i], 0.5 * (strokeWidth + lineHeight) + i * lineHeight);\\n      }\\n    }\\n  }\\n  return labelCache.get(key);\\n};\\n\\n\\n/**\\n * @private\\n * @param {HTMLCanvasElement} label Label.\\n * @param {number} begin Begin.\\n * @param {number} end End.\\n */\\nCanvasTextReplay.prototype.drawTextImage_ = function(label, begin, end) {\\n  const textState = this.textState_;\\n  const strokeState = this.textStrokeState_;\\n  const pixelRatio = this.pixelRatio;\\n  const align = TEXT_ALIGN[textState.textAlign || defaultTextAlign];\\n  const baseline = TEXT_ALIGN[textState.textBaseline];\\n  const strokeWidth = strokeState && strokeState.lineWidth ? strokeState.lineWidth : 0;\\n\\n  const anchorX = align * label.width / pixelRatio + 2 * (0.5 - align) * strokeWidth;\\n  const anchorY = baseline * label.height / pixelRatio + 2 * (0.5 - baseline) * strokeWidth;\\n  this.instructions.push([CanvasInstruction.DRAW_IMAGE, begin, end,\\n    label, (anchorX - this.textOffsetX_) * pixelRatio, (anchorY - this.textOffsetY_) * pixelRatio,\\n    this.declutterGroup_, label.height, 1, 0, 0, this.textRotateWithView_, this.textRotation_,\\n    1, true, label.width,\\n    textState.padding == defaultPadding ?\\n      defaultPadding : textState.padding.map(function(p) {\\n        return p * pixelRatio;\\n      }),\\n    !!textState.backgroundFill, !!textState.backgroundStroke\\n  ]);\\n  this.hitDetectionInstructions.push([CanvasInstruction.DRAW_IMAGE, begin, end,\\n    label, (anchorX - this.textOffsetX_) * pixelRatio, (anchorY - this.textOffsetY_) * pixelRatio,\\n    this.declutterGroup_, label.height, 1, 0, 0, this.textRotateWithView_, this.textRotation_,\\n    1 / pixelRatio, true, label.width, textState.padding,\\n    !!textState.backgroundFill, !!textState.backgroundStroke\\n  ]);\\n};\\n\\n\\n/**\\n * @private\\n * @param {number} begin Begin.\\n * @param {number} end End.\\n * @param {module:ol/render/canvas~DeclutterGroup} declutterGroup Declutter group.\\n */\\nCanvasTextReplay.prototype.drawChars_ = function(begin, end, declutterGroup) {\\n  const strokeState = this.textStrokeState_;\\n  const textState = this.textState_;\\n  const fillState = this.textFillState_;\\n\\n  const strokeKey = this.strokeKey_;\\n  if (strokeState) {\\n    if (!(strokeKey in this.strokeStates)) {\\n      this.strokeStates[strokeKey] = /** @type {module:ol/render/canvas~StrokeState} */ ({\\n        strokeStyle: strokeState.strokeStyle,\\n        lineCap: strokeState.lineCap,\\n        lineDashOffset: strokeState.lineDashOffset,\\n        lineWidth: strokeState.lineWidth,\\n        lineJoin: strokeState.lineJoin,\\n        miterLimit: strokeState.miterLimit,\\n        lineDash: strokeState.lineDash\\n      });\\n    }\\n  }\\n  const textKey = this.textKey_;\\n  if (!(this.textKey_ in this.textStates)) {\\n    this.textStates[this.textKey_] = /** @type {module:ol/render/canvas~TextState} */ ({\\n      font: textState.font,\\n      textAlign: textState.textAlign || defaultTextAlign,\\n      scale: textState.scale\\n    });\\n  }\\n  const fillKey = this.fillKey_;\\n  if (fillState) {\\n    if (!(fillKey in this.fillStates)) {\\n      this.fillStates[fillKey] = /** @type {module:ol/render/canvas~FillState} */ ({\\n        fillStyle: fillState.fillStyle\\n      });\\n    }\\n  }\\n\\n  const pixelRatio = this.pixelRatio;\\n  const baseline = TEXT_ALIGN[textState.textBaseline];\\n\\n  const offsetY = this.textOffsetY_ * pixelRatio;\\n  const text = this.text_;\\n  const font = textState.font;\\n  const textScale = textState.scale;\\n  const strokeWidth = strokeState ? strokeState.lineWidth * textScale / 2 : 0;\\n  let widths = this.widths_[font];\\n  if (!widths) {\\n    this.widths_[font] = widths = {};\\n  }\\n  this.instructions.push([CanvasInstruction.DRAW_CHARS,\\n    begin, end, baseline, declutterGroup,\\n    textState.overflow, fillKey, textState.maxAngle,\\n    function(text) {\\n      let width = widths[text];\\n      if (!width) {\\n        width = widths[text] = measureTextWidth(font, text);\\n      }\\n      return width * textScale * pixelRatio;\\n    },\\n    offsetY, strokeKey, strokeWidth * pixelRatio, text, textKey, 1\\n  ]);\\n  this.hitDetectionInstructions.push([CanvasInstruction.DRAW_CHARS,\\n    begin, end, baseline, declutterGroup,\\n    textState.overflow, fillKey, textState.maxAngle,\\n    function(text) {\\n      let width = widths[text];\\n      if (!width) {\\n        width = widths[text] = measureTextWidth(font, text);\\n      }\\n      return width * textScale;\\n    },\\n    offsetY, strokeKey, strokeWidth, text, textKey, 1 / pixelRatio\\n  ]);\\n};\\n\\n\\n/**\\n * @inheritDoc\\n */\\nCanvasTextReplay.prototype.setTextStyle = function(textStyle, declutterGroup) {\\n  let textState, fillState, strokeState;\\n  if (!textStyle) {\\n    this.text_ = '';\\n  } else {\\n    this.declutterGroup_ = /** @type {module:ol/render/canvas~DeclutterGroup} */ (declutterGroup);\\n\\n    const textFillStyle = textStyle.getFill();\\n    if (!textFillStyle) {\\n      fillState = this.textFillState_ = null;\\n    } else {\\n      fillState = this.textFillState_;\\n      if (!fillState) {\\n        fillState = this.textFillState_ = /** @type {module:ol/render/canvas~FillState} */ ({});\\n      }\\n      fillState.fillStyle = asColorLike(\\n        textFillStyle.getColor() || defaultFillStyle);\\n    }\\n\\n    const textStrokeStyle = textStyle.getStroke();\\n    if (!textStrokeStyle) {\\n      strokeState = this.textStrokeState_ = null;\\n    } else {\\n      strokeState = this.textStrokeState_;\\n      if (!strokeState) {\\n        strokeState = this.textStrokeState_ = /** @type {module:ol/render/canvas~StrokeState} */ ({});\\n      }\\n      const lineDash = textStrokeStyle.getLineDash();\\n      const lineDashOffset = textStrokeStyle.getLineDashOffset();\\n      const lineWidth = textStrokeStyle.getWidth();\\n      const miterLimit = textStrokeStyle.getMiterLimit();\\n      strokeState.lineCap = textStrokeStyle.getLineCap() || defaultLineCap;\\n      strokeState.lineDash = lineDash ? lineDash.slice() : defaultLineDash;\\n      strokeState.lineDashOffset =\\n          lineDashOffset === undefined ? defaultLineDashOffset : lineDashOffset;\\n      strokeState.lineJoin = textStrokeStyle.getLineJoin() || defaultLineJoin;\\n      strokeState.lineWidth =\\n          lineWidth === undefined ? defaultLineWidth : lineWidth;\\n      strokeState.miterLimit =\\n          miterLimit === undefined ? defaultMiterLimit : miterLimit;\\n      strokeState.strokeStyle = asColorLike(\\n        textStrokeStyle.getColor() || defaultStrokeStyle);\\n    }\\n\\n    textState = this.textState_;\\n    const font = textStyle.getFont() || defaultFont;\\n    checkFont(font);\\n    const textScale = textStyle.getScale();\\n    textState.overflow = textStyle.getOverflow();\\n    textState.font = font;\\n    textState.maxAngle = textStyle.getMaxAngle();\\n    textState.placement = textStyle.getPlacement();\\n    textState.textAlign = textStyle.getTextAlign();\\n    textState.textBaseline = textStyle.getTextBaseline() || defaultTextBaseline;\\n    textState.backgroundFill = textStyle.getBackgroundFill();\\n    textState.backgroundStroke = textStyle.getBackgroundStroke();\\n    textState.padding = textStyle.getPadding() || defaultPadding;\\n    textState.scale = textScale === undefined ? 1 : textScale;\\n\\n    const textOffsetX = textStyle.getOffsetX();\\n    const textOffsetY = textStyle.getOffsetY();\\n    const textRotateWithView = textStyle.getRotateWithView();\\n    const textRotation = textStyle.getRotation();\\n    this.text_ = textStyle.getText() || '';\\n    this.textOffsetX_ = textOffsetX === undefined ? 0 : textOffsetX;\\n    this.textOffsetY_ = textOffsetY === undefined ? 0 : textOffsetY;\\n    this.textRotateWithView_ = textRotateWithView === undefined ? false : textRotateWithView;\\n    this.textRotation_ = textRotation === undefined ? 0 : textRotation;\\n\\n    this.strokeKey_ = strokeState ?\\n      (typeof strokeState.strokeStyle == 'string' ? strokeState.strokeStyle : getUid(strokeState.strokeStyle)) +\\n      strokeState.lineCap + strokeState.lineDashOffset + '|' + strokeState.lineWidth +\\n      strokeState.lineJoin + strokeState.miterLimit + '[' + strokeState.lineDash.join() + ']' :\\n      '';\\n    this.textKey_ = textState.font + textState.scale + (textState.textAlign || '?');\\n    this.fillKey_ = fillState ?\\n      (typeof fillState.fillStyle == 'string' ? fillState.fillStyle : ('|' + getUid(fillState.fillStyle))) :\\n      '';\\n  }\\n};\\nexport default CanvasTextReplay;\\n\",\"/**\\n * @module ol/render/canvas/ReplayGroup\\n */\\nimport {inherits} from '../../index.js';\\nimport {numberSafeCompareFunction} from '../../array.js';\\nimport {createCanvasContext2D} from '../../dom.js';\\nimport {buffer, createEmpty, extendCoordinate} from '../../extent.js';\\nimport {transform2D} from '../../geom/flat/transform.js';\\nimport {isEmpty} from '../../obj.js';\\nimport ReplayGroup from '../ReplayGroup.js';\\nimport ReplayType from '../ReplayType.js';\\nimport CanvasReplay from '../canvas/Replay.js';\\nimport CanvasImageReplay from '../canvas/ImageReplay.js';\\nimport CanvasLineStringReplay from '../canvas/LineStringReplay.js';\\nimport CanvasPolygonReplay from '../canvas/PolygonReplay.js';\\nimport CanvasTextReplay from '../canvas/TextReplay.js';\\nimport {ORDER} from '../replay.js';\\nimport {create as createTransform, compose as composeTransform} from '../../transform.js';\\n\\n\\n/**\\n * @type {Object.<module:ol/render/ReplayType,\\n *                function(new: module:ol/render/canvas/Replay, number, module:ol/extent~Extent,\\n *                number, number, boolean, Array.<module:ol/render/canvas~DeclutterGroup>)>}\\n */\\nconst BATCH_CONSTRUCTORS = {\\n  'Circle': CanvasPolygonReplay,\\n  'Default': CanvasReplay,\\n  'Image': CanvasImageReplay,\\n  'LineString': CanvasLineStringReplay,\\n  'Polygon': CanvasPolygonReplay,\\n  'Text': CanvasTextReplay\\n};\\n\\n\\n/**\\n * @constructor\\n * @extends {module:ol/render/ReplayGroup}\\n * @param {number} tolerance Tolerance.\\n * @param {module:ol/extent~Extent} maxExtent Max extent.\\n * @param {number} resolution Resolution.\\n * @param {number} pixelRatio Pixel ratio.\\n * @param {boolean} overlaps The replay group can have overlapping geometries.\\n * @param {?} declutterTree Declutter tree\\n * for declutter processing in postrender.\\n * @param {number=} opt_renderBuffer Optional rendering buffer.\\n * @struct\\n */\\nconst CanvasReplayGroup = function(\\n  tolerance, maxExtent, resolution, pixelRatio, overlaps, declutterTree, opt_renderBuffer) {\\n  ReplayGroup.call(this);\\n\\n  /**\\n   * Declutter tree.\\n   * @private\\n   */\\n  this.declutterTree_ = declutterTree;\\n\\n  /**\\n   * @type {module:ol/render/canvas~DeclutterGroup}\\n   * @private\\n   */\\n  this.declutterGroup_ = null;\\n\\n  /**\\n   * @private\\n   * @type {number}\\n   */\\n  this.tolerance_ = tolerance;\\n\\n  /**\\n   * @private\\n   * @type {module:ol/extent~Extent}\\n   */\\n  this.maxExtent_ = maxExtent;\\n\\n  /**\\n   * @private\\n   * @type {boolean}\\n   */\\n  this.overlaps_ = overlaps;\\n\\n  /**\\n   * @private\\n   * @type {number}\\n   */\\n  this.pixelRatio_ = pixelRatio;\\n\\n  /**\\n   * @private\\n   * @type {number}\\n   */\\n  this.resolution_ = resolution;\\n\\n  /**\\n   * @private\\n   * @type {number|undefined}\\n   */\\n  this.renderBuffer_ = opt_renderBuffer;\\n\\n  /**\\n   * @private\\n   * @type {!Object.<string, !Object.<module:ol/render/ReplayType, module:ol/render/canvas/Replay>>}\\n   */\\n  this.replaysByZIndex_ = {};\\n\\n  /**\\n   * @private\\n   * @type {CanvasRenderingContext2D}\\n   */\\n  this.hitDetectionContext_ = createCanvasContext2D(1, 1);\\n\\n  /**\\n   * @private\\n   * @type {module:ol/transform~Transform}\\n   */\\n  this.hitDetectionTransform_ = createTransform();\\n};\\n\\ninherits(CanvasReplayGroup, ReplayGroup);\\n\\n\\n/**\\n * This cache is used for storing calculated pixel circles for increasing performance.\\n * It is a static property to allow each Replaygroup to access it.\\n * @type {Object.<number, Array.<Array.<(boolean|undefined)>>>}\\n */\\nconst circleArrayCache = {\\n  0: [[true]]\\n};\\n\\n\\n/**\\n * This method fills a row in the array from the given coordinate to the\\n * middle with `true`.\\n * @param {Array.<Array.<(boolean|undefined)>>} array The array that will be altered.\\n * @param {number} x X coordinate.\\n * @param {number} y Y coordinate.\\n */\\nfunction fillCircleArrayRowToMiddle(array, x, y) {\\n  let i;\\n  const radius = Math.floor(array.length / 2);\\n  if (x >= radius) {\\n    for (i = radius; i < x; i++) {\\n      array[i][y] = true;\\n    }\\n  } else if (x < radius) {\\n    for (i = x + 1; i < radius; i++) {\\n      array[i][y] = true;\\n    }\\n  }\\n}\\n\\n\\n/**\\n * This methods creates a circle inside a fitting array. Points inside the\\n * circle are marked by true, points on the outside are undefined.\\n * It uses the midpoint circle algorithm.\\n * A cache is used to increase performance.\\n * @param {number} radius Radius.\\n * @returns {Array.<Array.<(boolean|undefined)>>} An array with marked circle points.\\n */\\nexport function getCircleArray(radius) {\\n  if (circleArrayCache[radius] !== undefined) {\\n    return circleArrayCache[radius];\\n  }\\n\\n  const arraySize = radius * 2 + 1;\\n  const arr = new Array(arraySize);\\n  for (let i = 0; i < arraySize; i++) {\\n    arr[i] = new Array(arraySize);\\n  }\\n\\n  let x = radius;\\n  let y = 0;\\n  let error = 0;\\n\\n  while (x >= y) {\\n    fillCircleArrayRowToMiddle(arr, radius + x, radius + y);\\n    fillCircleArrayRowToMiddle(arr, radius + y, radius + x);\\n    fillCircleArrayRowToMiddle(arr, radius - y, radius + x);\\n    fillCircleArrayRowToMiddle(arr, radius - x, radius + y);\\n    fillCircleArrayRowToMiddle(arr, radius - x, radius - y);\\n    fillCircleArrayRowToMiddle(arr, radius - y, radius - x);\\n    fillCircleArrayRowToMiddle(arr, radius + y, radius - x);\\n    fillCircleArrayRowToMiddle(arr, radius + x, radius - y);\\n\\n    y++;\\n    error += 1 + 2 * y;\\n    if (2 * (error - x) + 1 > 0) {\\n      x -= 1;\\n      error += 1 - 2 * x;\\n    }\\n  }\\n\\n  circleArrayCache[radius] = arr;\\n  return arr;\\n}\\n\\n\\n/**\\n * @param {!Object.<string, Array.<*>>} declutterReplays Declutter replays.\\n * @param {CanvasRenderingContext2D} context Context.\\n * @param {number} rotation Rotation.\\n */\\nexport function replayDeclutter(declutterReplays, context, rotation) {\\n  const zs = Object.keys(declutterReplays).map(Number).sort(numberSafeCompareFunction);\\n  const skippedFeatureUids = {};\\n  for (let z = 0, zz = zs.length; z < zz; ++z) {\\n    const replayData = declutterReplays[zs[z].toString()];\\n    for (let i = 0, ii = replayData.length; i < ii;) {\\n      const replay = replayData[i++];\\n      const transform = replayData[i++];\\n      replay.replay(context, transform, rotation, skippedFeatureUids);\\n    }\\n  }\\n}\\n\\n\\n/**\\n * @param {boolean} group Group with previous replay.\\n * @return {module:ol/render/canvas~DeclutterGroup} Declutter instruction group.\\n */\\nCanvasReplayGroup.prototype.addDeclutter = function(group) {\\n  let declutter = null;\\n  if (this.declutterTree_) {\\n    if (group) {\\n      declutter = this.declutterGroup_;\\n      /** @type {number} */ (declutter[4])++;\\n    } else {\\n      declutter = this.declutterGroup_ = createEmpty();\\n      declutter.push(1);\\n    }\\n  }\\n  return declutter;\\n};\\n\\n\\n/**\\n * @param {CanvasRenderingContext2D} context Context.\\n * @param {module:ol/transform~Transform} transform Transform.\\n */\\nCanvasReplayGroup.prototype.clip = function(context, transform) {\\n  const flatClipCoords = this.getClipCoords(transform);\\n  context.beginPath();\\n  context.moveTo(flatClipCoords[0], flatClipCoords[1]);\\n  context.lineTo(flatClipCoords[2], flatClipCoords[3]);\\n  context.lineTo(flatClipCoords[4], flatClipCoords[5]);\\n  context.lineTo(flatClipCoords[6], flatClipCoords[7]);\\n  context.clip();\\n};\\n\\n\\n/**\\n * @param {Array.<module:ol/render/ReplayType>} replays Replays.\\n * @return {boolean} Has replays of the provided types.\\n */\\nCanvasReplayGroup.prototype.hasReplays = function(replays) {\\n  for (const zIndex in this.replaysByZIndex_) {\\n    const candidates = this.replaysByZIndex_[zIndex];\\n    for (let i = 0, ii = replays.length; i < ii; ++i) {\\n      if (replays[i] in candidates) {\\n        return true;\\n      }\\n    }\\n  }\\n  return false;\\n};\\n\\n\\n/**\\n * FIXME empty description for jsdoc\\n */\\nCanvasReplayGroup.prototype.finish = function() {\\n  for (const zKey in this.replaysByZIndex_) {\\n    const replays = this.replaysByZIndex_[zKey];\\n    for (const replayKey in replays) {\\n      replays[replayKey].finish();\\n    }\\n  }\\n};\\n\\n\\n/**\\n * @param {module:ol/coordinate~Coordinate} coordinate Coordinate.\\n * @param {number} resolution Resolution.\\n * @param {number} rotation Rotation.\\n * @param {number} hitTolerance Hit tolerance in pixels.\\n * @param {Object.<string, boolean>} skippedFeaturesHash Ids of features to skip.\\n * @param {function((module:ol/Feature|module:ol/render/Feature)): T} callback Feature callback.\\n * @param {Object.<string, module:ol/render/canvas~DeclutterGroup>} declutterReplays Declutter replays.\\n * @return {T|undefined} Callback result.\\n * @template T\\n */\\nCanvasReplayGroup.prototype.forEachFeatureAtCoordinate = function(\\n  coordinate, resolution, rotation, hitTolerance, skippedFeaturesHash, callback, declutterReplays) {\\n\\n  hitTolerance = Math.round(hitTolerance);\\n  const contextSize = hitTolerance * 2 + 1;\\n  const transform = composeTransform(this.hitDetectionTransform_,\\n    hitTolerance + 0.5, hitTolerance + 0.5,\\n    1 / resolution, -1 / resolution,\\n    -rotation,\\n    -coordinate[0], -coordinate[1]);\\n  const context = this.hitDetectionContext_;\\n\\n  if (context.canvas.width !== contextSize || context.canvas.height !== contextSize) {\\n    context.canvas.width = contextSize;\\n    context.canvas.height = contextSize;\\n  } else {\\n    context.clearRect(0, 0, contextSize, contextSize);\\n  }\\n\\n  /**\\n   * @type {module:ol/extent~Extent}\\n   */\\n  let hitExtent;\\n  if (this.renderBuffer_ !== undefined) {\\n    hitExtent = createEmpty();\\n    extendCoordinate(hitExtent, coordinate);\\n    buffer(hitExtent, resolution * (this.renderBuffer_ + hitTolerance), hitExtent);\\n  }\\n\\n  const mask = getCircleArray(hitTolerance);\\n  let declutteredFeatures;\\n  if (this.declutterTree_) {\\n    declutteredFeatures = this.declutterTree_.all().map(function(entry) {\\n      return entry.value;\\n    });\\n  }\\n\\n  let replayType;\\n\\n  /**\\n   * @param {module:ol/Feature|module:ol/render/Feature} feature Feature.\\n   * @return {?} Callback result.\\n   */\\n  function featureCallback(feature) {\\n    const imageData = context.getImageData(0, 0, contextSize, contextSize).data;\\n    for (let i = 0; i < contextSize; i++) {\\n      for (let j = 0; j < contextSize; j++) {\\n        if (mask[i][j]) {\\n          if (imageData[(j * contextSize + i) * 4 + 3] > 0) {\\n            let result;\\n            if (!(declutteredFeatures && (replayType == ReplayType.IMAGE || replayType == ReplayType.TEXT)) ||\\n                declutteredFeatures.indexOf(feature) !== -1) {\\n              result = callback(feature);\\n            }\\n            if (result) {\\n              return result;\\n            } else {\\n              context.clearRect(0, 0, contextSize, contextSize);\\n              return undefined;\\n            }\\n          }\\n        }\\n      }\\n    }\\n  }\\n\\n  /** @type {Array.<number>} */\\n  const zs = Object.keys(this.replaysByZIndex_).map(Number);\\n  zs.sort(numberSafeCompareFunction);\\n\\n  let i, j, replays, replay, result;\\n  for (i = zs.length - 1; i >= 0; --i) {\\n    const zIndexKey = zs[i].toString();\\n    replays = this.replaysByZIndex_[zIndexKey];\\n    for (j = ORDER.length - 1; j >= 0; --j) {\\n      replayType = ORDER[j];\\n      replay = replays[replayType];\\n      if (replay !== undefined) {\\n        if (declutterReplays &&\\n            (replayType == ReplayType.IMAGE || replayType == ReplayType.TEXT)) {\\n          const declutter = declutterReplays[zIndexKey];\\n          if (!declutter) {\\n            declutterReplays[zIndexKey] = [replay, transform.slice(0)];\\n          } else {\\n            declutter.push(replay, transform.slice(0));\\n          }\\n        } else {\\n          result = replay.replayHitDetection(context, transform, rotation,\\n            skippedFeaturesHash, featureCallback, hitExtent);\\n          if (result) {\\n            return result;\\n          }\\n        }\\n      }\\n    }\\n  }\\n  return undefined;\\n};\\n\\n\\n/**\\n * @param {module:ol/transform~Transform} transform Transform.\\n * @return {Array.<number>} Clip coordinates.\\n */\\nCanvasReplayGroup.prototype.getClipCoords = function(transform) {\\n  const maxExtent = this.maxExtent_;\\n  const minX = maxExtent[0];\\n  const minY = maxExtent[1];\\n  const maxX = maxExtent[2];\\n  const maxY = maxExtent[3];\\n  const flatClipCoords = [minX, minY, minX, maxY, maxX, maxY, maxX, minY];\\n  transform2D(\\n    flatClipCoords, 0, 8, 2, transform, flatClipCoords);\\n  return flatClipCoords;\\n};\\n\\n\\n/**\\n * @inheritDoc\\n */\\nCanvasReplayGroup.prototype.getReplay = function(zIndex, replayType) {\\n  const zIndexKey = zIndex !== undefined ? zIndex.toString() : '0';\\n  let replays = this.replaysByZIndex_[zIndexKey];\\n  if (replays === undefined) {\\n    replays = {};\\n    this.replaysByZIndex_[zIndexKey] = replays;\\n  }\\n  let replay = replays[replayType];\\n  if (replay === undefined) {\\n    const Constructor = BATCH_CONSTRUCTORS[replayType];\\n    replay = new Constructor(this.tolerance_, this.maxExtent_,\\n      this.resolution_, this.pixelRatio_, this.overlaps_, this.declutterTree_);\\n    replays[replayType] = replay;\\n  }\\n  return replay;\\n};\\n\\n\\n/**\\n * @return {Object.<string, Object.<module:ol/render/ReplayType, module:ol/render/canvas/Replay>>} Replays.\\n */\\nCanvasReplayGroup.prototype.getReplays = function() {\\n  return this.replaysByZIndex_;\\n};\\n\\n\\n/**\\n * @inheritDoc\\n */\\nCanvasReplayGroup.prototype.isEmpty = function() {\\n  return isEmpty(this.replaysByZIndex_);\\n};\\n\\n\\n/**\\n * @param {CanvasRenderingContext2D} context Context.\\n * @param {module:ol/transform~Transform} transform Transform.\\n * @param {number} viewRotation View rotation.\\n * @param {Object.<string, boolean>} skippedFeaturesHash Ids of features to skip.\\n * @param {Array.<module:ol/render/ReplayType>=} opt_replayTypes Ordered replay types to replay.\\n *     Default is {@link module:ol/render/replay~ORDER}\\n * @param {Object.<string, module:ol/render/canvas~DeclutterGroup>=} opt_declutterReplays Declutter replays.\\n */\\nCanvasReplayGroup.prototype.replay = function(context,\\n  transform, viewRotation, skippedFeaturesHash, opt_replayTypes, opt_declutterReplays) {\\n\\n  /** @type {Array.<number>} */\\n  const zs = Object.keys(this.replaysByZIndex_).map(Number);\\n  zs.sort(numberSafeCompareFunction);\\n\\n  // setup clipping so that the parts of over-simplified geometries are not\\n  // visible outside the current extent when panning\\n  context.save();\\n  this.clip(context, transform);\\n\\n  const replayTypes = opt_replayTypes ? opt_replayTypes : ORDER;\\n  let i, ii, j, jj, replays, replay;\\n  for (i = 0, ii = zs.length; i < ii; ++i) {\\n    const zIndexKey = zs[i].toString();\\n    replays = this.replaysByZIndex_[zIndexKey];\\n    for (j = 0, jj = replayTypes.length; j < jj; ++j) {\\n      const replayType = replayTypes[j];\\n      replay = replays[replayType];\\n      if (replay !== undefined) {\\n        if (opt_declutterReplays &&\\n            (replayType == ReplayType.IMAGE || replayType == ReplayType.TEXT)) {\\n          const declutter = opt_declutterReplays[zIndexKey];\\n          if (!declutter) {\\n            opt_declutterReplays[zIndexKey] = [replay, transform.slice(0)];\\n          } else {\\n            declutter.push(replay, transform.slice(0));\\n          }\\n        } else {\\n          replay.replay(context, transform, viewRotation, skippedFeaturesHash);\\n        }\\n      }\\n    }\\n  }\\n\\n  context.restore();\\n};\\n\\nexport default CanvasReplayGroup;\\n\",\"/**\\n * @module ol/renderer/vector\\n */\\nimport {getUid} from '../index.js';\\nimport ImageState from '../ImageState.js';\\nimport GeometryType from '../geom/GeometryType.js';\\nimport ReplayType from '../render/ReplayType.js';\\n\\n\\n/**\\n * Tolerance for geometry simplification in device pixels.\\n * @type {number}\\n */\\nconst SIMPLIFY_TOLERANCE = 0.5;\\n\\n\\n/**\\n * @const\\n * @type {Object.<module:ol/geom/GeometryType,\\n *                function(module:ol/render/ReplayGroup, module:ol/geom/Geometry,\\n *                         module:ol/style/Style, Object)>}\\n */\\nconst GEOMETRY_RENDERERS = {\\n  'Point': renderPointGeometry,\\n  'LineString': renderLineStringGeometry,\\n  'Polygon': renderPolygonGeometry,\\n  'MultiPoint': renderMultiPointGeometry,\\n  'MultiLineString': renderMultiLineStringGeometry,\\n  'MultiPolygon': renderMultiPolygonGeometry,\\n  'GeometryCollection': renderGeometryCollectionGeometry,\\n  'Circle': renderCircleGeometry\\n};\\n\\n\\n/**\\n * @param {module:ol/Feature|module:ol/render/Feature} feature1 Feature 1.\\n * @param {module:ol/Feature|module:ol/render/Feature} feature2 Feature 2.\\n * @return {number} Order.\\n */\\nexport function defaultOrder(feature1, feature2) {\\n  return getUid(feature1) - getUid(feature2);\\n}\\n\\n\\n/**\\n * @param {number} resolution Resolution.\\n * @param {number} pixelRatio Pixel ratio.\\n * @return {number} Squared pixel tolerance.\\n */\\nexport function getSquaredTolerance(resolution, pixelRatio) {\\n  const tolerance = getTolerance(resolution, pixelRatio);\\n  return tolerance * tolerance;\\n}\\n\\n\\n/**\\n * @param {number} resolution Resolution.\\n * @param {number} pixelRatio Pixel ratio.\\n * @return {number} Pixel tolerance.\\n */\\nexport function getTolerance(resolution, pixelRatio) {\\n  return SIMPLIFY_TOLERANCE * resolution / pixelRatio;\\n}\\n\\n\\n/**\\n * @param {module:ol/render/ReplayGroup} replayGroup Replay group.\\n * @param {module:ol/geom/Circle} geometry Geometry.\\n * @param {module:ol/style/Style} style Style.\\n * @param {module:ol/Feature} feature Feature.\\n */\\nfunction renderCircleGeometry(replayGroup, geometry, style, feature) {\\n  const fillStyle = style.getFill();\\n  const strokeStyle = style.getStroke();\\n  if (fillStyle || strokeStyle) {\\n    const circleReplay = replayGroup.getReplay(style.getZIndex(), ReplayType.CIRCLE);\\n    circleReplay.setFillStrokeStyle(fillStyle, strokeStyle);\\n    circleReplay.drawCircle(geometry, feature);\\n  }\\n  const textStyle = style.getText();\\n  if (textStyle) {\\n    const textReplay = replayGroup.getReplay(style.getZIndex(), ReplayType.TEXT);\\n    textReplay.setTextStyle(textStyle, replayGroup.addDeclutter(false));\\n    textReplay.drawText(geometry, feature);\\n  }\\n}\\n\\n\\n/**\\n * @param {module:ol/render/ReplayGroup} replayGroup Replay group.\\n * @param {module:ol/Feature|module:ol/render/Feature} feature Feature.\\n * @param {module:ol/style/Style} style Style.\\n * @param {number} squaredTolerance Squared tolerance.\\n * @param {function(this: T, module:ol/events/Event)} listener Listener function.\\n * @param {T} thisArg Value to use as `this` when executing `listener`.\\n * @return {boolean} `true` if style is loading.\\n * @template T\\n */\\nexport function renderFeature(replayGroup, feature, style, squaredTolerance, listener, thisArg) {\\n  let loading = false;\\n  const imageStyle = style.getImage();\\n  if (imageStyle) {\\n    let imageState = imageStyle.getImageState();\\n    if (imageState == ImageState.LOADED || imageState == ImageState.ERROR) {\\n      imageStyle.unlistenImageChange(listener, thisArg);\\n    } else {\\n      if (imageState == ImageState.IDLE) {\\n        imageStyle.load();\\n      }\\n      imageState = imageStyle.getImageState();\\n      imageStyle.listenImageChange(listener, thisArg);\\n      loading = true;\\n    }\\n  }\\n  renderFeatureInternal(replayGroup, feature, style, squaredTolerance);\\n\\n  return loading;\\n}\\n\\n\\n/**\\n * @param {module:ol/render/ReplayGroup} replayGroup Replay group.\\n * @param {module:ol/Feature|module:ol/render/Feature} feature Feature.\\n * @param {module:ol/style/Style} style Style.\\n * @param {number} squaredTolerance Squared tolerance.\\n */\\nfunction renderFeatureInternal(replayGroup, feature, style, squaredTolerance) {\\n  const geometry = style.getGeometryFunction()(feature);\\n  if (!geometry) {\\n    return;\\n  }\\n  const simplifiedGeometry = geometry.getSimplifiedGeometry(squaredTolerance);\\n  const renderer = style.getRenderer();\\n  if (renderer) {\\n    renderGeometry(replayGroup, simplifiedGeometry, style, feature);\\n  } else {\\n    const geometryRenderer = GEOMETRY_RENDERERS[simplifiedGeometry.getType()];\\n    geometryRenderer(replayGroup, simplifiedGeometry, style, feature);\\n  }\\n}\\n\\n\\n/**\\n * @param {module:ol/render/ReplayGroup} replayGroup Replay group.\\n * @param {module:ol/geom/Geometry} geometry Geometry.\\n * @param {module:ol/style/Style} style Style.\\n * @param {module:ol/Feature|module:ol/render/Feature} feature Feature.\\n */\\nfunction renderGeometry(replayGroup, geometry, style, feature) {\\n  if (geometry.getType() == GeometryType.GEOMETRY_COLLECTION) {\\n    const geometries = /** @type {module:ol/geom/GeometryCollection} */ (geometry).getGeometries();\\n    for (let i = 0, ii = geometries.length; i < ii; ++i) {\\n      renderGeometry(replayGroup, geometries[i], style, feature);\\n    }\\n    return;\\n  }\\n  const replay = replayGroup.getReplay(style.getZIndex(), ReplayType.DEFAULT);\\n  replay.drawCustom(/** @type {module:ol/geom/SimpleGeometry} */ (geometry), feature, style.getRenderer());\\n}\\n\\n\\n/**\\n * @param {module:ol/render/ReplayGroup} replayGroup Replay group.\\n * @param {module:ol/geom/GeometryCollection} geometry Geometry.\\n * @param {module:ol/style/Style} style Style.\\n * @param {module:ol/Feature} feature Feature.\\n */\\nfunction renderGeometryCollectionGeometry(replayGroup, geometry, style, feature) {\\n  const geometries = geometry.getGeometriesArray();\\n  let i, ii;\\n  for (i = 0, ii = geometries.length; i < ii; ++i) {\\n    const geometryRenderer =\\n        GEOMETRY_RENDERERS[geometries[i].getType()];\\n    geometryRenderer(replayGroup, geometries[i], style, feature);\\n  }\\n}\\n\\n\\n/**\\n * @param {module:ol/render/ReplayGroup} replayGroup Replay group.\\n * @param {module:ol/geom/LineString|module:ol/render/Feature} geometry Geometry.\\n * @param {module:ol/style/Style} style Style.\\n * @param {module:ol/Feature|module:ol/render/Feature} feature Feature.\\n */\\nfunction renderLineStringGeometry(replayGroup, geometry, style, feature) {\\n  const strokeStyle = style.getStroke();\\n  if (strokeStyle) {\\n    const lineStringReplay = replayGroup.getReplay(style.getZIndex(), ReplayType.LINE_STRING);\\n    lineStringReplay.setFillStrokeStyle(null, strokeStyle);\\n    lineStringReplay.drawLineString(geometry, feature);\\n  }\\n  const textStyle = style.getText();\\n  if (textStyle) {\\n    const textReplay = replayGroup.getReplay(style.getZIndex(), ReplayType.TEXT);\\n    textReplay.setTextStyle(textStyle, replayGroup.addDeclutter(false));\\n    textReplay.drawText(geometry, feature);\\n  }\\n}\\n\\n\\n/**\\n * @param {module:ol/render/ReplayGroup} replayGroup Replay group.\\n * @param {module:ol/geom/MultiLineString|module:ol/render/Feature} geometry Geometry.\\n * @param {module:ol/style/Style} style Style.\\n * @param {module:ol/Feature|module:ol/render/Feature} feature Feature.\\n */\\nfunction renderMultiLineStringGeometry(replayGroup, geometry, style, feature) {\\n  const strokeStyle = style.getStroke();\\n  if (strokeStyle) {\\n    const lineStringReplay = replayGroup.getReplay(style.getZIndex(), ReplayType.LINE_STRING);\\n    lineStringReplay.setFillStrokeStyle(null, strokeStyle);\\n    lineStringReplay.drawMultiLineString(geometry, feature);\\n  }\\n  const textStyle = style.getText();\\n  if (textStyle) {\\n    const textReplay = replayGroup.getReplay(style.getZIndex(), ReplayType.TEXT);\\n    textReplay.setTextStyle(textStyle, replayGroup.addDeclutter(false));\\n    textReplay.drawText(geometry, feature);\\n  }\\n}\\n\\n\\n/**\\n * @param {module:ol/render/ReplayGroup} replayGroup Replay group.\\n * @param {module:ol/geom/MultiPolygon} geometry Geometry.\\n * @param {module:ol/style/Style} style Style.\\n * @param {module:ol/Feature} feature Feature.\\n */\\nfunction renderMultiPolygonGeometry(replayGroup, geometry, style, feature) {\\n  const fillStyle = style.getFill();\\n  const strokeStyle = style.getStroke();\\n  if (strokeStyle || fillStyle) {\\n    const polygonReplay = replayGroup.getReplay(style.getZIndex(), ReplayType.POLYGON);\\n    polygonReplay.setFillStrokeStyle(fillStyle, strokeStyle);\\n    polygonReplay.drawMultiPolygon(geometry, feature);\\n  }\\n  const textStyle = style.getText();\\n  if (textStyle) {\\n    const textReplay = replayGroup.getReplay(style.getZIndex(), ReplayType.TEXT);\\n    textReplay.setTextStyle(textStyle, replayGroup.addDeclutter(false));\\n    textReplay.drawText(geometry, feature);\\n  }\\n}\\n\\n\\n/**\\n * @param {module:ol/render/ReplayGroup} replayGroup Replay group.\\n * @param {module:ol/geom/Point|module:ol/render/Feature} geometry Geometry.\\n * @param {module:ol/style/Style} style Style.\\n * @param {module:ol/Feature|module:ol/render/Feature} feature Feature.\\n */\\nfunction renderPointGeometry(replayGroup, geometry, style, feature) {\\n  const imageStyle = style.getImage();\\n  if (imageStyle) {\\n    if (imageStyle.getImageState() != ImageState.LOADED) {\\n      return;\\n    }\\n    const imageReplay = replayGroup.getReplay(style.getZIndex(), ReplayType.IMAGE);\\n    imageReplay.setImageStyle(imageStyle, replayGroup.addDeclutter(false));\\n    imageReplay.drawPoint(geometry, feature);\\n  }\\n  const textStyle = style.getText();\\n  if (textStyle) {\\n    const textReplay = replayGroup.getReplay(style.getZIndex(), ReplayType.TEXT);\\n    textReplay.setTextStyle(textStyle, replayGroup.addDeclutter(!!imageStyle));\\n    textReplay.drawText(geometry, feature);\\n  }\\n}\\n\\n\\n/**\\n * @param {module:ol/render/ReplayGroup} replayGroup Replay group.\\n * @param {module:ol/geom/MultiPoint|module:ol/render/Feature} geometry Geometry.\\n * @param {module:ol/style/Style} style Style.\\n * @param {module:ol/Feature|module:ol/render/Feature} feature Feature.\\n */\\nfunction renderMultiPointGeometry(replayGroup, geometry, style, feature) {\\n  const imageStyle = style.getImage();\\n  if (imageStyle) {\\n    if (imageStyle.getImageState() != ImageState.LOADED) {\\n      return;\\n    }\\n    const imageReplay = replayGroup.getReplay(style.getZIndex(), ReplayType.IMAGE);\\n    imageReplay.setImageStyle(imageStyle, replayGroup.addDeclutter(false));\\n    imageReplay.drawMultiPoint(geometry, feature);\\n  }\\n  const textStyle = style.getText();\\n  if (textStyle) {\\n    const textReplay = replayGroup.getReplay(style.getZIndex(), ReplayType.TEXT);\\n    textReplay.setTextStyle(textStyle, replayGroup.addDeclutter(!!imageStyle));\\n    textReplay.drawText(geometry, feature);\\n  }\\n}\\n\\n\\n/**\\n * @param {module:ol/render/ReplayGroup} replayGroup Replay group.\\n * @param {module:ol/geom/Polygon|module:ol/render/Feature} geometry Geometry.\\n * @param {module:ol/style/Style} style Style.\\n * @param {module:ol/Feature|module:ol/render/Feature} feature Feature.\\n */\\nfunction renderPolygonGeometry(replayGroup, geometry, style, feature) {\\n  const fillStyle = style.getFill();\\n  const strokeStyle = style.getStroke();\\n  if (fillStyle || strokeStyle) {\\n    const polygonReplay = replayGroup.getReplay(style.getZIndex(), ReplayType.POLYGON);\\n    polygonReplay.setFillStrokeStyle(fillStyle, strokeStyle);\\n    polygonReplay.drawPolygon(geometry, feature);\\n  }\\n  const textStyle = style.getText();\\n  if (textStyle) {\\n    const textReplay = replayGroup.getReplay(style.getZIndex(), ReplayType.TEXT);\\n    textReplay.setTextStyle(textStyle, replayGroup.addDeclutter(false));\\n    textReplay.drawText(geometry, feature);\\n  }\\n}\\n\",\"/**\\n * @module ol/renderer/canvas/VectorLayer\\n */\\nimport {getUid, inherits} from '../../index.js';\\nimport LayerType from '../../LayerType.js';\\nimport ViewHint from '../../ViewHint.js';\\nimport {createCanvasContext2D} from '../../dom.js';\\nimport {listen, unlisten} from '../../events.js';\\nimport EventType from '../../events/EventType.js';\\nimport rbush from 'rbush';\\nimport {buffer, createEmpty, containsExtent, getWidth} from '../../extent.js';\\nimport RenderEventType from '../../render/EventType.js';\\nimport {labelCache, rotateAtOffset} from '../../render/canvas.js';\\nimport CanvasReplayGroup from '../../render/canvas/ReplayGroup.js';\\nimport CanvasLayerRenderer from '../canvas/Layer.js';\\nimport {defaultOrder as defaultRenderOrder, getTolerance as getRenderTolerance, getSquaredTolerance as getSquaredRenderTolerance, renderFeature} from '../vector.js';\\n\\n/**\\n * @constructor\\n * @extends {module:ol/renderer/canvas/Layer}\\n * @param {module:ol/layer/Vector} vectorLayer Vector layer.\\n * @api\\n */\\nconst CanvasVectorLayerRenderer = function(vectorLayer) {\\n\\n  CanvasLayerRenderer.call(this, vectorLayer);\\n\\n  /**\\n   * Declutter tree.\\n   * @private\\n   */\\n  this.declutterTree_ = vectorLayer.getDeclutter() ? rbush(9, undefined) : null;\\n\\n  /**\\n   * @private\\n   * @type {boolean}\\n   */\\n  this.dirty_ = false;\\n\\n  /**\\n   * @private\\n   * @type {number}\\n   */\\n  this.renderedRevision_ = -1;\\n\\n  /**\\n   * @private\\n   * @type {number}\\n   */\\n  this.renderedResolution_ = NaN;\\n\\n  /**\\n   * @private\\n   * @type {module:ol/extent~Extent}\\n   */\\n  this.renderedExtent_ = createEmpty();\\n\\n  /**\\n   * @private\\n   * @type {function(module:ol/Feature, module:ol/Feature): number|null}\\n   */\\n  this.renderedRenderOrder_ = null;\\n\\n  /**\\n   * @private\\n   * @type {module:ol/render/canvas/ReplayGroup}\\n   */\\n  this.replayGroup_ = null;\\n\\n  /**\\n   * A new replay group had to be created by `prepareFrame()`\\n   * @type {boolean}\\n   */\\n  this.replayGroupChanged = true;\\n\\n  /**\\n   * @type {CanvasRenderingContext2D}\\n   */\\n  this.context = createCanvasContext2D();\\n\\n  listen(labelCache, EventType.CLEAR, this.handleFontsChanged_, this);\\n\\n};\\n\\ninherits(CanvasVectorLayerRenderer, CanvasLayerRenderer);\\n\\n\\n/**\\n * Determine if this renderer handles the provided layer.\\n * @param {module:ol/layer/Layer} layer The candidate layer.\\n * @return {boolean} The renderer can render the layer.\\n */\\nCanvasVectorLayerRenderer['handles'] = function(layer) {\\n  return layer.getType() === LayerType.VECTOR;\\n};\\n\\n\\n/**\\n * Create a layer renderer.\\n * @param {module:ol/renderer/Map} mapRenderer The map renderer.\\n * @param {module:ol/layer/Layer} layer The layer to be rendererd.\\n * @return {module:ol/renderer/canvas/VectorLayer} The layer renderer.\\n */\\nCanvasVectorLayerRenderer['create'] = function(mapRenderer, layer) {\\n  return new CanvasVectorLayerRenderer(/** @type {module:ol/layer/Vector} */ (layer));\\n};\\n\\n\\n/**\\n * @inheritDoc\\n */\\nCanvasVectorLayerRenderer.prototype.disposeInternal = function() {\\n  unlisten(labelCache, EventType.CLEAR, this.handleFontsChanged_, this);\\n  CanvasLayerRenderer.prototype.disposeInternal.call(this);\\n};\\n\\n\\n/**\\n * @param {CanvasRenderingContext2D} context Context.\\n * @param {module:ol/PluggableMap~FrameState} frameState Frame state.\\n * @param {module:ol/layer/Layer~State} layerState Layer state.\\n */\\nCanvasVectorLayerRenderer.prototype.compose = function(context, frameState, layerState) {\\n  const extent = frameState.extent;\\n  const pixelRatio = frameState.pixelRatio;\\n  const skippedFeatureUids = layerState.managed ?\\n    frameState.skippedFeatureUids : {};\\n  const viewState = frameState.viewState;\\n  const projection = viewState.projection;\\n  const rotation = viewState.rotation;\\n  const projectionExtent = projection.getExtent();\\n  const vectorSource = /** @type {module:ol/source/Vector} */ (this.getLayer().getSource());\\n\\n  let transform = this.getTransform(frameState, 0);\\n\\n  // clipped rendering if layer extent is set\\n  const clipExtent = layerState.extent;\\n  const clipped = clipExtent !== undefined;\\n  if (clipped) {\\n    this.clip(context, frameState,  /** @type {module:ol/extent~Extent} */ (clipExtent));\\n  }\\n  const replayGroup = this.replayGroup_;\\n  if (replayGroup && !replayGroup.isEmpty()) {\\n    if (this.declutterTree_) {\\n      this.declutterTree_.clear();\\n    }\\n    const layer = /** @type {module:ol/layer/Vector} */ (this.getLayer());\\n    let drawOffsetX = 0;\\n    let drawOffsetY = 0;\\n    let replayContext;\\n    const transparentLayer = layerState.opacity !== 1;\\n    const hasRenderListeners = layer.hasListener(RenderEventType.RENDER);\\n    if (transparentLayer || hasRenderListeners) {\\n      let drawWidth = context.canvas.width;\\n      let drawHeight = context.canvas.height;\\n      if (rotation) {\\n        const drawSize = Math.round(Math.sqrt(drawWidth * drawWidth + drawHeight * drawHeight));\\n        drawOffsetX = (drawSize - drawWidth) / 2;\\n        drawOffsetY = (drawSize - drawHeight) / 2;\\n        drawWidth = drawHeight = drawSize;\\n      }\\n      // resize and clear\\n      this.context.canvas.width = drawWidth;\\n      this.context.canvas.height = drawHeight;\\n      replayContext = this.context;\\n    } else {\\n      replayContext = context;\\n    }\\n\\n    const alpha = replayContext.globalAlpha;\\n    if (!transparentLayer) {\\n      // for performance reasons, context.save / context.restore is not used\\n      // to save and restore the transformation matrix and the opacity.\\n      // see http://jsperf.com/context-save-restore-versus-variable\\n      replayContext.globalAlpha = layerState.opacity;\\n    }\\n\\n    if (replayContext != context) {\\n      replayContext.translate(drawOffsetX, drawOffsetY);\\n    }\\n\\n    const width = frameState.size[0] * pixelRatio;\\n    const height = frameState.size[1] * pixelRatio;\\n    rotateAtOffset(replayContext, -rotation,\\n      width / 2, height / 2);\\n    replayGroup.replay(replayContext, transform, rotation, skippedFeatureUids);\\n    if (vectorSource.getWrapX() && projection.canWrapX() &&\\n        !containsExtent(projectionExtent, extent)) {\\n      let startX = extent[0];\\n      const worldWidth = getWidth(projectionExtent);\\n      let world = 0;\\n      let offsetX;\\n      while (startX < projectionExtent[0]) {\\n        --world;\\n        offsetX = worldWidth * world;\\n        transform = this.getTransform(frameState, offsetX);\\n        replayGroup.replay(replayContext, transform, rotation, skippedFeatureUids);\\n        startX += worldWidth;\\n      }\\n      world = 0;\\n      startX = extent[2];\\n      while (startX > projectionExtent[2]) {\\n        ++world;\\n        offsetX = worldWidth * world;\\n        transform = this.getTransform(frameState, offsetX);\\n        replayGroup.replay(replayContext, transform, rotation, skippedFeatureUids);\\n        startX -= worldWidth;\\n      }\\n    }\\n    rotateAtOffset(replayContext, rotation,\\n      width / 2, height / 2);\\n\\n    if (replayContext != context) {\\n      if (hasRenderListeners) {\\n        this.dispatchRenderEvent(replayContext, frameState, transform);\\n      }\\n      if (transparentLayer) {\\n        const mainContextAlpha = context.globalAlpha;\\n        context.globalAlpha = layerState.opacity;\\n        context.drawImage(replayContext.canvas, -drawOffsetX, -drawOffsetY);\\n        context.globalAlpha = mainContextAlpha;\\n      } else {\\n        context.drawImage(replayContext.canvas, -drawOffsetX, -drawOffsetY);\\n      }\\n      replayContext.translate(-drawOffsetX, -drawOffsetY);\\n    }\\n\\n    if (!transparentLayer) {\\n      replayContext.globalAlpha = alpha;\\n    }\\n  }\\n\\n  if (clipped) {\\n    context.restore();\\n  }\\n};\\n\\n\\n/**\\n * @inheritDoc\\n */\\nCanvasVectorLayerRenderer.prototype.composeFrame = function(frameState, layerState, context) {\\n  const transform = this.getTransform(frameState, 0);\\n  this.preCompose(context, frameState, transform);\\n  this.compose(context, frameState, layerState);\\n  this.postCompose(context, frameState, layerState, transform);\\n};\\n\\n\\n/**\\n * @inheritDoc\\n */\\nCanvasVectorLayerRenderer.prototype.forEachFeatureAtCoordinate = function(coordinate, frameState, hitTolerance, callback, thisArg) {\\n  if (!this.replayGroup_) {\\n    return undefined;\\n  } else {\\n    const resolution = frameState.viewState.resolution;\\n    const rotation = frameState.viewState.rotation;\\n    const layer = /** @type {module:ol/layer/Vector} */ (this.getLayer());\\n    /** @type {!Object.<string, boolean>} */\\n    const features = {};\\n    const result = this.replayGroup_.forEachFeatureAtCoordinate(coordinate, resolution, rotation, hitTolerance, {},\\n      /**\\n       * @param {module:ol/Feature|module:ol/render/Feature} feature Feature.\\n       * @return {?} Callback result.\\n       */\\n      function(feature) {\\n        const key = getUid(feature).toString();\\n        if (!(key in features)) {\\n          features[key] = true;\\n          return callback.call(thisArg, feature, layer);\\n        }\\n      }, null);\\n    return result;\\n  }\\n};\\n\\n\\n/**\\n * @param {module:ol/events/Event} event Event.\\n */\\nCanvasVectorLayerRenderer.prototype.handleFontsChanged_ = function(event) {\\n  const layer = this.getLayer();\\n  if (layer.getVisible() && this.replayGroup_) {\\n    layer.changed();\\n  }\\n};\\n\\n\\n/**\\n * Handle changes in image style state.\\n * @param {module:ol/events/Event} event Image style change event.\\n * @private\\n */\\nCanvasVectorLayerRenderer.prototype.handleStyleImageChange_ = function(event) {\\n  this.renderIfReadyAndVisible();\\n};\\n\\n\\n/**\\n * @inheritDoc\\n */\\nCanvasVectorLayerRenderer.prototype.prepareFrame = function(frameState, layerState) {\\n  const vectorLayer = /** @type {module:ol/layer/Vector} */ (this.getLayer());\\n  const vectorSource = vectorLayer.getSource();\\n\\n  const animating = frameState.viewHints[ViewHint.ANIMATING];\\n  const interacting = frameState.viewHints[ViewHint.INTERACTING];\\n  const updateWhileAnimating = vectorLayer.getUpdateWhileAnimating();\\n  const updateWhileInteracting = vectorLayer.getUpdateWhileInteracting();\\n\\n  if (!this.dirty_ && (!updateWhileAnimating && animating) ||\\n      (!updateWhileInteracting && interacting)) {\\n    return true;\\n  }\\n\\n  const frameStateExtent = frameState.extent;\\n  const viewState = frameState.viewState;\\n  const projection = viewState.projection;\\n  const resolution = viewState.resolution;\\n  const pixelRatio = frameState.pixelRatio;\\n  const vectorLayerRevision = vectorLayer.getRevision();\\n  const vectorLayerRenderBuffer = vectorLayer.getRenderBuffer();\\n  let vectorLayerRenderOrder = vectorLayer.getRenderOrder();\\n\\n  if (vectorLayerRenderOrder === undefined) {\\n    vectorLayerRenderOrder = defaultRenderOrder;\\n  }\\n\\n  const extent = buffer(frameStateExtent,\\n    vectorLayerRenderBuffer * resolution);\\n  const projectionExtent = viewState.projection.getExtent();\\n\\n  if (vectorSource.getWrapX() && viewState.projection.canWrapX() &&\\n      !containsExtent(projectionExtent, frameState.extent)) {\\n    // For the replay group, we need an extent that intersects the real world\\n    // (-180 to +180). To support geometries in a coordinate range from -540\\n    // to +540, we add at least 1 world width on each side of the projection\\n    // extent. If the viewport is wider than the world, we need to add half of\\n    // the viewport width to make sure we cover the whole viewport.\\n    const worldWidth = getWidth(projectionExtent);\\n    const gutter = Math.max(getWidth(extent) / 2, worldWidth);\\n    extent[0] = projectionExtent[0] - gutter;\\n    extent[2] = projectionExtent[2] + gutter;\\n  }\\n\\n  if (!this.dirty_ &&\\n      this.renderedResolution_ == resolution &&\\n      this.renderedRevision_ == vectorLayerRevision &&\\n      this.renderedRenderOrder_ == vectorLayerRenderOrder &&\\n      containsExtent(this.renderedExtent_, extent)) {\\n    this.replayGroupChanged = false;\\n    return true;\\n  }\\n\\n  this.replayGroup_ = null;\\n\\n  this.dirty_ = false;\\n\\n  const replayGroup = new CanvasReplayGroup(\\n    getRenderTolerance(resolution, pixelRatio), extent, resolution,\\n    pixelRatio, vectorSource.getOverlaps(), this.declutterTree_, vectorLayer.getRenderBuffer());\\n  vectorSource.loadFeatures(extent, resolution, projection);\\n  /**\\n   * @param {module:ol/Feature} feature Feature.\\n   * @this {module:ol/renderer/canvas/VectorLayer}\\n   */\\n  const render = function(feature) {\\n    let styles;\\n    const styleFunction = feature.getStyleFunction() || vectorLayer.getStyleFunction();\\n    if (styleFunction) {\\n      styles = styleFunction(feature, resolution);\\n    }\\n    if (styles) {\\n      const dirty = this.renderFeature(\\n        feature, resolution, pixelRatio, styles, replayGroup);\\n      this.dirty_ = this.dirty_ || dirty;\\n    }\\n  }.bind(this);\\n  if (vectorLayerRenderOrder) {\\n    /** @type {Array.<module:ol/Feature>} */\\n    const features = [];\\n    vectorSource.forEachFeatureInExtent(extent,\\n      /**\\n       * @param {module:ol/Feature} feature Feature.\\n       */\\n      function(feature) {\\n        features.push(feature);\\n      }, this);\\n    features.sort(vectorLayerRenderOrder);\\n    for (let i = 0, ii = features.length; i < ii; ++i) {\\n      render(features[i]);\\n    }\\n  } else {\\n    vectorSource.forEachFeatureInExtent(extent, render, this);\\n  }\\n  replayGroup.finish();\\n\\n  this.renderedResolution_ = resolution;\\n  this.renderedRevision_ = vectorLayerRevision;\\n  this.renderedRenderOrder_ = vectorLayerRenderOrder;\\n  this.renderedExtent_ = extent;\\n  this.replayGroup_ = replayGroup;\\n\\n  this.replayGroupChanged = true;\\n  return true;\\n};\\n\\n\\n/**\\n * @param {module:ol/Feature} feature Feature.\\n * @param {number} resolution Resolution.\\n * @param {number} pixelRatio Pixel ratio.\\n * @param {(module:ol/style/Style|Array.<module:ol/style/Style>)} styles The style or array of styles.\\n * @param {module:ol/render/canvas/ReplayGroup} replayGroup Replay group.\\n * @return {boolean} `true` if an image is loading.\\n */\\nCanvasVectorLayerRenderer.prototype.renderFeature = function(feature, resolution, pixelRatio, styles, replayGroup) {\\n  if (!styles) {\\n    return false;\\n  }\\n  let loading = false;\\n  if (Array.isArray(styles)) {\\n    for (let i = 0, ii = styles.length; i < ii; ++i) {\\n      loading = renderFeature(\\n        replayGroup, feature, styles[i],\\n        getSquaredRenderTolerance(resolution, pixelRatio),\\n        this.handleStyleImageChange_, this) || loading;\\n    }\\n  } else {\\n    loading = renderFeature(\\n      replayGroup, feature, styles,\\n      getSquaredRenderTolerance(resolution, pixelRatio),\\n      this.handleStyleImageChange_, this);\\n  }\\n  return loading;\\n};\\nexport default CanvasVectorLayerRenderer;\\n\",\"/**\\n * @module ol/layer/VectorTileRenderType\\n */\\n\\n/**\\n * @enum {string}\\n * Render mode for vector tiles:\\n *  * `'image'`: Vector tiles are rendered as images. Great performance, but\\n *    point symbols and texts are always rotated with the view and pixels are\\n *    scaled during zoom animations.\\n *  * `'hybrid'`: Polygon and line elements are rendered as images, so pixels\\n *    are scaled during zoom animations. Point symbols and texts are accurately\\n *    rendered as vectors and can stay upright on rotated views.\\n *  * `'vector'`: Vector tiles are rendered as vectors. Most accurate rendering\\n *    even during animations, but slower performance than the other options.\\n * @api\\n */\\nexport default {\\n  IMAGE: 'image',\\n  HYBRID: 'hybrid',\\n  VECTOR: 'vector'\\n};\\n\",\"/**\\n * @module ol/renderer/canvas/VectorTileLayer\\n */\\nimport {getUid, inherits} from '../../index.js';\\nimport LayerType from '../../LayerType.js';\\nimport TileState from '../../TileState.js';\\nimport {createCanvasContext2D} from '../../dom.js';\\nimport {listen, unlisten} from '../../events.js';\\nimport EventType from '../../events/EventType.js';\\nimport rbush from 'rbush';\\nimport {buffer, containsCoordinate, equals, getIntersection, getTopLeft, intersects} from '../../extent.js';\\nimport VectorTileRenderType from '../../layer/VectorTileRenderType.js';\\nimport {equivalent as equivalentProjection} from '../../proj.js';\\nimport Units from '../../proj/Units.js';\\nimport ReplayType from '../../render/ReplayType.js';\\nimport {labelCache, rotateAtOffset} from '../../render/canvas.js';\\nimport CanvasReplayGroup, {replayDeclutter} from '../../render/canvas/ReplayGroup.js';\\nimport {ORDER} from '../../render/replay.js';\\nimport CanvasTileLayerRenderer from '../canvas/TileLayer.js';\\nimport {getSquaredTolerance as getSquaredRenderTolerance, renderFeature} from '../vector.js';\\nimport {\\n  create as createTransform,\\n  compose as composeTransform,\\n  reset as resetTransform,\\n  scale as scaleTransform,\\n  translate as translateTransform\\n} from '../../transform.js';\\n\\n\\n/**\\n * @type {!Object.<string, Array.<module:ol/render/ReplayType>>}\\n */\\nconst IMAGE_REPLAYS = {\\n  'image': [ReplayType.POLYGON, ReplayType.CIRCLE,\\n    ReplayType.LINE_STRING, ReplayType.IMAGE, ReplayType.TEXT],\\n  'hybrid': [ReplayType.POLYGON, ReplayType.LINE_STRING]\\n};\\n\\n\\n/**\\n * @type {!Object.<string, Array.<module:ol/render/ReplayType>>}\\n */\\nconst VECTOR_REPLAYS = {\\n  'image': [ReplayType.DEFAULT],\\n  'hybrid': [ReplayType.IMAGE, ReplayType.TEXT, ReplayType.DEFAULT],\\n  'vector': ORDER\\n};\\n\\n\\n/**\\n * @constructor\\n * @extends {module:ol/renderer/canvas/TileLayer}\\n * @param {module:ol/layer/VectorTile} layer VectorTile layer.\\n * @api\\n */\\nconst CanvasVectorTileLayerRenderer = function(layer) {\\n\\n  /**\\n   * @type {CanvasRenderingContext2D}\\n   */\\n  this.context = null;\\n\\n  CanvasTileLayerRenderer.call(this, layer);\\n\\n  /**\\n   * Declutter tree.\\n   * @private\\n   */\\n  this.declutterTree_ = layer.getDeclutter() ? rbush(9, undefined) : null;\\n\\n  /**\\n   * @private\\n   * @type {boolean}\\n   */\\n  this.dirty_ = false;\\n\\n  /**\\n   * @private\\n   * @type {number}\\n   */\\n  this.renderedLayerRevision_;\\n\\n  /**\\n   * @private\\n   * @type {module:ol/transform~Transform}\\n   */\\n  this.tmpTransform_ = createTransform();\\n\\n  // Use lower resolution for pure vector rendering. Closest resolution otherwise.\\n  this.zDirection = layer.getRenderMode() == VectorTileRenderType.VECTOR ? 1 : 0;\\n\\n  listen(labelCache, EventType.CLEAR, this.handleFontsChanged_, this);\\n\\n};\\n\\ninherits(CanvasVectorTileLayerRenderer, CanvasTileLayerRenderer);\\n\\n\\n/**\\n * Determine if this renderer handles the provided layer.\\n * @param {module:ol/layer/Layer} layer The candidate layer.\\n * @return {boolean} The renderer can render the layer.\\n */\\nCanvasVectorTileLayerRenderer['handles'] = function(layer) {\\n  return layer.getType() === LayerType.VECTOR_TILE;\\n};\\n\\n\\n/**\\n * Create a layer renderer.\\n * @param {module:ol/renderer/Map} mapRenderer The map renderer.\\n * @param {module:ol/layer/Layer} layer The layer to be rendererd.\\n * @return {module:ol/renderer/canvas/VectorTileLayer} The layer renderer.\\n */\\nCanvasVectorTileLayerRenderer['create'] = function(mapRenderer, layer) {\\n  return new CanvasVectorTileLayerRenderer(/** @type {module:ol/layer/VectorTile} */ (layer));\\n};\\n\\n\\n/**\\n * @inheritDoc\\n */\\nCanvasVectorTileLayerRenderer.prototype.disposeInternal = function() {\\n  unlisten(labelCache, EventType.CLEAR, this.handleFontsChanged_, this);\\n  CanvasTileLayerRenderer.prototype.disposeInternal.call(this);\\n};\\n\\n\\n/**\\n * @inheritDoc\\n */\\nCanvasVectorTileLayerRenderer.prototype.getTile = function(z, x, y, pixelRatio, projection) {\\n  const tile = CanvasTileLayerRenderer.prototype.getTile.call(this, z, x, y, pixelRatio, projection);\\n  if (tile.getState() === TileState.LOADED) {\\n    this.createReplayGroup_(tile, pixelRatio, projection);\\n    if (this.context) {\\n      this.renderTileImage_(tile, pixelRatio, projection);\\n    }\\n  }\\n  return tile;\\n};\\n\\n\\n/**\\n * @inheritDoc\\n */\\nCanvasVectorTileLayerRenderer.prototype.prepareFrame = function(frameState, layerState) {\\n  const layer = this.getLayer();\\n  const layerRevision = layer.getRevision();\\n  if (this.renderedLayerRevision_ != layerRevision) {\\n    this.renderedTiles.length = 0;\\n    const renderMode = layer.getRenderMode();\\n    if (!this.context && renderMode != VectorTileRenderType.VECTOR) {\\n      this.context = createCanvasContext2D();\\n    }\\n    if (this.context && renderMode == VectorTileRenderType.VECTOR) {\\n      this.context = null;\\n    }\\n  }\\n  this.renderedLayerRevision_ = layerRevision;\\n  return CanvasTileLayerRenderer.prototype.prepareFrame.apply(this, arguments);\\n};\\n\\n\\n/**\\n * @param {module:ol/VectorImageTile} tile Tile.\\n * @param {number} pixelRatio Pixel ratio.\\n * @param {module:ol/proj/Projection} projection Projection.\\n * @private\\n */\\nCanvasVectorTileLayerRenderer.prototype.createReplayGroup_ = function(tile, pixelRatio, projection) {\\n  const layer = this.getLayer();\\n  const revision = layer.getRevision();\\n  const renderOrder = /** @type {module:ol/render~OrderFunction} */ (layer.getRenderOrder()) || null;\\n\\n  const replayState = tile.getReplayState(layer);\\n  if (!replayState.dirty && replayState.renderedRevision == revision &&\\n      replayState.renderedRenderOrder == renderOrder) {\\n    return;\\n  }\\n\\n  const source = /** @type {module:ol/source/VectorTile} */ (layer.getSource());\\n  const sourceTileGrid = source.getTileGrid();\\n  const tileGrid = source.getTileGridForProjection(projection);\\n  const resolution = tileGrid.getResolution(tile.tileCoord[0]);\\n  const tileExtent = tile.extent;\\n\\n  const zIndexKeys = {};\\n  for (let t = 0, tt = tile.tileKeys.length; t < tt; ++t) {\\n    const sourceTile = tile.getTile(tile.tileKeys[t]);\\n    if (sourceTile.getState() != TileState.LOADED) {\\n      continue;\\n    }\\n\\n    const sourceTileCoord = sourceTile.tileCoord;\\n    const sourceTileExtent = sourceTileGrid.getTileCoordExtent(sourceTileCoord);\\n    const sharedExtent = getIntersection(tileExtent, sourceTileExtent);\\n    const bufferedExtent = equals(sourceTileExtent, sharedExtent) ? null :\\n      buffer(sharedExtent, layer.getRenderBuffer() * resolution, this.tmpExtent);\\n    const tileProjection = sourceTile.getProjection();\\n    let reproject = false;\\n    if (!equivalentProjection(projection, tileProjection)) {\\n      reproject = true;\\n      sourceTile.setProjection(projection);\\n    }\\n    replayState.dirty = false;\\n    const replayGroup = new CanvasReplayGroup(0, sharedExtent, resolution,\\n      pixelRatio, source.getOverlaps(), this.declutterTree_, layer.getRenderBuffer());\\n    const squaredTolerance = getSquaredRenderTolerance(resolution, pixelRatio);\\n\\n    /**\\n     * @param {module:ol/Feature|module:ol/render/Feature} feature Feature.\\n     * @this {module:ol/renderer/canvas/VectorTileLayer}\\n     */\\n    const render = function(feature) {\\n      let styles;\\n      const styleFunction = feature.getStyleFunction() || layer.getStyleFunction();\\n      if (styleFunction) {\\n        styles = styleFunction(feature, resolution);\\n      }\\n      if (styles) {\\n        const dirty = this.renderFeature(feature, squaredTolerance, styles, replayGroup);\\n        this.dirty_ = this.dirty_ || dirty;\\n        replayState.dirty = replayState.dirty || dirty;\\n      }\\n    };\\n\\n    const features = sourceTile.getFeatures();\\n    if (renderOrder && renderOrder !== replayState.renderedRenderOrder) {\\n      features.sort(renderOrder);\\n    }\\n    for (let i = 0, ii = features.length; i < ii; ++i) {\\n      const feature = features[i];\\n      if (reproject) {\\n        if (tileProjection.getUnits() == Units.TILE_PIXELS) {\\n          // projected tile extent\\n          tileProjection.setWorldExtent(sourceTileExtent);\\n          // tile extent in tile pixel space\\n          tileProjection.setExtent(sourceTile.getExtent());\\n        }\\n        feature.getGeometry().transform(tileProjection, projection);\\n      }\\n      if (!bufferedExtent || intersects(bufferedExtent, feature.getGeometry().getExtent())) {\\n        render.call(this, feature);\\n      }\\n    }\\n    replayGroup.finish();\\n    for (const r in replayGroup.getReplays()) {\\n      zIndexKeys[r] = true;\\n    }\\n    sourceTile.setReplayGroup(layer, tile.tileCoord.toString(), replayGroup);\\n  }\\n  replayState.renderedRevision = revision;\\n  replayState.renderedRenderOrder = renderOrder;\\n};\\n\\n\\n/**\\n * @inheritDoc\\n */\\nCanvasVectorTileLayerRenderer.prototype.forEachFeatureAtCoordinate = function(coordinate, frameState, hitTolerance, callback, thisArg) {\\n  const resolution = frameState.viewState.resolution;\\n  const rotation = frameState.viewState.rotation;\\n  hitTolerance = hitTolerance == undefined ? 0 : hitTolerance;\\n  const layer = this.getLayer();\\n  /** @type {!Object.<string, boolean>} */\\n  const features = {};\\n\\n  /** @type {Array.<module:ol/VectorImageTile>} */\\n  const renderedTiles = this.renderedTiles;\\n\\n  let bufferedExtent, found;\\n  let i, ii, replayGroup;\\n  for (i = 0, ii = renderedTiles.length; i < ii; ++i) {\\n    const tile = renderedTiles[i];\\n    bufferedExtent = buffer(tile.extent, hitTolerance * resolution, bufferedExtent);\\n    if (!containsCoordinate(bufferedExtent, coordinate)) {\\n      continue;\\n    }\\n    for (let t = 0, tt = tile.tileKeys.length; t < tt; ++t) {\\n      const sourceTile = tile.getTile(tile.tileKeys[t]);\\n      if (sourceTile.getState() != TileState.LOADED) {\\n        continue;\\n      }\\n      replayGroup = sourceTile.getReplayGroup(layer, tile.tileCoord.toString());\\n      found = found || replayGroup.forEachFeatureAtCoordinate(coordinate, resolution, rotation, hitTolerance, {},\\n        /**\\n         * @param {module:ol/Feature|module:ol/render/Feature} feature Feature.\\n         * @return {?} Callback result.\\n         */\\n        function(feature) {\\n          const key = getUid(feature).toString();\\n          if (!(key in features)) {\\n            features[key] = true;\\n            return callback.call(thisArg, feature, layer);\\n          }\\n        }, null);\\n    }\\n  }\\n  return found;\\n};\\n\\n\\n/**\\n * @param {module:ol/VectorTile} tile Tile.\\n * @param {module:ol/PluggableMap~FrameState} frameState Frame state.\\n * @return {module:ol/transform~Transform} transform Transform.\\n * @private\\n */\\nCanvasVectorTileLayerRenderer.prototype.getReplayTransform_ = function(tile, frameState) {\\n  const layer = this.getLayer();\\n  const source = /** @type {module:ol/source/VectorTile} */ (layer.getSource());\\n  const tileGrid = source.getTileGrid();\\n  const tileCoord = tile.tileCoord;\\n  const tileResolution = tileGrid.getResolution(tileCoord[0]);\\n  const viewState = frameState.viewState;\\n  const pixelRatio = frameState.pixelRatio;\\n  const renderResolution = viewState.resolution / pixelRatio;\\n  const tileExtent = tileGrid.getTileCoordExtent(tileCoord, this.tmpExtent);\\n  const center = viewState.center;\\n  const origin = getTopLeft(tileExtent);\\n  const size = frameState.size;\\n  const offsetX = Math.round(pixelRatio * size[0] / 2);\\n  const offsetY = Math.round(pixelRatio * size[1] / 2);\\n  return composeTransform(this.tmpTransform_,\\n    offsetX, offsetY,\\n    tileResolution / renderResolution, tileResolution / renderResolution,\\n    viewState.rotation,\\n    (origin[0] - center[0]) / tileResolution,\\n    (center[1] - origin[1]) / tileResolution);\\n};\\n\\n\\n/**\\n * @param {module:ol/events/Event} event Event.\\n */\\nCanvasVectorTileLayerRenderer.prototype.handleFontsChanged_ = function(event) {\\n  const layer = this.getLayer();\\n  if (layer.getVisible() && this.renderedLayerRevision_ !== undefined) {\\n    layer.changed();\\n  }\\n};\\n\\n\\n/**\\n * Handle changes in image style state.\\n * @param {module:ol/events/Event} event Image style change event.\\n * @private\\n */\\nCanvasVectorTileLayerRenderer.prototype.handleStyleImageChange_ = function(event) {\\n  this.renderIfReadyAndVisible();\\n};\\n\\n\\n/**\\n * @inheritDoc\\n */\\nCanvasVectorTileLayerRenderer.prototype.postCompose = function(context, frameState, layerState) {\\n  const layer = this.getLayer();\\n  const declutterReplays = layer.getDeclutter() ? {} : null;\\n  const source = /** @type {module:ol/source/VectorTile} */ (layer.getSource());\\n  const renderMode = layer.getRenderMode();\\n  const replayTypes = VECTOR_REPLAYS[renderMode];\\n  const pixelRatio = frameState.pixelRatio;\\n  const rotation = frameState.viewState.rotation;\\n  const size = frameState.size;\\n  let offsetX, offsetY;\\n  if (rotation) {\\n    offsetX = Math.round(pixelRatio * size[0] / 2);\\n    offsetY = Math.round(pixelRatio * size[1] / 2);\\n    rotateAtOffset(context, -rotation, offsetX, offsetY);\\n  }\\n  if (declutterReplays) {\\n    this.declutterTree_.clear();\\n  }\\n  const tiles = this.renderedTiles;\\n  const tileGrid = source.getTileGridForProjection(frameState.viewState.projection);\\n  const clips = [];\\n  const zs = [];\\n  for (let i = tiles.length - 1; i >= 0; --i) {\\n    const tile = /** @type {module:ol/VectorImageTile} */ (tiles[i]);\\n    if (tile.getState() == TileState.ABORT) {\\n      continue;\\n    }\\n    const tileCoord = tile.tileCoord;\\n    const worldOffset = tileGrid.getTileCoordExtent(tileCoord, this.tmpExtent)[0] - tile.extent[0];\\n    let transform = undefined;\\n    for (let t = 0, tt = tile.tileKeys.length; t < tt; ++t) {\\n      const sourceTile = tile.getTile(tile.tileKeys[t]);\\n      if (sourceTile.getState() != TileState.LOADED) {\\n        continue;\\n      }\\n      const replayGroup = sourceTile.getReplayGroup(layer, tileCoord.toString());\\n      if (renderMode != VectorTileRenderType.VECTOR && !replayGroup.hasReplays(replayTypes)) {\\n        continue;\\n      }\\n      if (!transform) {\\n        transform = this.getTransform(frameState, worldOffset);\\n      }\\n      const currentZ = sourceTile.tileCoord[0];\\n      const currentClip = replayGroup.getClipCoords(transform);\\n      context.save();\\n      context.globalAlpha = layerState.opacity;\\n      // Create a clip mask for regions in this low resolution tile that are\\n      // already filled by a higher resolution tile\\n      for (let j = 0, jj = clips.length; j < jj; ++j) {\\n        const clip = clips[j];\\n        if (currentZ < zs[j]) {\\n          context.beginPath();\\n          // counter-clockwise (outer ring) for current tile\\n          context.moveTo(currentClip[0], currentClip[1]);\\n          context.lineTo(currentClip[2], currentClip[3]);\\n          context.lineTo(currentClip[4], currentClip[5]);\\n          context.lineTo(currentClip[6], currentClip[7]);\\n          // clockwise (inner ring) for higher resolution tile\\n          context.moveTo(clip[6], clip[7]);\\n          context.lineTo(clip[4], clip[5]);\\n          context.lineTo(clip[2], clip[3]);\\n          context.lineTo(clip[0], clip[1]);\\n          context.clip();\\n        }\\n      }\\n      replayGroup.replay(context, transform, rotation, {}, replayTypes, declutterReplays);\\n      context.restore();\\n      clips.push(currentClip);\\n      zs.push(currentZ);\\n    }\\n  }\\n  if (declutterReplays) {\\n    replayDeclutter(declutterReplays, context, rotation);\\n  }\\n  if (rotation) {\\n    rotateAtOffset(context, rotation,\\n      /** @type {number} */ (offsetX), /** @type {number} */ (offsetY));\\n  }\\n  CanvasTileLayerRenderer.prototype.postCompose.apply(this, arguments);\\n};\\n\\n\\n/**\\n * @param {module:ol/Feature|module:ol/render/Feature} feature Feature.\\n * @param {number} squaredTolerance Squared tolerance.\\n * @param {(module:ol/style/Style|Array.<module:ol/style/Style>)} styles The style or array of styles.\\n * @param {module:ol/render/canvas/ReplayGroup} replayGroup Replay group.\\n * @return {boolean} `true` if an image is loading.\\n */\\nCanvasVectorTileLayerRenderer.prototype.renderFeature = function(feature, squaredTolerance, styles, replayGroup) {\\n  if (!styles) {\\n    return false;\\n  }\\n  let loading = false;\\n  if (Array.isArray(styles)) {\\n    for (let i = 0, ii = styles.length; i < ii; ++i) {\\n      loading = renderFeature(\\n        replayGroup, feature, styles[i], squaredTolerance,\\n        this.handleStyleImageChange_, this) || loading;\\n    }\\n  } else {\\n    loading = renderFeature(\\n      replayGroup, feature, styles, squaredTolerance,\\n      this.handleStyleImageChange_, this);\\n  }\\n  return loading;\\n};\\n\\n\\n/**\\n * @param {module:ol/VectorImageTile} tile Tile.\\n * @param {number} pixelRatio Pixel ratio.\\n * @param {module:ol/proj/Projection} projection Projection.\\n * @private\\n */\\nCanvasVectorTileLayerRenderer.prototype.renderTileImage_ = function(\\n  tile, pixelRatio, projection) {\\n  const layer = this.getLayer();\\n  const replayState = tile.getReplayState(layer);\\n  const revision = layer.getRevision();\\n  const replays = IMAGE_REPLAYS[layer.getRenderMode()];\\n  if (replays && replayState.renderedTileRevision !== revision) {\\n    replayState.renderedTileRevision = revision;\\n    const tileCoord = tile.wrappedTileCoord;\\n    const z = tileCoord[0];\\n    const source = /** @type {module:ol/source/VectorTile} */ (layer.getSource());\\n    const tileGrid = source.getTileGridForProjection(projection);\\n    const resolution = tileGrid.getResolution(z);\\n    const context = tile.getContext(layer);\\n    const size = source.getTilePixelSize(z, pixelRatio, projection);\\n    context.canvas.width = size[0];\\n    context.canvas.height = size[1];\\n    const tileExtent = tileGrid.getTileCoordExtent(tileCoord, this.tmpExtent);\\n    for (let i = 0, ii = tile.tileKeys.length; i < ii; ++i) {\\n      const sourceTile = tile.getTile(tile.tileKeys[i]);\\n      if (sourceTile.getState() != TileState.LOADED) {\\n        continue;\\n      }\\n      const pixelScale = pixelRatio / resolution;\\n      const transform = resetTransform(this.tmpTransform_);\\n      scaleTransform(transform, pixelScale, -pixelScale);\\n      translateTransform(transform, -tileExtent[0], -tileExtent[3]);\\n      const replayGroup = sourceTile.getReplayGroup(layer, tile.tileCoord.toString());\\n      replayGroup.replay(context, transform, 0, {}, replays);\\n    }\\n  }\\n};\\n\\nexport default CanvasVectorTileLayerRenderer;\\n\",\"/**\\n * @module ol/Map\\n */\\nimport {inherits} from './index.js';\\nimport PluggableMap from './PluggableMap.js';\\nimport {defaults as defaultControls} from './control/util.js';\\nimport {defaults as defaultInteractions} from './interaction.js';\\nimport {assign} from './obj.js';\\nimport CanvasImageLayerRenderer from './renderer/canvas/ImageLayer.js';\\nimport CanvasMapRenderer from './renderer/canvas/Map.js';\\nimport CanvasTileLayerRenderer from './renderer/canvas/TileLayer.js';\\nimport CanvasVectorLayerRenderer from './renderer/canvas/VectorLayer.js';\\nimport CanvasVectorTileLayerRenderer from './renderer/canvas/VectorTileLayer.js';\\n\\n/**\\n * @classdesc\\n * The map is the core component of OpenLayers. For a map to render, a view,\\n * one or more layers, and a target container are needed:\\n *\\n *     import Map from 'ol/Map';\\n *     import View from 'ol/View';\\n *     import TileLayer from 'ol/layer/Tile';\\n *     import OSM from 'ol/source/OSM';\\n *\\n *     var map = new Map({\\n *       view: new View({\\n *         center: [0, 0],\\n *         zoom: 1\\n *       }),\\n *       layers: [\\n *         new TileLayer({\\n *           source: new OSM()\\n *         })\\n *       ],\\n *       target: 'map'\\n *     });\\n *\\n * The above snippet creates a map using a {@link module:ol/layer/Tile} to\\n * display {@link module:ol/source/OSM~OSM} OSM data and render it to a DOM\\n * element with the id `map`.\\n *\\n * The constructor places a viewport container (with CSS class name\\n * `ol-viewport`) in the target element (see `getViewport()`), and then two\\n * further elements within the viewport: one with CSS class name\\n * `ol-overlaycontainer-stopevent` for controls and some overlays, and one with\\n * CSS class name `ol-overlaycontainer` for other overlays (see the `stopEvent`\\n * option of {@link module:ol/Overlay~Overlay} for the difference). The map\\n * itself is placed in a further element within the viewport.\\n *\\n * Layers are stored as a {@link module:ol/Collection~Collection} in\\n * layerGroups. A top-level group is provided by the library. This is what is\\n * accessed by `getLayerGroup` and `setLayerGroup`. Layers entered in the\\n * options are added to this group, and `addLayer` and `removeLayer` change the\\n * layer collection in the group. `getLayers` is a convenience function for\\n * `getLayerGroup().getLayers()`. Note that {@link module:ol/layer/Group~Group}\\n * is a subclass of {@link module:ol/layer/Base}, so layers entered in the\\n * options or added with `addLayer` can be groups, which can contain further\\n * groups, and so on.\\n *\\n * @constructor\\n * @extends {module:ol/PluggableMap}\\n * @param {module:ol/PluggableMap~MapOptions} options Map options.\\n * @fires module:ol/MapBrowserEvent~MapBrowserEvent\\n * @fires module:ol/MapEvent~MapEvent\\n * @fires module:ol/render/Event~RenderEvent#postcompose\\n * @fires module:ol/render/Event~RenderEvent#precompose\\n * @api\\n */\\nconst Map = function(options) {\\n  options = assign({}, options);\\n  if (!options.controls) {\\n    options.controls = defaultControls();\\n  }\\n  if (!options.interactions) {\\n    options.interactions = defaultInteractions();\\n  }\\n\\n  PluggableMap.call(this, options);\\n};\\n\\ninherits(Map, PluggableMap);\\n\\nMap.prototype.createRenderer = function() {\\n  const renderer = new CanvasMapRenderer(this);\\n  renderer.registerLayerRenderers([\\n    CanvasImageLayerRenderer,\\n    CanvasTileLayerRenderer,\\n    CanvasVectorLayerRenderer,\\n    CanvasVectorTileLayerRenderer\\n  ]);\\n  return renderer;\\n};\\n\\nexport default Map;\\n\",\"/**\\n * @module ol/control/util\\n */\\nimport Collection from '../Collection.js';\\nimport Attribution from './Attribution.js';\\nimport Rotate from './Rotate.js';\\nimport Zoom from './Zoom.js';\\n\\n\\n/**\\n * @typedef {Object} DefaultsOptions\\n * @property {boolean} [attribution=true] Include\\n * {@link module:ol/control/Attribution~Attribution}.\\n * @property {module:ol/control/Attribution~Options} [attributionOptions]\\n * Options for {@link module:ol/control/Attribution~Attribution}.\\n * @property {boolean} [rotate=true] Include\\n * {@link module:ol/control/Rotate~Rotate}.\\n * @property {module:ol/control/Rotate~Options} [rotateOptions] Options\\n * for {@link module:ol/control/Rotate~Rotate}.\\n * @property {boolean} [zoom] Include {@link module:ol/control/Zoom~Zoom}.\\n * @property {module:ol/control/Zoom~Options} [zoomOptions] Options for\\n * {@link module:ol/control/Zoom~Zoom}.\\n * @api\\n */\\n\\n\\n/**\\n * Set of controls included in maps by default. Unless configured otherwise,\\n * this returns a collection containing an instance of each of the following\\n * controls:\\n * * {@link module:ol/control/Zoom~Zoom}\\n * * {@link module:ol/control/Rotate~Rotate}\\n * * {@link module:ol/control/Attribution~Attribution}\\n *\\n * @param {module:ol/control/util~DefaultsOptions=} opt_options\\n * Defaults options.\\n * @return {module:ol/Collection.<module:ol/control/Control>}\\n * Controls.\\n * @function module:ol/control.defaults\\n * @api\\n */\\nexport function defaults(opt_options) {\\n\\n  const options = opt_options ? opt_options : {};\\n\\n  const controls = new Collection();\\n\\n  const zoomControl = options.zoom !== undefined ? options.zoom : true;\\n  if (zoomControl) {\\n    controls.push(new Zoom(options.zoomOptions));\\n  }\\n\\n  const rotateControl = options.rotate !== undefined ? options.rotate : true;\\n  if (rotateControl) {\\n    controls.push(new Rotate(options.rotateOptions));\\n  }\\n\\n  const attributionControl = options.attribution !== undefined ?\\n    options.attribution : true;\\n  if (attributionControl) {\\n    controls.push(new Attribution(options.attributionOptions));\\n  }\\n\\n  return controls;\\n}\\n\",\"/**\\n * @module ol/interaction\\n */\\nimport Collection from './Collection.js';\\nimport Kinetic from './Kinetic.js';\\nimport DoubleClickZoom from './interaction/DoubleClickZoom.js';\\nimport DragPan from './interaction/DragPan.js';\\nimport DragRotate from './interaction/DragRotate.js';\\nimport DragZoom from './interaction/DragZoom.js';\\nimport KeyboardPan from './interaction/KeyboardPan.js';\\nimport KeyboardZoom from './interaction/KeyboardZoom.js';\\nimport MouseWheelZoom from './interaction/MouseWheelZoom.js';\\nimport PinchRotate from './interaction/PinchRotate.js';\\nimport PinchZoom from './interaction/PinchZoom.js';\\n\\nexport {default as DoubleClickZoom} from './interaction/DoubleClickZoom.js';\\nexport {default as DragAndDrop} from './interaction/DragAndDrop.js';\\nexport {default as DragBox} from './interaction/DragBox.js';\\nexport {default as DragPan} from './interaction/DragPan.js';\\nexport {default as DragRotate} from './interaction/DragRotate.js';\\nexport {default as DragRotateAndZoom} from './interaction/DragRotateAndZoom.js';\\nexport {default as DragZoom} from './interaction/DragZoom.js';\\nexport {default as Draw} from './interaction/Draw.js';\\nexport {default as Extent} from './interaction/Extent.js';\\nexport {default as Interaction} from './interaction/Interaction.js';\\nexport {default as KeyboardPan} from './interaction/KeyboardPan.js';\\nexport {default as KeyboardZoom} from './interaction/KeyboardZoom.js';\\nexport {default as Modify} from './interaction/Modify.js';\\nexport {default as MouseWheelZoom} from './interaction/MouseWheelZoom.js';\\nexport {default as PinchRotate} from './interaction/PinchRotate.js';\\nexport {default as PinchZoom} from './interaction/PinchZoom.js';\\nexport {default as Pointer} from './interaction/Pointer.js';\\nexport {default as Select} from './interaction/Select.js';\\nexport {default as Snap} from './interaction/Snap.js';\\nexport {default as Translate} from './interaction/Translate.js';\\n\\n\\n/**\\n * @typedef {Object} DefaultsOptions\\n * @property {boolean} [altShiftDragRotate=true] Whether Alt-Shift-drag rotate is\\n * desired.\\n * @property {boolean} [constrainResolution=false] Zoom to the closest integer\\n * zoom level after the wheel/trackpad or pinch gesture ends.\\n * @property {boolean} [doubleClickZoom=true] Whether double click zoom is\\n * desired.\\n * @property {boolean} [keyboard=true] Whether keyboard interaction is desired.\\n * @property {boolean} [mouseWheelZoom=true] Whether mousewheel zoom is desired.\\n * @property {boolean} [shiftDragZoom=true] Whether Shift-drag zoom is desired.\\n * @property {boolean} [dragPan=true] Whether drag pan is desired.\\n * @property {boolean} [pinchRotate=true] Whether pinch rotate is desired.\\n * @property {boolean} [pinchZoom=true] Whether pinch zoom is desired.\\n * @property {number} [zoomDelta] Zoom level delta when using keyboard or\\n * mousewheel zoom.\\n * @property {number} [zoomDuration] Duration of the zoom animation in\\n * milliseconds.\\n */\\n\\n\\n/**\\n * Set of interactions included in maps by default. Specific interactions can be\\n * excluded by setting the appropriate option to false in the constructor\\n * options, but the order of the interactions is fixed.  If you want to specify\\n * a different order for interactions, you will need to create your own\\n * {@link module:ol/interaction/Interaction} instances and insert\\n * them into a {@link module:ol/Collection} in the order you want\\n * before creating your {@link module:ol/Map~Map} instance. The default set of\\n * interactions, in sequence, is:\\n * * {@link module:ol/interaction/DragRotate~DragRotate}\\n * * {@link module:ol/interaction/DoubleClickZoom~DoubleClickZoom}\\n * * {@link module:ol/interaction/DragPan~DragPan}\\n * * {@link module:ol/interaction/PinchRotate~PinchRotate}\\n * * {@link module:ol/interaction/PinchZoom~PinchZoom}\\n * * {@link module:ol/interaction/KeyboardPan~KeyboardPan}\\n * * {@link module:ol/interaction/KeyboardZoom~KeyboardZoom}\\n * * {@link module:ol/interaction/MouseWheelZoom~MouseWheelZoom}\\n * * {@link module:ol/interaction/DragZoom~DragZoom}\\n *\\n * @param {module:ol/interaction/Interaction~DefaultsOptions=} opt_options\\n * Defaults options.\\n * @return {module:ol/Collection.<module:ol/interaction/Interaction>}\\n * A collection of interactions to be used with the {@link module:ol/Map~Map}\\n * constructor's `interactions` option.\\n * @api\\n */\\nexport function defaults(opt_options) {\\n\\n  const options = opt_options ? opt_options : {};\\n\\n  const interactions = new Collection();\\n\\n  const kinetic = new Kinetic(-0.005, 0.05, 100);\\n\\n  const altShiftDragRotate = options.altShiftDragRotate !== undefined ?\\n    options.altShiftDragRotate : true;\\n  if (altShiftDragRotate) {\\n    interactions.push(new DragRotate());\\n  }\\n\\n  const doubleClickZoom = options.doubleClickZoom !== undefined ?\\n    options.doubleClickZoom : true;\\n  if (doubleClickZoom) {\\n    interactions.push(new DoubleClickZoom({\\n      delta: options.zoomDelta,\\n      duration: options.zoomDuration\\n    }));\\n  }\\n\\n  const dragPan = options.dragPan !== undefined ? options.dragPan : true;\\n  if (dragPan) {\\n    interactions.push(new DragPan({\\n      kinetic: kinetic\\n    }));\\n  }\\n\\n  const pinchRotate = options.pinchRotate !== undefined ? options.pinchRotate :\\n    true;\\n  if (pinchRotate) {\\n    interactions.push(new PinchRotate());\\n  }\\n\\n  const pinchZoom = options.pinchZoom !== undefined ? options.pinchZoom : true;\\n  if (pinchZoom) {\\n    interactions.push(new PinchZoom({\\n      constrainResolution: options.constrainResolution,\\n      duration: options.zoomDuration\\n    }));\\n  }\\n\\n  const keyboard = options.keyboard !== undefined ? options.keyboard : true;\\n  if (keyboard) {\\n    interactions.push(new KeyboardPan());\\n    interactions.push(new KeyboardZoom({\\n      delta: options.zoomDelta,\\n      duration: options.zoomDuration\\n    }));\\n  }\\n\\n  const mouseWheelZoom = options.mouseWheelZoom !== undefined ?\\n    options.mouseWheelZoom : true;\\n  if (mouseWheelZoom) {\\n    interactions.push(new MouseWheelZoom({\\n      constrainResolution: options.constrainResolution,\\n      duration: options.zoomDuration\\n    }));\\n  }\\n\\n  const shiftDragZoom = options.shiftDragZoom !== undefined ?\\n    options.shiftDragZoom : true;\\n  if (shiftDragZoom) {\\n    interactions.push(new DragZoom({\\n      duration: options.zoomDuration\\n    }));\\n  }\\n\\n  return interactions;\\n\\n}\\n\",\"/**\\n * @module ol/layer/TileProperty\\n */\\n\\n/**\\n * @enum {string}\\n */\\nexport default {\\n  PRELOAD: 'preload',\\n  USE_INTERIM_TILES_ON_ERROR: 'useInterimTilesOnError'\\n};\\n\",\"/**\\n * @module ol/layer/Tile\\n */\\nimport {inherits} from '../index.js';\\nimport LayerType from '../LayerType.js';\\nimport Layer from '../layer/Layer.js';\\nimport TileProperty from '../layer/TileProperty.js';\\nimport {assign} from '../obj.js';\\n\\n\\n/**\\n * @typedef {Object} Options\\n * @property {number} [opacity=1] Opacity (0, 1).\\n * @property {boolean} [visible=true] Visibility.\\n * @property {module:ol/extent~Extent} [extent] The bounding extent for layer rendering.  The layer will not be\\n * rendered outside of this extent.\\n * @property {number} [zIndex=0] The z-index for layer rendering.  At rendering time, the layers\\n * will be ordered, first by Z-index and then by position.\\n * @property {number} [minResolution] The minimum resolution (inclusive) at which this layer will be\\n * visible.\\n * @property {number} [maxResolution] The maximum resolution (exclusive) below which this layer will\\n * be visible.\\n * @property {number} [preload=0] Preload. Load low-resolution tiles up to `preload` levels. `0`\\n * means no preloading.\\n * @property {module:ol/source/Tile} [source] Source for this layer.\\n * @property {module:ol/PluggableMap} [map] Sets the layer as overlay on a map. The map will not manage\\n * this layer in its layers collection, and the layer will be rendered on top. This is useful for\\n * temporary layers. The standard way to add a layer to a map and have it managed by the map is to\\n * use {@link module:ol/Map#addLayer}.\\n * @property {boolean} [useInterimTilesOnError=true] Use interim tiles on error.\\n */\\n\\n\\n/**\\n * @classdesc\\n * For layer sources that provide pre-rendered, tiled images in grids that are\\n * organized by zoom levels for specific resolutions.\\n * Note that any property set in the options is set as a {@link module:ol/Object~BaseObject}\\n * property on the layer object; for example, setting `title: 'My Title'` in the\\n * options means that `title` is observable, and has get/set accessors.\\n *\\n * @constructor\\n * @extends {module:ol/layer/Layer}\\n * @fires module:ol/render/Event~RenderEvent\\n * @param {module:ol/layer/Tile~Options=} opt_options Tile layer options.\\n * @api\\n */\\nconst TileLayer = function(opt_options) {\\n  const options = opt_options ? opt_options : {};\\n\\n  const baseOptions = assign({}, options);\\n\\n  delete baseOptions.preload;\\n  delete baseOptions.useInterimTilesOnError;\\n  Layer.call(this,  /** @type {module:ol/layer/Layer~Options} */ (baseOptions));\\n\\n  this.setPreload(options.preload !== undefined ? options.preload : 0);\\n  this.setUseInterimTilesOnError(options.useInterimTilesOnError !== undefined ?\\n    options.useInterimTilesOnError : true);\\n\\n  /**\\n   * The layer type.\\n   * @protected\\n   * @type {module:ol/LayerType}\\n   */\\n  this.type = LayerType.TILE;\\n\\n};\\n\\ninherits(TileLayer, Layer);\\n\\n\\n/**\\n * Return the level as number to which we will preload tiles up to.\\n * @return {number} The level to preload tiles up to.\\n * @observable\\n * @api\\n */\\nTileLayer.prototype.getPreload = function() {\\n  return /** @type {number} */ (this.get(TileProperty.PRELOAD));\\n};\\n\\n\\n/**\\n * Return the associated {@link module:ol/source/Tile tilesource} of the layer.\\n * @function\\n * @return {module:ol/source/Tile} Source.\\n * @api\\n */\\nTileLayer.prototype.getSource;\\n\\n\\n/**\\n * Set the level as number to which we will preload tiles up to.\\n * @param {number} preload The level to preload tiles up to.\\n * @observable\\n * @api\\n */\\nTileLayer.prototype.setPreload = function(preload) {\\n  this.set(TileProperty.PRELOAD, preload);\\n};\\n\\n\\n/**\\n * Whether we use interim tiles on error.\\n * @return {boolean} Use interim tiles on error.\\n * @observable\\n * @api\\n */\\nTileLayer.prototype.getUseInterimTilesOnError = function() {\\n  return /** @type {boolean} */ (this.get(TileProperty.USE_INTERIM_TILES_ON_ERROR));\\n};\\n\\n\\n/**\\n * Set whether we use interim tiles on error.\\n * @param {boolean} useInterimTilesOnError Use interim tiles on error.\\n * @observable\\n * @api\\n */\\nTileLayer.prototype.setUseInterimTilesOnError = function(useInterimTilesOnError) {\\n  this.set(TileProperty.USE_INTERIM_TILES_ON_ERROR, useInterimTilesOnError);\\n};\\nexport default TileLayer;\\n\",\"/**\\n * @module ol/Tile\\n */\\nimport {inherits} from './index.js';\\nimport TileState from './TileState.js';\\nimport {easeIn} from './easing.js';\\nimport EventTarget from './events/EventTarget.js';\\nimport EventType from './events/EventType.js';\\n\\n\\n/**\\n * A function that takes an {@link module:ol/Tile} for the tile and a\\n * `{string}` for the url as arguments.\\n *\\n * @typedef {function(module:ol/Tile, string)} LoadFunction\\n * @api\\n */\\n\\n/**\\n * {@link module:ol/source/Tile~Tile} sources use a function of this type to get\\n * the url that provides a tile for a given tile coordinate.\\n *\\n * This function takes an {@link module:ol/tilecoord~TileCoord} for the tile\\n * coordinate, a `{number}` representing the pixel ratio and a\\n * {@link module:ol/proj/Projection} for the projection  as arguments\\n * and returns a `{string}` representing the tile URL, or undefined if no tile\\n * should be requested for the passed tile coordinate.\\n *\\n * @typedef {function(module:ol/tilecoord~TileCoord, number,\\n *           module:ol/proj/Projection): (string|undefined)} UrlFunction\\n * @api\\n */\\n\\n\\n/**\\n * @typedef {Object} Options\\n * @property {number} [transition=250] A duration for tile opacity\\n * transitions in milliseconds. A duration of 0 disables the opacity transition.\\n * @api\\n */\\n\\n\\n/**\\n * @classdesc\\n * Base class for tiles.\\n *\\n * @constructor\\n * @abstract\\n * @extends {module:ol/events/EventTarget}\\n * @param {module:ol/tilecoord~TileCoord} tileCoord Tile coordinate.\\n * @param {module:ol/TileState} state State.\\n * @param {module:ol/Tile~Options=} opt_options Tile options.\\n */\\nconst Tile = function(tileCoord, state, opt_options) {\\n  EventTarget.call(this);\\n\\n  const options = opt_options ? opt_options : {};\\n\\n  /**\\n   * @type {module:ol/tilecoord~TileCoord}\\n   */\\n  this.tileCoord = tileCoord;\\n\\n  /**\\n   * @protected\\n   * @type {module:ol/TileState}\\n   */\\n  this.state = state;\\n\\n  /**\\n   * An \\\"interim\\\" tile for this tile. The interim tile may be used while this\\n   * one is loading, for \\\"smooth\\\" transitions when changing params/dimensions\\n   * on the source.\\n   * @type {module:ol/Tile}\\n   */\\n  this.interimTile = null;\\n\\n  /**\\n   * A key assigned to the tile. This is used by the tile source to determine\\n   * if this tile can effectively be used, or if a new tile should be created\\n   * and this one be used as an interim tile for this new tile.\\n   * @type {string}\\n   */\\n  this.key = '';\\n\\n  /**\\n   * The duration for the opacity transition.\\n   * @type {number}\\n   */\\n  this.transition_ = options.transition === undefined ? 250 : options.transition;\\n\\n  /**\\n   * Lookup of start times for rendering transitions.  If the start time is\\n   * equal to -1, the transition is complete.\\n   * @type {Object.<number, number>}\\n   */\\n  this.transitionStarts_ = {};\\n\\n};\\n\\ninherits(Tile, EventTarget);\\n\\n\\n/**\\n * @protected\\n */\\nTile.prototype.changed = function() {\\n  this.dispatchEvent(EventType.CHANGE);\\n};\\n\\n\\n/**\\n * @return {string} Key.\\n */\\nTile.prototype.getKey = function() {\\n  return this.key + '/' + this.tileCoord;\\n};\\n\\n/**\\n * Get the interim tile most suitable for rendering using the chain of interim\\n * tiles. This corresponds to the  most recent tile that has been loaded, if no\\n * such tile exists, the original tile is returned.\\n * @return {!module:ol/Tile} Best tile for rendering.\\n */\\nTile.prototype.getInterimTile = function() {\\n  if (!this.interimTile) {\\n    //empty chain\\n    return this;\\n  }\\n  let tile = this.interimTile;\\n\\n  // find the first loaded tile and return it. Since the chain is sorted in\\n  // decreasing order of creation time, there is no need to search the remainder\\n  // of the list (all those tiles correspond to older requests and will be\\n  // cleaned up by refreshInterimChain)\\n  do {\\n    if (tile.getState() == TileState.LOADED) {\\n      return tile;\\n    }\\n    tile = tile.interimTile;\\n  } while (tile);\\n\\n  // we can not find a better tile\\n  return this;\\n};\\n\\n/**\\n * Goes through the chain of interim tiles and discards sections of the chain\\n * that are no longer relevant.\\n */\\nTile.prototype.refreshInterimChain = function() {\\n  if (!this.interimTile) {\\n    return;\\n  }\\n\\n  let tile = this.interimTile;\\n  let prev = this;\\n\\n  do {\\n    if (tile.getState() == TileState.LOADED) {\\n      //we have a loaded tile, we can discard the rest of the list\\n      //we would could abort any LOADING tile request\\n      //older than this tile (i.e. any LOADING tile following this entry in the chain)\\n      tile.interimTile = null;\\n      break;\\n    } else if (tile.getState() == TileState.LOADING) {\\n      //keep this LOADING tile any loaded tiles later in the chain are\\n      //older than this tile, so we're still interested in the request\\n      prev = tile;\\n    } else if (tile.getState() == TileState.IDLE) {\\n      //the head of the list is the most current tile, we don't need\\n      //to start any other requests for this chain\\n      prev.interimTile = tile.interimTile;\\n    } else {\\n      prev = tile;\\n    }\\n    tile = prev.interimTile;\\n  } while (tile);\\n};\\n\\n/**\\n * Get the tile coordinate for this tile.\\n * @return {module:ol/tilecoord~TileCoord} The tile coordinate.\\n * @api\\n */\\nTile.prototype.getTileCoord = function() {\\n  return this.tileCoord;\\n};\\n\\n\\n/**\\n * @return {module:ol/TileState} State.\\n */\\nTile.prototype.getState = function() {\\n  return this.state;\\n};\\n\\n/**\\n * @param {module:ol/TileState} state State.\\n */\\nTile.prototype.setState = function(state) {\\n  this.state = state;\\n  this.changed();\\n};\\n\\n/**\\n * Load the image or retry if loading previously failed.\\n * Loading is taken care of by the tile queue, and calling this method is\\n * only needed for preloading or for reloading in case of an error.\\n * @abstract\\n * @api\\n */\\nTile.prototype.load = function() {};\\n\\n/**\\n * Get the alpha value for rendering.\\n * @param {number} id An id for the renderer.\\n * @param {number} time The render frame time.\\n * @return {number} A number between 0 and 1.\\n */\\nTile.prototype.getAlpha = function(id, time) {\\n  if (!this.transition_) {\\n    return 1;\\n  }\\n\\n  let start = this.transitionStarts_[id];\\n  if (!start) {\\n    start = time;\\n    this.transitionStarts_[id] = start;\\n  } else if (start === -1) {\\n    return 1;\\n  }\\n\\n  const delta = time - start + (1000 / 60); // avoid rendering at 0\\n  if (delta >= this.transition_) {\\n    return 1;\\n  }\\n  return easeIn(delta / this.transition_);\\n};\\n\\n/**\\n * Determine if a tile is in an alpha transition.  A tile is considered in\\n * transition if tile.getAlpha() has not yet been called or has been called\\n * and returned 1.\\n * @param {number} id An id for the renderer.\\n * @return {boolean} The tile is in transition.\\n */\\nTile.prototype.inTransition = function(id) {\\n  if (!this.transition_) {\\n    return false;\\n  }\\n  return this.transitionStarts_[id] !== -1;\\n};\\n\\n/**\\n * Mark a transition as complete.\\n * @param {number} id An id for the renderer.\\n */\\nTile.prototype.endTransition = function(id) {\\n  if (this.transition_) {\\n    this.transitionStarts_[id] = -1;\\n  }\\n};\\nexport default Tile;\\n\",\"/**\\n * @module ol/ImageTile\\n */\\nimport {inherits} from './index.js';\\nimport Tile from './Tile.js';\\nimport TileState from './TileState.js';\\nimport {createCanvasContext2D} from './dom.js';\\nimport {listenOnce, unlistenByKey} from './events.js';\\nimport EventType from './events/EventType.js';\\n\\n/**\\n * @typedef {function(new: module:ol/ImageTile, module:ol/tilecoord~TileCoord,\\n * module:ol/TileState, string, ?string, module:ol/Tile~LoadFunction)} TileClass\\n * @api\\n */\\n\\n/**\\n * @constructor\\n * @extends {module:ol/Tile}\\n * @param {module:ol/tilecoord~TileCoord} tileCoord Tile coordinate.\\n * @param {module:ol/TileState} state State.\\n * @param {string} src Image source URI.\\n * @param {?string} crossOrigin Cross origin.\\n * @param {module:ol/Tile~LoadFunction} tileLoadFunction Tile load function.\\n * @param {module:ol/Tile~Options=} opt_options Tile options.\\n */\\nconst ImageTile = function(tileCoord, state, src, crossOrigin, tileLoadFunction, opt_options) {\\n\\n  Tile.call(this, tileCoord, state, opt_options);\\n\\n  /**\\n   * @private\\n   * @type {?string}\\n   */\\n  this.crossOrigin_ = crossOrigin;\\n\\n  /**\\n   * Image URI\\n   *\\n   * @private\\n   * @type {string}\\n   */\\n  this.src_ = src;\\n\\n  /**\\n   * @private\\n   * @type {Image|HTMLCanvasElement}\\n   */\\n  this.image_ = new Image();\\n  if (crossOrigin !== null) {\\n    this.image_.crossOrigin = crossOrigin;\\n  }\\n\\n  /**\\n   * @private\\n   * @type {Array.<module:ol/events~EventsKey>}\\n   */\\n  this.imageListenerKeys_ = null;\\n\\n  /**\\n   * @private\\n   * @type {module:ol/Tile~LoadFunction}\\n   */\\n  this.tileLoadFunction_ = tileLoadFunction;\\n\\n};\\n\\ninherits(ImageTile, Tile);\\n\\n\\n/**\\n * @inheritDoc\\n */\\nImageTile.prototype.disposeInternal = function() {\\n  if (this.state == TileState.LOADING) {\\n    this.unlistenImage_();\\n    this.image_ = getBlankImage();\\n  }\\n  if (this.interimTile) {\\n    this.interimTile.dispose();\\n  }\\n  this.state = TileState.ABORT;\\n  this.changed();\\n  Tile.prototype.disposeInternal.call(this);\\n};\\n\\n\\n/**\\n * Get the HTML image element for this tile (may be a Canvas, Image, or Video).\\n * @return {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} Image.\\n * @api\\n */\\nImageTile.prototype.getImage = function() {\\n  return this.image_;\\n};\\n\\n\\n/**\\n * @inheritDoc\\n */\\nImageTile.prototype.getKey = function() {\\n  return this.src_;\\n};\\n\\n\\n/**\\n * Tracks loading or read errors.\\n *\\n * @private\\n */\\nImageTile.prototype.handleImageError_ = function() {\\n  this.state = TileState.ERROR;\\n  this.unlistenImage_();\\n  this.image_ = getBlankImage();\\n  this.changed();\\n};\\n\\n\\n/**\\n * Tracks successful image load.\\n *\\n * @private\\n */\\nImageTile.prototype.handleImageLoad_ = function() {\\n  if (this.image_.naturalWidth && this.image_.naturalHeight) {\\n    this.state = TileState.LOADED;\\n  } else {\\n    this.state = TileState.EMPTY;\\n  }\\n  this.unlistenImage_();\\n  this.changed();\\n};\\n\\n\\n/**\\n * @inheritDoc\\n * @api\\n */\\nImageTile.prototype.load = function() {\\n  if (this.state == TileState.ERROR) {\\n    this.state = TileState.IDLE;\\n    this.image_ = new Image();\\n    if (this.crossOrigin_ !== null) {\\n      this.image_.crossOrigin = this.crossOrigin_;\\n    }\\n  }\\n  if (this.state == TileState.IDLE) {\\n    this.state = TileState.LOADING;\\n    this.changed();\\n    this.imageListenerKeys_ = [\\n      listenOnce(this.image_, EventType.ERROR,\\n        this.handleImageError_, this),\\n      listenOnce(this.image_, EventType.LOAD,\\n        this.handleImageLoad_, this)\\n    ];\\n    this.tileLoadFunction_(this, this.src_);\\n  }\\n};\\n\\n\\n/**\\n * Discards event handlers which listen for load completion or errors.\\n *\\n * @private\\n */\\nImageTile.prototype.unlistenImage_ = function() {\\n  this.imageListenerKeys_.forEach(unlistenByKey);\\n  this.imageListenerKeys_ = null;\\n};\\n\\n\\n/**\\n * Get a 1-pixel blank image.\\n * @return {HTMLCanvasElement} Blank image.\\n */\\nfunction getBlankImage() {\\n  const ctx = createCanvasContext2D(1, 1);\\n  ctx.fillStyle = 'rgba(0,0,0,0)';\\n  ctx.fillRect(0, 0, 1, 1);\\n  return ctx.canvas;\\n}\\n\\nexport default ImageTile;\\n\",\"/**\\n * @module ol/tilecoord\\n */\\n\\n\\n/**\\n * An array of three numbers representing the location of a tile in a tile\\n * grid. The order is `z`, `x`, and `y`. `z` is the zoom level.\\n * @typedef {Array.<number>} TileCoord\\n * @api\\n */\\n\\n\\n/**\\n * @param {number} z Z.\\n * @param {number} x X.\\n * @param {number} y Y.\\n * @param {module:ol/tilecoord~TileCoord=} opt_tileCoord Tile coordinate.\\n * @return {module:ol/tilecoord~TileCoord} Tile coordinate.\\n */\\nexport function createOrUpdate(z, x, y, opt_tileCoord) {\\n  if (opt_tileCoord !== undefined) {\\n    opt_tileCoord[0] = z;\\n    opt_tileCoord[1] = x;\\n    opt_tileCoord[2] = y;\\n    return opt_tileCoord;\\n  } else {\\n    return [z, x, y];\\n  }\\n}\\n\\n\\n/**\\n * @param {number} z Z.\\n * @param {number} x X.\\n * @param {number} y Y.\\n * @return {string} Key.\\n */\\nexport function getKeyZXY(z, x, y) {\\n  return z + '/' + x + '/' + y;\\n}\\n\\n\\n/**\\n * Get the key for a tile coord.\\n * @param {module:ol/tilecoord~TileCoord} tileCoord The tile coord.\\n * @return {string} Key.\\n */\\nexport function getKey(tileCoord) {\\n  return getKeyZXY(tileCoord[0], tileCoord[1], tileCoord[2]);\\n}\\n\\n\\n/**\\n * Get a tile coord given a key.\\n * @param {string} key The tile coord key.\\n * @return {module:ol/tilecoord~TileCoord} The tile coord.\\n */\\nexport function fromKey(key) {\\n  return key.split('/').map(Number);\\n}\\n\\n\\n/**\\n * @param {module:ol/tilecoord~TileCoord} tileCoord Tile coord.\\n * @return {number} Hash.\\n */\\nexport function hash(tileCoord) {\\n  return (tileCoord[1] << tileCoord[0]) + tileCoord[2];\\n}\\n\\n\\n/**\\n * @param {module:ol/tilecoord~TileCoord} tileCoord Tile coord.\\n * @return {string} Quad key.\\n */\\nexport function quadKey(tileCoord) {\\n  const z = tileCoord[0];\\n  const digits = new Array(z);\\n  let mask = 1 << (z - 1);\\n  let i, charCode;\\n  for (i = 0; i < z; ++i) {\\n    // 48 is charCode for 0 - '0'.charCodeAt(0)\\n    charCode = 48;\\n    if (tileCoord[1] & mask) {\\n      charCode += 1;\\n    }\\n    if (tileCoord[2] & mask) {\\n      charCode += 2;\\n    }\\n    digits[i] = String.fromCharCode(charCode);\\n    mask >>= 1;\\n  }\\n  return digits.join('');\\n}\\n\\n\\n/**\\n * @param {module:ol/tilecoord~TileCoord} tileCoord Tile coordinate.\\n * @param {!module:ol/tilegrid/TileGrid} tileGrid Tile grid.\\n * @return {boolean} Tile coordinate is within extent and zoom level range.\\n */\\nexport function withinExtentAndZ(tileCoord, tileGrid) {\\n  const z = tileCoord[0];\\n  const x = tileCoord[1];\\n  const y = tileCoord[2];\\n\\n  if (tileGrid.getMinZoom() > z || z > tileGrid.getMaxZoom()) {\\n    return false;\\n  }\\n  const extent = tileGrid.getExtent();\\n  let tileRange;\\n  if (!extent) {\\n    tileRange = tileGrid.getFullTileRange(z);\\n  } else {\\n    tileRange = tileGrid.getTileRangeForExtentAndZ(extent, z);\\n  }\\n  if (!tileRange) {\\n    return true;\\n  } else {\\n    return tileRange.containsXY(x, y);\\n  }\\n}\\n\",\"/**\\n * @module ol/TileCache\\n */\\nimport {inherits} from './index.js';\\nimport LRUCache from './structs/LRUCache.js';\\nimport {fromKey, getKey} from './tilecoord.js';\\n\\n/**\\n * @constructor\\n * @extends {module:ol/structs/LRUCache.<module:ol/Tile>}\\n * @param {number=} opt_highWaterMark High water mark.\\n * @struct\\n */\\nconst TileCache = function(opt_highWaterMark) {\\n\\n  LRUCache.call(this, opt_highWaterMark);\\n\\n};\\n\\ninherits(TileCache, LRUCache);\\n\\n\\n/**\\n * @param {!Object.<string, module:ol/TileRange>} usedTiles Used tiles.\\n */\\nTileCache.prototype.expireCache = function(usedTiles) {\\n  while (this.canExpireCache()) {\\n    const tile = this.peekLast();\\n    const zKey = tile.tileCoord[0].toString();\\n    if (zKey in usedTiles && usedTiles[zKey].contains(tile.tileCoord)) {\\n      break;\\n    } else {\\n      this.pop().dispose();\\n    }\\n  }\\n};\\n\\n\\n/**\\n * Prune all tiles from the cache that don't have the same z as the newest tile.\\n */\\nTileCache.prototype.pruneExceptNewestZ = function() {\\n  if (this.getCount() === 0) {\\n    return;\\n  }\\n  const key = this.peekFirstKey();\\n  const tileCoord = fromKey(key);\\n  const z = tileCoord[0];\\n  this.forEach(function(tile) {\\n    if (tile.tileCoord[0] !== z) {\\n      this.remove(getKey(tile.tileCoord));\\n      tile.dispose();\\n    }\\n  }, this);\\n};\\nexport default TileCache;\\n\",\"/**\\n * @module ol/reproj\\n */\\nimport {createCanvasContext2D} from './dom.js';\\nimport {containsCoordinate, createEmpty, extend, getHeight, getTopLeft, getWidth} from './extent.js';\\nimport {solveLinearSystem} from './math.js';\\nimport {getPointResolution, transform} from './proj.js';\\n\\n\\n/**\\n * Calculates ideal resolution to use from the source in order to achieve\\n * pixel mapping as close as possible to 1:1 during reprojection.\\n * The resolution is calculated regardless of what resolutions\\n * are actually available in the dataset (TileGrid, Image, ...).\\n *\\n * @param {module:ol/proj/Projection} sourceProj Source projection.\\n * @param {module:ol/proj/Projection} targetProj Target projection.\\n * @param {module:ol/coordinate~Coordinate} targetCenter Target center.\\n * @param {number} targetResolution Target resolution.\\n * @return {number} The best resolution to use. Can be +-Infinity, NaN or 0.\\n */\\nexport function calculateSourceResolution(sourceProj, targetProj,\\n  targetCenter, targetResolution) {\\n\\n  const sourceCenter = transform(targetCenter, targetProj, sourceProj);\\n\\n  // calculate the ideal resolution of the source data\\n  let sourceResolution = getPointResolution(targetProj, targetResolution, targetCenter);\\n\\n  const targetMetersPerUnit = targetProj.getMetersPerUnit();\\n  if (targetMetersPerUnit !== undefined) {\\n    sourceResolution *= targetMetersPerUnit;\\n  }\\n  const sourceMetersPerUnit = sourceProj.getMetersPerUnit();\\n  if (sourceMetersPerUnit !== undefined) {\\n    sourceResolution /= sourceMetersPerUnit;\\n  }\\n\\n  // Based on the projection properties, the point resolution at the specified\\n  // coordinates may be slightly different. We need to reverse-compensate this\\n  // in order to achieve optimal results.\\n\\n  const sourceExtent = sourceProj.getExtent();\\n  if (!sourceExtent || containsCoordinate(sourceExtent, sourceCenter)) {\\n    const compensationFactor = getPointResolution(sourceProj, sourceResolution, sourceCenter) /\\n        sourceResolution;\\n    if (isFinite(compensationFactor) && compensationFactor > 0) {\\n      sourceResolution /= compensationFactor;\\n    }\\n  }\\n\\n  return sourceResolution;\\n}\\n\\n\\n/**\\n * Enlarge the clipping triangle point by 1 pixel to ensure the edges overlap\\n * in order to mask gaps caused by antialiasing.\\n *\\n * @param {number} centroidX Centroid of the triangle (x coordinate in pixels).\\n * @param {number} centroidY Centroid of the triangle (y coordinate in pixels).\\n * @param {number} x X coordinate of the point (in pixels).\\n * @param {number} y Y coordinate of the point (in pixels).\\n * @return {module:ol/coordinate~Coordinate} New point 1 px farther from the centroid.\\n */\\nfunction enlargeClipPoint(centroidX, centroidY, x, y) {\\n  const dX = x - centroidX;\\n  const dY = y - centroidY;\\n  const distance = Math.sqrt(dX * dX + dY * dY);\\n  return [Math.round(x + dX / distance), Math.round(y + dY / distance)];\\n}\\n\\n\\n/**\\n * Renders the source data into new canvas based on the triangulation.\\n *\\n * @param {number} width Width of the canvas.\\n * @param {number} height Height of the canvas.\\n * @param {number} pixelRatio Pixel ratio.\\n * @param {number} sourceResolution Source resolution.\\n * @param {module:ol/extent~Extent} sourceExtent Extent of the data source.\\n * @param {number} targetResolution Target resolution.\\n * @param {module:ol/extent~Extent} targetExtent Target extent.\\n * @param {module:ol/reproj/Triangulation} triangulation\\n * Calculated triangulation.\\n * @param {Array.<{extent: module:ol/extent~Extent,\\n *                 image: (HTMLCanvasElement|Image|HTMLVideoElement)}>} sources\\n * Array of sources.\\n * @param {number} gutter Gutter of the sources.\\n * @param {boolean=} opt_renderEdges Render reprojection edges.\\n * @return {HTMLCanvasElement} Canvas with reprojected data.\\n */\\nexport function render(width, height, pixelRatio,\\n  sourceResolution, sourceExtent, targetResolution, targetExtent,\\n  triangulation, sources, gutter, opt_renderEdges) {\\n\\n  const context = createCanvasContext2D(Math.round(pixelRatio * width),\\n    Math.round(pixelRatio * height));\\n\\n  if (sources.length === 0) {\\n    return context.canvas;\\n  }\\n\\n  context.scale(pixelRatio, pixelRatio);\\n\\n  const sourceDataExtent = createEmpty();\\n  sources.forEach(function(src, i, arr) {\\n    extend(sourceDataExtent, src.extent);\\n  });\\n\\n  const canvasWidthInUnits = getWidth(sourceDataExtent);\\n  const canvasHeightInUnits = getHeight(sourceDataExtent);\\n  const stitchContext = createCanvasContext2D(\\n    Math.round(pixelRatio * canvasWidthInUnits / sourceResolution),\\n    Math.round(pixelRatio * canvasHeightInUnits / sourceResolution));\\n\\n  const stitchScale = pixelRatio / sourceResolution;\\n\\n  sources.forEach(function(src, i, arr) {\\n    const xPos = src.extent[0] - sourceDataExtent[0];\\n    const yPos = -(src.extent[3] - sourceDataExtent[3]);\\n    const srcWidth = getWidth(src.extent);\\n    const srcHeight = getHeight(src.extent);\\n\\n    stitchContext.drawImage(\\n      src.image,\\n      gutter, gutter,\\n      src.image.width - 2 * gutter, src.image.height - 2 * gutter,\\n      xPos * stitchScale, yPos * stitchScale,\\n      srcWidth * stitchScale, srcHeight * stitchScale);\\n  });\\n\\n  const targetTopLeft = getTopLeft(targetExtent);\\n\\n  triangulation.getTriangles().forEach(function(triangle, i, arr) {\\n    /* Calculate affine transform (src -> dst)\\n     * Resulting matrix can be used to transform coordinate\\n     * from `sourceProjection` to destination pixels.\\n     *\\n     * To optimize number of context calls and increase numerical stability,\\n     * we also do the following operations:\\n     * trans(-topLeftExtentCorner), scale(1 / targetResolution), scale(1, -1)\\n     * here before solving the linear system so [ui, vi] are pixel coordinates.\\n     *\\n     * Src points: xi, yi\\n     * Dst points: ui, vi\\n     * Affine coefficients: aij\\n     *\\n     * | x0 y0 1  0  0 0 |   |a00|   |u0|\\n     * | x1 y1 1  0  0 0 |   |a01|   |u1|\\n     * | x2 y2 1  0  0 0 | x |a02| = |u2|\\n     * |  0  0 0 x0 y0 1 |   |a10|   |v0|\\n     * |  0  0 0 x1 y1 1 |   |a11|   |v1|\\n     * |  0  0 0 x2 y2 1 |   |a12|   |v2|\\n     */\\n    const source = triangle.source;\\n    const target = triangle.target;\\n    let x0 = source[0][0], y0 = source[0][1];\\n    let x1 = source[1][0], y1 = source[1][1];\\n    let x2 = source[2][0], y2 = source[2][1];\\n    const u0 = (target[0][0] - targetTopLeft[0]) / targetResolution;\\n    const v0 = -(target[0][1] - targetTopLeft[1]) / targetResolution;\\n    const u1 = (target[1][0] - targetTopLeft[0]) / targetResolution;\\n    const v1 = -(target[1][1] - targetTopLeft[1]) / targetResolution;\\n    const u2 = (target[2][0] - targetTopLeft[0]) / targetResolution;\\n    const v2 = -(target[2][1] - targetTopLeft[1]) / targetResolution;\\n\\n    // Shift all the source points to improve numerical stability\\n    // of all the subsequent calculations. The [x0, y0] is used here.\\n    // This is also used to simplify the linear system.\\n    const sourceNumericalShiftX = x0;\\n    const sourceNumericalShiftY = y0;\\n    x0 = 0;\\n    y0 = 0;\\n    x1 -= sourceNumericalShiftX;\\n    y1 -= sourceNumericalShiftY;\\n    x2 -= sourceNumericalShiftX;\\n    y2 -= sourceNumericalShiftY;\\n\\n    const augmentedMatrix = [\\n      [x1, y1, 0, 0, u1 - u0],\\n      [x2, y2, 0, 0, u2 - u0],\\n      [0, 0, x1, y1, v1 - v0],\\n      [0, 0, x2, y2, v2 - v0]\\n    ];\\n    const affineCoefs = solveLinearSystem(augmentedMatrix);\\n    if (!affineCoefs) {\\n      return;\\n    }\\n\\n    context.save();\\n    context.beginPath();\\n    const centroidX = (u0 + u1 + u2) / 3;\\n    const centroidY = (v0 + v1 + v2) / 3;\\n    const p0 = enlargeClipPoint(centroidX, centroidY, u0, v0);\\n    const p1 = enlargeClipPoint(centroidX, centroidY, u1, v1);\\n    const p2 = enlargeClipPoint(centroidX, centroidY, u2, v2);\\n\\n    context.moveTo(p1[0], p1[1]);\\n    context.lineTo(p0[0], p0[1]);\\n    context.lineTo(p2[0], p2[1]);\\n    context.clip();\\n\\n    context.transform(\\n      affineCoefs[0], affineCoefs[2], affineCoefs[1], affineCoefs[3], u0, v0);\\n\\n    context.translate(sourceDataExtent[0] - sourceNumericalShiftX,\\n      sourceDataExtent[3] - sourceNumericalShiftY);\\n\\n    context.scale(sourceResolution / pixelRatio,\\n      -sourceResolution / pixelRatio);\\n\\n    context.drawImage(stitchContext.canvas, 0, 0);\\n    context.restore();\\n  });\\n\\n  if (opt_renderEdges) {\\n    context.save();\\n\\n    context.strokeStyle = 'black';\\n    context.lineWidth = 1;\\n\\n    triangulation.getTriangles().forEach(function(triangle, i, arr) {\\n      const target = triangle.target;\\n      const u0 = (target[0][0] - targetTopLeft[0]) / targetResolution;\\n      const v0 = -(target[0][1] - targetTopLeft[1]) / targetResolution;\\n      const u1 = (target[1][0] - targetTopLeft[0]) / targetResolution;\\n      const v1 = -(target[1][1] - targetTopLeft[1]) / targetResolution;\\n      const u2 = (target[2][0] - targetTopLeft[0]) / targetResolution;\\n      const v2 = -(target[2][1] - targetTopLeft[1]) / targetResolution;\\n\\n      context.beginPath();\\n      context.moveTo(u1, v1);\\n      context.lineTo(u0, v0);\\n      context.lineTo(u2, v2);\\n      context.closePath();\\n      context.stroke();\\n    });\\n\\n    context.restore();\\n  }\\n  return context.canvas;\\n}\\n\",\"/**\\n * @module ol/reproj/Triangulation\\n */\\nimport {boundingExtent, createEmpty, extendCoordinate, getBottomLeft, getBottomRight,\\n  getTopLeft, getTopRight, getWidth, intersects} from '../extent.js';\\nimport {modulo} from '../math.js';\\nimport {getTransform} from '../proj.js';\\n\\n\\n/**\\n * Single triangle; consists of 3 source points and 3 target points.\\n * @typedef {Object} Triangle\\n * @property {Array.<module:ol/coordinate~Coordinate>} source\\n * @property {Array.<module:ol/coordinate~Coordinate>} target\\n */\\n\\n\\n/**\\n * Maximum number of subdivision steps during raster reprojection triangulation.\\n * Prevents high memory usage and large number of proj4 calls (for certain\\n * transformations and areas). At most `2*(2^this)` triangles are created for\\n * each triangulated extent (tile/image).\\n * @type {number}\\n */\\nconst MAX_SUBDIVISION = 10;\\n\\n\\n/**\\n * Maximum allowed size of triangle relative to world width. When transforming\\n * corners of world extent between certain projections, the resulting\\n * triangulation seems to have zero error and no subdivision is performed. If\\n * the triangle width is more than this (relative to world width; 0-1),\\n * subdivison is forced (up to `MAX_SUBDIVISION`). Default is `0.25`.\\n * @type {number}\\n */\\nconst MAX_TRIANGLE_WIDTH = 0.25;\\n\\n\\n/**\\n * @classdesc\\n * Class containing triangulation of the given target extent.\\n * Used for determining source data and the reprojection itself.\\n *\\n * @param {module:ol/proj/Projection} sourceProj Source projection.\\n * @param {module:ol/proj/Projection} targetProj Target projection.\\n * @param {module:ol/extent~Extent} targetExtent Target extent to triangulate.\\n * @param {module:ol/extent~Extent} maxSourceExtent Maximal source extent that can be used.\\n * @param {number} errorThreshold Acceptable error (in source units).\\n * @constructor\\n */\\nconst Triangulation = function(sourceProj, targetProj, targetExtent,\\n  maxSourceExtent, errorThreshold) {\\n\\n  /**\\n   * @type {module:ol/proj/Projection}\\n   * @private\\n   */\\n  this.sourceProj_ = sourceProj;\\n\\n  /**\\n   * @type {module:ol/proj/Projection}\\n   * @private\\n   */\\n  this.targetProj_ = targetProj;\\n\\n  /** @type {!Object.<string, module:ol/coordinate~Coordinate>} */\\n  let transformInvCache = {};\\n  const transformInv = getTransform(this.targetProj_, this.sourceProj_);\\n\\n  /**\\n   * @param {module:ol/coordinate~Coordinate} c A coordinate.\\n   * @return {module:ol/coordinate~Coordinate} Transformed coordinate.\\n   * @private\\n   */\\n  this.transformInv_ = function(c) {\\n    const key = c[0] + '/' + c[1];\\n    if (!transformInvCache[key]) {\\n      transformInvCache[key] = transformInv(c);\\n    }\\n    return transformInvCache[key];\\n  };\\n\\n  /**\\n   * @type {module:ol/extent~Extent}\\n   * @private\\n   */\\n  this.maxSourceExtent_ = maxSourceExtent;\\n\\n  /**\\n   * @type {number}\\n   * @private\\n   */\\n  this.errorThresholdSquared_ = errorThreshold * errorThreshold;\\n\\n  /**\\n   * @type {Array.<module:ol/reproj/Triangulation~Triangle>}\\n   * @private\\n   */\\n  this.triangles_ = [];\\n\\n  /**\\n   * Indicates that the triangulation crosses edge of the source projection.\\n   * @type {boolean}\\n   * @private\\n   */\\n  this.wrapsXInSource_ = false;\\n\\n  /**\\n   * @type {boolean}\\n   * @private\\n   */\\n  this.canWrapXInSource_ = this.sourceProj_.canWrapX() &&\\n      !!maxSourceExtent &&\\n      !!this.sourceProj_.getExtent() &&\\n      (getWidth(maxSourceExtent) == getWidth(this.sourceProj_.getExtent()));\\n\\n  /**\\n   * @type {?number}\\n   * @private\\n   */\\n  this.sourceWorldWidth_ = this.sourceProj_.getExtent() ?\\n    getWidth(this.sourceProj_.getExtent()) : null;\\n\\n  /**\\n   * @type {?number}\\n   * @private\\n   */\\n  this.targetWorldWidth_ = this.targetProj_.getExtent() ?\\n    getWidth(this.targetProj_.getExtent()) : null;\\n\\n  const destinationTopLeft = getTopLeft(targetExtent);\\n  const destinationTopRight = getTopRight(targetExtent);\\n  const destinationBottomRight = getBottomRight(targetExtent);\\n  const destinationBottomLeft = getBottomLeft(targetExtent);\\n  const sourceTopLeft = this.transformInv_(destinationTopLeft);\\n  const sourceTopRight = this.transformInv_(destinationTopRight);\\n  const sourceBottomRight = this.transformInv_(destinationBottomRight);\\n  const sourceBottomLeft = this.transformInv_(destinationBottomLeft);\\n\\n  this.addQuad_(\\n    destinationTopLeft, destinationTopRight,\\n    destinationBottomRight, destinationBottomLeft,\\n    sourceTopLeft, sourceTopRight, sourceBottomRight, sourceBottomLeft,\\n    MAX_SUBDIVISION);\\n\\n  if (this.wrapsXInSource_) {\\n    let leftBound = Infinity;\\n    this.triangles_.forEach(function(triangle, i, arr) {\\n      leftBound = Math.min(leftBound,\\n        triangle.source[0][0], triangle.source[1][0], triangle.source[2][0]);\\n    });\\n\\n    // Shift triangles to be as close to `leftBound` as possible\\n    // (if the distance is more than `worldWidth / 2` it can be closer.\\n    this.triangles_.forEach(function(triangle) {\\n      if (Math.max(triangle.source[0][0], triangle.source[1][0],\\n        triangle.source[2][0]) - leftBound > this.sourceWorldWidth_ / 2) {\\n        const newTriangle = [[triangle.source[0][0], triangle.source[0][1]],\\n          [triangle.source[1][0], triangle.source[1][1]],\\n          [triangle.source[2][0], triangle.source[2][1]]];\\n        if ((newTriangle[0][0] - leftBound) > this.sourceWorldWidth_ / 2) {\\n          newTriangle[0][0] -= this.sourceWorldWidth_;\\n        }\\n        if ((newTriangle[1][0] - leftBound) > this.sourceWorldWidth_ / 2) {\\n          newTriangle[1][0] -= this.sourceWorldWidth_;\\n        }\\n        if ((newTriangle[2][0] - leftBound) > this.sourceWorldWidth_ / 2) {\\n          newTriangle[2][0] -= this.sourceWorldWidth_;\\n        }\\n\\n        // Rarely (if the extent contains both the dateline and prime meridian)\\n        // the shift can in turn break some triangles.\\n        // Detect this here and don't shift in such cases.\\n        const minX = Math.min(\\n          newTriangle[0][0], newTriangle[1][0], newTriangle[2][0]);\\n        const maxX = Math.max(\\n          newTriangle[0][0], newTriangle[1][0], newTriangle[2][0]);\\n        if ((maxX - minX) < this.sourceWorldWidth_ / 2) {\\n          triangle.source = newTriangle;\\n        }\\n      }\\n    }.bind(this));\\n  }\\n\\n  transformInvCache = {};\\n};\\n\\n\\n/**\\n * Adds triangle to the triangulation.\\n * @param {module:ol/coordinate~Coordinate} a The target a coordinate.\\n * @param {module:ol/coordinate~Coordinate} b The target b coordinate.\\n * @param {module:ol/coordinate~Coordinate} c The target c coordinate.\\n * @param {module:ol/coordinate~Coordinate} aSrc The source a coordinate.\\n * @param {module:ol/coordinate~Coordinate} bSrc The source b coordinate.\\n * @param {module:ol/coordinate~Coordinate} cSrc The source c coordinate.\\n * @private\\n */\\nTriangulation.prototype.addTriangle_ = function(a, b, c,\\n  aSrc, bSrc, cSrc) {\\n  this.triangles_.push({\\n    source: [aSrc, bSrc, cSrc],\\n    target: [a, b, c]\\n  });\\n};\\n\\n\\n/**\\n * Adds quad (points in clock-wise order) to the triangulation\\n * (and reprojects the vertices) if valid.\\n * Performs quad subdivision if needed to increase precision.\\n *\\n * @param {module:ol/coordinate~Coordinate} a The target a coordinate.\\n * @param {module:ol/coordinate~Coordinate} b The target b coordinate.\\n * @param {module:ol/coordinate~Coordinate} c The target c coordinate.\\n * @param {module:ol/coordinate~Coordinate} d The target d coordinate.\\n * @param {module:ol/coordinate~Coordinate} aSrc The source a coordinate.\\n * @param {module:ol/coordinate~Coordinate} bSrc The source b coordinate.\\n * @param {module:ol/coordinate~Coordinate} cSrc The source c coordinate.\\n * @param {module:ol/coordinate~Coordinate} dSrc The source d coordinate.\\n * @param {number} maxSubdivision Maximal allowed subdivision of the quad.\\n * @private\\n */\\nTriangulation.prototype.addQuad_ = function(a, b, c, d,\\n  aSrc, bSrc, cSrc, dSrc, maxSubdivision) {\\n\\n  const sourceQuadExtent = boundingExtent([aSrc, bSrc, cSrc, dSrc]);\\n  const sourceCoverageX = this.sourceWorldWidth_ ?\\n    getWidth(sourceQuadExtent) / this.sourceWorldWidth_ : null;\\n  const sourceWorldWidth = /** @type {number} */ (this.sourceWorldWidth_);\\n\\n  // when the quad is wrapped in the source projection\\n  // it covers most of the projection extent, but not fully\\n  const wrapsX = this.sourceProj_.canWrapX() &&\\n               sourceCoverageX > 0.5 && sourceCoverageX < 1;\\n\\n  let needsSubdivision = false;\\n\\n  if (maxSubdivision > 0) {\\n    if (this.targetProj_.isGlobal() && this.targetWorldWidth_) {\\n      const targetQuadExtent = boundingExtent([a, b, c, d]);\\n      const targetCoverageX = getWidth(targetQuadExtent) / this.targetWorldWidth_;\\n      needsSubdivision |=\\n          targetCoverageX > MAX_TRIANGLE_WIDTH;\\n    }\\n    if (!wrapsX && this.sourceProj_.isGlobal() && sourceCoverageX) {\\n      needsSubdivision |=\\n          sourceCoverageX > MAX_TRIANGLE_WIDTH;\\n    }\\n  }\\n\\n  if (!needsSubdivision && this.maxSourceExtent_) {\\n    if (!intersects(sourceQuadExtent, this.maxSourceExtent_)) {\\n      // whole quad outside source projection extent -> ignore\\n      return;\\n    }\\n  }\\n\\n  if (!needsSubdivision) {\\n    if (!isFinite(aSrc[0]) || !isFinite(aSrc[1]) ||\\n        !isFinite(bSrc[0]) || !isFinite(bSrc[1]) ||\\n        !isFinite(cSrc[0]) || !isFinite(cSrc[1]) ||\\n        !isFinite(dSrc[0]) || !isFinite(dSrc[1])) {\\n      if (maxSubdivision > 0) {\\n        needsSubdivision = true;\\n      } else {\\n        return;\\n      }\\n    }\\n  }\\n\\n  if (maxSubdivision > 0) {\\n    if (!needsSubdivision) {\\n      const center = [(a[0] + c[0]) / 2, (a[1] + c[1]) / 2];\\n      const centerSrc = this.transformInv_(center);\\n\\n      let dx;\\n      if (wrapsX) {\\n        const centerSrcEstimX =\\n            (modulo(aSrc[0], sourceWorldWidth) +\\n             modulo(cSrc[0], sourceWorldWidth)) / 2;\\n        dx = centerSrcEstimX -\\n            modulo(centerSrc[0], sourceWorldWidth);\\n      } else {\\n        dx = (aSrc[0] + cSrc[0]) / 2 - centerSrc[0];\\n      }\\n      const dy = (aSrc[1] + cSrc[1]) / 2 - centerSrc[1];\\n      const centerSrcErrorSquared = dx * dx + dy * dy;\\n      needsSubdivision = centerSrcErrorSquared > this.errorThresholdSquared_;\\n    }\\n    if (needsSubdivision) {\\n      if (Math.abs(a[0] - c[0]) <= Math.abs(a[1] - c[1])) {\\n        // split horizontally (top & bottom)\\n        const bc = [(b[0] + c[0]) / 2, (b[1] + c[1]) / 2];\\n        const bcSrc = this.transformInv_(bc);\\n        const da = [(d[0] + a[0]) / 2, (d[1] + a[1]) / 2];\\n        const daSrc = this.transformInv_(da);\\n\\n        this.addQuad_(\\n          a, b, bc, da, aSrc, bSrc, bcSrc, daSrc, maxSubdivision - 1);\\n        this.addQuad_(\\n          da, bc, c, d, daSrc, bcSrc, cSrc, dSrc, maxSubdivision - 1);\\n      } else {\\n        // split vertically (left & right)\\n        const ab = [(a[0] + b[0]) / 2, (a[1] + b[1]) / 2];\\n        const abSrc = this.transformInv_(ab);\\n        const cd = [(c[0] + d[0]) / 2, (c[1] + d[1]) / 2];\\n        const cdSrc = this.transformInv_(cd);\\n\\n        this.addQuad_(\\n          a, ab, cd, d, aSrc, abSrc, cdSrc, dSrc, maxSubdivision - 1);\\n        this.addQuad_(\\n          ab, b, c, cd, abSrc, bSrc, cSrc, cdSrc, maxSubdivision - 1);\\n      }\\n      return;\\n    }\\n  }\\n\\n  if (wrapsX) {\\n    if (!this.canWrapXInSource_) {\\n      return;\\n    }\\n    this.wrapsXInSource_ = true;\\n  }\\n\\n  this.addTriangle_(a, c, d, aSrc, cSrc, dSrc);\\n  this.addTriangle_(a, b, c, aSrc, bSrc, cSrc);\\n};\\n\\n\\n/**\\n * Calculates extent of the 'source' coordinates from all the triangles.\\n *\\n * @return {module:ol/extent~Extent} Calculated extent.\\n */\\nTriangulation.prototype.calculateSourceExtent = function() {\\n  const extent = createEmpty();\\n\\n  this.triangles_.forEach(function(triangle, i, arr) {\\n    const src = triangle.source;\\n    extendCoordinate(extent, src[0]);\\n    extendCoordinate(extent, src[1]);\\n    extendCoordinate(extent, src[2]);\\n  });\\n\\n  return extent;\\n};\\n\\n\\n/**\\n * @return {Array.<module:ol/reproj/Triangulation~Triangle>} Array of the calculated triangles.\\n */\\nTriangulation.prototype.getTriangles = function() {\\n  return this.triangles_;\\n};\\nexport default Triangulation;\\n\",\"/**\\n * @module ol/reproj/Tile\\n */\\nimport {ERROR_THRESHOLD} from './common.js';\\nimport {inherits} from '../index.js';\\nimport Tile from '../Tile.js';\\nimport TileState from '../TileState.js';\\nimport {listen, unlistenByKey} from '../events.js';\\nimport EventType from '../events/EventType.js';\\nimport {getArea, getCenter, getIntersection} from '../extent.js';\\nimport {clamp} from '../math.js';\\nimport {calculateSourceResolution, render as renderReprojected} from '../reproj.js';\\nimport Triangulation from '../reproj/Triangulation.js';\\n\\n\\n/**\\n * @typedef {function(number, number, number, number) : module:ol/Tile} FunctionType\\n */\\n\\n\\n/**\\n * @classdesc\\n * Class encapsulating single reprojected tile.\\n * See {@link module:ol/source/TileImage~TileImage}.\\n *\\n * @constructor\\n * @extends {module:ol/Tile}\\n * @param {module:ol/proj/Projection} sourceProj Source projection.\\n * @param {module:ol/tilegrid/TileGrid} sourceTileGrid Source tile grid.\\n * @param {module:ol/proj/Projection} targetProj Target projection.\\n * @param {module:ol/tilegrid/TileGrid} targetTileGrid Target tile grid.\\n * @param {module:ol/tilecoord~TileCoord} tileCoord Coordinate of the tile.\\n * @param {module:ol/tilecoord~TileCoord} wrappedTileCoord Coordinate of the tile wrapped in X.\\n * @param {number} pixelRatio Pixel ratio.\\n * @param {number} gutter Gutter of the source tiles.\\n * @param {module:ol/reproj/Tile~FunctionType} getTileFunction\\n *     Function returning source tiles (z, x, y, pixelRatio).\\n * @param {number=} opt_errorThreshold Acceptable reprojection error (in px).\\n * @param {boolean=} opt_renderEdges Render reprojection edges.\\n */\\nconst ReprojTile = function(sourceProj, sourceTileGrid,\\n  targetProj, targetTileGrid, tileCoord, wrappedTileCoord,\\n  pixelRatio, gutter, getTileFunction,\\n  opt_errorThreshold, opt_renderEdges) {\\n  Tile.call(this, tileCoord, TileState.IDLE);\\n\\n  /**\\n   * @private\\n   * @type {boolean}\\n   */\\n  this.renderEdges_ = opt_renderEdges !== undefined ? opt_renderEdges : false;\\n\\n  /**\\n   * @private\\n   * @type {number}\\n   */\\n  this.pixelRatio_ = pixelRatio;\\n\\n  /**\\n   * @private\\n   * @type {number}\\n   */\\n  this.gutter_ = gutter;\\n\\n  /**\\n   * @private\\n   * @type {HTMLCanvasElement}\\n   */\\n  this.canvas_ = null;\\n\\n  /**\\n   * @private\\n   * @type {module:ol/tilegrid/TileGrid}\\n   */\\n  this.sourceTileGrid_ = sourceTileGrid;\\n\\n  /**\\n   * @private\\n   * @type {module:ol/tilegrid/TileGrid}\\n   */\\n  this.targetTileGrid_ = targetTileGrid;\\n\\n  /**\\n   * @private\\n   * @type {module:ol/tilecoord~TileCoord}\\n   */\\n  this.wrappedTileCoord_ = wrappedTileCoord ? wrappedTileCoord : tileCoord;\\n\\n  /**\\n   * @private\\n   * @type {!Array.<module:ol/Tile>}\\n   */\\n  this.sourceTiles_ = [];\\n\\n  /**\\n   * @private\\n   * @type {Array.<module:ol/events~EventsKey>}\\n   */\\n  this.sourcesListenerKeys_ = null;\\n\\n  /**\\n   * @private\\n   * @type {number}\\n   */\\n  this.sourceZ_ = 0;\\n\\n  const targetExtent = targetTileGrid.getTileCoordExtent(this.wrappedTileCoord_);\\n  const maxTargetExtent = this.targetTileGrid_.getExtent();\\n  let maxSourceExtent = this.sourceTileGrid_.getExtent();\\n\\n  const limitedTargetExtent = maxTargetExtent ?\\n    getIntersection(targetExtent, maxTargetExtent) : targetExtent;\\n\\n  if (getArea(limitedTargetExtent) === 0) {\\n    // Tile is completely outside range -> EMPTY\\n    // TODO: is it actually correct that the source even creates the tile ?\\n    this.state = TileState.EMPTY;\\n    return;\\n  }\\n\\n  const sourceProjExtent = sourceProj.getExtent();\\n  if (sourceProjExtent) {\\n    if (!maxSourceExtent) {\\n      maxSourceExtent = sourceProjExtent;\\n    } else {\\n      maxSourceExtent = getIntersection(maxSourceExtent, sourceProjExtent);\\n    }\\n  }\\n\\n  const targetResolution = targetTileGrid.getResolution(\\n    this.wrappedTileCoord_[0]);\\n\\n  const targetCenter = getCenter(limitedTargetExtent);\\n  const sourceResolution = calculateSourceResolution(\\n    sourceProj, targetProj, targetCenter, targetResolution);\\n\\n  if (!isFinite(sourceResolution) || sourceResolution <= 0) {\\n    // invalid sourceResolution -> EMPTY\\n    // probably edges of the projections when no extent is defined\\n    this.state = TileState.EMPTY;\\n    return;\\n  }\\n\\n  const errorThresholdInPixels = opt_errorThreshold !== undefined ?\\n    opt_errorThreshold : ERROR_THRESHOLD;\\n\\n  /**\\n   * @private\\n   * @type {!module:ol/reproj/Triangulation}\\n   */\\n  this.triangulation_ = new Triangulation(\\n    sourceProj, targetProj, limitedTargetExtent, maxSourceExtent,\\n    sourceResolution * errorThresholdInPixels);\\n\\n  if (this.triangulation_.getTriangles().length === 0) {\\n    // no valid triangles -> EMPTY\\n    this.state = TileState.EMPTY;\\n    return;\\n  }\\n\\n  this.sourceZ_ = sourceTileGrid.getZForResolution(sourceResolution);\\n  let sourceExtent = this.triangulation_.calculateSourceExtent();\\n\\n  if (maxSourceExtent) {\\n    if (sourceProj.canWrapX()) {\\n      sourceExtent[1] = clamp(\\n        sourceExtent[1], maxSourceExtent[1], maxSourceExtent[3]);\\n      sourceExtent[3] = clamp(\\n        sourceExtent[3], maxSourceExtent[1], maxSourceExtent[3]);\\n    } else {\\n      sourceExtent = getIntersection(sourceExtent, maxSourceExtent);\\n    }\\n  }\\n\\n  if (!getArea(sourceExtent)) {\\n    this.state = TileState.EMPTY;\\n  } else {\\n    const sourceRange = sourceTileGrid.getTileRangeForExtentAndZ(\\n      sourceExtent, this.sourceZ_);\\n\\n    for (let srcX = sourceRange.minX; srcX <= sourceRange.maxX; srcX++) {\\n      for (let srcY = sourceRange.minY; srcY <= sourceRange.maxY; srcY++) {\\n        const tile = getTileFunction(this.sourceZ_, srcX, srcY, pixelRatio);\\n        if (tile) {\\n          this.sourceTiles_.push(tile);\\n        }\\n      }\\n    }\\n\\n    if (this.sourceTiles_.length === 0) {\\n      this.state = TileState.EMPTY;\\n    }\\n  }\\n};\\n\\ninherits(ReprojTile, Tile);\\n\\n\\n/**\\n * @inheritDoc\\n */\\nReprojTile.prototype.disposeInternal = function() {\\n  if (this.state == TileState.LOADING) {\\n    this.unlistenSources_();\\n  }\\n  Tile.prototype.disposeInternal.call(this);\\n};\\n\\n\\n/**\\n * Get the HTML Canvas element for this tile.\\n * @return {HTMLCanvasElement} Canvas.\\n */\\nReprojTile.prototype.getImage = function() {\\n  return this.canvas_;\\n};\\n\\n\\n/**\\n * @private\\n */\\nReprojTile.prototype.reproject_ = function() {\\n  const sources = [];\\n  this.sourceTiles_.forEach(function(tile, i, arr) {\\n    if (tile && tile.getState() == TileState.LOADED) {\\n      sources.push({\\n        extent: this.sourceTileGrid_.getTileCoordExtent(tile.tileCoord),\\n        image: tile.getImage()\\n      });\\n    }\\n  }.bind(this));\\n  this.sourceTiles_.length = 0;\\n\\n  if (sources.length === 0) {\\n    this.state = TileState.ERROR;\\n  } else {\\n    const z = this.wrappedTileCoord_[0];\\n    const size = this.targetTileGrid_.getTileSize(z);\\n    const width = typeof size === 'number' ? size : size[0];\\n    const height = typeof size === 'number' ? size : size[1];\\n    const targetResolution = this.targetTileGrid_.getResolution(z);\\n    const sourceResolution = this.sourceTileGrid_.getResolution(this.sourceZ_);\\n\\n    const targetExtent = this.targetTileGrid_.getTileCoordExtent(\\n      this.wrappedTileCoord_);\\n    this.canvas_ = renderReprojected(width, height, this.pixelRatio_,\\n      sourceResolution, this.sourceTileGrid_.getExtent(),\\n      targetResolution, targetExtent, this.triangulation_, sources,\\n      this.gutter_, this.renderEdges_);\\n\\n    this.state = TileState.LOADED;\\n  }\\n  this.changed();\\n};\\n\\n\\n/**\\n * @inheritDoc\\n */\\nReprojTile.prototype.load = function() {\\n  if (this.state == TileState.IDLE) {\\n    this.state = TileState.LOADING;\\n    this.changed();\\n\\n    let leftToLoad = 0;\\n\\n    this.sourcesListenerKeys_ = [];\\n    this.sourceTiles_.forEach(function(tile, i, arr) {\\n      const state = tile.getState();\\n      if (state == TileState.IDLE || state == TileState.LOADING) {\\n        leftToLoad++;\\n\\n        const sourceListenKey = listen(tile, EventType.CHANGE,\\n          function(e) {\\n            const state = tile.getState();\\n            if (state == TileState.LOADED ||\\n                  state == TileState.ERROR ||\\n                  state == TileState.EMPTY) {\\n              unlistenByKey(sourceListenKey);\\n              leftToLoad--;\\n              if (leftToLoad === 0) {\\n                this.unlistenSources_();\\n                this.reproject_();\\n              }\\n            }\\n          }, this);\\n        this.sourcesListenerKeys_.push(sourceListenKey);\\n      }\\n    }.bind(this));\\n\\n    this.sourceTiles_.forEach(function(tile, i, arr) {\\n      const state = tile.getState();\\n      if (state == TileState.IDLE) {\\n        tile.load();\\n      }\\n    });\\n\\n    if (leftToLoad === 0) {\\n      setTimeout(this.reproject_.bind(this), 0);\\n    }\\n  }\\n};\\n\\n\\n/**\\n * @private\\n */\\nReprojTile.prototype.unlistenSources_ = function() {\\n  this.sourcesListenerKeys_.forEach(unlistenByKey);\\n  this.sourcesListenerKeys_ = null;\\n};\\nexport default ReprojTile;\\n\",\"/**\\n * @module ol/tileurlfunction\\n */\\nimport {assert} from './asserts.js';\\nimport {modulo} from './math.js';\\nimport {hash as tileCoordHash} from './tilecoord.js';\\n\\n\\n/**\\n * @param {string} template Template.\\n * @param {module:ol/tilegrid/TileGrid} tileGrid Tile grid.\\n * @return {module:ol/Tile~UrlFunction} Tile URL function.\\n */\\nexport function createFromTemplate(template, tileGrid) {\\n  const zRegEx = /\\\\{z\\\\}/g;\\n  const xRegEx = /\\\\{x\\\\}/g;\\n  const yRegEx = /\\\\{y\\\\}/g;\\n  const dashYRegEx = /\\\\{-y\\\\}/g;\\n  return (\\n    /**\\n     * @param {module:ol/tilecoord~TileCoord} tileCoord Tile Coordinate.\\n     * @param {number} pixelRatio Pixel ratio.\\n     * @param {module:ol/proj/Projection} projection Projection.\\n     * @return {string|undefined} Tile URL.\\n     */\\n    function(tileCoord, pixelRatio, projection) {\\n      if (!tileCoord) {\\n        return undefined;\\n      } else {\\n        return template.replace(zRegEx, tileCoord[0].toString())\\n          .replace(xRegEx, tileCoord[1].toString())\\n          .replace(yRegEx, function() {\\n            const y = -tileCoord[2] - 1;\\n            return y.toString();\\n          })\\n          .replace(dashYRegEx, function() {\\n            const z = tileCoord[0];\\n            const range = tileGrid.getFullTileRange(z);\\n            assert(range, 55); // The {-y} placeholder requires a tile grid with extent\\n            const y = range.getHeight() + tileCoord[2];\\n            return y.toString();\\n          });\\n      }\\n    }\\n  );\\n}\\n\\n\\n/**\\n * @param {Array.<string>} templates Templates.\\n * @param {module:ol/tilegrid/TileGrid} tileGrid Tile grid.\\n * @return {module:ol/Tile~UrlFunction} Tile URL function.\\n */\\nexport function createFromTemplates(templates, tileGrid) {\\n  const len = templates.length;\\n  const tileUrlFunctions = new Array(len);\\n  for (let i = 0; i < len; ++i) {\\n    tileUrlFunctions[i] = createFromTemplate(templates[i], tileGrid);\\n  }\\n  return createFromTileUrlFunctions(tileUrlFunctions);\\n}\\n\\n\\n/**\\n * @param {Array.<module:ol/Tile~UrlFunction>} tileUrlFunctions Tile URL Functions.\\n * @return {module:ol/Tile~UrlFunction} Tile URL function.\\n */\\nexport function createFromTileUrlFunctions(tileUrlFunctions) {\\n  if (tileUrlFunctions.length === 1) {\\n    return tileUrlFunctions[0];\\n  }\\n  return (\\n    /**\\n     * @param {module:ol/tilecoord~TileCoord} tileCoord Tile Coordinate.\\n     * @param {number} pixelRatio Pixel ratio.\\n     * @param {module:ol/proj/Projection} projection Projection.\\n     * @return {string|undefined} Tile URL.\\n     */\\n    function(tileCoord, pixelRatio, projection) {\\n      if (!tileCoord) {\\n        return undefined;\\n      } else {\\n        const h = tileCoordHash(tileCoord);\\n        const index = modulo(h, tileUrlFunctions.length);\\n        return tileUrlFunctions[index](tileCoord, pixelRatio, projection);\\n      }\\n    }\\n  );\\n}\\n\\n\\n/**\\n * @param {module:ol/tilecoord~TileCoord} tileCoord Tile coordinate.\\n * @param {number} pixelRatio Pixel ratio.\\n * @param {module:ol/proj/Projection} projection Projection.\\n * @return {string|undefined} Tile URL.\\n */\\nexport function nullTileUrlFunction(tileCoord, pixelRatio, projection) {\\n  return undefined;\\n}\\n\\n\\n/**\\n * @param {string} url URL.\\n * @return {Array.<string>} Array of urls.\\n */\\nexport function expandUrl(url) {\\n  const urls = [];\\n  let match = /\\\\{([a-z])-([a-z])\\\\}/.exec(url);\\n  if (match) {\\n    // char range\\n    const startCharCode = match[1].charCodeAt(0);\\n    const stopCharCode = match[2].charCodeAt(0);\\n    let charCode;\\n    for (charCode = startCharCode; charCode <= stopCharCode; ++charCode) {\\n      urls.push(url.replace(match[0], String.fromCharCode(charCode)));\\n    }\\n    return urls;\\n  }\\n  match = match = /\\\\{(\\\\d+)-(\\\\d+)\\\\}/.exec(url);\\n  if (match) {\\n    // number range\\n    const stop = parseInt(match[2], 10);\\n    for (let i = parseInt(match[1], 10); i <= stop; i++) {\\n      urls.push(url.replace(match[0], i.toString()));\\n    }\\n    return urls;\\n  }\\n  urls.push(url);\\n  return urls;\\n}\\n\",\"/**\\n * @module ol/tilegrid/TileGrid\\n */\\nimport {DEFAULT_TILE_SIZE} from './common.js';\\nimport {assert} from '../asserts.js';\\nimport TileRange, {createOrUpdate as createOrUpdateTileRange} from '../TileRange.js';\\nimport {isSorted, linearFindNearest} from '../array.js';\\nimport {createOrUpdate, getTopLeft} from '../extent.js';\\nimport {clamp} from '../math.js';\\nimport {toSize} from '../size.js';\\nimport {createOrUpdate as createOrUpdateTileCoord} from '../tilecoord.js';\\n\\n\\n/**\\n * @typedef {Object} Options\\n * @property {module:ol/extent~Extent} [extent] Extent for the tile grid. No tiles outside this\\n * extent will be requested by {@link module:ol/source/Tile} sources. When no `origin` or\\n * `origins` are configured, the `origin` will be set to the top-left corner of the extent.\\n * @property {number} [minZoom=0] Minimum zoom.\\n * @property {module:ol/coordinate~Coordinate} [origin] The tile grid origin, i.e. where the `x`\\n * and `y` axes meet (`[z, 0, 0]`). Tile coordinates increase left to right and upwards. If not\\n * specified, `extent` or `origins` must be provided.\\n * @property {Array.<module:ol/coordinate~Coordinate>} [origins] Tile grid origins, i.e. where\\n * the `x` and `y` axes meet (`[z, 0, 0]`), for each zoom level. If given, the array length\\n * should match the length of the `resolutions` array, i.e. each resolution can have a different\\n * origin. Tile coordinates increase left to right and upwards. If not specified, `extent` or\\n * `origin` must be provided.\\n * @property {!Array.<number>} resolutions Resolutions. The array index of each resolution needs\\n * to match the zoom level. This means that even if a `minZoom` is configured, the resolutions\\n * array will have a length of `maxZoom + 1`.\\n * @property {Array.<module:ol/size~Size>} [sizes] Sizes.\\n * @property {number|module:ol/size~Size} [tileSize] Tile size.\\n * Default is `[256, 256]`.\\n * @property {Array.<module:ol/size~Size>} [tileSizes] Tile sizes. If given, the array length\\n * should match the length of the `resolutions` array, i.e. each resolution can have a different\\n * tile size.\\n */\\n\\n\\n/**\\n * @classdesc\\n * Base class for setting the grid pattern for sources accessing tiled-image\\n * servers.\\n *\\n * @constructor\\n * @param {module:ol/tilegrid/TileGrid~Options} options Tile grid options.\\n * @struct\\n * @api\\n */\\nconst TileGrid = function(options) {\\n\\n  /**\\n   * @protected\\n   * @type {number}\\n   */\\n  this.minZoom = options.minZoom !== undefined ? options.minZoom : 0;\\n\\n  /**\\n   * @private\\n   * @type {!Array.<number>}\\n   */\\n  this.resolutions_ = options.resolutions;\\n  assert(isSorted(this.resolutions_, function(a, b) {\\n    return b - a;\\n  }, true), 17); // `resolutions` must be sorted in descending order\\n\\n\\n  // check if we've got a consistent zoom factor and origin\\n  let zoomFactor;\\n  if (!options.origins) {\\n    for (let i = 0, ii = this.resolutions_.length - 1; i < ii; ++i) {\\n      if (!zoomFactor) {\\n        zoomFactor = this.resolutions_[i] / this.resolutions_[i + 1];\\n      } else {\\n        if (this.resolutions_[i] / this.resolutions_[i + 1] !== zoomFactor) {\\n          zoomFactor = undefined;\\n          break;\\n        }\\n      }\\n    }\\n  }\\n\\n\\n  /**\\n   * @private\\n   * @type {number|undefined}\\n   */\\n  this.zoomFactor_ = zoomFactor;\\n\\n\\n  /**\\n   * @protected\\n   * @type {number}\\n   */\\n  this.maxZoom = this.resolutions_.length - 1;\\n\\n  /**\\n   * @private\\n   * @type {module:ol/coordinate~Coordinate}\\n   */\\n  this.origin_ = options.origin !== undefined ? options.origin : null;\\n\\n  /**\\n   * @private\\n   * @type {Array.<module:ol/coordinate~Coordinate>}\\n   */\\n  this.origins_ = null;\\n  if (options.origins !== undefined) {\\n    this.origins_ = options.origins;\\n    assert(this.origins_.length == this.resolutions_.length,\\n      20); // Number of `origins` and `resolutions` must be equal\\n  }\\n\\n  const extent = options.extent;\\n\\n  if (extent !== undefined &&\\n      !this.origin_ && !this.origins_) {\\n    this.origin_ = getTopLeft(extent);\\n  }\\n\\n  assert(\\n    (!this.origin_ && this.origins_) || (this.origin_ && !this.origins_),\\n    18); // Either `origin` or `origins` must be configured, never both\\n\\n  /**\\n   * @private\\n   * @type {Array.<number|module:ol/size~Size>}\\n   */\\n  this.tileSizes_ = null;\\n  if (options.tileSizes !== undefined) {\\n    this.tileSizes_ = options.tileSizes;\\n    assert(this.tileSizes_.length == this.resolutions_.length,\\n      19); // Number of `tileSizes` and `resolutions` must be equal\\n  }\\n\\n  /**\\n   * @private\\n   * @type {number|module:ol/size~Size}\\n   */\\n  this.tileSize_ = options.tileSize !== undefined ?\\n    options.tileSize :\\n    !this.tileSizes_ ? DEFAULT_TILE_SIZE : null;\\n  assert(\\n    (!this.tileSize_ && this.tileSizes_) ||\\n      (this.tileSize_ && !this.tileSizes_),\\n    22); // Either `tileSize` or `tileSizes` must be configured, never both\\n\\n  /**\\n   * @private\\n   * @type {module:ol/extent~Extent}\\n   */\\n  this.extent_ = extent !== undefined ? extent : null;\\n\\n\\n  /**\\n   * @private\\n   * @type {Array.<module:ol/TileRange>}\\n   */\\n  this.fullTileRanges_ = null;\\n\\n  /**\\n   * @private\\n   * @type {module:ol/size~Size}\\n   */\\n  this.tmpSize_ = [0, 0];\\n\\n  if (options.sizes !== undefined) {\\n    this.fullTileRanges_ = options.sizes.map(function(size, z) {\\n      const tileRange = new TileRange(\\n        Math.min(0, size[0]), Math.max(size[0] - 1, -1),\\n        Math.min(0, size[1]), Math.max(size[1] - 1, -1));\\n      return tileRange;\\n    }, this);\\n  } else if (extent) {\\n    this.calculateTileRanges_(extent);\\n  }\\n\\n};\\n\\n\\n/**\\n * @private\\n * @type {module:ol/tilecoord~TileCoord}\\n */\\nconst tmpTileCoord = [0, 0, 0];\\n\\n\\n/**\\n * Call a function with each tile coordinate for a given extent and zoom level.\\n *\\n * @param {module:ol/extent~Extent} extent Extent.\\n * @param {number} zoom Integer zoom level.\\n * @param {function(module:ol/tilecoord~TileCoord)} callback Function called with each tile coordinate.\\n * @api\\n */\\nTileGrid.prototype.forEachTileCoord = function(extent, zoom, callback) {\\n  const tileRange = this.getTileRangeForExtentAndZ(extent, zoom);\\n  for (let i = tileRange.minX, ii = tileRange.maxX; i <= ii; ++i) {\\n    for (let j = tileRange.minY, jj = tileRange.maxY; j <= jj; ++j) {\\n      callback([zoom, i, j]);\\n    }\\n  }\\n};\\n\\n\\n/**\\n * @param {module:ol/tilecoord~TileCoord} tileCoord Tile coordinate.\\n * @param {function(this: T, number, module:ol/TileRange): boolean} callback Callback.\\n * @param {T=} opt_this The object to use as `this` in `callback`.\\n * @param {module:ol/TileRange=} opt_tileRange Temporary module:ol/TileRange object.\\n * @param {module:ol/extent~Extent=} opt_extent Temporary module:ol/extent~Extent object.\\n * @return {boolean} Callback succeeded.\\n * @template T\\n */\\nTileGrid.prototype.forEachTileCoordParentTileRange = function(tileCoord, callback, opt_this, opt_tileRange, opt_extent) {\\n  let tileRange, x, y;\\n  let tileCoordExtent = null;\\n  let z = tileCoord[0] - 1;\\n  if (this.zoomFactor_ === 2) {\\n    x = tileCoord[1];\\n    y = tileCoord[2];\\n  } else {\\n    tileCoordExtent = this.getTileCoordExtent(tileCoord, opt_extent);\\n  }\\n  while (z >= this.minZoom) {\\n    if (this.zoomFactor_ === 2) {\\n      x = Math.floor(x / 2);\\n      y = Math.floor(y / 2);\\n      tileRange = createOrUpdateTileRange(x, x, y, y, opt_tileRange);\\n    } else {\\n      tileRange = this.getTileRangeForExtentAndZ(tileCoordExtent, z, opt_tileRange);\\n    }\\n    if (callback.call(opt_this, z, tileRange)) {\\n      return true;\\n    }\\n    --z;\\n  }\\n  return false;\\n};\\n\\n\\n/**\\n * Get the extent for this tile grid, if it was configured.\\n * @return {module:ol/extent~Extent} Extent.\\n */\\nTileGrid.prototype.getExtent = function() {\\n  return this.extent_;\\n};\\n\\n\\n/**\\n * Get the maximum zoom level for the grid.\\n * @return {number} Max zoom.\\n * @api\\n */\\nTileGrid.prototype.getMaxZoom = function() {\\n  return this.maxZoom;\\n};\\n\\n\\n/**\\n * Get the minimum zoom level for the grid.\\n * @return {number} Min zoom.\\n * @api\\n */\\nTileGrid.prototype.getMinZoom = function() {\\n  return this.minZoom;\\n};\\n\\n\\n/**\\n * Get the origin for the grid at the given zoom level.\\n * @param {number} z Integer zoom level.\\n * @return {module:ol/coordinate~Coordinate} Origin.\\n * @api\\n */\\nTileGrid.prototype.getOrigin = function(z) {\\n  if (this.origin_) {\\n    return this.origin_;\\n  } else {\\n    return this.origins_[z];\\n  }\\n};\\n\\n\\n/**\\n * Get the resolution for the given zoom level.\\n * @param {number} z Integer zoom level.\\n * @return {number} Resolution.\\n * @api\\n */\\nTileGrid.prototype.getResolution = function(z) {\\n  return this.resolutions_[z];\\n};\\n\\n\\n/**\\n * Get the list of resolutions for the tile grid.\\n * @return {Array.<number>} Resolutions.\\n * @api\\n */\\nTileGrid.prototype.getResolutions = function() {\\n  return this.resolutions_;\\n};\\n\\n\\n/**\\n * @param {module:ol/tilecoord~TileCoord} tileCoord Tile coordinate.\\n * @param {module:ol/TileRange=} opt_tileRange Temporary module:ol/TileRange object.\\n * @param {module:ol/extent~Extent=} opt_extent Temporary module:ol/extent~Extent object.\\n * @return {module:ol/TileRange} Tile range.\\n */\\nTileGrid.prototype.getTileCoordChildTileRange = function(tileCoord, opt_tileRange, opt_extent) {\\n  if (tileCoord[0] < this.maxZoom) {\\n    if (this.zoomFactor_ === 2) {\\n      const minX = tileCoord[1] * 2;\\n      const minY = tileCoord[2] * 2;\\n      return createOrUpdateTileRange(minX, minX + 1, minY, minY + 1, opt_tileRange);\\n    }\\n    const tileCoordExtent = this.getTileCoordExtent(tileCoord, opt_extent);\\n    return this.getTileRangeForExtentAndZ(\\n      tileCoordExtent, tileCoord[0] + 1, opt_tileRange);\\n  }\\n  return null;\\n};\\n\\n\\n/**\\n * Get the extent for a tile range.\\n * @param {number} z Integer zoom level.\\n * @param {module:ol/TileRange} tileRange Tile range.\\n * @param {module:ol/extent~Extent=} opt_extent Temporary module:ol/extent~Extent object.\\n * @return {module:ol/extent~Extent} Extent.\\n */\\nTileGrid.prototype.getTileRangeExtent = function(z, tileRange, opt_extent) {\\n  const origin = this.getOrigin(z);\\n  const resolution = this.getResolution(z);\\n  const tileSize = toSize(this.getTileSize(z), this.tmpSize_);\\n  const minX = origin[0] + tileRange.minX * tileSize[0] * resolution;\\n  const maxX = origin[0] + (tileRange.maxX + 1) * tileSize[0] * resolution;\\n  const minY = origin[1] + tileRange.minY * tileSize[1] * resolution;\\n  const maxY = origin[1] + (tileRange.maxY + 1) * tileSize[1] * resolution;\\n  return createOrUpdate(minX, minY, maxX, maxY, opt_extent);\\n};\\n\\n\\n/**\\n * Get a tile range for the given extent and integer zoom level.\\n * @param {module:ol/extent~Extent} extent Extent.\\n * @param {number} z Integer zoom level.\\n * @param {module:ol/TileRange=} opt_tileRange Temporary tile range object.\\n * @return {module:ol/TileRange} Tile range.\\n */\\nTileGrid.prototype.getTileRangeForExtentAndZ = function(extent, z, opt_tileRange) {\\n  const tileCoord = tmpTileCoord;\\n  this.getTileCoordForXYAndZ_(extent[0], extent[1], z, false, tileCoord);\\n  const minX = tileCoord[1];\\n  const minY = tileCoord[2];\\n  this.getTileCoordForXYAndZ_(extent[2], extent[3], z, true, tileCoord);\\n  return createOrUpdateTileRange(minX, tileCoord[1], minY, tileCoord[2], opt_tileRange);\\n};\\n\\n\\n/**\\n * @param {module:ol/tilecoord~TileCoord} tileCoord Tile coordinate.\\n * @return {module:ol/coordinate~Coordinate} Tile center.\\n */\\nTileGrid.prototype.getTileCoordCenter = function(tileCoord) {\\n  const origin = this.getOrigin(tileCoord[0]);\\n  const resolution = this.getResolution(tileCoord[0]);\\n  const tileSize = toSize(this.getTileSize(tileCoord[0]), this.tmpSize_);\\n  return [\\n    origin[0] + (tileCoord[1] + 0.5) * tileSize[0] * resolution,\\n    origin[1] + (tileCoord[2] + 0.5) * tileSize[1] * resolution\\n  ];\\n};\\n\\n\\n/**\\n * Get the extent of a tile coordinate.\\n *\\n * @param {module:ol/tilecoord~TileCoord} tileCoord Tile coordinate.\\n * @param {module:ol/extent~Extent=} opt_extent Temporary extent object.\\n * @return {module:ol/extent~Extent} Extent.\\n * @api\\n */\\nTileGrid.prototype.getTileCoordExtent = function(tileCoord, opt_extent) {\\n  const origin = this.getOrigin(tileCoord[0]);\\n  const resolution = this.getResolution(tileCoord[0]);\\n  const tileSize = toSize(this.getTileSize(tileCoord[0]), this.tmpSize_);\\n  const minX = origin[0] + tileCoord[1] * tileSize[0] * resolution;\\n  const minY = origin[1] + tileCoord[2] * tileSize[1] * resolution;\\n  const maxX = minX + tileSize[0] * resolution;\\n  const maxY = minY + tileSize[1] * resolution;\\n  return createOrUpdate(minX, minY, maxX, maxY, opt_extent);\\n};\\n\\n\\n/**\\n * Get the tile coordinate for the given map coordinate and resolution.  This\\n * method considers that coordinates that intersect tile boundaries should be\\n * assigned the higher tile coordinate.\\n *\\n * @param {module:ol/coordinate~Coordinate} coordinate Coordinate.\\n * @param {number} resolution Resolution.\\n * @param {module:ol/tilecoord~TileCoord=} opt_tileCoord Destination module:ol/tilecoord~TileCoord object.\\n * @return {module:ol/tilecoord~TileCoord} Tile coordinate.\\n * @api\\n */\\nTileGrid.prototype.getTileCoordForCoordAndResolution = function(coordinate, resolution, opt_tileCoord) {\\n  return this.getTileCoordForXYAndResolution_(\\n    coordinate[0], coordinate[1], resolution, false, opt_tileCoord);\\n};\\n\\n\\n/**\\n * Note that this method should not be called for resolutions that correspond\\n * to an integer zoom level.  Instead call the `getTileCoordForXYAndZ_` method.\\n * @param {number} x X.\\n * @param {number} y Y.\\n * @param {number} resolution Resolution (for a non-integer zoom level).\\n * @param {boolean} reverseIntersectionPolicy Instead of letting edge\\n *     intersections go to the higher tile coordinate, let edge intersections\\n *     go to the lower tile coordinate.\\n * @param {module:ol/tilecoord~TileCoord=} opt_tileCoord Temporary module:ol/tilecoord~TileCoord object.\\n * @return {module:ol/tilecoord~TileCoord} Tile coordinate.\\n * @private\\n */\\nTileGrid.prototype.getTileCoordForXYAndResolution_ = function(\\n  x, y, resolution, reverseIntersectionPolicy, opt_tileCoord) {\\n  const z = this.getZForResolution(resolution);\\n  const scale = resolution / this.getResolution(z);\\n  const origin = this.getOrigin(z);\\n  const tileSize = toSize(this.getTileSize(z), this.tmpSize_);\\n\\n  const adjustX = reverseIntersectionPolicy ? 0.5 : 0;\\n  const adjustY = reverseIntersectionPolicy ? 0 : 0.5;\\n  const xFromOrigin = Math.floor((x - origin[0]) / resolution + adjustX);\\n  const yFromOrigin = Math.floor((y - origin[1]) / resolution + adjustY);\\n  let tileCoordX = scale * xFromOrigin / tileSize[0];\\n  let tileCoordY = scale * yFromOrigin / tileSize[1];\\n\\n  if (reverseIntersectionPolicy) {\\n    tileCoordX = Math.ceil(tileCoordX) - 1;\\n    tileCoordY = Math.ceil(tileCoordY) - 1;\\n  } else {\\n    tileCoordX = Math.floor(tileCoordX);\\n    tileCoordY = Math.floor(tileCoordY);\\n  }\\n\\n  return createOrUpdateTileCoord(z, tileCoordX, tileCoordY, opt_tileCoord);\\n};\\n\\n\\n/**\\n * Although there is repetition between this method and `getTileCoordForXYAndResolution_`,\\n * they should have separate implementations.  This method is for integer zoom\\n * levels.  The other method should only be called for resolutions corresponding\\n * to non-integer zoom levels.\\n * @param {number} x Map x coordinate.\\n * @param {number} y Map y coordinate.\\n * @param {number} z Integer zoom level.\\n * @param {boolean} reverseIntersectionPolicy Instead of letting edge\\n *     intersections go to the higher tile coordinate, let edge intersections\\n *     go to the lower tile coordinate.\\n * @param {module:ol/tilecoord~TileCoord=} opt_tileCoord Temporary module:ol/tilecoord~TileCoord object.\\n * @return {module:ol/tilecoord~TileCoord} Tile coordinate.\\n * @private\\n */\\nTileGrid.prototype.getTileCoordForXYAndZ_ = function(x, y, z, reverseIntersectionPolicy, opt_tileCoord) {\\n  const origin = this.getOrigin(z);\\n  const resolution = this.getResolution(z);\\n  const tileSize = toSize(this.getTileSize(z), this.tmpSize_);\\n\\n  const adjustX = reverseIntersectionPolicy ? 0.5 : 0;\\n  const adjustY = reverseIntersectionPolicy ? 0 : 0.5;\\n  const xFromOrigin = Math.floor((x - origin[0]) / resolution + adjustX);\\n  const yFromOrigin = Math.floor((y - origin[1]) / resolution + adjustY);\\n  let tileCoordX = xFromOrigin / tileSize[0];\\n  let tileCoordY = yFromOrigin / tileSize[1];\\n\\n  if (reverseIntersectionPolicy) {\\n    tileCoordX = Math.ceil(tileCoordX) - 1;\\n    tileCoordY = Math.ceil(tileCoordY) - 1;\\n  } else {\\n    tileCoordX = Math.floor(tileCoordX);\\n    tileCoordY = Math.floor(tileCoordY);\\n  }\\n\\n  return createOrUpdateTileCoord(z, tileCoordX, tileCoordY, opt_tileCoord);\\n};\\n\\n\\n/**\\n * Get a tile coordinate given a map coordinate and zoom level.\\n * @param {module:ol/coordinate~Coordinate} coordinate Coordinate.\\n * @param {number} z Zoom level.\\n * @param {module:ol/tilecoord~TileCoord=} opt_tileCoord Destination module:ol/tilecoord~TileCoord object.\\n * @return {module:ol/tilecoord~TileCoord} Tile coordinate.\\n * @api\\n */\\nTileGrid.prototype.getTileCoordForCoordAndZ = function(coordinate, z, opt_tileCoord) {\\n  return this.getTileCoordForXYAndZ_(\\n    coordinate[0], coordinate[1], z, false, opt_tileCoord);\\n};\\n\\n\\n/**\\n * @param {module:ol/tilecoord~TileCoord} tileCoord Tile coordinate.\\n * @return {number} Tile resolution.\\n */\\nTileGrid.prototype.getTileCoordResolution = function(tileCoord) {\\n  return this.resolutions_[tileCoord[0]];\\n};\\n\\n\\n/**\\n * Get the tile size for a zoom level. The type of the return value matches the\\n * `tileSize` or `tileSizes` that the tile grid was configured with. To always\\n * get an `module:ol/size~Size`, run the result through `module:ol/size~Size.toSize()`.\\n * @param {number} z Z.\\n * @return {number|module:ol/size~Size} Tile size.\\n * @api\\n */\\nTileGrid.prototype.getTileSize = function(z) {\\n  if (this.tileSize_) {\\n    return this.tileSize_;\\n  } else {\\n    return this.tileSizes_[z];\\n  }\\n};\\n\\n\\n/**\\n * @param {number} z Zoom level.\\n * @return {module:ol/TileRange} Extent tile range for the specified zoom level.\\n */\\nTileGrid.prototype.getFullTileRange = function(z) {\\n  if (!this.fullTileRanges_) {\\n    return null;\\n  } else {\\n    return this.fullTileRanges_[z];\\n  }\\n};\\n\\n\\n/**\\n * @param {number} resolution Resolution.\\n * @param {number=} opt_direction If 0, the nearest resolution will be used.\\n *     If 1, the nearest lower resolution will be used. If -1, the nearest\\n *     higher resolution will be used. Default is 0.\\n * @return {number} Z.\\n * @api\\n */\\nTileGrid.prototype.getZForResolution = function(resolution, opt_direction) {\\n  const z = linearFindNearest(this.resolutions_, resolution, opt_direction || 0);\\n  return clamp(z, this.minZoom, this.maxZoom);\\n};\\n\\n\\n/**\\n * @param {!module:ol/extent~Extent} extent Extent for this tile grid.\\n * @private\\n */\\nTileGrid.prototype.calculateTileRanges_ = function(extent) {\\n  const length = this.resolutions_.length;\\n  const fullTileRanges = new Array(length);\\n  for (let z = this.minZoom; z < length; ++z) {\\n    fullTileRanges[z] = this.getTileRangeForExtentAndZ(extent, z);\\n  }\\n  this.fullTileRanges_ = fullTileRanges;\\n};\\nexport default TileGrid;\\n\",\"/**\\n * @module ol/tilegrid\\n */\\nimport {DEFAULT_MAX_ZOOM, DEFAULT_TILE_SIZE} from './tilegrid/common.js';\\nimport {toSize} from './size.js';\\nimport {containsCoordinate, createOrUpdate, getCorner, getHeight, getWidth} from './extent.js';\\nimport Corner from './extent/Corner.js';\\nimport {assign} from './obj.js';\\nimport {get as getProjection, METERS_PER_UNIT} from './proj.js';\\nimport Units from './proj/Units.js';\\nimport TileGrid from './tilegrid/TileGrid.js';\\n\\n\\n/**\\n * @param {module:ol/proj/Projection} projection Projection.\\n * @return {!module:ol/tilegrid/TileGrid} Default tile grid for the\\n * passed projection.\\n */\\nexport function getForProjection(projection) {\\n  let tileGrid = projection.getDefaultTileGrid();\\n  if (!tileGrid) {\\n    tileGrid = createForProjection(projection);\\n    projection.setDefaultTileGrid(tileGrid);\\n  }\\n  return tileGrid;\\n}\\n\\n\\n/**\\n * @param {module:ol/tilegrid/TileGrid} tileGrid Tile grid.\\n * @param {module:ol/tilecoord~TileCoord} tileCoord Tile coordinate.\\n * @param {module:ol/proj/Projection} projection Projection.\\n * @return {module:ol/tilecoord~TileCoord} Tile coordinate.\\n */\\nexport function wrapX(tileGrid, tileCoord, projection) {\\n  const z = tileCoord[0];\\n  const center = tileGrid.getTileCoordCenter(tileCoord);\\n  const projectionExtent = extentFromProjection(projection);\\n  if (!containsCoordinate(projectionExtent, center)) {\\n    const worldWidth = getWidth(projectionExtent);\\n    const worldsAway = Math.ceil((projectionExtent[0] - center[0]) / worldWidth);\\n    center[0] += worldWidth * worldsAway;\\n    return tileGrid.getTileCoordForCoordAndZ(center, z);\\n  } else {\\n    return tileCoord;\\n  }\\n}\\n\\n\\n/**\\n * @param {module:ol/extent~Extent} extent Extent.\\n * @param {number=} opt_maxZoom Maximum zoom level (default is\\n *     DEFAULT_MAX_ZOOM).\\n * @param {number|module:ol/size~Size=} opt_tileSize Tile size (default uses\\n *     DEFAULT_TILE_SIZE).\\n * @param {module:ol/extent/Corner=} opt_corner Extent corner (default is `'top-left'`).\\n * @return {!module:ol/tilegrid/TileGrid} TileGrid instance.\\n */\\nexport function createForExtent(extent, opt_maxZoom, opt_tileSize, opt_corner) {\\n  const corner = opt_corner !== undefined ? opt_corner : Corner.TOP_LEFT;\\n\\n  const resolutions = resolutionsFromExtent(extent, opt_maxZoom, opt_tileSize);\\n\\n  return new TileGrid({\\n    extent: extent,\\n    origin: getCorner(extent, corner),\\n    resolutions: resolutions,\\n    tileSize: opt_tileSize\\n  });\\n}\\n\\n\\n/**\\n * @typedef {Object} XYZOptions\\n * @property {module:ol/extent~Extent} [extent] Extent for the tile grid. The origin for an XYZ tile grid is the\\n * top-left corner of the extent. The zero level of the grid is defined by the resolution at which one tile fits in the\\n * provided extent. If not provided, the extent of the EPSG:3857 projection is used.\\n * @property {number} [maxZoom] Maximum zoom. The default is `42`. This determines the number of levels\\n * in the grid set. For example, a `maxZoom` of 21 means there are 22 levels in the grid set.\\n * @property {number} [minZoom=0] Minimum zoom.\\n * @property {number|module:ol/size~Size} [tileSize=[256, 256]] Tile size in pixels.\\n */\\n\\n\\n/**\\n * Creates a tile grid with a standard XYZ tiling scheme.\\n * @param {module:ol/tilegrid~XYZOptions=} opt_options Tile grid options.\\n * @return {!module:ol/tilegrid/TileGrid} Tile grid instance.\\n * @api\\n */\\nexport function createXYZ(opt_options) {\\n  const options = /** @type {module:ol/tilegrid/TileGrid~Options} */ ({});\\n  assign(options, opt_options !== undefined ?\\n    opt_options : /** @type {module:ol/tilegrid~XYZOptions} */ ({}));\\n  if (options.extent === undefined) {\\n    options.extent = getProjection('EPSG:3857').getExtent();\\n  }\\n  options.resolutions = resolutionsFromExtent(\\n    options.extent, options.maxZoom, options.tileSize);\\n  delete options.maxZoom;\\n\\n  return new TileGrid(options);\\n}\\n\\n\\n/**\\n * Create a resolutions array from an extent.  A zoom factor of 2 is assumed.\\n * @param {module:ol/extent~Extent} extent Extent.\\n * @param {number=} opt_maxZoom Maximum zoom level (default is\\n *     DEFAULT_MAX_ZOOM).\\n * @param {number|module:ol/size~Size=} opt_tileSize Tile size (default uses\\n *     DEFAULT_TILE_SIZE).\\n * @return {!Array.<number>} Resolutions array.\\n */\\nfunction resolutionsFromExtent(extent, opt_maxZoom, opt_tileSize) {\\n  const maxZoom = opt_maxZoom !== undefined ?\\n    opt_maxZoom : DEFAULT_MAX_ZOOM;\\n\\n  const height = getHeight(extent);\\n  const width = getWidth(extent);\\n\\n  const tileSize = toSize(opt_tileSize !== undefined ?\\n    opt_tileSize : DEFAULT_TILE_SIZE);\\n  const maxResolution = Math.max(\\n    width / tileSize[0], height / tileSize[1]);\\n\\n  const length = maxZoom + 1;\\n  const resolutions = new Array(length);\\n  for (let z = 0; z < length; ++z) {\\n    resolutions[z] = maxResolution / Math.pow(2, z);\\n  }\\n  return resolutions;\\n}\\n\\n\\n/**\\n * @param {module:ol/proj~ProjectionLike} projection Projection.\\n * @param {number=} opt_maxZoom Maximum zoom level (default is\\n *     DEFAULT_MAX_ZOOM).\\n * @param {number|module:ol/size~Size=} opt_tileSize Tile size (default uses\\n *     DEFAULT_TILE_SIZE).\\n * @param {module:ol/extent/Corner=} opt_corner Extent corner (default is `'top-left'`).\\n * @return {!module:ol/tilegrid/TileGrid} TileGrid instance.\\n */\\nexport function createForProjection(projection, opt_maxZoom, opt_tileSize, opt_corner) {\\n  const extent = extentFromProjection(projection);\\n  return createForExtent(extent, opt_maxZoom, opt_tileSize, opt_corner);\\n}\\n\\n\\n/**\\n * Generate a tile grid extent from a projection.  If the projection has an\\n * extent, it is used.  If not, a global extent is assumed.\\n * @param {module:ol/proj~ProjectionLike} projection Projection.\\n * @return {module:ol/extent~Extent} Extent.\\n */\\nexport function extentFromProjection(projection) {\\n  projection = getProjection(projection);\\n  let extent = projection.getExtent();\\n  if (!extent) {\\n    const half = 180 * METERS_PER_UNIT[Units.DEGREES] / projection.getMetersPerUnit();\\n    extent = createOrUpdate(-half, -half, half, half);\\n  }\\n  return extent;\\n}\\n\",\"/**\\n * @module ol/source/Tile\\n */\\nimport {inherits} from '../index.js';\\nimport {UNDEFINED} from '../functions.js';\\nimport TileCache from '../TileCache.js';\\nimport TileState from '../TileState.js';\\nimport Event from '../events/Event.js';\\nimport {equivalent} from '../proj.js';\\nimport {toSize, scale as scaleSize} from '../size.js';\\nimport Source from '../source/Source.js';\\nimport {getKeyZXY, withinExtentAndZ} from '../tilecoord.js';\\nimport {wrapX, getForProjection as getTileGridForProjection} from '../tilegrid.js';\\n\\n/**\\n * @typedef {Object} Options\\n * @property {module:ol/source/Source~AttributionLike} [attributions]\\n * @property {number} [cacheSize]\\n * @property {module:ol/extent~Extent} [extent]\\n * @property {boolean} [opaque]\\n * @property {number} [tilePixelRatio]\\n * @property {module:ol/proj~ProjectionLike} [projection]\\n * @property {module:ol/source/State} [state]\\n * @property {module:ol/tilegrid/TileGrid} [tileGrid]\\n * @property {boolean} [wrapX=true]\\n * @property {number} [transition]\\n */\\n\\n\\n/**\\n * @classdesc\\n * Abstract base class; normally only used for creating subclasses and not\\n * instantiated in apps.\\n * Base class for sources providing images divided into a tile grid.\\n *\\n * @constructor\\n * @abstract\\n * @extends {module:ol/source/Source}\\n * @param {module:ol/source/Tile~Options=} options SourceTile source options.\\n * @api\\n */\\nconst TileSource = function(options) {\\n\\n  Source.call(this, {\\n    attributions: options.attributions,\\n    extent: options.extent,\\n    projection: options.projection,\\n    state: options.state,\\n    wrapX: options.wrapX\\n  });\\n\\n  /**\\n   * @private\\n   * @type {boolean}\\n   */\\n  this.opaque_ = options.opaque !== undefined ? options.opaque : false;\\n\\n  /**\\n   * @private\\n   * @type {number}\\n   */\\n  this.tilePixelRatio_ = options.tilePixelRatio !== undefined ?\\n    options.tilePixelRatio : 1;\\n\\n  /**\\n   * @protected\\n   * @type {module:ol/tilegrid/TileGrid}\\n   */\\n  this.tileGrid = options.tileGrid !== undefined ? options.tileGrid : null;\\n\\n  /**\\n   * @protected\\n   * @type {module:ol/TileCache}\\n   */\\n  this.tileCache = new TileCache(options.cacheSize);\\n\\n  /**\\n   * @protected\\n   * @type {module:ol/size~Size}\\n   */\\n  this.tmpSize = [0, 0];\\n\\n  /**\\n   * @private\\n   * @type {string}\\n   */\\n  this.key_ = '';\\n\\n  /**\\n   * @protected\\n   * @type {module:ol/Tile~Options}\\n   */\\n  this.tileOptions = {transition: options.transition};\\n\\n};\\n\\ninherits(TileSource, Source);\\n\\n\\n/**\\n * @return {boolean} Can expire cache.\\n */\\nTileSource.prototype.canExpireCache = function() {\\n  return this.tileCache.canExpireCache();\\n};\\n\\n\\n/**\\n * @param {module:ol/proj/Projection} projection Projection.\\n * @param {!Object.<string, module:ol/TileRange>} usedTiles Used tiles.\\n */\\nTileSource.prototype.expireCache = function(projection, usedTiles) {\\n  const tileCache = this.getTileCacheForProjection(projection);\\n  if (tileCache) {\\n    tileCache.expireCache(usedTiles);\\n  }\\n};\\n\\n\\n/**\\n * @param {module:ol/proj/Projection} projection Projection.\\n * @param {number} z Zoom level.\\n * @param {module:ol/TileRange} tileRange Tile range.\\n * @param {function(module:ol/Tile):(boolean|undefined)} callback Called with each\\n *     loaded tile.  If the callback returns `false`, the tile will not be\\n *     considered loaded.\\n * @return {boolean} The tile range is fully covered with loaded tiles.\\n */\\nTileSource.prototype.forEachLoadedTile = function(projection, z, tileRange, callback) {\\n  const tileCache = this.getTileCacheForProjection(projection);\\n  if (!tileCache) {\\n    return false;\\n  }\\n\\n  let covered = true;\\n  let tile, tileCoordKey, loaded;\\n  for (let x = tileRange.minX; x <= tileRange.maxX; ++x) {\\n    for (let y = tileRange.minY; y <= tileRange.maxY; ++y) {\\n      tileCoordKey = getKeyZXY(z, x, y);\\n      loaded = false;\\n      if (tileCache.containsKey(tileCoordKey)) {\\n        tile = /** @type {!module:ol/Tile} */ (tileCache.get(tileCoordKey));\\n        loaded = tile.getState() === TileState.LOADED;\\n        if (loaded) {\\n          loaded = (callback(tile) !== false);\\n        }\\n      }\\n      if (!loaded) {\\n        covered = false;\\n      }\\n    }\\n  }\\n  return covered;\\n};\\n\\n\\n/**\\n * @param {module:ol/proj/Projection} projection Projection.\\n * @return {number} Gutter.\\n */\\nTileSource.prototype.getGutter = function(projection) {\\n  return 0;\\n};\\n\\n\\n/**\\n * Return the key to be used for all tiles in the source.\\n * @return {string} The key for all tiles.\\n * @protected\\n */\\nTileSource.prototype.getKey = function() {\\n  return this.key_;\\n};\\n\\n\\n/**\\n * Set the value to be used as the key for all tiles in the source.\\n * @param {string} key The key for tiles.\\n * @protected\\n */\\nTileSource.prototype.setKey = function(key) {\\n  if (this.key_ !== key) {\\n    this.key_ = key;\\n    this.changed();\\n  }\\n};\\n\\n\\n/**\\n * @param {module:ol/proj/Projection} projection Projection.\\n * @return {boolean} Opaque.\\n */\\nTileSource.prototype.getOpaque = function(projection) {\\n  return this.opaque_;\\n};\\n\\n\\n/**\\n * @inheritDoc\\n */\\nTileSource.prototype.getResolutions = function() {\\n  return this.tileGrid.getResolutions();\\n};\\n\\n\\n/**\\n * @abstract\\n * @param {number} z Tile coordinate z.\\n * @param {number} x Tile coordinate x.\\n * @param {number} y Tile coordinate y.\\n * @param {number} pixelRatio Pixel ratio.\\n * @param {module:ol/proj/Projection} projection Projection.\\n * @return {!module:ol/Tile} Tile.\\n */\\nTileSource.prototype.getTile = function(z, x, y, pixelRatio, projection) {};\\n\\n\\n/**\\n * Return the tile grid of the tile source.\\n * @return {module:ol/tilegrid/TileGrid} Tile grid.\\n * @api\\n */\\nTileSource.prototype.getTileGrid = function() {\\n  return this.tileGrid;\\n};\\n\\n\\n/**\\n * @param {module:ol/proj/Projection} projection Projection.\\n * @return {!module:ol/tilegrid/TileGrid} Tile grid.\\n */\\nTileSource.prototype.getTileGridForProjection = function(projection) {\\n  if (!this.tileGrid) {\\n    return getTileGridForProjection(projection);\\n  } else {\\n    return this.tileGrid;\\n  }\\n};\\n\\n\\n/**\\n * @param {module:ol/proj/Projection} projection Projection.\\n * @return {module:ol/TileCache} Tile cache.\\n * @protected\\n */\\nTileSource.prototype.getTileCacheForProjection = function(projection) {\\n  const thisProj = this.getProjection();\\n  if (thisProj && !equivalent(thisProj, projection)) {\\n    return null;\\n  } else {\\n    return this.tileCache;\\n  }\\n};\\n\\n\\n/**\\n * Get the tile pixel ratio for this source. Subclasses may override this\\n * method, which is meant to return a supported pixel ratio that matches the\\n * provided `pixelRatio` as close as possible.\\n * @param {number} pixelRatio Pixel ratio.\\n * @return {number} Tile pixel ratio.\\n */\\nTileSource.prototype.getTilePixelRatio = function(pixelRatio) {\\n  return this.tilePixelRatio_;\\n};\\n\\n\\n/**\\n * @param {number} z Z.\\n * @param {number} pixelRatio Pixel ratio.\\n * @param {module:ol/proj/Projection} projection Projection.\\n * @return {module:ol/size~Size} Tile size.\\n */\\nTileSource.prototype.getTilePixelSize = function(z, pixelRatio, projection) {\\n  const tileGrid = this.getTileGridForProjection(projection);\\n  const tilePixelRatio = this.getTilePixelRatio(pixelRatio);\\n  const tileSize = toSize(tileGrid.getTileSize(z), this.tmpSize);\\n  if (tilePixelRatio == 1) {\\n    return tileSize;\\n  } else {\\n    return scaleSize(tileSize, tilePixelRatio, this.tmpSize);\\n  }\\n};\\n\\n\\n/**\\n * Returns a tile coordinate wrapped around the x-axis. When the tile coordinate\\n * is outside the resolution and extent range of the tile grid, `null` will be\\n * returned.\\n * @param {module:ol/tilecoord~TileCoord} tileCoord Tile coordinate.\\n * @param {module:ol/proj/Projection=} opt_projection Projection.\\n * @return {module:ol/tilecoord~TileCoord} Tile coordinate to be passed to the tileUrlFunction or\\n *     null if no tile URL should be created for the passed `tileCoord`.\\n */\\nTileSource.prototype.getTileCoordForTileUrlFunction = function(tileCoord, opt_projection) {\\n  const projection = opt_projection !== undefined ?\\n    opt_projection : this.getProjection();\\n  const tileGrid = this.getTileGridForProjection(projection);\\n  if (this.getWrapX() && projection.isGlobal()) {\\n    tileCoord = wrapX(tileGrid, tileCoord, projection);\\n  }\\n  return withinExtentAndZ(tileCoord, tileGrid) ? tileCoord : null;\\n};\\n\\n\\n/**\\n * @inheritDoc\\n */\\nTileSource.prototype.refresh = function() {\\n  this.tileCache.clear();\\n  this.changed();\\n};\\n\\n\\n/**\\n * Marks a tile coord as being used, without triggering a load.\\n * @param {number} z Tile coordinate z.\\n * @param {number} x Tile coordinate x.\\n * @param {number} y Tile coordinate y.\\n * @param {module:ol/proj/Projection} projection Projection.\\n */\\nTileSource.prototype.useTile = UNDEFINED;\\n\\n\\n/**\\n * @classdesc\\n * Events emitted by {@link module:ol/source/Tile~TileSource} instances are instances of this\\n * type.\\n *\\n * @constructor\\n * @extends {module:ol/events/Event}\\n * @param {string} type Type.\\n * @param {module:ol/Tile} tile The tile.\\n */\\nexport const TileSourceEvent = function(type, tile) {\\n\\n  Event.call(this, type);\\n\\n  /**\\n   * The tile related to the event.\\n   * @type {module:ol/Tile}\\n   * @api\\n   */\\n  this.tile = tile;\\n\\n};\\ninherits(TileSourceEvent, Event);\\n\\nexport default TileSource;\\n\",\"/**\\n * @module ol/source/TileEventType\\n */\\n\\n/**\\n * @enum {string}\\n */\\nexport default {\\n\\n  /**\\n   * Triggered when a tile starts loading.\\n   * @event module:ol/source/Tile~TileSourceEvent#tileloadstart\\n   * @api\\n   */\\n  TILELOADSTART: 'tileloadstart',\\n\\n  /**\\n   * Triggered when a tile finishes loading, either when its data is loaded,\\n   * or when loading was aborted because the tile is no longer needed.\\n   * @event module:ol/source/Tile~TileSourceEvent#tileloadend\\n   * @api\\n   */\\n  TILELOADEND: 'tileloadend',\\n\\n  /**\\n   * Triggered if tile loading results in an error.\\n   * @event module:ol/source/Tile~TileSourceEvent#tileloaderror\\n   * @api\\n   */\\n  TILELOADERROR: 'tileloaderror'\\n\\n};\\n\",\"/**\\n * @module ol/source/UrlTile\\n */\\nimport {getUid, inherits} from '../index.js';\\nimport TileState from '../TileState.js';\\nimport {expandUrl, createFromTemplates, nullTileUrlFunction} from '../tileurlfunction.js';\\nimport TileSource, {TileSourceEvent} from '../source/Tile.js';\\nimport TileEventType from '../source/TileEventType.js';\\nimport {getKeyZXY} from '../tilecoord.js';\\n\\n/**\\n * @typedef {Object} Options\\n * @property {module:ol/source/Source~AttributionLike} [attributions]\\n * @property {number} [cacheSize]\\n * @property {module:ol/extent~Extent} [extent]\\n * @property {boolean} [opaque]\\n * @property {module:ol/proj~ProjectionLike} [projection]\\n * @property {module:ol/source/State} [state]\\n * @property {module:ol/tilegrid/TileGrid} [tileGrid]\\n * @property {module:ol/Tile~LoadFunction} tileLoadFunction\\n * @property {number} [tilePixelRatio]\\n * @property {module:ol/Tile~UrlFunction} [tileUrlFunction]\\n * @property {string} [url]\\n * @property {Array.<string>} [urls]\\n * @property {boolean} [wrapX=true]\\n * @property {number} [transition]\\n */\\n\\n\\n/**\\n * @classdesc\\n * Base class for sources providing tiles divided into a tile grid over http.\\n *\\n * @constructor\\n * @abstract\\n * @fires module:ol/source/TileEvent\\n * @extends {module:ol/source/Tile}\\n * @param {module:ol/source/UrlTile~Options=} options Image tile options.\\n */\\nconst UrlTile = function(options) {\\n\\n  TileSource.call(this, {\\n    attributions: options.attributions,\\n    cacheSize: options.cacheSize,\\n    extent: options.extent,\\n    opaque: options.opaque,\\n    projection: options.projection,\\n    state: options.state,\\n    tileGrid: options.tileGrid,\\n    tilePixelRatio: options.tilePixelRatio,\\n    wrapX: options.wrapX,\\n    transition: options.transition\\n  });\\n\\n  /**\\n   * @protected\\n   * @type {module:ol/Tile~LoadFunction}\\n   */\\n  this.tileLoadFunction = options.tileLoadFunction;\\n\\n  /**\\n   * @protected\\n   * @type {module:ol/Tile~UrlFunction}\\n   */\\n  this.tileUrlFunction = this.fixedTileUrlFunction ?\\n    this.fixedTileUrlFunction.bind(this) : nullTileUrlFunction;\\n\\n  /**\\n   * @protected\\n   * @type {!Array.<string>|null}\\n   */\\n  this.urls = null;\\n\\n  if (options.urls) {\\n    this.setUrls(options.urls);\\n  } else if (options.url) {\\n    this.setUrl(options.url);\\n  }\\n  if (options.tileUrlFunction) {\\n    this.setTileUrlFunction(options.tileUrlFunction);\\n  }\\n\\n  /**\\n   * @private\\n   * @type {!Object.<number, boolean>}\\n   */\\n  this.tileLoadingKeys_ = {};\\n\\n};\\n\\ninherits(UrlTile, TileSource);\\n\\n\\n/**\\n * @type {module:ol/Tile~UrlFunction|undefined}\\n * @protected\\n */\\nUrlTile.prototype.fixedTileUrlFunction;\\n\\n/**\\n * Return the tile load function of the source.\\n * @return {module:ol/Tile~LoadFunction} TileLoadFunction\\n * @api\\n */\\nUrlTile.prototype.getTileLoadFunction = function() {\\n  return this.tileLoadFunction;\\n};\\n\\n\\n/**\\n * Return the tile URL function of the source.\\n * @return {module:ol/Tile~UrlFunction} TileUrlFunction\\n * @api\\n */\\nUrlTile.prototype.getTileUrlFunction = function() {\\n  return this.tileUrlFunction;\\n};\\n\\n\\n/**\\n * Return the URLs used for this source.\\n * When a tileUrlFunction is used instead of url or urls,\\n * null will be returned.\\n * @return {!Array.<string>|null} URLs.\\n * @api\\n */\\nUrlTile.prototype.getUrls = function() {\\n  return this.urls;\\n};\\n\\n\\n/**\\n * Handle tile change events.\\n * @param {module:ol/events/Event} event Event.\\n * @protected\\n */\\nUrlTile.prototype.handleTileChange = function(event) {\\n  const tile = /** @type {module:ol/Tile} */ (event.target);\\n  const uid = getUid(tile);\\n  const tileState = tile.getState();\\n  let type;\\n  if (tileState == TileState.LOADING) {\\n    this.tileLoadingKeys_[uid] = true;\\n    type = TileEventType.TILELOADSTART;\\n  } else if (uid in this.tileLoadingKeys_) {\\n    delete this.tileLoadingKeys_[uid];\\n    type = tileState == TileState.ERROR ? TileEventType.TILELOADERROR :\\n      (tileState == TileState.LOADED || tileState == TileState.ABORT) ?\\n        TileEventType.TILELOADEND : undefined;\\n  }\\n  if (type != undefined) {\\n    this.dispatchEvent(new TileSourceEvent(type, tile));\\n  }\\n};\\n\\n\\n/**\\n * Set the tile load function of the source.\\n * @param {module:ol/Tile~LoadFunction} tileLoadFunction Tile load function.\\n * @api\\n */\\nUrlTile.prototype.setTileLoadFunction = function(tileLoadFunction) {\\n  this.tileCache.clear();\\n  this.tileLoadFunction = tileLoadFunction;\\n  this.changed();\\n};\\n\\n\\n/**\\n * Set the tile URL function of the source.\\n * @param {module:ol/Tile~UrlFunction} tileUrlFunction Tile URL function.\\n * @param {string=} opt_key Optional new tile key for the source.\\n * @api\\n */\\nUrlTile.prototype.setTileUrlFunction = function(tileUrlFunction, opt_key) {\\n  this.tileUrlFunction = tileUrlFunction;\\n  this.tileCache.pruneExceptNewestZ();\\n  if (typeof opt_key !== 'undefined') {\\n    this.setKey(opt_key);\\n  } else {\\n    this.changed();\\n  }\\n};\\n\\n\\n/**\\n * Set the URL to use for requests.\\n * @param {string} url URL.\\n * @api\\n */\\nUrlTile.prototype.setUrl = function(url) {\\n  const urls = this.urls = expandUrl(url);\\n  this.setTileUrlFunction(this.fixedTileUrlFunction ?\\n    this.fixedTileUrlFunction.bind(this) :\\n    createFromTemplates(urls, this.tileGrid), url);\\n};\\n\\n\\n/**\\n * Set the URLs to use for requests.\\n * @param {Array.<string>} urls URLs.\\n * @api\\n */\\nUrlTile.prototype.setUrls = function(urls) {\\n  this.urls = urls;\\n  const key = urls.join('\\\\n');\\n  this.setTileUrlFunction(this.fixedTileUrlFunction ?\\n    this.fixedTileUrlFunction.bind(this) :\\n    createFromTemplates(urls, this.tileGrid), key);\\n};\\n\\n\\n/**\\n * @inheritDoc\\n */\\nUrlTile.prototype.useTile = function(z, x, y) {\\n  const tileCoordKey = getKeyZXY(z, x, y);\\n  if (this.tileCache.containsKey(tileCoordKey)) {\\n    this.tileCache.get(tileCoordKey);\\n  }\\n};\\nexport default UrlTile;\\n\",\"/**\\n * @module ol/source/TileImage\\n */\\nimport {ENABLE_RASTER_REPROJECTION} from '../reproj/common.js';\\nimport {getUid, inherits} from '../index.js';\\nimport ImageTile from '../ImageTile.js';\\nimport TileCache from '../TileCache.js';\\nimport TileState from '../TileState.js';\\nimport {listen} from '../events.js';\\nimport EventType from '../events/EventType.js';\\nimport {equivalent, get as getProjection} from '../proj.js';\\nimport ReprojTile from '../reproj/Tile.js';\\nimport UrlTile from '../source/UrlTile.js';\\nimport {getKey, getKeyZXY} from '../tilecoord.js';\\nimport {getForProjection as getTileGridForProjection} from '../tilegrid.js';\\n\\n/**\\n * @typedef {Object} Options\\n * @property {module:ol/source/Source~AttributionLike} [attributions] Attributions.\\n * @property {number} [cacheSize=2048] Cache size.\\n * @property {null|string} [crossOrigin] The `crossOrigin` attribute for loaded images.  Note that\\n * you must provide a `crossOrigin` value if you are using the WebGL renderer or if you want to\\n * access pixel data with the Canvas renderer.  See\\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_enabled_image} for more detail.\\n * @property {boolean} [opaque=true] Whether the layer is opaque.\\n * @property {module:ol/proj~ProjectionLike} projection Projection.\\n * @property {boolean} [reprojectionErrorThreshold=0.5] Maximum allowed reprojection error (in pixels).\\n * Higher values can increase reprojection performance, but decrease precision.\\n * @property {module:ol/source/State} [state] Source state.\\n * @property {module:ol/ImageTile~TileClass} [tileClass] Class used to instantiate image tiles.\\n * Default is {@link module:ol/ImageTile~ImageTile}.\\n * @property {module:ol/tilegrid/TileGrid} [tileGrid] Tile grid.\\n * @property {module:ol/Tile~LoadFunction} [tileLoadFunction] Optional function to load a tile given a URL. The default is\\n * ```js\\n * function(imageTile, src) {\\n *   imageTile.getImage().src = src;\\n * };\\n * ```\\n * @property {number} [tilePixelRatio=1] The pixel ratio used by the tile service. For example, if the tile\\n * service advertizes 256px by 256px tiles but actually sends 512px\\n * by 512px images (for retina/hidpi devices) then `tilePixelRatio`\\n * should be set to `2`.\\n * @property {module:ol/Tile~UrlFunction} [tileUrlFunction] Optional function to get tile URL given a tile coordinate and the projection.\\n * @property {string} [url] URL template. Must include `{x}`, `{y}` or `{-y}`, and `{z}` placeholders.\\n * A `{?-?}` template pattern, for example `subdomain{a-f}.domain.com`, may be\\n * used instead of defining each one separately in the `urls` option.\\n * @property {Array.<string>} [urls] An array of URL templates.\\n * @property {boolean} [wrapX] Whether to wrap the world horizontally. The default, is to\\n * request out-of-bounds tiles from the server. When set to `false`, only one\\n * world will be rendered. When set to `true`, tiles will be requested for one\\n * world only, but they will be wrapped horizontally to render multiple worlds.\\n * @property {number} [transition] Duration of the opacity transition for rendering.\\n * To disable the opacity transition, pass `transition: 0`.\\n */\\n\\n\\n/**\\n * @classdesc\\n * Base class for sources providing images divided into a tile grid.\\n *\\n * @constructor\\n * @fires module:ol/source/Tile~TileSourceEvent\\n * @extends {module:ol/source/UrlTile}\\n * @param {module:ol/source/TileImage~Options=} options Image tile options.\\n * @api\\n */\\nconst TileImage = function(options) {\\n\\n  UrlTile.call(this, {\\n    attributions: options.attributions,\\n    cacheSize: options.cacheSize,\\n    extent: options.extent,\\n    opaque: options.opaque,\\n    projection: options.projection,\\n    state: options.state,\\n    tileGrid: options.tileGrid,\\n    tileLoadFunction: options.tileLoadFunction ?\\n      options.tileLoadFunction : defaultTileLoadFunction,\\n    tilePixelRatio: options.tilePixelRatio,\\n    tileUrlFunction: options.tileUrlFunction,\\n    url: options.url,\\n    urls: options.urls,\\n    wrapX: options.wrapX,\\n    transition: options.transition\\n  });\\n\\n  /**\\n   * @protected\\n   * @type {?string}\\n   */\\n  this.crossOrigin =\\n      options.crossOrigin !== undefined ? options.crossOrigin : null;\\n\\n  /**\\n   * @protected\\n   * @type {function(new: module:ol/ImageTile, module:ol/tilecoord~TileCoord, module:ol/TileState, string,\\n   *        ?string, module:ol/Tile~LoadFunction, module:ol/Tile~Options=)}\\n   */\\n  this.tileClass = options.tileClass !== undefined ?\\n    options.tileClass : ImageTile;\\n\\n  /**\\n   * @protected\\n   * @type {!Object.<string, module:ol/TileCache>}\\n   */\\n  this.tileCacheForProjection = {};\\n\\n  /**\\n   * @protected\\n   * @type {!Object.<string, module:ol/tilegrid/TileGrid>}\\n   */\\n  this.tileGridForProjection = {};\\n\\n  /**\\n   * @private\\n   * @type {number|undefined}\\n   */\\n  this.reprojectionErrorThreshold_ = options.reprojectionErrorThreshold;\\n\\n  /**\\n   * @private\\n   * @type {boolean}\\n   */\\n  this.renderReprojectionEdges_ = false;\\n};\\n\\ninherits(TileImage, UrlTile);\\n\\n\\n/**\\n * @inheritDoc\\n */\\nTileImage.prototype.canExpireCache = function() {\\n  if (!ENABLE_RASTER_REPROJECTION) {\\n    return UrlTile.prototype.canExpireCache.call(this);\\n  }\\n  if (this.tileCache.canExpireCache()) {\\n    return true;\\n  } else {\\n    for (const key in this.tileCacheForProjection) {\\n      if (this.tileCacheForProjection[key].canExpireCache()) {\\n        return true;\\n      }\\n    }\\n  }\\n  return false;\\n};\\n\\n\\n/**\\n * @inheritDoc\\n */\\nTileImage.prototype.expireCache = function(projection, usedTiles) {\\n  if (!ENABLE_RASTER_REPROJECTION) {\\n    UrlTile.prototype.expireCache.call(this, projection, usedTiles);\\n    return;\\n  }\\n  const usedTileCache = this.getTileCacheForProjection(projection);\\n\\n  this.tileCache.expireCache(this.tileCache == usedTileCache ? usedTiles : {});\\n  for (const id in this.tileCacheForProjection) {\\n    const tileCache = this.tileCacheForProjection[id];\\n    tileCache.expireCache(tileCache == usedTileCache ? usedTiles : {});\\n  }\\n};\\n\\n\\n/**\\n * @inheritDoc\\n */\\nTileImage.prototype.getGutter = function(projection) {\\n  if (ENABLE_RASTER_REPROJECTION &&\\n      this.getProjection() && projection && !equivalent(this.getProjection(), projection)) {\\n    return 0;\\n  } else {\\n    return this.getGutterInternal();\\n  }\\n};\\n\\n\\n/**\\n * @protected\\n * @return {number} Gutter.\\n */\\nTileImage.prototype.getGutterInternal = function() {\\n  return 0;\\n};\\n\\n\\n/**\\n * @inheritDoc\\n */\\nTileImage.prototype.getOpaque = function(projection) {\\n  if (ENABLE_RASTER_REPROJECTION &&\\n      this.getProjection() && projection && !equivalent(this.getProjection(), projection)) {\\n    return false;\\n  } else {\\n    return UrlTile.prototype.getOpaque.call(this, projection);\\n  }\\n};\\n\\n\\n/**\\n * @inheritDoc\\n */\\nTileImage.prototype.getTileGridForProjection = function(projection) {\\n  if (!ENABLE_RASTER_REPROJECTION) {\\n    return UrlTile.prototype.getTileGridForProjection.call(this, projection);\\n  }\\n  const thisProj = this.getProjection();\\n  if (this.tileGrid && (!thisProj || equivalent(thisProj, projection))) {\\n    return this.tileGrid;\\n  } else {\\n    const projKey = getUid(projection).toString();\\n    if (!(projKey in this.tileGridForProjection)) {\\n      this.tileGridForProjection[projKey] = getTileGridForProjection(projection);\\n    }\\n    return (\\n      /** @type {!module:ol/tilegrid/TileGrid} */ (this.tileGridForProjection[projKey])\\n    );\\n  }\\n};\\n\\n\\n/**\\n * @inheritDoc\\n */\\nTileImage.prototype.getTileCacheForProjection = function(projection) {\\n  if (!ENABLE_RASTER_REPROJECTION) {\\n    return UrlTile.prototype.getTileCacheForProjection.call(this, projection);\\n  }\\n  const thisProj = this.getProjection(); if (!thisProj || equivalent(thisProj, projection)) {\\n    return this.tileCache;\\n  } else {\\n    const projKey = getUid(projection).toString();\\n    if (!(projKey in this.tileCacheForProjection)) {\\n      this.tileCacheForProjection[projKey] = new TileCache(this.tileCache.highWaterMark);\\n    }\\n    return this.tileCacheForProjection[projKey];\\n  }\\n};\\n\\n\\n/**\\n * @param {number} z Tile coordinate z.\\n * @param {number} x Tile coordinate x.\\n * @param {number} y Tile coordinate y.\\n * @param {number} pixelRatio Pixel ratio.\\n * @param {module:ol/proj/Projection} projection Projection.\\n * @param {string} key The key set on the tile.\\n * @return {!module:ol/Tile} Tile.\\n * @private\\n */\\nTileImage.prototype.createTile_ = function(z, x, y, pixelRatio, projection, key) {\\n  const tileCoord = [z, x, y];\\n  const urlTileCoord = this.getTileCoordForTileUrlFunction(\\n    tileCoord, projection);\\n  const tileUrl = urlTileCoord ?\\n    this.tileUrlFunction(urlTileCoord, pixelRatio, projection) : undefined;\\n  const tile = new this.tileClass(\\n    tileCoord,\\n    tileUrl !== undefined ? TileState.IDLE : TileState.EMPTY,\\n    tileUrl !== undefined ? tileUrl : '',\\n    this.crossOrigin,\\n    this.tileLoadFunction,\\n    this.tileOptions);\\n  tile.key = key;\\n  listen(tile, EventType.CHANGE,\\n    this.handleTileChange, this);\\n  return tile;\\n};\\n\\n\\n/**\\n * @inheritDoc\\n */\\nTileImage.prototype.getTile = function(z, x, y, pixelRatio, projection) {\\n  const sourceProjection = /** @type {!module:ol/proj/Projection} */ (this.getProjection());\\n  if (!ENABLE_RASTER_REPROJECTION ||\\n      !sourceProjection || !projection || equivalent(sourceProjection, projection)) {\\n    return this.getTileInternal(z, x, y, pixelRatio, sourceProjection || projection);\\n  } else {\\n    const cache = this.getTileCacheForProjection(projection);\\n    const tileCoord = [z, x, y];\\n    let tile;\\n    const tileCoordKey = getKey(tileCoord);\\n    if (cache.containsKey(tileCoordKey)) {\\n      tile = /** @type {!module:ol/Tile} */ (cache.get(tileCoordKey));\\n    }\\n    const key = this.getKey();\\n    if (tile && tile.key == key) {\\n      return tile;\\n    } else {\\n      const sourceTileGrid = this.getTileGridForProjection(sourceProjection);\\n      const targetTileGrid = this.getTileGridForProjection(projection);\\n      const wrappedTileCoord =\\n          this.getTileCoordForTileUrlFunction(tileCoord, projection);\\n      const newTile = new ReprojTile(\\n        sourceProjection, sourceTileGrid,\\n        projection, targetTileGrid,\\n        tileCoord, wrappedTileCoord, this.getTilePixelRatio(pixelRatio),\\n        this.getGutterInternal(),\\n        function(z, x, y, pixelRatio) {\\n          return this.getTileInternal(z, x, y, pixelRatio, sourceProjection);\\n        }.bind(this), this.reprojectionErrorThreshold_,\\n        this.renderReprojectionEdges_);\\n      newTile.key = key;\\n\\n      if (tile) {\\n        newTile.interimTile = tile;\\n        newTile.refreshInterimChain();\\n        cache.replace(tileCoordKey, newTile);\\n      } else {\\n        cache.set(tileCoordKey, newTile);\\n      }\\n      return newTile;\\n    }\\n  }\\n};\\n\\n\\n/**\\n * @param {number} z Tile coordinate z.\\n * @param {number} x Tile coordinate x.\\n * @param {number} y Tile coordinate y.\\n * @param {number} pixelRatio Pixel ratio.\\n * @param {!module:ol/proj/Projection} projection Projection.\\n * @return {!module:ol/Tile} Tile.\\n * @protected\\n */\\nTileImage.prototype.getTileInternal = function(z, x, y, pixelRatio, projection) {\\n  let tile = null;\\n  const tileCoordKey = getKeyZXY(z, x, y);\\n  const key = this.getKey();\\n  if (!this.tileCache.containsKey(tileCoordKey)) {\\n    tile = this.createTile_(z, x, y, pixelRatio, projection, key);\\n    this.tileCache.set(tileCoordKey, tile);\\n  } else {\\n    tile = this.tileCache.get(tileCoordKey);\\n    if (tile.key != key) {\\n      // The source's params changed. If the tile has an interim tile and if we\\n      // can use it then we use it. Otherwise we create a new tile.  In both\\n      // cases we attempt to assign an interim tile to the new tile.\\n      const interimTile = tile;\\n      tile = this.createTile_(z, x, y, pixelRatio, projection, key);\\n\\n      //make the new tile the head of the list,\\n      if (interimTile.getState() == TileState.IDLE) {\\n        //the old tile hasn't begun loading yet, and is now outdated, so we can simply discard it\\n        tile.interimTile = interimTile.interimTile;\\n      } else {\\n        tile.interimTile = interimTile;\\n      }\\n      tile.refreshInterimChain();\\n      this.tileCache.replace(tileCoordKey, tile);\\n    }\\n  }\\n  return tile;\\n};\\n\\n\\n/**\\n * Sets whether to render reprojection edges or not (usually for debugging).\\n * @param {boolean} render Render the edges.\\n * @api\\n */\\nTileImage.prototype.setRenderReprojectionEdges = function(render) {\\n  if (!ENABLE_RASTER_REPROJECTION ||\\n      this.renderReprojectionEdges_ == render) {\\n    return;\\n  }\\n  this.renderReprojectionEdges_ = render;\\n  for (const id in this.tileCacheForProjection) {\\n    this.tileCacheForProjection[id].clear();\\n  }\\n  this.changed();\\n};\\n\\n\\n/**\\n * Sets the tile grid to use when reprojecting the tiles to the given\\n * projection instead of the default tile grid for the projection.\\n *\\n * This can be useful when the default tile grid cannot be created\\n * (e.g. projection has no extent defined) or\\n * for optimization reasons (custom tile size, resolutions, ...).\\n *\\n * @param {module:ol/proj~ProjectionLike} projection Projection.\\n * @param {module:ol/tilegrid/TileGrid} tilegrid Tile grid to use for the projection.\\n * @api\\n */\\nTileImage.prototype.setTileGridForProjection = function(projection, tilegrid) {\\n  if (ENABLE_RASTER_REPROJECTION) {\\n    const proj = getProjection(projection);\\n    if (proj) {\\n      const projKey = getUid(proj).toString();\\n      if (!(projKey in this.tileGridForProjection)) {\\n        this.tileGridForProjection[projKey] = tilegrid;\\n      }\\n    }\\n  }\\n};\\n\\n\\n/**\\n * @param {module:ol/ImageTile} imageTile Image tile.\\n * @param {string} src Source.\\n */\\nfunction defaultTileLoadFunction(imageTile, src) {\\n  imageTile.getImage().src = src;\\n}\\n\\nexport default TileImage;\\n\",\"/**\\n * @module ol/source/XYZ\\n */\\nimport {inherits} from '../index.js';\\nimport TileImage from '../source/TileImage.js';\\nimport {createXYZ, extentFromProjection} from '../tilegrid.js';\\n\\n/**\\n * @typedef {Object} Options\\n * @property {module:ol/source/Source~AttributionLike} [attributions] Attributions.\\n * @property {number} [cacheSize=2048] Cache size.\\n * @property {null|string} [crossOrigin] The `crossOrigin` attribute for loaded images.  Note that\\n * you must provide a `crossOrigin` value if you are using the WebGL renderer or if you want to\\n * access pixel data with the Canvas renderer.  See\\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_enabled_image} for more detail.\\n * @property {boolean} [opaque=true] Whether the layer is opaque.\\n * @property {module:ol/proj~ProjectionLike} [projection='EPSG:3857'] Projection.\\n * @property {boolean} [reprojectionErrorThreshold=0.5] Maximum allowed reprojection error (in pixels).\\n * Higher values can increase reprojection performance, but decrease precision.\\n * @property {number} [maxZoom=18] Optional max zoom level.\\n * @property {number} [minZoom=0] Optional min zoom level.\\n * @property {module:ol/tilegrid/TileGrid} [tileGrid] Tile grid.\\n * @property {module:ol/Tile~LoadFunction} [tileLoadFunction] Optional function to load a tile given a URL. The default is\\n * ```js\\n * function(imageTile, src) {\\n *   imageTile.getImage().src = src;\\n * };\\n * ```\\n * @property {number} [tilePixelRatio=1] The pixel ratio used by the tile service.\\n * For example, if the tile service advertizes 256px by 256px tiles but actually sends 512px\\n * by 512px images (for retina/hidpi devices) then `tilePixelRatio`\\n * should be set to `2`.\\n * @property {number|module:ol/size~Size} [tileSize=[256, 256]] The tile size used by the tile service.\\n * @property {module:ol/Tile~UrlFunction} [tileUrlFunction] Optional function to get\\n * tile URL given a tile coordinate and the projection.\\n * Required if url or urls are not provided.\\n * @property {string} [url] URL template. Must include `{x}`, `{y}` or `{-y}`,\\n * and `{z}` placeholders. A `{?-?}` template pattern, for example `subdomain{a-f}.domain.com`,\\n * may be used instead of defining each one separately in the `urls` option.\\n * @property {Array.<string>} [urls] An array of URL templates.\\n * @property {boolean} [wrapX=true] Whether to wrap the world horizontally.\\n * @property {number} [transition] Duration of the opacity transition for rendering.\\n * To disable the opacity transition, pass `transition: 0`.\\n */\\n\\n\\n/**\\n * @classdesc\\n * Layer source for tile data with URLs in a set XYZ format that are\\n * defined in a URL template. By default, this follows the widely-used\\n * Google grid where `x` 0 and `y` 0 are in the top left. Grids like\\n * TMS where `x` 0 and `y` 0 are in the bottom left can be used by\\n * using the `{-y}` placeholder in the URL template, so long as the\\n * source does not have a custom tile grid. In this case,\\n * {@link module:ol/source/TileImage} can be used with a `tileUrlFunction`\\n * such as:\\n *\\n *  tileUrlFunction: function(coordinate) {\\n *    return 'http://mapserver.com/' + coordinate[0] + '/' +\\n *        coordinate[1] + '/' + coordinate[2] + '.png';\\n *    }\\n *\\n *\\n * @constructor\\n * @extends {module:ol/source/TileImage}\\n * @param {module:ol/source/XYZ~Options=} opt_options XYZ options.\\n * @api\\n */\\nconst XYZ = function(opt_options) {\\n  const options = opt_options || {};\\n  const projection = options.projection !== undefined ?\\n    options.projection : 'EPSG:3857';\\n\\n  const tileGrid = options.tileGrid !== undefined ? options.tileGrid :\\n    createXYZ({\\n      extent: extentFromProjection(projection),\\n      maxZoom: options.maxZoom,\\n      minZoom: options.minZoom,\\n      tileSize: options.tileSize\\n    });\\n\\n  TileImage.call(this, {\\n    attributions: options.attributions,\\n    cacheSize: options.cacheSize,\\n    crossOrigin: options.crossOrigin,\\n    opaque: options.opaque,\\n    projection: projection,\\n    reprojectionErrorThreshold: options.reprojectionErrorThreshold,\\n    tileGrid: tileGrid,\\n    tileLoadFunction: options.tileLoadFunction,\\n    tilePixelRatio: options.tilePixelRatio,\\n    tileUrlFunction: options.tileUrlFunction,\\n    url: options.url,\\n    urls: options.urls,\\n    wrapX: options.wrapX !== undefined ? options.wrapX : true,\\n    transition: options.transition\\n  });\\n\\n};\\n\\ninherits(XYZ, TileImage);\\nexport default XYZ;\\n\",\"/**\\n * @module ol/source/OSM\\n */\\nimport {inherits} from '../index.js';\\nimport XYZ from '../source/XYZ.js';\\n\\n\\n/**\\n * The attribution containing a link to the OpenStreetMap Copyright and License\\n * page.\\n * @const\\n * @type {string}\\n * @api\\n */\\nexport const ATTRIBUTION = '&copy; ' +\\n      '<a href=\\\"https://www.openstreetmap.org/copyright\\\">OpenStreetMap</a> ' +\\n      'contributors.';\\n\\n\\n/**\\n * @typedef {Object} Options\\n * @property {module:ol/source/Source~AttributionLike} [attributions] Attributions.\\n * @property {number} [cacheSize=2048] Cache size.\\n * @property {null|string} [crossOrigin] The `crossOrigin` attribute for loaded images.  Note that\\n * you must provide a `crossOrigin` value if you are using the WebGL renderer or if you want to\\n * access pixel data with the Canvas renderer.  See\\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_enabled_image} for more detail.\\n * @property {number} [maxZoom=19] Max zoom.\\n * @property {boolean} [opaque=true] Whether the layer is opaque.\\n * @property {number} [reprojectionErrorThreshold=1.5] Maximum allowed reprojection error (in pixels).\\n * Higher values can increase reprojection performance, but decrease precision.\\n * @property {module:ol/Tile~LoadFunction} [tileLoadFunction] Optional function to load a tile given a URL. The default is\\n * ```js\\n * function(imageTile, src) {\\n *   imageTile.getImage().src = src;\\n * };\\n * ```\\n * @property {string} [url='https://{a-c}.tile.openstreetmap.org/{z}/{x}/{y}.png'] URL template.\\n * Must include `{x}`, `{y}` or `{-y}`, and `{z}` placeholders.\\n * @property {boolean} [wrapX=true] Whether to wrap the world horizontally.\\n */\\n\\n\\n/**\\n * @classdesc\\n * Layer source for the OpenStreetMap tile server.\\n *\\n * @constructor\\n * @extends {module:ol/source/XYZ}\\n * @param {module:ol/source/OSM~Options=} [opt_options] Open Street Map options.\\n * @api\\n */\\nconst OSM = function(opt_options) {\\n\\n  const options = opt_options || {};\\n\\n  let attributions;\\n  if (options.attributions !== undefined) {\\n    attributions = options.attributions;\\n  } else {\\n    attributions = [ATTRIBUTION];\\n  }\\n\\n  const crossOrigin = options.crossOrigin !== undefined ?\\n    options.crossOrigin : 'anonymous';\\n\\n  const url = options.url !== undefined ?\\n    options.url : 'https://{a-c}.tile.openstreetmap.org/{z}/{x}/{y}.png';\\n\\n  XYZ.call(this, {\\n    attributions: attributions,\\n    cacheSize: options.cacheSize,\\n    crossOrigin: crossOrigin,\\n    opaque: options.opaque !== undefined ? options.opaque : true,\\n    maxZoom: options.maxZoom !== undefined ? options.maxZoom : 19,\\n    reprojectionErrorThreshold: options.reprojectionErrorThreshold,\\n    tileLoadFunction: options.tileLoadFunction,\\n    url: url,\\n    wrapX: options.wrapX\\n  });\\n\\n};\\n\\ninherits(OSM, XYZ);\\n\\nexport default OSM;\\n\",\"/**\\n * @module ol/style/Atlas\\n */\\nimport {createCanvasContext2D} from '../dom.js';\\n\\n\\n/**\\n * @typedef {Object} AtlasBlock\\n * @property {number} x\\n * @property {number} y\\n * @property {number} width\\n * @property {number} height\\n */\\n\\n/**\\n * Provides information for an image inside an atlas.\\n * `offsetX` and `offsetY` are the position of the image inside the atlas image `image`.\\n * @typedef {Object} AtlasInfo\\n * @property {number} offsetX\\n * @property {number} offsetY\\n * @property {HTMLCanvasElement} image\\n */\\n\\n/**\\n * This class facilitates the creation of image atlases.\\n *\\n * Images added to an atlas will be rendered onto a single\\n * atlas canvas. The distribution of images on the canvas is\\n * managed with the bin packing algorithm described in:\\n * http://www.blackpawn.com/texts/lightmaps/\\n *\\n * @constructor\\n * @struct\\n * @param {number} size The size in pixels of the sprite image.\\n * @param {number} space The space in pixels between images.\\n *    Because texture coordinates are float values, the edges of\\n *    images might not be completely correct (in a way that the\\n *    edges overlap when being rendered). To avoid this we add a\\n *    padding around each image.\\n */\\nconst Atlas = function(size, space) {\\n\\n  /**\\n   * @private\\n   * @type {number}\\n   */\\n  this.space_ = space;\\n\\n  /**\\n   * @private\\n   * @type {Array.<module:ol/style/Atlas~AtlasBlock>}\\n   */\\n  this.emptyBlocks_ = [{x: 0, y: 0, width: size, height: size}];\\n\\n  /**\\n   * @private\\n   * @type {Object.<string, module:ol/style/Atlas~AtlasInfo>}\\n   */\\n  this.entries_ = {};\\n\\n  /**\\n   * @private\\n   * @type {CanvasRenderingContext2D}\\n   */\\n  this.context_ = createCanvasContext2D(size, size);\\n\\n  /**\\n   * @private\\n   * @type {HTMLCanvasElement}\\n   */\\n  this.canvas_ = this.context_.canvas;\\n};\\n\\n\\n/**\\n * @param {string} id The identifier of the entry to check.\\n * @return {?module:ol/style/Atlas~AtlasInfo} The atlas info.\\n */\\nAtlas.prototype.get = function(id) {\\n  return this.entries_[id] || null;\\n};\\n\\n\\n/**\\n * @param {string} id The identifier of the entry to add.\\n * @param {number} width The width.\\n * @param {number} height The height.\\n * @param {function(CanvasRenderingContext2D, number, number)} renderCallback\\n *    Called to render the new image onto an atlas image.\\n * @param {Object=} opt_this Value to use as `this` when executing\\n *    `renderCallback`.\\n * @return {?module:ol/style/Atlas~AtlasInfo} The position and atlas image for the entry.\\n */\\nAtlas.prototype.add = function(id, width, height, renderCallback, opt_this) {\\n  for (let i = 0, ii = this.emptyBlocks_.length; i < ii; ++i) {\\n    const block = this.emptyBlocks_[i];\\n    if (block.width >= width + this.space_ &&\\n        block.height >= height + this.space_) {\\n      // we found a block that is big enough for our entry\\n      const entry = {\\n        offsetX: block.x + this.space_,\\n        offsetY: block.y + this.space_,\\n        image: this.canvas_\\n      };\\n      this.entries_[id] = entry;\\n\\n      // render the image on the atlas image\\n      renderCallback.call(opt_this, this.context_,\\n        block.x + this.space_, block.y + this.space_);\\n\\n      // split the block after the insertion, either horizontally or vertically\\n      this.split_(i, block, width + this.space_, height + this.space_);\\n\\n      return entry;\\n    }\\n  }\\n\\n  // there is no space for the new entry in this atlas\\n  return null;\\n};\\n\\n\\n/**\\n * @private\\n * @param {number} index The index of the block.\\n * @param {module:ol/style/Atlas~AtlasBlock} block The block to split.\\n * @param {number} width The width of the entry to insert.\\n * @param {number} height The height of the entry to insert.\\n */\\nAtlas.prototype.split_ = function(index, block, width, height) {\\n  const deltaWidth = block.width - width;\\n  const deltaHeight = block.height - height;\\n\\n  /** @type {module:ol/style/Atlas~AtlasBlock} */\\n  let newBlock1;\\n  /** @type {module:ol/style/Atlas~AtlasBlock} */\\n  let newBlock2;\\n\\n  if (deltaWidth > deltaHeight) {\\n    // split vertically\\n    // block right of the inserted entry\\n    newBlock1 = {\\n      x: block.x + width,\\n      y: block.y,\\n      width: block.width - width,\\n      height: block.height\\n    };\\n\\n    // block below the inserted entry\\n    newBlock2 = {\\n      x: block.x,\\n      y: block.y + height,\\n      width: width,\\n      height: block.height - height\\n    };\\n    this.updateBlocks_(index, newBlock1, newBlock2);\\n  } else {\\n    // split horizontally\\n    // block right of the inserted entry\\n    newBlock1 = {\\n      x: block.x + width,\\n      y: block.y,\\n      width: block.width - width,\\n      height: height\\n    };\\n\\n    // block below the inserted entry\\n    newBlock2 = {\\n      x: block.x,\\n      y: block.y + height,\\n      width: block.width,\\n      height: block.height - height\\n    };\\n    this.updateBlocks_(index, newBlock1, newBlock2);\\n  }\\n};\\n\\n\\n/**\\n * Remove the old block and insert new blocks at the same array position.\\n * The new blocks are inserted at the same position, so that splitted\\n * blocks (that are potentially smaller) are filled first.\\n * @private\\n * @param {number} index The index of the block to remove.\\n * @param {module:ol/style/Atlas~AtlasBlock} newBlock1 The 1st block to add.\\n * @param {module:ol/style/Atlas~AtlasBlock} newBlock2 The 2nd block to add.\\n */\\nAtlas.prototype.updateBlocks_ = function(index, newBlock1, newBlock2) {\\n  const args = [index, 1];\\n  if (newBlock1.width > 0 && newBlock1.height > 0) {\\n    args.push(newBlock1);\\n  }\\n  if (newBlock2.width > 0 && newBlock2.height > 0) {\\n    args.push(newBlock2);\\n  }\\n  this.emptyBlocks_.splice.apply(this.emptyBlocks_, args);\\n};\\nexport default Atlas;\\n\",\"/**\\n * @module ol/style/AtlasManager\\n */\\nimport {WEBGL_MAX_TEXTURE_SIZE} from '../index.js';\\nimport {UNDEFINED} from '../functions.js';\\nimport Atlas from '../style/Atlas.js';\\n\\n\\n/**\\n * @typedef {Object} Options\\n * @property {number} [initialSize=256] The size in pixels of the first atlas image.\\n * @property {number} [maxSize] The maximum size in pixels of atlas images. Default is\\n * `WEBGL_MAX_TEXTURE_SIZE` or 2048 if WebGL is not supported.\\n * @property {number} [space=1] The space in pixels between images.\\n */\\n\\n\\n/**\\n * Provides information for an image inside an atlas manager.\\n * `offsetX` and `offsetY` is the position of the image inside\\n * the atlas image `image` and the position of the hit-detection image\\n * inside the hit-detection atlas image `hitImage`.\\n * @typedef {Object} AtlasManagerInfo\\n * @property {number} offsetX\\n * @property {number} offsetY\\n * @property {HTMLCanvasElement} image\\n * @property {HTMLCanvasElement} hitImage\\n */\\n\\n\\n/**\\n * The size in pixels of the first atlas image.\\n * @type {number}\\n */\\nconst INITIAL_ATLAS_SIZE = 256;\\n\\n/**\\n * The maximum size in pixels of atlas images.\\n * @type {number}\\n */\\nconst MAX_ATLAS_SIZE = -1;\\n\\n\\n/**\\n * Manages the creation of image atlases.\\n *\\n * Images added to this manager will be inserted into an atlas, which\\n * will be used for rendering.\\n * The `size` given in the constructor is the size for the first\\n * atlas. After that, when new atlases are created, they will have\\n * twice the size as the latest atlas (until `maxSize` is reached).\\n *\\n * If an application uses many images or very large images, it is recommended\\n * to set a higher `size` value to avoid the creation of too many atlases.\\n *\\n * @constructor\\n * @struct\\n * @api\\n * @param {module:ol/style/AtlasManager~Options=} opt_options Options.\\n */\\nconst AtlasManager = function(opt_options) {\\n\\n  const options = opt_options || {};\\n\\n  /**\\n   * The size in pixels of the latest atlas image.\\n   * @private\\n   * @type {number}\\n   */\\n  this.currentSize_ = options.initialSize !== undefined ?\\n    options.initialSize : INITIAL_ATLAS_SIZE;\\n\\n  /**\\n   * The maximum size in pixels of atlas images.\\n   * @private\\n   * @type {number}\\n   */\\n  this.maxSize_ = options.maxSize !== undefined ?\\n    options.maxSize : MAX_ATLAS_SIZE != -1 ?\\n      MAX_ATLAS_SIZE : WEBGL_MAX_TEXTURE_SIZE !== undefined ?\\n        WEBGL_MAX_TEXTURE_SIZE : 2048;\\n\\n  /**\\n   * The size in pixels between images.\\n   * @private\\n   * @type {number}\\n   */\\n  this.space_ = options.space !== undefined ? options.space : 1;\\n\\n  /**\\n   * @private\\n   * @type {Array.<module:ol/style/Atlas>}\\n   */\\n  this.atlases_ = [new Atlas(this.currentSize_, this.space_)];\\n\\n  /**\\n   * The size in pixels of the latest atlas image for hit-detection images.\\n   * @private\\n   * @type {number}\\n   */\\n  this.currentHitSize_ = this.currentSize_;\\n\\n  /**\\n   * @private\\n   * @type {Array.<module:ol/style/Atlas>}\\n   */\\n  this.hitAtlases_ = [new Atlas(this.currentHitSize_, this.space_)];\\n};\\n\\n\\n/**\\n * @param {string} id The identifier of the entry to check.\\n * @return {?module:ol/style/AtlasManager~AtlasManagerInfo} The position and atlas image for the\\n *    entry, or `null` if the entry is not part of the atlas manager.\\n */\\nAtlasManager.prototype.getInfo = function(id) {\\n  /** @type {?module:ol/style/Atlas~AtlasInfo} */\\n  const info = this.getInfo_(this.atlases_, id);\\n\\n  if (!info) {\\n    return null;\\n  }\\n  const hitInfo = /** @type {module:ol/style/Atlas~AtlasInfo} */ (this.getInfo_(this.hitAtlases_, id));\\n\\n  return this.mergeInfos_(info, hitInfo);\\n};\\n\\n\\n/**\\n * @private\\n * @param {Array.<module:ol/style/Atlas>} atlases The atlases to search.\\n * @param {string} id The identifier of the entry to check.\\n * @return {?module:ol/style/Atlas~AtlasInfo} The position and atlas image for the entry,\\n *    or `null` if the entry is not part of the atlases.\\n */\\nAtlasManager.prototype.getInfo_ = function(atlases, id) {\\n  for (let i = 0, ii = atlases.length; i < ii; ++i) {\\n    const atlas = atlases[i];\\n    const info = atlas.get(id);\\n    if (info) {\\n      return info;\\n    }\\n  }\\n  return null;\\n};\\n\\n\\n/**\\n * @private\\n * @param {module:ol/style/Atlas~AtlasInfo} info The info for the real image.\\n * @param {module:ol/style/Atlas~AtlasInfo} hitInfo The info for the hit-detection\\n *    image.\\n * @return {?module:ol/style/AtlasManager~AtlasManagerInfo} The position and atlas image for the\\n *    entry, or `null` if the entry is not part of the atlases.\\n */\\nAtlasManager.prototype.mergeInfos_ = function(info, hitInfo) {\\n  return (\\n    /** @type {module:ol/style/AtlasManager~AtlasManagerInfo} */ ({\\n      offsetX: info.offsetX,\\n      offsetY: info.offsetY,\\n      image: info.image,\\n      hitImage: hitInfo.image\\n    })\\n  );\\n};\\n\\n\\n/**\\n * Add an image to the atlas manager.\\n *\\n * If an entry for the given id already exists, the entry will\\n * be overridden (but the space on the atlas graphic will not be freed).\\n *\\n * If `renderHitCallback` is provided, the image (or the hit-detection version\\n * of the image) will be rendered into a separate hit-detection atlas image.\\n *\\n * @param {string} id The identifier of the entry to add.\\n * @param {number} width The width.\\n * @param {number} height The height.\\n * @param {function(CanvasRenderingContext2D, number, number)} renderCallback\\n *    Called to render the new image onto an atlas image.\\n * @param {function(CanvasRenderingContext2D, number, number)=}\\n *    opt_renderHitCallback Called to render a hit-detection image onto a hit\\n *    detection atlas image.\\n * @param {Object=} opt_this Value to use as `this` when executing\\n *    `renderCallback` and `renderHitCallback`.\\n * @return {?module:ol/style/AtlasManager~AtlasManagerInfo}  The position and atlas image for the\\n *    entry, or `null` if the image is too big.\\n */\\nAtlasManager.prototype.add = function(id, width, height,\\n  renderCallback, opt_renderHitCallback, opt_this) {\\n  if (width + this.space_ > this.maxSize_ ||\\n      height + this.space_ > this.maxSize_) {\\n    return null;\\n  }\\n\\n  /** @type {?module:ol/style/Atlas~AtlasInfo} */\\n  const info = this.add_(false, id, width, height, renderCallback, opt_this);\\n  if (!info) {\\n    return null;\\n  }\\n\\n  // even if no hit-detection entry is requested, we insert a fake entry into\\n  // the hit-detection atlas, to make sure that the offset is the same for\\n  // the original image and the hit-detection image.\\n  const renderHitCallback = opt_renderHitCallback !== undefined ?\\n    opt_renderHitCallback : UNDEFINED;\\n\\n  const hitInfo = /** @type {module:ol/style/Atlas~AtlasInfo} */ (this.add_(true,\\n    id, width, height, renderHitCallback, opt_this));\\n\\n  return this.mergeInfos_(info, hitInfo);\\n};\\n\\n\\n/**\\n * @private\\n * @param {boolean} isHitAtlas If the hit-detection atlases are used.\\n * @param {string} id The identifier of the entry to add.\\n * @param {number} width The width.\\n * @param {number} height The height.\\n * @param {function(CanvasRenderingContext2D, number, number)} renderCallback\\n *    Called to render the new image onto an atlas image.\\n * @param {Object=} opt_this Value to use as `this` when executing\\n *    `renderCallback` and `renderHitCallback`.\\n * @return {?module:ol/style/Atlas~AtlasInfo}  The position and atlas image for the entry,\\n *    or `null` if the image is too big.\\n */\\nAtlasManager.prototype.add_ = function(isHitAtlas, id, width, height, renderCallback, opt_this) {\\n  const atlases = (isHitAtlas) ? this.hitAtlases_ : this.atlases_;\\n  let atlas, info, i, ii;\\n  for (i = 0, ii = atlases.length; i < ii; ++i) {\\n    atlas = atlases[i];\\n    info = atlas.add(id, width, height, renderCallback, opt_this);\\n    if (info) {\\n      return info;\\n    } else if (!info && i === ii - 1) {\\n      // the entry could not be added to one of the existing atlases,\\n      // create a new atlas that is twice as big and try to add to this one.\\n      let size;\\n      if (isHitAtlas) {\\n        size = Math.min(this.currentHitSize_ * 2, this.maxSize_);\\n        this.currentHitSize_ = size;\\n      } else {\\n        size = Math.min(this.currentSize_ * 2, this.maxSize_);\\n        this.currentSize_ = size;\\n      }\\n      atlas = new Atlas(size, this.space_);\\n      atlases.push(atlas);\\n      // run the loop another time\\n      ++ii;\\n    }\\n  }\\n  return null;\\n};\\nexport default AtlasManager;\\n\",\"/**\\n * @module ol/style/IconAnchorUnits\\n */\\n\\n/**\\n * Icon anchor units. One of 'fraction', 'pixels'.\\n * @enum {string}\\n */\\nexport default {\\n  FRACTION: 'fraction',\\n  PIXELS: 'pixels'\\n};\\n\",\"/**\\n * @module ol/style/IconImage\\n */\\nimport {inherits} from '../index.js';\\nimport {createCanvasContext2D} from '../dom.js';\\nimport {listenOnce, unlistenByKey} from '../events.js';\\nimport EventTarget from '../events/EventTarget.js';\\nimport EventType from '../events/EventType.js';\\nimport ImageState from '../ImageState.js';\\nimport {shared as iconImageCache} from '../style/IconImageCache.js';\\n\\n/**\\n * @constructor\\n * @param {Image|HTMLCanvasElement} image Image.\\n * @param {string|undefined} src Src.\\n * @param {module:ol/size~Size} size Size.\\n * @param {?string} crossOrigin Cross origin.\\n * @param {module:ol/ImageState} imageState Image state.\\n * @param {module:ol/color~Color} color Color.\\n * @extends {module:ol/events/EventTarget}\\n */\\nconst IconImage = function(image, src, size, crossOrigin, imageState, color) {\\n\\n  EventTarget.call(this);\\n\\n  /**\\n   * @private\\n   * @type {Image|HTMLCanvasElement}\\n   */\\n  this.hitDetectionImage_ = null;\\n\\n  /**\\n   * @private\\n   * @type {Image|HTMLCanvasElement}\\n   */\\n  this.image_ = !image ? new Image() : image;\\n\\n  if (crossOrigin !== null) {\\n    this.image_.crossOrigin = crossOrigin;\\n  }\\n\\n  /**\\n   * @private\\n   * @type {HTMLCanvasElement}\\n   */\\n  this.canvas_ = color ?\\n    /** @type {HTMLCanvasElement} */ (document.createElement('CANVAS')) :\\n    null;\\n\\n  /**\\n   * @private\\n   * @type {module:ol/color~Color}\\n   */\\n  this.color_ = color;\\n\\n  /**\\n   * @private\\n   * @type {Array.<module:ol/events~EventsKey>}\\n   */\\n  this.imageListenerKeys_ = null;\\n\\n  /**\\n   * @private\\n   * @type {module:ol/ImageState}\\n   */\\n  this.imageState_ = imageState;\\n\\n  /**\\n   * @private\\n   * @type {module:ol/size~Size}\\n   */\\n  this.size_ = size;\\n\\n  /**\\n   * @private\\n   * @type {string|undefined}\\n   */\\n  this.src_ = src;\\n\\n  /**\\n   * @private\\n   * @type {boolean}\\n   */\\n  this.tainting_ = false;\\n  if (this.imageState_ == ImageState.LOADED) {\\n    this.determineTainting_();\\n  }\\n\\n};\\n\\ninherits(IconImage, EventTarget);\\n\\n\\n/**\\n * @param {Image|HTMLCanvasElement} image Image.\\n * @param {string} src Src.\\n * @param {module:ol/size~Size} size Size.\\n * @param {?string} crossOrigin Cross origin.\\n * @param {module:ol/ImageState} imageState Image state.\\n * @param {module:ol/color~Color} color Color.\\n * @return {module:ol/style/IconImage} Icon image.\\n */\\nexport function get(image, src, size, crossOrigin, imageState, color) {\\n  let iconImage = iconImageCache.get(src, crossOrigin, color);\\n  if (!iconImage) {\\n    iconImage = new IconImage(image, src, size, crossOrigin, imageState, color);\\n    iconImageCache.set(src, crossOrigin, color, iconImage);\\n  }\\n  return iconImage;\\n}\\n\\n\\n/**\\n * @private\\n */\\nIconImage.prototype.determineTainting_ = function() {\\n  const context = createCanvasContext2D(1, 1);\\n  try {\\n    context.drawImage(this.image_, 0, 0);\\n    context.getImageData(0, 0, 1, 1);\\n  } catch (e) {\\n    this.tainting_ = true;\\n  }\\n};\\n\\n\\n/**\\n * @private\\n */\\nIconImage.prototype.dispatchChangeEvent_ = function() {\\n  this.dispatchEvent(EventType.CHANGE);\\n};\\n\\n\\n/**\\n * @private\\n */\\nIconImage.prototype.handleImageError_ = function() {\\n  this.imageState_ = ImageState.ERROR;\\n  this.unlistenImage_();\\n  this.dispatchChangeEvent_();\\n};\\n\\n\\n/**\\n * @private\\n */\\nIconImage.prototype.handleImageLoad_ = function() {\\n  this.imageState_ = ImageState.LOADED;\\n  if (this.size_) {\\n    this.image_.width = this.size_[0];\\n    this.image_.height = this.size_[1];\\n  }\\n  this.size_ = [this.image_.width, this.image_.height];\\n  this.unlistenImage_();\\n  this.determineTainting_();\\n  this.replaceColor_();\\n  this.dispatchChangeEvent_();\\n};\\n\\n\\n/**\\n * @param {number} pixelRatio Pixel ratio.\\n * @return {Image|HTMLCanvasElement} Image or Canvas element.\\n */\\nIconImage.prototype.getImage = function(pixelRatio) {\\n  return this.canvas_ ? this.canvas_ : this.image_;\\n};\\n\\n\\n/**\\n * @return {module:ol/ImageState} Image state.\\n */\\nIconImage.prototype.getImageState = function() {\\n  return this.imageState_;\\n};\\n\\n\\n/**\\n * @param {number} pixelRatio Pixel ratio.\\n * @return {Image|HTMLCanvasElement} Image element.\\n */\\nIconImage.prototype.getHitDetectionImage = function(pixelRatio) {\\n  if (!this.hitDetectionImage_) {\\n    if (this.tainting_) {\\n      const width = this.size_[0];\\n      const height = this.size_[1];\\n      const context = createCanvasContext2D(width, height);\\n      context.fillRect(0, 0, width, height);\\n      this.hitDetectionImage_ = context.canvas;\\n    } else {\\n      this.hitDetectionImage_ = this.image_;\\n    }\\n  }\\n  return this.hitDetectionImage_;\\n};\\n\\n\\n/**\\n * @return {module:ol/size~Size} Image size.\\n */\\nIconImage.prototype.getSize = function() {\\n  return this.size_;\\n};\\n\\n\\n/**\\n * @return {string|undefined} Image src.\\n */\\nIconImage.prototype.getSrc = function() {\\n  return this.src_;\\n};\\n\\n\\n/**\\n * Load not yet loaded URI.\\n */\\nIconImage.prototype.load = function() {\\n  if (this.imageState_ == ImageState.IDLE) {\\n    this.imageState_ = ImageState.LOADING;\\n    this.imageListenerKeys_ = [\\n      listenOnce(this.image_, EventType.ERROR,\\n        this.handleImageError_, this),\\n      listenOnce(this.image_, EventType.LOAD,\\n        this.handleImageLoad_, this)\\n    ];\\n    try {\\n      this.image_.src = this.src_;\\n    } catch (e) {\\n      this.handleImageError_();\\n    }\\n  }\\n};\\n\\n\\n/**\\n * @private\\n */\\nIconImage.prototype.replaceColor_ = function() {\\n  if (this.tainting_ || this.color_ === null) {\\n    return;\\n  }\\n\\n  this.canvas_.width = this.image_.width;\\n  this.canvas_.height = this.image_.height;\\n\\n  const ctx = this.canvas_.getContext('2d');\\n  ctx.drawImage(this.image_, 0, 0);\\n\\n  const imgData = ctx.getImageData(0, 0, this.image_.width, this.image_.height);\\n  const data = imgData.data;\\n  const r = this.color_[0] / 255.0;\\n  const g = this.color_[1] / 255.0;\\n  const b = this.color_[2] / 255.0;\\n\\n  for (let i = 0, ii = data.length; i < ii; i += 4) {\\n    data[i] *= r;\\n    data[i + 1] *= g;\\n    data[i + 2] *= b;\\n  }\\n  ctx.putImageData(imgData, 0, 0);\\n};\\n\\n\\n/**\\n * Discards event handlers which listen for load completion or errors.\\n *\\n * @private\\n */\\nIconImage.prototype.unlistenImage_ = function() {\\n  this.imageListenerKeys_.forEach(unlistenByKey);\\n  this.imageListenerKeys_ = null;\\n};\\nexport default IconImage;\\n\",\"/**\\n * @module ol/style/IconOrigin\\n */\\n\\n/**\\n * Icon origin. One of 'bottom-left', 'bottom-right', 'top-left', 'top-right'.\\n * @enum {string}\\n */\\nexport default {\\n  BOTTOM_LEFT: 'bottom-left',\\n  BOTTOM_RIGHT: 'bottom-right',\\n  TOP_LEFT: 'top-left',\\n  TOP_RIGHT: 'top-right'\\n};\\n\",\"/**\\n * @module ol/style/Icon\\n */\\nimport {getUid, inherits} from '../index.js';\\nimport ImageState from '../ImageState.js';\\nimport {assert} from '../asserts.js';\\nimport {asArray} from '../color.js';\\nimport {listen, unlisten} from '../events.js';\\nimport EventType from '../events/EventType.js';\\nimport IconAnchorUnits from '../style/IconAnchorUnits.js';\\nimport {get as getIconImage} from '../style/IconImage.js';\\nimport IconOrigin from '../style/IconOrigin.js';\\nimport ImageStyle from '../style/Image.js';\\n\\n\\n/**\\n * @typedef {Object} Options\\n * @property {Array.<number>} [anchor=[0.5, 0.5]] Anchor. Default value is the icon center.\\n * @property {module:ol/style/IconOrigin} [anchorOrigin] Origin of the anchor: `bottom-left`, `bottom-right`,\\n * `top-left` or `top-right`. Default is `top-left`.\\n * @property {module:ol/style/IconAnchorUnits} [anchorXUnits] Units in which the anchor x value is\\n * specified. A value of `'fraction'` indicates the x value is a fraction of the icon. A value of `'pixels'` indicates\\n * the x value in pixels. Default is `'fraction'`.\\n * @property {module:ol/style/IconAnchorUnits} [anchorYUnits] Units in which the anchor y value is\\n * specified. A value of `'fraction'` indicates the y value is a fraction of the icon. A value of `'pixels'` indicates\\n * the y value in pixels. Default is `'fraction'`.\\n * @property {module:ol/color~Color|string} [color] Color to tint the icon. If not specified,\\n * the icon will be left as is.\\n * @property {null|string} [crossOrigin] The `crossOrigin` attribute for loaded images. Note that you must provide a\\n * `crossOrigin` value if you are using the WebGL renderer or if you want to access pixel data with the Canvas renderer.\\n * See {@link https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_enabled_image} for more detail.\\n * @property {Image|HTMLCanvasElement} [img] Image object for the icon. If the `src` option is not provided then the\\n * provided image must already be loaded. And in that case, it is required\\n * to provide the size of the image, with the `imgSize` option.\\n * @property {Array.<number>} [offset=[0, 0]] Offset, which, together with the size and the offset origin, define the\\n * sub-rectangle to use from the original icon image.\\n * @property {module:ol/style/IconOrigin} [offsetOrigin] Origin of the offset: `bottom-left`, `bottom-right`,\\n * `top-left` or `top-right`. Default is `top-left`.\\n * @property {number} [opacity=1] Opacity of the icon.\\n * @property {number} [scale=1] Scale.\\n * @property {boolean} [snapToPixel=true] If `true` integral numbers of pixels are used as the X and Y pixel coordinate\\n * when drawing the icon in the output canvas. If `false` fractional numbers may be used. Using `true` allows for\\n * \\\"sharp\\\" rendering (no blur), while using `false` allows for \\\"accurate\\\" rendering. Note that accuracy is important if\\n * the icon's position is animated. Without it, the icon may jitter noticeably.\\n * @property {boolean} [rotateWithView=false] Whether to rotate the icon with the view.\\n * @property {number} [rotation=0] Rotation in radians (positive rotation clockwise).\\n * @property {module:ol/size~Size} [size] Icon size in pixel. Can be used together with `offset` to define the\\n * sub-rectangle to use from the origin (sprite) icon image.\\n * @property {module:ol/size~Size} [imgSize] Image size in pixels. Only required if `img` is set and `src` is not, and\\n * for SVG images in Internet Explorer 11. The provided `imgSize` needs to match the actual size of the image.\\n * @property {string} [src] Image source URI.\\n */\\n\\n\\n/**\\n * @classdesc\\n * Set icon style for vector features.\\n *\\n * @constructor\\n * @param {module:ol/style/Icon~Options=} opt_options Options.\\n * @extends {module:ol/style/Image}\\n * @api\\n */\\nconst Icon = function(opt_options) {\\n\\n  const options = opt_options || {};\\n\\n  /**\\n   * @private\\n   * @type {Array.<number>}\\n   */\\n  this.anchor_ = options.anchor !== undefined ? options.anchor : [0.5, 0.5];\\n\\n  /**\\n   * @private\\n   * @type {Array.<number>}\\n   */\\n  this.normalizedAnchor_ = null;\\n\\n  /**\\n   * @private\\n   * @type {module:ol/style/IconOrigin}\\n   */\\n  this.anchorOrigin_ = options.anchorOrigin !== undefined ?\\n    options.anchorOrigin : IconOrigin.TOP_LEFT;\\n\\n  /**\\n   * @private\\n   * @type {module:ol/style/IconAnchorUnits}\\n   */\\n  this.anchorXUnits_ = options.anchorXUnits !== undefined ?\\n    options.anchorXUnits : IconAnchorUnits.FRACTION;\\n\\n  /**\\n   * @private\\n   * @type {module:ol/style/IconAnchorUnits}\\n   */\\n  this.anchorYUnits_ = options.anchorYUnits !== undefined ?\\n    options.anchorYUnits : IconAnchorUnits.FRACTION;\\n\\n  /**\\n   * @private\\n   * @type {?string}\\n   */\\n  this.crossOrigin_ =\\n      options.crossOrigin !== undefined ? options.crossOrigin : null;\\n\\n  /**\\n   * @type {Image|HTMLCanvasElement}\\n   */\\n  const image = options.img !== undefined ? options.img : null;\\n\\n  /**\\n   * @type {module:ol/size~Size}\\n   */\\n  const imgSize = options.imgSize !== undefined ? options.imgSize : null;\\n\\n  /**\\n   * @type {string|undefined}\\n   */\\n  let src = options.src;\\n\\n  assert(!(src !== undefined && image),\\n    4); // `image` and `src` cannot be provided at the same time\\n  assert(!image || (image && imgSize),\\n    5); // `imgSize` must be set when `image` is provided\\n\\n  if ((src === undefined || src.length === 0) && image) {\\n    src = image.src || getUid(image).toString();\\n  }\\n  assert(src !== undefined && src.length > 0,\\n    6); // A defined and non-empty `src` or `image` must be provided\\n\\n  /**\\n   * @type {module:ol/ImageState}\\n   */\\n  const imageState = options.src !== undefined ?\\n    ImageState.IDLE : ImageState.LOADED;\\n\\n  /**\\n   * @private\\n   * @type {module:ol/color~Color}\\n   */\\n  this.color_ = options.color !== undefined ? asArray(options.color) : null;\\n\\n  /**\\n   * @private\\n   * @type {module:ol/style/IconImage}\\n   */\\n  this.iconImage_ = getIconImage(\\n    image, /** @type {string} */ (src), imgSize, this.crossOrigin_, imageState, this.color_);\\n\\n  /**\\n   * @private\\n   * @type {Array.<number>}\\n   */\\n  this.offset_ = options.offset !== undefined ? options.offset : [0, 0];\\n\\n  /**\\n   * @private\\n   * @type {module:ol/style/IconOrigin}\\n   */\\n  this.offsetOrigin_ = options.offsetOrigin !== undefined ?\\n    options.offsetOrigin : IconOrigin.TOP_LEFT;\\n\\n  /**\\n   * @private\\n   * @type {Array.<number>}\\n   */\\n  this.origin_ = null;\\n\\n  /**\\n   * @private\\n   * @type {module:ol/size~Size}\\n   */\\n  this.size_ = options.size !== undefined ? options.size : null;\\n\\n  /**\\n   * @type {number}\\n   */\\n  const opacity = options.opacity !== undefined ? options.opacity : 1;\\n\\n  /**\\n   * @type {boolean}\\n   */\\n  const rotateWithView = options.rotateWithView !== undefined ?\\n    options.rotateWithView : false;\\n\\n  /**\\n   * @type {number}\\n   */\\n  const rotation = options.rotation !== undefined ? options.rotation : 0;\\n\\n  /**\\n   * @type {number}\\n   */\\n  const scale = options.scale !== undefined ? options.scale : 1;\\n\\n  /**\\n   * @type {boolean}\\n   */\\n  const snapToPixel = options.snapToPixel !== undefined ?\\n    options.snapToPixel : true;\\n\\n  ImageStyle.call(this, {\\n    opacity: opacity,\\n    rotation: rotation,\\n    scale: scale,\\n    snapToPixel: snapToPixel,\\n    rotateWithView: rotateWithView\\n  });\\n\\n};\\n\\ninherits(Icon, ImageStyle);\\n\\n\\n/**\\n * Clones the style. The underlying Image/HTMLCanvasElement is not cloned.\\n * @return {module:ol/style/Icon} The cloned style.\\n * @api\\n */\\nIcon.prototype.clone = function() {\\n  return new Icon({\\n    anchor: this.anchor_.slice(),\\n    anchorOrigin: this.anchorOrigin_,\\n    anchorXUnits: this.anchorXUnits_,\\n    anchorYUnits: this.anchorYUnits_,\\n    crossOrigin: this.crossOrigin_,\\n    color: (this.color_ && this.color_.slice) ? this.color_.slice() : this.color_ || undefined,\\n    src: this.getSrc(),\\n    offset: this.offset_.slice(),\\n    offsetOrigin: this.offsetOrigin_,\\n    size: this.size_ !== null ? this.size_.slice() : undefined,\\n    opacity: this.getOpacity(),\\n    scale: this.getScale(),\\n    snapToPixel: this.getSnapToPixel(),\\n    rotation: this.getRotation(),\\n    rotateWithView: this.getRotateWithView()\\n  });\\n};\\n\\n\\n/**\\n * @inheritDoc\\n * @api\\n */\\nIcon.prototype.getAnchor = function() {\\n  if (this.normalizedAnchor_) {\\n    return this.normalizedAnchor_;\\n  }\\n  let anchor = this.anchor_;\\n  const size = this.getSize();\\n  if (this.anchorXUnits_ == IconAnchorUnits.FRACTION ||\\n      this.anchorYUnits_ == IconAnchorUnits.FRACTION) {\\n    if (!size) {\\n      return null;\\n    }\\n    anchor = this.anchor_.slice();\\n    if (this.anchorXUnits_ == IconAnchorUnits.FRACTION) {\\n      anchor[0] *= size[0];\\n    }\\n    if (this.anchorYUnits_ == IconAnchorUnits.FRACTION) {\\n      anchor[1] *= size[1];\\n    }\\n  }\\n\\n  if (this.anchorOrigin_ != IconOrigin.TOP_LEFT) {\\n    if (!size) {\\n      return null;\\n    }\\n    if (anchor === this.anchor_) {\\n      anchor = this.anchor_.slice();\\n    }\\n    if (this.anchorOrigin_ == IconOrigin.TOP_RIGHT ||\\n        this.anchorOrigin_ == IconOrigin.BOTTOM_RIGHT) {\\n      anchor[0] = -anchor[0] + size[0];\\n    }\\n    if (this.anchorOrigin_ == IconOrigin.BOTTOM_LEFT ||\\n        this.anchorOrigin_ == IconOrigin.BOTTOM_RIGHT) {\\n      anchor[1] = -anchor[1] + size[1];\\n    }\\n  }\\n  this.normalizedAnchor_ = anchor;\\n  return this.normalizedAnchor_;\\n};\\n\\n\\n/**\\n * Get the icon color.\\n * @return {module:ol/color~Color} Color.\\n * @api\\n */\\nIcon.prototype.getColor = function() {\\n  return this.color_;\\n};\\n\\n\\n/**\\n * Get the image icon.\\n * @param {number} pixelRatio Pixel ratio.\\n * @return {Image|HTMLCanvasElement} Image or Canvas element.\\n * @override\\n * @api\\n */\\nIcon.prototype.getImage = function(pixelRatio) {\\n  return this.iconImage_.getImage(pixelRatio);\\n};\\n\\n\\n/**\\n * @override\\n */\\nIcon.prototype.getImageSize = function() {\\n  return this.iconImage_.getSize();\\n};\\n\\n\\n/**\\n * @override\\n */\\nIcon.prototype.getHitDetectionImageSize = function() {\\n  return this.getImageSize();\\n};\\n\\n\\n/**\\n * @override\\n */\\nIcon.prototype.getImageState = function() {\\n  return this.iconImage_.getImageState();\\n};\\n\\n\\n/**\\n * @override\\n */\\nIcon.prototype.getHitDetectionImage = function(pixelRatio) {\\n  return this.iconImage_.getHitDetectionImage(pixelRatio);\\n};\\n\\n\\n/**\\n * @inheritDoc\\n * @api\\n */\\nIcon.prototype.getOrigin = function() {\\n  if (this.origin_) {\\n    return this.origin_;\\n  }\\n  let offset = this.offset_;\\n\\n  if (this.offsetOrigin_ != IconOrigin.TOP_LEFT) {\\n    const size = this.getSize();\\n    const iconImageSize = this.iconImage_.getSize();\\n    if (!size || !iconImageSize) {\\n      return null;\\n    }\\n    offset = offset.slice();\\n    if (this.offsetOrigin_ == IconOrigin.TOP_RIGHT ||\\n        this.offsetOrigin_ == IconOrigin.BOTTOM_RIGHT) {\\n      offset[0] = iconImageSize[0] - size[0] - offset[0];\\n    }\\n    if (this.offsetOrigin_ == IconOrigin.BOTTOM_LEFT ||\\n        this.offsetOrigin_ == IconOrigin.BOTTOM_RIGHT) {\\n      offset[1] = iconImageSize[1] - size[1] - offset[1];\\n    }\\n  }\\n  this.origin_ = offset;\\n  return this.origin_;\\n};\\n\\n\\n/**\\n * Get the image URL.\\n * @return {string|undefined} Image src.\\n * @api\\n */\\nIcon.prototype.getSrc = function() {\\n  return this.iconImage_.getSrc();\\n};\\n\\n\\n/**\\n * @inheritDoc\\n * @api\\n */\\nIcon.prototype.getSize = function() {\\n  return !this.size_ ? this.iconImage_.getSize() : this.size_;\\n};\\n\\n\\n/**\\n * @override\\n */\\nIcon.prototype.listenImageChange = function(listener, thisArg) {\\n  return listen(this.iconImage_, EventType.CHANGE,\\n    listener, thisArg);\\n};\\n\\n\\n/**\\n * Load not yet loaded URI.\\n * When rendering a feature with an icon style, the vector renderer will\\n * automatically call this method. However, you might want to call this\\n * method yourself for preloading or other purposes.\\n * @override\\n * @api\\n */\\nIcon.prototype.load = function() {\\n  this.iconImage_.load();\\n};\\n\\n\\n/**\\n * @override\\n */\\nIcon.prototype.unlistenImageChange = function(listener, thisArg) {\\n  unlisten(this.iconImage_, EventType.CHANGE,\\n    listener, thisArg);\\n};\\nexport default Icon;\\n\",\"/**\\n * @module ol/style/Text\\n */\\nimport Fill from '../style/Fill.js';\\nimport TextPlacement from '../style/TextPlacement.js';\\n\\n\\n/**\\n * The default fill color to use if no fill was set at construction time; a\\n * blackish `#333`.\\n *\\n * @const {string}\\n */\\nconst DEFAULT_FILL_COLOR = '#333';\\n\\n\\n/**\\n * @typedef {Object} Options\\n * @property {string} [font] Font style as CSS 'font' value, see:\\n * {@link https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/font}. Default is '10px sans-serif'\\n * @property {number} [maxAngle] When `placement` is set to `'line'`, allow a maximum angle between adjacent characters.\\n * The expected value is in radians, and the default is 45 (`Math.PI / 4`).\\n * @property {number} [offsetX=0] Horizontal text offset in pixels. A positive will shift the text right.\\n * @property {number} [offsetY=0] Vertical text offset in pixels. A positive will shift the text down.\\n * @property {boolean} [overflow=false] For polygon labels or when `placement` is set to `'line'`, allow text to exceed\\n * the width of the polygon at the label position or the length of the path that it follows.\\n * @property {module:ol/style/TextPlacement|string} [placement] Text placement.\\n * @property {number} [scale] Scale.\\n * @property {boolean} [rotateWithView=false] Whether to rotate the text with the view.\\n * @property {number} [rotation=0] Rotation in radians (positive rotation clockwise).\\n * @property {string} [text] Text content.\\n * @property {string} [textAlign] Text alignment. Possible values: 'left', 'right', 'center', 'end' or 'start'.\\n * Default is 'center' for `placement: 'point'`. For `placement: 'line'`, the default is to let the renderer choose a\\n * placement where `maxAngle` is not exceeded.\\n * @property {string} [textBaseline='middle'] Text base line. Possible values: 'bottom', 'top', 'middle', 'alphabetic',\\n * 'hanging', 'ideographic'.\\n * @property {module:ol/style/Fill} [fill] Fill style. If none is provided, we'll use a dark fill-style (#333).\\n * @property {module:ol/style/Stroke} [stroke] Stroke style.\\n * @property {module:ol/style/Fill} [backgroundFill] Fill style for the text background when `placement` is\\n * `'point'`. Default is no fill.\\n * @property {module:ol/style/Stroke} [backgroundStroke] Stroke style for the text background  when `placement`\\n * is `'point'`. Default is no stroke.\\n * @property {Array.<number>} [padding=[0, 0, 0, 0]] Padding in pixels around the text for decluttering and background. The order of\\n * values in the array is `[top, right, bottom, left]`.\\n */\\n\\n\\n/**\\n * @classdesc\\n * Set text style for vector features.\\n *\\n * @constructor\\n * @param {module:ol/style/Text~Options=} opt_options Options.\\n * @api\\n */\\nconst Text = function(opt_options) {\\n\\n  const options = opt_options || {};\\n\\n  /**\\n   * @private\\n   * @type {string|undefined}\\n   */\\n  this.font_ = options.font;\\n\\n  /**\\n   * @private\\n   * @type {number|undefined}\\n   */\\n  this.rotation_ = options.rotation;\\n\\n  /**\\n   * @private\\n   * @type {boolean|undefined}\\n   */\\n  this.rotateWithView_ = options.rotateWithView;\\n\\n  /**\\n   * @private\\n   * @type {number|undefined}\\n   */\\n  this.scale_ = options.scale;\\n\\n  /**\\n   * @private\\n   * @type {string|undefined}\\n   */\\n  this.text_ = options.text;\\n\\n  /**\\n   * @private\\n   * @type {string|undefined}\\n   */\\n  this.textAlign_ = options.textAlign;\\n\\n  /**\\n   * @private\\n   * @type {string|undefined}\\n   */\\n  this.textBaseline_ = options.textBaseline;\\n\\n  /**\\n   * @private\\n   * @type {module:ol/style/Fill}\\n   */\\n  this.fill_ = options.fill !== undefined ? options.fill :\\n    new Fill({color: DEFAULT_FILL_COLOR});\\n\\n  /**\\n   * @private\\n   * @type {number}\\n   */\\n  this.maxAngle_ = options.maxAngle !== undefined ? options.maxAngle : Math.PI / 4;\\n\\n  /**\\n   * @private\\n   * @type {module:ol/style/TextPlacement|string}\\n   */\\n  this.placement_ = options.placement !== undefined ? options.placement : TextPlacement.POINT;\\n\\n  /**\\n   * @private\\n   * @type {boolean}\\n   */\\n  this.overflow_ = !!options.overflow;\\n\\n  /**\\n   * @private\\n   * @type {module:ol/style/Stroke}\\n   */\\n  this.stroke_ = options.stroke !== undefined ? options.stroke : null;\\n\\n  /**\\n   * @private\\n   * @type {number}\\n   */\\n  this.offsetX_ = options.offsetX !== undefined ? options.offsetX : 0;\\n\\n  /**\\n   * @private\\n   * @type {number}\\n   */\\n  this.offsetY_ = options.offsetY !== undefined ? options.offsetY : 0;\\n\\n  /**\\n   * @private\\n   * @type {module:ol/style/Fill}\\n   */\\n  this.backgroundFill_ = options.backgroundFill ? options.backgroundFill : null;\\n\\n  /**\\n   * @private\\n   * @type {module:ol/style/Stroke}\\n   */\\n  this.backgroundStroke_ = options.backgroundStroke ? options.backgroundStroke : null;\\n\\n  /**\\n   * @private\\n   * @type {Array.<number>}\\n   */\\n  this.padding_ = options.padding === undefined ? null : options.padding;\\n};\\n\\n\\n/**\\n * Clones the style.\\n * @return {module:ol/style/Text} The cloned style.\\n * @api\\n */\\nText.prototype.clone = function() {\\n  return new Text({\\n    font: this.getFont(),\\n    placement: this.getPlacement(),\\n    maxAngle: this.getMaxAngle(),\\n    overflow: this.getOverflow(),\\n    rotation: this.getRotation(),\\n    rotateWithView: this.getRotateWithView(),\\n    scale: this.getScale(),\\n    text: this.getText(),\\n    textAlign: this.getTextAlign(),\\n    textBaseline: this.getTextBaseline(),\\n    fill: this.getFill() ? this.getFill().clone() : undefined,\\n    stroke: this.getStroke() ? this.getStroke().clone() : undefined,\\n    offsetX: this.getOffsetX(),\\n    offsetY: this.getOffsetY(),\\n    backgroundFill: this.getBackgroundFill() ? this.getBackgroundFill().clone() : undefined,\\n    backgroundStroke: this.getBackgroundStroke() ? this.getBackgroundStroke().clone() : undefined\\n  });\\n};\\n\\n\\n/**\\n * Get the `overflow` configuration.\\n * @return {boolean} Let text overflow the length of the path they follow.\\n * @api\\n */\\nText.prototype.getOverflow = function() {\\n  return this.overflow_;\\n};\\n\\n\\n/**\\n * Get the font name.\\n * @return {string|undefined} Font.\\n * @api\\n */\\nText.prototype.getFont = function() {\\n  return this.font_;\\n};\\n\\n\\n/**\\n * Get the maximum angle between adjacent characters.\\n * @return {number} Angle in radians.\\n * @api\\n */\\nText.prototype.getMaxAngle = function() {\\n  return this.maxAngle_;\\n};\\n\\n\\n/**\\n * Get the label placement.\\n * @return {module:ol/style/TextPlacement|string} Text placement.\\n * @api\\n */\\nText.prototype.getPlacement = function() {\\n  return this.placement_;\\n};\\n\\n\\n/**\\n * Get the x-offset for the text.\\n * @return {number} Horizontal text offset.\\n * @api\\n */\\nText.prototype.getOffsetX = function() {\\n  return this.offsetX_;\\n};\\n\\n\\n/**\\n * Get the y-offset for the text.\\n * @return {number} Vertical text offset.\\n * @api\\n */\\nText.prototype.getOffsetY = function() {\\n  return this.offsetY_;\\n};\\n\\n\\n/**\\n * Get the fill style for the text.\\n * @return {module:ol/style/Fill} Fill style.\\n * @api\\n */\\nText.prototype.getFill = function() {\\n  return this.fill_;\\n};\\n\\n\\n/**\\n * Determine whether the text rotates with the map.\\n * @return {boolean|undefined} Rotate with map.\\n * @api\\n */\\nText.prototype.getRotateWithView = function() {\\n  return this.rotateWithView_;\\n};\\n\\n\\n/**\\n * Get the text rotation.\\n * @return {number|undefined} Rotation.\\n * @api\\n */\\nText.prototype.getRotation = function() {\\n  return this.rotation_;\\n};\\n\\n\\n/**\\n * Get the text scale.\\n * @return {number|undefined} Scale.\\n * @api\\n */\\nText.prototype.getScale = function() {\\n  return this.scale_;\\n};\\n\\n\\n/**\\n * Get the stroke style for the text.\\n * @return {module:ol/style/Stroke} Stroke style.\\n * @api\\n */\\nText.prototype.getStroke = function() {\\n  return this.stroke_;\\n};\\n\\n\\n/**\\n * Get the text to be rendered.\\n * @return {string|undefined} Text.\\n * @api\\n */\\nText.prototype.getText = function() {\\n  return this.text_;\\n};\\n\\n\\n/**\\n * Get the text alignment.\\n * @return {string|undefined} Text align.\\n * @api\\n */\\nText.prototype.getTextAlign = function() {\\n  return this.textAlign_;\\n};\\n\\n\\n/**\\n * Get the text baseline.\\n * @return {string|undefined} Text baseline.\\n * @api\\n */\\nText.prototype.getTextBaseline = function() {\\n  return this.textBaseline_;\\n};\\n\\n\\n/**\\n * Get the background fill style for the text.\\n * @return {module:ol/style/Fill} Fill style.\\n * @api\\n */\\nText.prototype.getBackgroundFill = function() {\\n  return this.backgroundFill_;\\n};\\n\\n\\n/**\\n * Get the background stroke style for the text.\\n * @return {module:ol/style/Stroke} Stroke style.\\n * @api\\n */\\nText.prototype.getBackgroundStroke = function() {\\n  return this.backgroundStroke_;\\n};\\n\\n\\n/**\\n * Get the padding for the text.\\n * @return {Array.<number>} Padding.\\n * @api\\n */\\nText.prototype.getPadding = function() {\\n  return this.padding_;\\n};\\n\\n\\n/**\\n * Set the `overflow` property.\\n *\\n * @param {boolean} overflow Let text overflow the path that it follows.\\n * @api\\n */\\nText.prototype.setOverflow = function(overflow) {\\n  this.overflow_ = overflow;\\n};\\n\\n\\n/**\\n * Set the font.\\n *\\n * @param {string|undefined} font Font.\\n * @api\\n */\\nText.prototype.setFont = function(font) {\\n  this.font_ = font;\\n};\\n\\n\\n/**\\n * Set the maximum angle between adjacent characters.\\n *\\n * @param {number} maxAngle Angle in radians.\\n * @api\\n */\\nText.prototype.setMaxAngle = function(maxAngle) {\\n  this.maxAngle_ = maxAngle;\\n};\\n\\n\\n/**\\n * Set the x offset.\\n *\\n * @param {number} offsetX Horizontal text offset.\\n * @api\\n */\\nText.prototype.setOffsetX = function(offsetX) {\\n  this.offsetX_ = offsetX;\\n};\\n\\n\\n/**\\n * Set the y offset.\\n *\\n * @param {number} offsetY Vertical text offset.\\n * @api\\n */\\nText.prototype.setOffsetY = function(offsetY) {\\n  this.offsetY_ = offsetY;\\n};\\n\\n\\n/**\\n * Set the text placement.\\n *\\n * @param {module:ol/style/TextPlacement|string} placement Placement.\\n * @api\\n */\\nText.prototype.setPlacement = function(placement) {\\n  this.placement_ = placement;\\n};\\n\\n\\n/**\\n * Set the fill.\\n *\\n * @param {module:ol/style/Fill} fill Fill style.\\n * @api\\n */\\nText.prototype.setFill = function(fill) {\\n  this.fill_ = fill;\\n};\\n\\n\\n/**\\n * Set the rotation.\\n *\\n * @param {number|undefined} rotation Rotation.\\n * @api\\n */\\nText.prototype.setRotation = function(rotation) {\\n  this.rotation_ = rotation;\\n};\\n\\n\\n/**\\n * Set the scale.\\n *\\n * @param {number|undefined} scale Scale.\\n * @api\\n */\\nText.prototype.setScale = function(scale) {\\n  this.scale_ = scale;\\n};\\n\\n\\n/**\\n * Set the stroke.\\n *\\n * @param {module:ol/style/Stroke} stroke Stroke style.\\n * @api\\n */\\nText.prototype.setStroke = function(stroke) {\\n  this.stroke_ = stroke;\\n};\\n\\n\\n/**\\n * Set the text.\\n *\\n * @param {string|undefined} text Text.\\n * @api\\n */\\nText.prototype.setText = function(text) {\\n  this.text_ = text;\\n};\\n\\n\\n/**\\n * Set the text alignment.\\n *\\n * @param {string|undefined} textAlign Text align.\\n * @api\\n */\\nText.prototype.setTextAlign = function(textAlign) {\\n  this.textAlign_ = textAlign;\\n};\\n\\n\\n/**\\n * Set the text baseline.\\n *\\n * @param {string|undefined} textBaseline Text baseline.\\n * @api\\n */\\nText.prototype.setTextBaseline = function(textBaseline) {\\n  this.textBaseline_ = textBaseline;\\n};\\n\\n\\n/**\\n * Set the background fill.\\n *\\n * @param {module:ol/style/Fill} fill Fill style.\\n * @api\\n */\\nText.prototype.setBackgroundFill = function(fill) {\\n  this.backgroundFill_ = fill;\\n};\\n\\n\\n/**\\n * Set the background stroke.\\n *\\n * @param {module:ol/style/Stroke} stroke Stroke style.\\n * @api\\n */\\nText.prototype.setBackgroundStroke = function(stroke) {\\n  this.backgroundStroke_ = stroke;\\n};\\n\\n\\n/**\\n * Set the padding (`[top, right, bottom, left]`).\\n *\\n * @param {!Array.<number>} padding Padding.\\n * @api\\n */\\nText.prototype.setPadding = function(padding) {\\n  this.padding_ = padding;\\n};\\nexport default Text;\\n\",\"/**\\n * @module ol/OverlayPositioning\\n */\\n\\n/**\\n * Overlay position: `'bottom-left'`, `'bottom-center'`,  `'bottom-right'`,\\n * `'center-left'`, `'center-center'`, `'center-right'`, `'top-left'`,\\n * `'top-center'`, `'top-right'`\\n * @enum {string}\\n */\\nexport default {\\n  BOTTOM_LEFT: 'bottom-left',\\n  BOTTOM_CENTER: 'bottom-center',\\n  BOTTOM_RIGHT: 'bottom-right',\\n  CENTER_LEFT: 'center-left',\\n  CENTER_CENTER: 'center-center',\\n  CENTER_RIGHT: 'center-right',\\n  TOP_LEFT: 'top-left',\\n  TOP_CENTER: 'top-center',\\n  TOP_RIGHT: 'top-right'\\n};\\n\",\"/**\\n * @module ol/Overlay\\n */\\nimport {inherits} from './index.js';\\nimport MapEventType from './MapEventType.js';\\nimport BaseObject, {getChangeEventType} from './Object.js';\\nimport OverlayPositioning from './OverlayPositioning.js';\\nimport {CLASS_SELECTABLE} from './css.js';\\nimport {removeNode, removeChildren, outerWidth, outerHeight} from './dom.js';\\nimport {listen, unlistenByKey} from './events.js';\\nimport {containsExtent} from './extent.js';\\n\\n\\n/**\\n * @typedef {Object} Options\\n * @property {number|string} [id] Set the overlay id. The overlay id can be used\\n * with the {@link module:ol/Map~Map#getOverlayById} method.\\n * @property {Element} [element] The overlay element.\\n * @property {Array.<number>} [offset=[0, 0]] Offsets in pixels used when positioning\\n * the overlay. The first element in the\\n * array is the horizontal offset. A positive value shifts the overlay right.\\n * The second element in the array is the vertical offset. A positive value\\n * shifts the overlay down.\\n * @property {module:ol/coordinate~Coordinate} [position] The overlay position\\n * in map projection.\\n * @property {module:ol/OverlayPositioning} [positioning='top-left'] Defines how\\n * the overlay is actually positioned with respect to its `position` property.\\n * Possible values are `'bottom-left'`, `'bottom-center'`, `'bottom-right'`,\\n * `'center-left'`, `'center-center'`, `'center-right'`, `'top-left'`,\\n * `'top-center'`, and `'top-right'`.\\n * @property {boolean} [stopEvent=true] Whether event propagation to the map\\n * viewport should be stopped. If `true` the overlay is placed in the same\\n * container as that of the controls (CSS class name\\n * `ol-overlaycontainer-stopevent`); if `false` it is placed in the container\\n * with CSS class name `ol-overlaycontainer`.\\n * @property {boolean} [insertFirst=true] Whether the overlay is inserted first\\n * in the overlay container, or appended. If the overlay is placed in the same\\n * container as that of the controls (see the `stopEvent` option) you will\\n * probably set `insertFirst` to `true` so the overlay is displayed below the\\n * controls.\\n * @property {boolean} [autoPan=false] If set to `true` the map is panned when\\n * calling `setPosition`, so that the overlay is entirely visible in the current\\n * viewport.\\n * @property {module:ol/Overlay~PanOptions} [autoPanAnimation] The\\n * animation options used to pan the overlay into view. This animation is only\\n * used when `autoPan` is enabled. A `duration` and `easing` may be provided to\\n * customize the animation.\\n * @property {number} [autoPanMargin=20] The margin (in pixels) between the\\n * overlay and the borders of the map when autopanning.\\n * @property {string} [className='ol-overlay-container ol-selectable'] CSS class\\n * name.\\n */\\n\\n\\n/**\\n * @typedef {Object} PanOptions\\n * @property {number} [duration=1000] The duration of the animation in\\n * milliseconds.\\n * @property {function(number):number} [easing] The easing function to use. Can\\n * be one from {@link module:ol/easing} or a custom function.\\n * Default is {@link module:ol/easing~inAndOut}.\\n */\\n\\n\\n/**\\n * @enum {string}\\n * @protected\\n */\\nconst Property = {\\n  ELEMENT: 'element',\\n  MAP: 'map',\\n  OFFSET: 'offset',\\n  POSITION: 'position',\\n  POSITIONING: 'positioning'\\n};\\n\\n\\n/**\\n * @classdesc\\n * An element to be displayed over the map and attached to a single map\\n * location.  Like {@link module:ol/control/Control~Control}, Overlays are\\n * visible widgets. Unlike Controls, they are not in a fixed position on the\\n * screen, but are tied to a geographical coordinate, so panning the map will\\n * move an Overlay but not a Control.\\n *\\n * Example:\\n *\\n *     import Overlay from 'ol/Overlay';\\n *\\n *     var popup = new Overlay({\\n *       element: document.getElementById('popup')\\n *     });\\n *     popup.setPosition(coordinate);\\n *     map.addOverlay(popup);\\n *\\n * @constructor\\n * @extends {module:ol/Object}\\n * @param {module:ol/Overlay~Options} options Overlay options.\\n * @api\\n */\\nconst Overlay = function(options) {\\n\\n  BaseObject.call(this);\\n\\n  /**\\n   * @protected\\n   * @type {module:ol/Overlay~Options}\\n   */\\n  this.options = options;\\n\\n  /**\\n   * @protected\\n   * @type {number|string|undefined}\\n   */\\n  this.id = options.id;\\n\\n  /**\\n   * @protected\\n   * @type {boolean}\\n   */\\n  this.insertFirst = options.insertFirst !== undefined ?\\n    options.insertFirst : true;\\n\\n  /**\\n   * @protected\\n   * @type {boolean}\\n   */\\n  this.stopEvent = options.stopEvent !== undefined ? options.stopEvent : true;\\n\\n  /**\\n   * @protected\\n   * @type {Element}\\n   */\\n  this.element = document.createElement('DIV');\\n  this.element.className = options.className !== undefined ?\\n    options.className : 'ol-overlay-container ' + CLASS_SELECTABLE;\\n  this.element.style.position = 'absolute';\\n\\n  /**\\n   * @protected\\n   * @type {boolean}\\n   */\\n  this.autoPan = options.autoPan !== undefined ? options.autoPan : false;\\n\\n  /**\\n   * @protected\\n   * @type {module:ol/Overlay~PanOptions}\\n   */\\n  this.autoPanAnimation = options.autoPanAnimation || /** @type {module:ol/Overlay~PanOptions} */ ({});\\n\\n  /**\\n   * @protected\\n   * @type {number}\\n   */\\n  this.autoPanMargin = options.autoPanMargin !== undefined ?\\n    options.autoPanMargin : 20;\\n\\n  /**\\n   * @protected\\n   * @type {{bottom_: string,\\n   *         left_: string,\\n   *         right_: string,\\n   *         top_: string,\\n   *         visible: boolean}}\\n   */\\n  this.rendered = {\\n    bottom_: '',\\n    left_: '',\\n    right_: '',\\n    top_: '',\\n    visible: true\\n  };\\n\\n  /**\\n   * @protected\\n   * @type {?module:ol/events~EventsKey}\\n   */\\n  this.mapPostrenderListenerKey = null;\\n\\n  listen(\\n    this, getChangeEventType(Property.ELEMENT),\\n    this.handleElementChanged, this);\\n\\n  listen(\\n    this, getChangeEventType(Property.MAP),\\n    this.handleMapChanged, this);\\n\\n  listen(\\n    this, getChangeEventType(Property.OFFSET),\\n    this.handleOffsetChanged, this);\\n\\n  listen(\\n    this, getChangeEventType(Property.POSITION),\\n    this.handlePositionChanged, this);\\n\\n  listen(\\n    this, getChangeEventType(Property.POSITIONING),\\n    this.handlePositioningChanged, this);\\n\\n  if (options.element !== undefined) {\\n    this.setElement(options.element);\\n  }\\n\\n  this.setOffset(options.offset !== undefined ? options.offset : [0, 0]);\\n\\n  this.setPositioning(options.positioning !== undefined ?\\n    /** @type {module:ol/OverlayPositioning} */ (options.positioning) :\\n    OverlayPositioning.TOP_LEFT);\\n\\n  if (options.position !== undefined) {\\n    this.setPosition(options.position);\\n  }\\n\\n};\\n\\ninherits(Overlay, BaseObject);\\n\\n\\n/**\\n * Get the DOM element of this overlay.\\n * @return {Element|undefined} The Element containing the overlay.\\n * @observable\\n * @api\\n */\\nOverlay.prototype.getElement = function() {\\n  return /** @type {Element|undefined} */ (this.get(Property.ELEMENT));\\n};\\n\\n\\n/**\\n * Get the overlay identifier which is set on constructor.\\n * @return {number|string|undefined} Id.\\n * @api\\n */\\nOverlay.prototype.getId = function() {\\n  return this.id;\\n};\\n\\n\\n/**\\n * Get the map associated with this overlay.\\n * @return {module:ol/PluggableMap|undefined} The map that the\\n * overlay is part of.\\n * @observable\\n * @api\\n */\\nOverlay.prototype.getMap = function() {\\n  return (\\n    /** @type {module:ol/PluggableMap|undefined} */ (this.get(Property.MAP))\\n  );\\n};\\n\\n\\n/**\\n * Get the offset of this overlay.\\n * @return {Array.<number>} The offset.\\n * @observable\\n * @api\\n */\\nOverlay.prototype.getOffset = function() {\\n  return /** @type {Array.<number>} */ (this.get(Property.OFFSET));\\n};\\n\\n\\n/**\\n * Get the current position of this overlay.\\n * @return {module:ol/coordinate~Coordinate|undefined} The spatial point that the overlay is\\n *     anchored at.\\n * @observable\\n * @api\\n */\\nOverlay.prototype.getPosition = function() {\\n  return (\\n    /** @type {module:ol/coordinate~Coordinate|undefined} */ (this.get(Property.POSITION))\\n  );\\n};\\n\\n\\n/**\\n * Get the current positioning of this overlay.\\n * @return {module:ol/OverlayPositioning} How the overlay is positioned\\n *     relative to its point on the map.\\n * @observable\\n * @api\\n */\\nOverlay.prototype.getPositioning = function() {\\n  return (\\n    /** @type {module:ol/OverlayPositioning} */ (this.get(Property.POSITIONING))\\n  );\\n};\\n\\n\\n/**\\n * @protected\\n */\\nOverlay.prototype.handleElementChanged = function() {\\n  removeChildren(this.element);\\n  const element = this.getElement();\\n  if (element) {\\n    this.element.appendChild(element);\\n  }\\n};\\n\\n\\n/**\\n * @protected\\n */\\nOverlay.prototype.handleMapChanged = function() {\\n  if (this.mapPostrenderListenerKey) {\\n    removeNode(this.element);\\n    unlistenByKey(this.mapPostrenderListenerKey);\\n    this.mapPostrenderListenerKey = null;\\n  }\\n  const map = this.getMap();\\n  if (map) {\\n    this.mapPostrenderListenerKey = listen(map,\\n      MapEventType.POSTRENDER, this.render, this);\\n    this.updatePixelPosition();\\n    const container = this.stopEvent ?\\n      map.getOverlayContainerStopEvent() : map.getOverlayContainer();\\n    if (this.insertFirst) {\\n      container.insertBefore(this.element, container.childNodes[0] || null);\\n    } else {\\n      container.appendChild(this.element);\\n    }\\n  }\\n};\\n\\n\\n/**\\n * @protected\\n */\\nOverlay.prototype.render = function() {\\n  this.updatePixelPosition();\\n};\\n\\n\\n/**\\n * @protected\\n */\\nOverlay.prototype.handleOffsetChanged = function() {\\n  this.updatePixelPosition();\\n};\\n\\n\\n/**\\n * @protected\\n */\\nOverlay.prototype.handlePositionChanged = function() {\\n  this.updatePixelPosition();\\n  if (this.get(Property.POSITION) && this.autoPan) {\\n    this.panIntoView();\\n  }\\n};\\n\\n\\n/**\\n * @protected\\n */\\nOverlay.prototype.handlePositioningChanged = function() {\\n  this.updatePixelPosition();\\n};\\n\\n\\n/**\\n * Set the DOM element to be associated with this overlay.\\n * @param {Element|undefined} element The Element containing the overlay.\\n * @observable\\n * @api\\n */\\nOverlay.prototype.setElement = function(element) {\\n  this.set(Property.ELEMENT, element);\\n};\\n\\n\\n/**\\n * Set the map to be associated with this overlay.\\n * @param {module:ol/PluggableMap|undefined} map The map that the\\n * overlay is part of.\\n * @observable\\n * @api\\n */\\nOverlay.prototype.setMap = function(map) {\\n  this.set(Property.MAP, map);\\n};\\n\\n\\n/**\\n * Set the offset for this overlay.\\n * @param {Array.<number>} offset Offset.\\n * @observable\\n * @api\\n */\\nOverlay.prototype.setOffset = function(offset) {\\n  this.set(Property.OFFSET, offset);\\n};\\n\\n\\n/**\\n * Set the position for this overlay. If the position is `undefined` the\\n * overlay is hidden.\\n * @param {module:ol/coordinate~Coordinate|undefined} position The spatial point that the overlay\\n *     is anchored at.\\n * @observable\\n * @api\\n */\\nOverlay.prototype.setPosition = function(position) {\\n  this.set(Property.POSITION, position);\\n};\\n\\n\\n/**\\n * Pan the map so that the overlay is entirely visible in the current viewport\\n * (if necessary).\\n * @protected\\n */\\nOverlay.prototype.panIntoView = function() {\\n  const map = this.getMap();\\n\\n  if (!map || !map.getTargetElement()) {\\n    return;\\n  }\\n\\n  const mapRect = this.getRect(map.getTargetElement(), map.getSize());\\n  const element = /** @type {!Element} */ (this.getElement());\\n  const overlayRect = this.getRect(element, [outerWidth(element), outerHeight(element)]);\\n\\n  const margin = this.autoPanMargin;\\n  if (!containsExtent(mapRect, overlayRect)) {\\n    // the overlay is not completely inside the viewport, so pan the map\\n    const offsetLeft = overlayRect[0] - mapRect[0];\\n    const offsetRight = mapRect[2] - overlayRect[2];\\n    const offsetTop = overlayRect[1] - mapRect[1];\\n    const offsetBottom = mapRect[3] - overlayRect[3];\\n\\n    const delta = [0, 0];\\n    if (offsetLeft < 0) {\\n      // move map to the left\\n      delta[0] = offsetLeft - margin;\\n    } else if (offsetRight < 0) {\\n      // move map to the right\\n      delta[0] = Math.abs(offsetRight) + margin;\\n    }\\n    if (offsetTop < 0) {\\n      // move map up\\n      delta[1] = offsetTop - margin;\\n    } else if (offsetBottom < 0) {\\n      // move map down\\n      delta[1] = Math.abs(offsetBottom) + margin;\\n    }\\n\\n    if (delta[0] !== 0 || delta[1] !== 0) {\\n      const center = /** @type {module:ol/coordinate~Coordinate} */ (map.getView().getCenter());\\n      const centerPx = map.getPixelFromCoordinate(center);\\n      const newCenterPx = [\\n        centerPx[0] + delta[0],\\n        centerPx[1] + delta[1]\\n      ];\\n\\n      map.getView().animate({\\n        center: map.getCoordinateFromPixel(newCenterPx),\\n        duration: this.autoPanAnimation.duration,\\n        easing: this.autoPanAnimation.easing\\n      });\\n    }\\n  }\\n};\\n\\n\\n/**\\n * Get the extent of an element relative to the document\\n * @param {Element|undefined} element The element.\\n * @param {module:ol/size~Size|undefined} size The size of the element.\\n * @return {module:ol/extent~Extent} The extent.\\n * @protected\\n */\\nOverlay.prototype.getRect = function(element, size) {\\n  const box = element.getBoundingClientRect();\\n  const offsetX = box.left + window.pageXOffset;\\n  const offsetY = box.top + window.pageYOffset;\\n  return [\\n    offsetX,\\n    offsetY,\\n    offsetX + size[0],\\n    offsetY + size[1]\\n  ];\\n};\\n\\n\\n/**\\n * Set the positioning for this overlay.\\n * @param {module:ol/OverlayPositioning} positioning how the overlay is\\n *     positioned relative to its point on the map.\\n * @observable\\n * @api\\n */\\nOverlay.prototype.setPositioning = function(positioning) {\\n  this.set(Property.POSITIONING, positioning);\\n};\\n\\n\\n/**\\n * Modify the visibility of the element.\\n * @param {boolean} visible Element visibility.\\n * @protected\\n */\\nOverlay.prototype.setVisible = function(visible) {\\n  if (this.rendered.visible !== visible) {\\n    this.element.style.display = visible ? '' : 'none';\\n    this.rendered.visible = visible;\\n  }\\n};\\n\\n\\n/**\\n * Update pixel position.\\n * @protected\\n */\\nOverlay.prototype.updatePixelPosition = function() {\\n  const map = this.getMap();\\n  const position = this.getPosition();\\n  if (!map || !map.isRendered() || !position) {\\n    this.setVisible(false);\\n    return;\\n  }\\n\\n  const pixel = map.getPixelFromCoordinate(position);\\n  const mapSize = map.getSize();\\n  this.updateRenderedPosition(pixel, mapSize);\\n};\\n\\n\\n/**\\n * @param {module:ol~Pixel} pixel The pixel location.\\n * @param {module:ol/size~Size|undefined} mapSize The map size.\\n * @protected\\n */\\nOverlay.prototype.updateRenderedPosition = function(pixel, mapSize) {\\n  const style = this.element.style;\\n  const offset = this.getOffset();\\n\\n  const positioning = this.getPositioning();\\n\\n  this.setVisible(true);\\n\\n  let offsetX = offset[0];\\n  let offsetY = offset[1];\\n  if (positioning == OverlayPositioning.BOTTOM_RIGHT ||\\n      positioning == OverlayPositioning.CENTER_RIGHT ||\\n      positioning == OverlayPositioning.TOP_RIGHT) {\\n    if (this.rendered.left_ !== '') {\\n      this.rendered.left_ = style.left = '';\\n    }\\n    const right = Math.round(mapSize[0] - pixel[0] - offsetX) + 'px';\\n    if (this.rendered.right_ != right) {\\n      this.rendered.right_ = style.right = right;\\n    }\\n  } else {\\n    if (this.rendered.right_ !== '') {\\n      this.rendered.right_ = style.right = '';\\n    }\\n    if (positioning == OverlayPositioning.BOTTOM_CENTER ||\\n        positioning == OverlayPositioning.CENTER_CENTER ||\\n        positioning == OverlayPositioning.TOP_CENTER) {\\n      offsetX -= this.element.offsetWidth / 2;\\n    }\\n    const left = Math.round(pixel[0] + offsetX) + 'px';\\n    if (this.rendered.left_ != left) {\\n      this.rendered.left_ = style.left = left;\\n    }\\n  }\\n  if (positioning == OverlayPositioning.BOTTOM_LEFT ||\\n      positioning == OverlayPositioning.BOTTOM_CENTER ||\\n      positioning == OverlayPositioning.BOTTOM_RIGHT) {\\n    if (this.rendered.top_ !== '') {\\n      this.rendered.top_ = style.top = '';\\n    }\\n    const bottom = Math.round(mapSize[1] - pixel[1] - offsetY) + 'px';\\n    if (this.rendered.bottom_ != bottom) {\\n      this.rendered.bottom_ = style.bottom = bottom;\\n    }\\n  } else {\\n    if (this.rendered.bottom_ !== '') {\\n      this.rendered.bottom_ = style.bottom = '';\\n    }\\n    if (positioning == OverlayPositioning.CENTER_LEFT ||\\n        positioning == OverlayPositioning.CENTER_CENTER ||\\n        positioning == OverlayPositioning.CENTER_RIGHT) {\\n      offsetY -= this.element.offsetHeight / 2;\\n    }\\n    const top = Math.round(pixel[1] + offsetY) + 'px';\\n    if (this.rendered.top_ != top) {\\n      this.rendered.top_ = style.top = top;\\n    }\\n  }\\n};\\n\\n\\n/**\\n * returns the options this Overlay has been created with\\n * @return {module:ol/Overlay~Options} overlay options\\n */\\nOverlay.prototype.getOptions = function() {\\n  return this.options;\\n};\\n\\nexport default Overlay;\\n\",\"import 'ol/ol.css';\\nimport GeoJSON from 'ol/format/GeoJSON';\\nimport Map from 'ol/Map';\\nimport VectorLayer from 'ol/layer/Vector';\\nimport VectorSource from 'ol/source/Vector';\\nimport View from 'ol/View';\\nimport {fromLonLat} from 'ol/proj';\\nimport TileLayer from 'ol/layer/Tile';\\nimport OSM from 'ol/source/OSM';\\nimport {Fill, Stroke, Style, Text} from 'ol/style.js';\\nimport Overlay from 'ol/Overlay';\\nimport './data/buildings.geojson';\\n\\nconst txState = [-97.942999, 29.888998];\\nvar txStateWebMercator = fromLonLat(txState);\\n\\nconst buildingLayer = new VectorLayer({\\n      source: new VectorSource({\\n        format: new GeoJSON(),\\n        url: './data/buildings.geojson'\\n      })\\n\\n});\\n\\nconst baseLayer = new TileLayer({\\n\\tsource: new OSM()\\n})\\n\\nconst overlay = new Overlay({\\n  element: document.getElementById('popup-container'),\\n  positioning: 'bottom-center',\\n  offset: [0, -10],\\n  autoPan: true\\n});\\n\\nconst map = new Map({\\n  target: 'map-container',\\n  layers: [baseLayer, buildingLayer],\\n  view: new View({\\n    center: txStateWebMercator,\\n    zoom: 16\\n  })\\n});\\n\\noverlay.getElement().addEventListener('click', function() {\\n\\toverlay.setPosition();\\n});\\n\\nmap.addOverlay(overlay);\\n\\nmap.on('click', function(e) {\\n  let markup = '';\\n  map.forEachFeatureAtPixel(e.pixel, function(feature) {\\n    markup += `${markup && '<hr>'}<table>`;\\n    const bldg_name = feature.get('Bldg_Nam_1');\\n    const status = feature.get('Status');\\n      //markup += `<tr><th>${property}</th><td>${properties[property]}</td></tr>`;\\n    markup += `<tr><th>Building Name:</th> <td>${bldg_name}</td></tr>`;\\n    markup += `<tr><th>Status:</th> <td>${status}</td></tr>`;\\n    markup += '</table>';\\n  }, {hitTolerance: 1});\\n  if (markup) {\\n    document.getElementById('popup-content').innerHTML = markup;\\n    overlay.setPosition(e.coordinate);\\n  } else {\\n    overlay.setPosition();\\n  }\\n});\",\"(function (global, factory) {\\n\\ttypeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :\\n\\ttypeof define === 'function' && define.amd ? define(factory) :\\n\\t(global.quickselect = factory());\\n}(this, (function () { 'use strict';\\n\\nfunction quickselect(arr, k, left, right, compare) {\\n    quickselectStep(arr, k, left || 0, right || (arr.length - 1), compare || defaultCompare);\\n}\\n\\nfunction quickselectStep(arr, k, left, right, compare) {\\n\\n    while (right > left) {\\n        if (right - left > 600) {\\n            var n = right - left + 1;\\n            var m = k - left + 1;\\n            var z = Math.log(n);\\n            var s = 0.5 * Math.exp(2 * z / 3);\\n            var sd = 0.5 * Math.sqrt(z * s * (n - s) / n) * (m - n / 2 < 0 ? -1 : 1);\\n            var newLeft = Math.max(left, Math.floor(k - m * s / n + sd));\\n            var newRight = Math.min(right, Math.floor(k + (n - m) * s / n + sd));\\n            quickselectStep(arr, k, newLeft, newRight, compare);\\n        }\\n\\n        var t = arr[k];\\n        var i = left;\\n        var j = right;\\n\\n        swap(arr, left, k);\\n        if (compare(arr[right], t) > 0) swap(arr, left, right);\\n\\n        while (i < j) {\\n            swap(arr, i, j);\\n            i++;\\n            j--;\\n            while (compare(arr[i], t) < 0) i++;\\n            while (compare(arr[j], t) > 0) j--;\\n        }\\n\\n        if (compare(arr[left], t) === 0) swap(arr, left, j);\\n        else {\\n            j++;\\n            swap(arr, j, right);\\n        }\\n\\n        if (j <= k) left = j + 1;\\n        if (k <= j) right = j - 1;\\n    }\\n}\\n\\nfunction swap(arr, i, j) {\\n    var tmp = arr[i];\\n    arr[i] = arr[j];\\n    arr[j] = tmp;\\n}\\n\\nfunction defaultCompare(a, b) {\\n    return a < b ? -1 : a > b ? 1 : 0;\\n}\\n\\nreturn quickselect;\\n\\n})));\\n\",\"\\n/**\\n * When source maps are enabled, `style-loader` uses a link element with a data-uri to\\n * embed the css on the page. This breaks all relative urls because now they are relative to a\\n * bundle instead of the current page.\\n *\\n * One solution is to only use full urls, but that may be impossible.\\n *\\n * Instead, this function \\\"fixes\\\" the relative urls to be absolute according to the current page location.\\n *\\n * A rudimentary test suite is located at `test/fixUrls.js` and can be run via the `npm test` command.\\n *\\n */\\n\\nmodule.exports = function (css) {\\n  // get current location\\n  var location = typeof window !== \\\"undefined\\\" && window.location;\\n\\n  if (!location) {\\n    throw new Error(\\\"fixUrls requires window.location\\\");\\n  }\\n\\n\\t// blank or null?\\n\\tif (!css || typeof css !== \\\"string\\\") {\\n\\t  return css;\\n  }\\n\\n  var baseUrl = location.protocol + \\\"//\\\" + location.host;\\n  var currentDir = baseUrl + location.pathname.replace(/\\\\/[^\\\\/]*$/, \\\"/\\\");\\n\\n\\t// convert each url(...)\\n\\t/*\\n\\tThis regular expression is just a way to recursively match brackets within\\n\\ta string.\\n\\n\\t /url\\\\s*\\\\(  = Match on the word \\\"url\\\" with any whitespace after it and then a parens\\n\\t   (  = Start a capturing group\\n\\t     (?:  = Start a non-capturing group\\n\\t         [^)(]  = Match anything that isn't a parentheses\\n\\t         |  = OR\\n\\t         \\\\(  = Match a start parentheses\\n\\t             (?:  = Start another non-capturing groups\\n\\t                 [^)(]+  = Match anything that isn't a parentheses\\n\\t                 |  = OR\\n\\t                 \\\\(  = Match a start parentheses\\n\\t                     [^)(]*  = Match anything that isn't a parentheses\\n\\t                 \\\\)  = Match a end parentheses\\n\\t             )  = End Group\\n              *\\\\) = Match anything and then a close parens\\n          )  = Close non-capturing group\\n          *  = Match anything\\n       )  = Close capturing group\\n\\t \\\\)  = Match a close parens\\n\\n\\t /gi  = Get all matches, not the first.  Be case insensitive.\\n\\t */\\n\\tvar fixedCss = css.replace(/url\\\\s*\\\\(((?:[^)(]|\\\\((?:[^)(]+|\\\\([^)(]*\\\\))*\\\\))*)\\\\)/gi, function(fullMatch, origUrl) {\\n\\t\\t// strip quotes (if they exist)\\n\\t\\tvar unquotedOrigUrl = origUrl\\n\\t\\t\\t.trim()\\n\\t\\t\\t.replace(/^\\\"(.*)\\\"$/, function(o, $1){ return $1; })\\n\\t\\t\\t.replace(/^'(.*)'$/, function(o, $1){ return $1; });\\n\\n\\t\\t// already a full url? no change\\n\\t\\tif (/^(#|data:|http:\\\\/\\\\/|https:\\\\/\\\\/|file:\\\\/\\\\/\\\\/|\\\\s*$)/i.test(unquotedOrigUrl)) {\\n\\t\\t  return fullMatch;\\n\\t\\t}\\n\\n\\t\\t// convert the url to a full url\\n\\t\\tvar newUrl;\\n\\n\\t\\tif (unquotedOrigUrl.indexOf(\\\"//\\\") === 0) {\\n\\t\\t  \\t//TODO: should we add protocol?\\n\\t\\t\\tnewUrl = unquotedOrigUrl;\\n\\t\\t} else if (unquotedOrigUrl.indexOf(\\\"/\\\") === 0) {\\n\\t\\t\\t// path should be relative to the base url\\n\\t\\t\\tnewUrl = baseUrl + unquotedOrigUrl; // already starts with '/'\\n\\t\\t} else {\\n\\t\\t\\t// path should be relative to current directory\\n\\t\\t\\tnewUrl = currentDir + unquotedOrigUrl.replace(/^\\\\.\\\\//, \\\"\\\"); // Strip leading './'\\n\\t\\t}\\n\\n\\t\\t// send back the fixed url(...)\\n\\t\\treturn \\\"url(\\\" + JSON.stringify(newUrl) + \\\")\\\";\\n\\t});\\n\\n\\t// send back the fixed css\\n\\treturn fixedCss;\\n};\\n\",\"/*\\n\\tMIT License http://www.opensource.org/licenses/mit-license.php\\n\\tAuthor Tobias Koppers @sokra\\n*/\\n\\nvar stylesInDom = {};\\n\\nvar\\tmemoize = function (fn) {\\n\\tvar memo;\\n\\n\\treturn function () {\\n\\t\\tif (typeof memo === \\\"undefined\\\") memo = fn.apply(this, arguments);\\n\\t\\treturn memo;\\n\\t};\\n};\\n\\nvar isOldIE = memoize(function () {\\n\\t// Test for IE <= 9 as proposed by Browserhacks\\n\\t// @see http://browserhacks.com/#hack-e71d8692f65334173fee715c222cb805\\n\\t// Tests for existence of standard globals is to allow style-loader\\n\\t// to operate correctly into non-standard environments\\n\\t// @see https://github.com/webpack-contrib/style-loader/issues/177\\n\\treturn window && document && document.all && !window.atob;\\n});\\n\\nvar getTarget = function (target) {\\n  return document.querySelector(target);\\n};\\n\\nvar getElement = (function (fn) {\\n\\tvar memo = {};\\n\\n\\treturn function(target) {\\n                // If passing function in options, then use it for resolve \\\"head\\\" element.\\n                // Useful for Shadow Root style i.e\\n                // {\\n                //   insertInto: function () { return document.querySelector(\\\"#foo\\\").shadowRoot }\\n                // }\\n                if (typeof target === 'function') {\\n                        return target();\\n                }\\n                if (typeof memo[target] === \\\"undefined\\\") {\\n\\t\\t\\tvar styleTarget = getTarget.call(this, target);\\n\\t\\t\\t// Special case to return head of iframe instead of iframe itself\\n\\t\\t\\tif (window.HTMLIFrameElement && styleTarget instanceof window.HTMLIFrameElement) {\\n\\t\\t\\t\\ttry {\\n\\t\\t\\t\\t\\t// This will throw an exception if access to iframe is blocked\\n\\t\\t\\t\\t\\t// due to cross-origin restrictions\\n\\t\\t\\t\\t\\tstyleTarget = styleTarget.contentDocument.head;\\n\\t\\t\\t\\t} catch(e) {\\n\\t\\t\\t\\t\\tstyleTarget = null;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tmemo[target] = styleTarget;\\n\\t\\t}\\n\\t\\treturn memo[target]\\n\\t};\\n})();\\n\\nvar singleton = null;\\nvar\\tsingletonCounter = 0;\\nvar\\tstylesInsertedAtTop = [];\\n\\nvar\\tfixUrls = require(\\\"./urls\\\");\\n\\nmodule.exports = function(list, options) {\\n\\tif (typeof DEBUG !== \\\"undefined\\\" && DEBUG) {\\n\\t\\tif (typeof document !== \\\"object\\\") throw new Error(\\\"The style-loader cannot be used in a non-browser environment\\\");\\n\\t}\\n\\n\\toptions = options || {};\\n\\n\\toptions.attrs = typeof options.attrs === \\\"object\\\" ? options.attrs : {};\\n\\n\\t// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>\\n\\t// tags it will allow on a page\\n\\tif (!options.singleton && typeof options.singleton !== \\\"boolean\\\") options.singleton = isOldIE();\\n\\n\\t// By default, add <style> tags to the <head> element\\n        if (!options.insertInto) options.insertInto = \\\"head\\\";\\n\\n\\t// By default, add <style> tags to the bottom of the target\\n\\tif (!options.insertAt) options.insertAt = \\\"bottom\\\";\\n\\n\\tvar styles = listToStyles(list, options);\\n\\n\\taddStylesToDom(styles, options);\\n\\n\\treturn function update (newList) {\\n\\t\\tvar mayRemove = [];\\n\\n\\t\\tfor (var i = 0; i < styles.length; i++) {\\n\\t\\t\\tvar item = styles[i];\\n\\t\\t\\tvar domStyle = stylesInDom[item.id];\\n\\n\\t\\t\\tdomStyle.refs--;\\n\\t\\t\\tmayRemove.push(domStyle);\\n\\t\\t}\\n\\n\\t\\tif(newList) {\\n\\t\\t\\tvar newStyles = listToStyles(newList, options);\\n\\t\\t\\taddStylesToDom(newStyles, options);\\n\\t\\t}\\n\\n\\t\\tfor (var i = 0; i < mayRemove.length; i++) {\\n\\t\\t\\tvar domStyle = mayRemove[i];\\n\\n\\t\\t\\tif(domStyle.refs === 0) {\\n\\t\\t\\t\\tfor (var j = 0; j < domStyle.parts.length; j++) domStyle.parts[j]();\\n\\n\\t\\t\\t\\tdelete stylesInDom[domStyle.id];\\n\\t\\t\\t}\\n\\t\\t}\\n\\t};\\n};\\n\\nfunction addStylesToDom (styles, options) {\\n\\tfor (var i = 0; i < styles.length; i++) {\\n\\t\\tvar item = styles[i];\\n\\t\\tvar domStyle = stylesInDom[item.id];\\n\\n\\t\\tif(domStyle) {\\n\\t\\t\\tdomStyle.refs++;\\n\\n\\t\\t\\tfor(var j = 0; j < domStyle.parts.length; j++) {\\n\\t\\t\\t\\tdomStyle.parts[j](item.parts[j]);\\n\\t\\t\\t}\\n\\n\\t\\t\\tfor(; j < item.parts.length; j++) {\\n\\t\\t\\t\\tdomStyle.parts.push(addStyle(item.parts[j], options));\\n\\t\\t\\t}\\n\\t\\t} else {\\n\\t\\t\\tvar parts = [];\\n\\n\\t\\t\\tfor(var j = 0; j < item.parts.length; j++) {\\n\\t\\t\\t\\tparts.push(addStyle(item.parts[j], options));\\n\\t\\t\\t}\\n\\n\\t\\t\\tstylesInDom[item.id] = {id: item.id, refs: 1, parts: parts};\\n\\t\\t}\\n\\t}\\n}\\n\\nfunction listToStyles (list, options) {\\n\\tvar styles = [];\\n\\tvar newStyles = {};\\n\\n\\tfor (var i = 0; i < list.length; i++) {\\n\\t\\tvar item = list[i];\\n\\t\\tvar id = options.base ? item[0] + options.base : item[0];\\n\\t\\tvar css = item[1];\\n\\t\\tvar media = item[2];\\n\\t\\tvar sourceMap = item[3];\\n\\t\\tvar part = {css: css, media: media, sourceMap: sourceMap};\\n\\n\\t\\tif(!newStyles[id]) styles.push(newStyles[id] = {id: id, parts: [part]});\\n\\t\\telse newStyles[id].parts.push(part);\\n\\t}\\n\\n\\treturn styles;\\n}\\n\\nfunction insertStyleElement (options, style) {\\n\\tvar target = getElement(options.insertInto)\\n\\n\\tif (!target) {\\n\\t\\tthrow new Error(\\\"Couldn't find a style target. This probably means that the value for the 'insertInto' parameter is invalid.\\\");\\n\\t}\\n\\n\\tvar lastStyleElementInsertedAtTop = stylesInsertedAtTop[stylesInsertedAtTop.length - 1];\\n\\n\\tif (options.insertAt === \\\"top\\\") {\\n\\t\\tif (!lastStyleElementInsertedAtTop) {\\n\\t\\t\\ttarget.insertBefore(style, target.firstChild);\\n\\t\\t} else if (lastStyleElementInsertedAtTop.nextSibling) {\\n\\t\\t\\ttarget.insertBefore(style, lastStyleElementInsertedAtTop.nextSibling);\\n\\t\\t} else {\\n\\t\\t\\ttarget.appendChild(style);\\n\\t\\t}\\n\\t\\tstylesInsertedAtTop.push(style);\\n\\t} else if (options.insertAt === \\\"bottom\\\") {\\n\\t\\ttarget.appendChild(style);\\n\\t} else if (typeof options.insertAt === \\\"object\\\" && options.insertAt.before) {\\n\\t\\tvar nextSibling = getElement(options.insertInto + \\\" \\\" + options.insertAt.before);\\n\\t\\ttarget.insertBefore(style, nextSibling);\\n\\t} else {\\n\\t\\tthrow new Error(\\\"[Style Loader]\\\\n\\\\n Invalid value for parameter 'insertAt' ('options.insertAt') found.\\\\n Must be 'top', 'bottom', or Object.\\\\n (https://github.com/webpack-contrib/style-loader#insertat)\\\\n\\\");\\n\\t}\\n}\\n\\nfunction removeStyleElement (style) {\\n\\tif (style.parentNode === null) return false;\\n\\tstyle.parentNode.removeChild(style);\\n\\n\\tvar idx = stylesInsertedAtTop.indexOf(style);\\n\\tif(idx >= 0) {\\n\\t\\tstylesInsertedAtTop.splice(idx, 1);\\n\\t}\\n}\\n\\nfunction createStyleElement (options) {\\n\\tvar style = document.createElement(\\\"style\\\");\\n\\n\\tif(options.attrs.type === undefined) {\\n\\t\\toptions.attrs.type = \\\"text/css\\\";\\n\\t}\\n\\n\\taddAttrs(style, options.attrs);\\n\\tinsertStyleElement(options, style);\\n\\n\\treturn style;\\n}\\n\\nfunction createLinkElement (options) {\\n\\tvar link = document.createElement(\\\"link\\\");\\n\\n\\tif(options.attrs.type === undefined) {\\n\\t\\toptions.attrs.type = \\\"text/css\\\";\\n\\t}\\n\\toptions.attrs.rel = \\\"stylesheet\\\";\\n\\n\\taddAttrs(link, options.attrs);\\n\\tinsertStyleElement(options, link);\\n\\n\\treturn link;\\n}\\n\\nfunction addAttrs (el, attrs) {\\n\\tObject.keys(attrs).forEach(function (key) {\\n\\t\\tel.setAttribute(key, attrs[key]);\\n\\t});\\n}\\n\\nfunction addStyle (obj, options) {\\n\\tvar style, update, remove, result;\\n\\n\\t// If a transform function was defined, run it on the css\\n\\tif (options.transform && obj.css) {\\n\\t    result = options.transform(obj.css);\\n\\n\\t    if (result) {\\n\\t    \\t// If transform returns a value, use that instead of the original css.\\n\\t    \\t// This allows running runtime transformations on the css.\\n\\t    \\tobj.css = result;\\n\\t    } else {\\n\\t    \\t// If the transform function returns a falsy value, don't add this css.\\n\\t    \\t// This allows conditional loading of css\\n\\t    \\treturn function() {\\n\\t    \\t\\t// noop\\n\\t    \\t};\\n\\t    }\\n\\t}\\n\\n\\tif (options.singleton) {\\n\\t\\tvar styleIndex = singletonCounter++;\\n\\n\\t\\tstyle = singleton || (singleton = createStyleElement(options));\\n\\n\\t\\tupdate = applyToSingletonTag.bind(null, style, styleIndex, false);\\n\\t\\tremove = applyToSingletonTag.bind(null, style, styleIndex, true);\\n\\n\\t} else if (\\n\\t\\tobj.sourceMap &&\\n\\t\\ttypeof URL === \\\"function\\\" &&\\n\\t\\ttypeof URL.createObjectURL === \\\"function\\\" &&\\n\\t\\ttypeof URL.revokeObjectURL === \\\"function\\\" &&\\n\\t\\ttypeof Blob === \\\"function\\\" &&\\n\\t\\ttypeof btoa === \\\"function\\\"\\n\\t) {\\n\\t\\tstyle = createLinkElement(options);\\n\\t\\tupdate = updateLink.bind(null, style, options);\\n\\t\\tremove = function () {\\n\\t\\t\\tremoveStyleElement(style);\\n\\n\\t\\t\\tif(style.href) URL.revokeObjectURL(style.href);\\n\\t\\t};\\n\\t} else {\\n\\t\\tstyle = createStyleElement(options);\\n\\t\\tupdate = applyToTag.bind(null, style);\\n\\t\\tremove = function () {\\n\\t\\t\\tremoveStyleElement(style);\\n\\t\\t};\\n\\t}\\n\\n\\tupdate(obj);\\n\\n\\treturn function updateStyle (newObj) {\\n\\t\\tif (newObj) {\\n\\t\\t\\tif (\\n\\t\\t\\t\\tnewObj.css === obj.css &&\\n\\t\\t\\t\\tnewObj.media === obj.media &&\\n\\t\\t\\t\\tnewObj.sourceMap === obj.sourceMap\\n\\t\\t\\t) {\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\n\\t\\t\\tupdate(obj = newObj);\\n\\t\\t} else {\\n\\t\\t\\tremove();\\n\\t\\t}\\n\\t};\\n}\\n\\nvar replaceText = (function () {\\n\\tvar textStore = [];\\n\\n\\treturn function (index, replacement) {\\n\\t\\ttextStore[index] = replacement;\\n\\n\\t\\treturn textStore.filter(Boolean).join('\\\\n');\\n\\t};\\n})();\\n\\nfunction applyToSingletonTag (style, index, remove, obj) {\\n\\tvar css = remove ? \\\"\\\" : obj.css;\\n\\n\\tif (style.styleSheet) {\\n\\t\\tstyle.styleSheet.cssText = replaceText(index, css);\\n\\t} else {\\n\\t\\tvar cssNode = document.createTextNode(css);\\n\\t\\tvar childNodes = style.childNodes;\\n\\n\\t\\tif (childNodes[index]) style.removeChild(childNodes[index]);\\n\\n\\t\\tif (childNodes.length) {\\n\\t\\t\\tstyle.insertBefore(cssNode, childNodes[index]);\\n\\t\\t} else {\\n\\t\\t\\tstyle.appendChild(cssNode);\\n\\t\\t}\\n\\t}\\n}\\n\\nfunction applyToTag (style, obj) {\\n\\tvar css = obj.css;\\n\\tvar media = obj.media;\\n\\n\\tif(media) {\\n\\t\\tstyle.setAttribute(\\\"media\\\", media)\\n\\t}\\n\\n\\tif(style.styleSheet) {\\n\\t\\tstyle.styleSheet.cssText = css;\\n\\t} else {\\n\\t\\twhile(style.firstChild) {\\n\\t\\t\\tstyle.removeChild(style.firstChild);\\n\\t\\t}\\n\\n\\t\\tstyle.appendChild(document.createTextNode(css));\\n\\t}\\n}\\n\\nfunction updateLink (link, options, obj) {\\n\\tvar css = obj.css;\\n\\tvar sourceMap = obj.sourceMap;\\n\\n\\t/*\\n\\t\\tIf convertToAbsoluteUrls isn't defined, but sourcemaps are enabled\\n\\t\\tand there is no publicPath defined then lets turn convertToAbsoluteUrls\\n\\t\\ton by default.  Otherwise default to the convertToAbsoluteUrls option\\n\\t\\tdirectly\\n\\t*/\\n\\tvar autoFixUrls = options.convertToAbsoluteUrls === undefined && sourceMap;\\n\\n\\tif (options.convertToAbsoluteUrls || autoFixUrls) {\\n\\t\\tcss = fixUrls(css);\\n\\t}\\n\\n\\tif (sourceMap) {\\n\\t\\t// http://stackoverflow.com/a/26603875\\n\\t\\tcss += \\\"\\\\n/*# sourceMappingURL=data:application/json;base64,\\\" + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + \\\" */\\\";\\n\\t}\\n\\n\\tvar blob = new Blob([css], { type: \\\"text/css\\\" });\\n\\n\\tvar oldSrc = link.href;\\n\\n\\tlink.href = URL.createObjectURL(blob);\\n\\n\\tif(oldSrc) URL.revokeObjectURL(oldSrc);\\n}\\n\",\"/*\\n\\tMIT License http://www.opensource.org/licenses/mit-license.php\\n\\tAuthor Tobias Koppers @sokra\\n*/\\n// css base code, injected by the css-loader\\nmodule.exports = function(useSourceMap) {\\n\\tvar list = [];\\n\\n\\t// return the list of modules as css string\\n\\tlist.toString = function toString() {\\n\\t\\treturn this.map(function (item) {\\n\\t\\t\\tvar content = cssWithMappingToString(item, useSourceMap);\\n\\t\\t\\tif(item[2]) {\\n\\t\\t\\t\\treturn \\\"@media \\\" + item[2] + \\\"{\\\" + content + \\\"}\\\";\\n\\t\\t\\t} else {\\n\\t\\t\\t\\treturn content;\\n\\t\\t\\t}\\n\\t\\t}).join(\\\"\\\");\\n\\t};\\n\\n\\t// import a list of modules into the list\\n\\tlist.i = function(modules, mediaQuery) {\\n\\t\\tif(typeof modules === \\\"string\\\")\\n\\t\\t\\tmodules = [[null, modules, \\\"\\\"]];\\n\\t\\tvar alreadyImportedModules = {};\\n\\t\\tfor(var i = 0; i < this.length; i++) {\\n\\t\\t\\tvar id = this[i][0];\\n\\t\\t\\tif(typeof id === \\\"number\\\")\\n\\t\\t\\t\\talreadyImportedModules[id] = true;\\n\\t\\t}\\n\\t\\tfor(i = 0; i < modules.length; i++) {\\n\\t\\t\\tvar item = modules[i];\\n\\t\\t\\t// skip already imported module\\n\\t\\t\\t// this implementation is not 100% perfect for weird media query combinations\\n\\t\\t\\t//  when a module is imported multiple times with different media queries.\\n\\t\\t\\t//  I hope this will never occur (Hey this way we have smaller bundles)\\n\\t\\t\\tif(typeof item[0] !== \\\"number\\\" || !alreadyImportedModules[item[0]]) {\\n\\t\\t\\t\\tif(mediaQuery && !item[2]) {\\n\\t\\t\\t\\t\\titem[2] = mediaQuery;\\n\\t\\t\\t\\t} else if(mediaQuery) {\\n\\t\\t\\t\\t\\titem[2] = \\\"(\\\" + item[2] + \\\") and (\\\" + mediaQuery + \\\")\\\";\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tlist.push(item);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t};\\n\\treturn list;\\n};\\n\\nfunction cssWithMappingToString(item, useSourceMap) {\\n\\tvar content = item[1] || '';\\n\\tvar cssMapping = item[3];\\n\\tif (!cssMapping) {\\n\\t\\treturn content;\\n\\t}\\n\\n\\tif (useSourceMap && typeof btoa === 'function') {\\n\\t\\tvar sourceMapping = toComment(cssMapping);\\n\\t\\tvar sourceURLs = cssMapping.sources.map(function (source) {\\n\\t\\t\\treturn '/*# sourceURL=' + cssMapping.sourceRoot + source + ' */'\\n\\t\\t});\\n\\n\\t\\treturn [content].concat(sourceURLs).concat([sourceMapping]).join('\\\\n');\\n\\t}\\n\\n\\treturn [content].join('\\\\n');\\n}\\n\\n// Adapted from convert-source-map (MIT)\\nfunction toComment(sourceMap) {\\n\\t// eslint-disable-next-line no-undef\\n\\tvar base64 = btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap))));\\n\\tvar data = 'sourceMappingURL=data:application/json;charset=utf-8;base64,' + base64;\\n\\n\\treturn '/*# ' + data + ' */';\\n}\\n\",\"exports = module.exports = require(\\\"../css-loader/lib/css-base.js\\\")(false);\\n// imports\\n\\n\\n// module\\nexports.push([module.id, \\\".ol-box {\\\\n  box-sizing: border-box;\\\\n  border-radius: 2px;\\\\n  border: 2px solid blue;\\\\n}\\\\n\\\\n.ol-mouse-position {\\\\n  top: 8px;\\\\n  right: 8px;\\\\n  position: absolute;\\\\n}\\\\n\\\\n.ol-scale-line {\\\\n  background: rgba(0,60,136,0.3);\\\\n  border-radius: 4px;\\\\n  bottom: 8px;\\\\n  left: 8px;\\\\n  padding: 2px;\\\\n  position: absolute;\\\\n}\\\\n.ol-scale-line-inner {\\\\n  border: 1px solid #eee;\\\\n  border-top: none;\\\\n  color: #eee;\\\\n  font-size: 10px;\\\\n  text-align: center;\\\\n  margin: 1px;\\\\n  will-change: contents, width;\\\\n}\\\\n.ol-overlay-container {\\\\n  will-change: left,right,top,bottom;\\\\n}\\\\n\\\\n.ol-unsupported {\\\\n  display: none;\\\\n}\\\\n.ol-viewport, .ol-unselectable {\\\\n  -webkit-touch-callout: none;\\\\n  -webkit-user-select: none;\\\\n  -moz-user-select: none;\\\\n  -ms-user-select: none;\\\\n  user-select: none;\\\\n  -webkit-tap-highlight-color: rgba(0,0,0,0);\\\\n}\\\\n.ol-selectable {\\\\n  -webkit-touch-callout: default;\\\\n  -webkit-user-select: text;\\\\n  -moz-user-select: text;\\\\n  -ms-user-select: text;\\\\n  user-select: text;\\\\n}\\\\n.ol-grabbing {\\\\n  cursor: -webkit-grabbing;\\\\n  cursor: -moz-grabbing;\\\\n  cursor: grabbing;\\\\n}\\\\n.ol-grab {\\\\n  cursor: move;\\\\n  cursor: -webkit-grab;\\\\n  cursor: -moz-grab;\\\\n  cursor: grab;\\\\n}\\\\n.ol-control {\\\\n  position: absolute;\\\\n  background-color: rgba(255,255,255,0.4);\\\\n  border-radius: 4px;\\\\n  padding: 2px;\\\\n}\\\\n.ol-control:hover {\\\\n  background-color: rgba(255,255,255,0.6);\\\\n}\\\\n.ol-zoom {\\\\n  top: .5em;\\\\n  left: .5em;\\\\n}\\\\n.ol-rotate {\\\\n  top: .5em;\\\\n  right: .5em;\\\\n  transition: opacity .25s linear, visibility 0s linear;\\\\n}\\\\n.ol-rotate.ol-hidden {\\\\n  opacity: 0;\\\\n  visibility: hidden;\\\\n  transition: opacity .25s linear, visibility 0s linear .25s;\\\\n}\\\\n.ol-zoom-extent {\\\\n  top: 4.643em;\\\\n  left: .5em;\\\\n}\\\\n.ol-full-screen {\\\\n  right: .5em;\\\\n  top: .5em;\\\\n}\\\\n@media print {\\\\n  .ol-control {\\\\n    display: none;\\\\n  }\\\\n}\\\\n\\\\n.ol-control button {\\\\n  display: block;\\\\n  margin: 1px;\\\\n  padding: 0;\\\\n  color: white;\\\\n  font-size: 1.14em;\\\\n  font-weight: bold;\\\\n  text-decoration: none;\\\\n  text-align: center;\\\\n  height: 1.375em;\\\\n  width: 1.375em;\\\\n  line-height: .4em;\\\\n  background-color: rgba(0,60,136,0.5);\\\\n  border: none;\\\\n  border-radius: 2px;\\\\n}\\\\n.ol-control button::-moz-focus-inner {\\\\n  border: none;\\\\n  padding: 0;\\\\n}\\\\n.ol-zoom-extent button {\\\\n  line-height: 1.4em;\\\\n}\\\\n.ol-compass {\\\\n  display: block;\\\\n  font-weight: normal;\\\\n  font-size: 1.2em;\\\\n  will-change: transform;\\\\n}\\\\n.ol-touch .ol-control button {\\\\n  font-size: 1.5em;\\\\n}\\\\n.ol-touch .ol-zoom-extent {\\\\n  top: 5.5em;\\\\n}\\\\n.ol-control button:hover,\\\\n.ol-control button:focus {\\\\n  text-decoration: none;\\\\n  background-color: rgba(0,60,136,0.7);\\\\n}\\\\n.ol-zoom .ol-zoom-in {\\\\n  border-radius: 2px 2px 0 0;\\\\n}\\\\n.ol-zoom .ol-zoom-out {\\\\n  border-radius: 0 0 2px 2px;\\\\n}\\\\n\\\\n\\\\n.ol-attribution {\\\\n  text-align: right;\\\\n  bottom: .5em;\\\\n  right: .5em;\\\\n  max-width: calc(100% - 1.3em);\\\\n}\\\\n\\\\n.ol-attribution ul {\\\\n  margin: 0;\\\\n  padding: 0 .5em;\\\\n  font-size: .7rem;\\\\n  line-height: 1.375em;\\\\n  color: #000;\\\\n  text-shadow: 0 0 2px #fff;\\\\n}\\\\n.ol-attribution li {\\\\n  display: inline;\\\\n  list-style: none;\\\\n  line-height: inherit;\\\\n}\\\\n.ol-attribution li:not(:last-child):after {\\\\n  content: \\\\\\\" \\\\\\\";\\\\n}\\\\n.ol-attribution img {\\\\n  max-height: 2em;\\\\n  max-width: inherit;\\\\n  vertical-align: middle;\\\\n}\\\\n.ol-attribution ul, .ol-attribution button {\\\\n  display: inline-block;\\\\n}\\\\n.ol-attribution.ol-collapsed ul {\\\\n  display: none;\\\\n}\\\\n.ol-attribution:not(.ol-collapsed) {\\\\n  background: rgba(255,255,255,0.8);\\\\n}\\\\n.ol-attribution.ol-uncollapsible {\\\\n  bottom: 0;\\\\n  right: 0;\\\\n  border-radius: 4px 0 0;\\\\n  height: 1.1em;\\\\n  line-height: 1em;\\\\n}\\\\n.ol-attribution.ol-uncollapsible img {\\\\n  margin-top: -.2em;\\\\n  max-height: 1.6em;\\\\n}\\\\n.ol-attribution.ol-uncollapsible button {\\\\n  display: none;\\\\n}\\\\n\\\\n.ol-zoomslider {\\\\n  top: 4.5em;\\\\n  left: .5em;\\\\n  height: 200px;\\\\n}\\\\n.ol-zoomslider button {\\\\n  position: relative;\\\\n  height: 10px;\\\\n}\\\\n\\\\n.ol-touch .ol-zoomslider {\\\\n  top: 5.5em;\\\\n}\\\\n\\\\n.ol-overviewmap {\\\\n  left: 0.5em;\\\\n  bottom: 0.5em;\\\\n}\\\\n.ol-overviewmap.ol-uncollapsible {\\\\n  bottom: 0;\\\\n  left: 0;\\\\n  border-radius: 0 4px 0 0;\\\\n}\\\\n.ol-overviewmap .ol-overviewmap-map,\\\\n.ol-overviewmap button {\\\\n  display: inline-block;\\\\n}\\\\n.ol-overviewmap .ol-overviewmap-map {\\\\n  border: 1px solid #7b98bc;\\\\n  height: 150px;\\\\n  margin: 2px;\\\\n  width: 150px;\\\\n}\\\\n.ol-overviewmap:not(.ol-collapsed) button{\\\\n  bottom: 1px;\\\\n  left: 2px;\\\\n  position: absolute;\\\\n}\\\\n.ol-overviewmap.ol-collapsed .ol-overviewmap-map,\\\\n.ol-overviewmap.ol-uncollapsible button {\\\\n  display: none;\\\\n}\\\\n.ol-overviewmap:not(.ol-collapsed) {\\\\n  background: rgba(255,255,255,0.8);\\\\n}\\\\n.ol-overviewmap-box {\\\\n  border: 2px dotted rgba(0,60,136,0.7);\\\\n}\\\\n\\\\n.ol-overviewmap .ol-overviewmap-box:hover {\\\\n  cursor: move;\\\\n}\\\\n\\\", \\\"\\\"]);\\n\\n// exports\\n\",\"\\nvar content = require(\\\"!!../css-loader/index.js!./ol.css\\\");\\n\\nif(typeof content === 'string') content = [[module.id, content, '']];\\n\\nvar transform;\\nvar insertInto;\\n\\n\\n\\nvar options = {\\\"hmr\\\":true}\\n\\noptions.transform = transform\\noptions.insertInto = undefined;\\n\\nvar update = require(\\\"!../style-loader/lib/addStyles.js\\\")(content, options);\\n\\nif(content.locals) module.exports = content.locals;\\n\\nif(module.hot) {\\n\\tmodule.hot.accept(\\\"!!../css-loader/index.js!./ol.css\\\", function() {\\n\\t\\tvar newContent = require(\\\"!!../css-loader/index.js!./ol.css\\\");\\n\\n\\t\\tif(typeof newContent === 'string') newContent = [[module.id, newContent, '']];\\n\\n\\t\\tvar locals = (function(a, b) {\\n\\t\\t\\tvar key, idx = 0;\\n\\n\\t\\t\\tfor(key in a) {\\n\\t\\t\\t\\tif(!b || a[key] !== b[key]) return false;\\n\\t\\t\\t\\tidx++;\\n\\t\\t\\t}\\n\\n\\t\\t\\tfor(key in b) idx--;\\n\\n\\t\\t\\treturn idx === 0;\\n\\t\\t}(content.locals, newContent.locals));\\n\\n\\t\\tif(!locals) throw new Error('Aborting CSS HMR due to changed css-modules locals.');\\n\\n\\t\\tupdate(newContent);\\n\\t});\\n\\n\\tmodule.hot.dispose(function() { update(); });\\n}\"]}","code":"!function(t){var e={};function i(n){if(e[n])return e[n].exports;var o=e[n]={i:n,l:!1,exports:{}};return t[n].call(o.exports,o,o.exports,i),o.l=!0,o.exports}i.m=t,i.c=e,i.d=function(t,e,n){i.o(t,e)||Object.defineProperty(t,e,{configurable:!1,enumerable:!0,get:n})},i.r=function(t){Object.defineProperty(t,\"__esModule\",{value:!0})},i.n=function(t){var e=t&&t.__esModule?function(){return t.default}:function(){return t};return i.d(e,\"a\",e),e},i.o=function(t,e){return Object.prototype.hasOwnProperty.call(t,e)},i.p=\"\",i(i.s=1)}([function(t,e,i){\"use strict\";t.exports=o,t.exports.default=o;var n=i(3);function o(t,e){if(!(this instanceof o))return new o(t,e);this._maxEntries=Math.max(4,t||9),this._minEntries=Math.max(2,Math.ceil(.4*this._maxEntries)),e&&this._initFormat(e),this.clear()}function s(t,e,i){if(!i)return e.indexOf(t);for(var n=0;n<e.length;n++)if(i(t,e[n]))return n;return-1}function r(t,e){a(t,0,t.children.length,e,t)}function a(t,e,i,n,o){o||(o=g(null)),o.minX=1/0,o.minY=1/0,o.maxX=-1/0,o.maxY=-1/0;for(var s,r=e;r<i;r++)s=t.children[r],h(o,t.leaf?n(s):s);return o}function h(t,e){return t.minX=Math.min(t.minX,e.minX),t.minY=Math.min(t.minY,e.minY),t.maxX=Math.max(t.maxX,e.maxX),t.maxY=Math.max(t.maxY,e.maxY),t}function l(t,e){return t.minX-e.minX}function c(t,e){return t.minY-e.minY}function u(t){return(t.maxX-t.minX)*(t.maxY-t.minY)}function p(t){return t.maxX-t.minX+(t.maxY-t.minY)}function d(t,e){return t.minX<=e.minX&&t.minY<=e.minY&&e.maxX<=t.maxX&&e.maxY<=t.maxY}function f(t,e){return e.minX<=t.maxX&&e.minY<=t.maxY&&e.maxX>=t.minX&&e.maxY>=t.minY}function g(t){return{children:t,height:1,leaf:!0,minX:1/0,minY:1/0,maxX:-1/0,maxY:-1/0}}function _(t,e,i,o,s){for(var r,a=[e,i];a.length;)(i=a.pop())-(e=a.pop())<=o||(r=e+Math.ceil((i-e)/o/2)*o,n(t,r,e,i,s),a.push(e,r,r,i))}o.prototype={all:function(){return this._all(this.data,[])},search:function(t){var e=this.data,i=[],n=this.toBBox;if(!f(t,e))return i;for(var o,s,r,a,h=[];e;){for(o=0,s=e.children.length;o<s;o++)r=e.children[o],f(t,a=e.leaf?n(r):r)&&(e.leaf?i.push(r):d(t,a)?this._all(r,i):h.push(r));e=h.pop()}return i},collides:function(t){var e=this.data,i=this.toBBox;if(!f(t,e))return!1;for(var n,o,s,r,a=[];e;){for(n=0,o=e.children.length;n<o;n++)if(s=e.children[n],f(t,r=e.leaf?i(s):s)){if(e.leaf||d(t,r))return!0;a.push(s)}e=a.pop()}return!1},load:function(t){if(!t||!t.length)return this;if(t.length<this._minEntries){for(var e=0,i=t.length;e<i;e++)this.insert(t[e]);return this}var n=this._build(t.slice(),0,t.length-1,0);if(this.data.children.length)if(this.data.height===n.height)this._splitRoot(this.data,n);else{if(this.data.height<n.height){var o=this.data;this.data=n,n=o}this._insert(n,this.data.height-n.height-1,!0)}else this.data=n;return this},insert:function(t){return t&&this._insert(t,this.data.height-1),this},clear:function(){return this.data=g([]),this},remove:function(t,e){if(!t)return this;for(var i,n,o,r,a=this.data,h=this.toBBox(t),l=[],c=[];a||l.length;){if(a||(a=l.pop(),n=l[l.length-1],i=c.pop(),r=!0),a.leaf&&-1!==(o=s(t,a.children,e)))return a.children.splice(o,1),l.push(a),this._condense(l),this;r||a.leaf||!d(a,h)?n?(i++,a=n.children[i],r=!1):a=null:(l.push(a),c.push(i),i=0,n=a,a=a.children[0])}return this},toBBox:function(t){return t},compareMinX:l,compareMinY:c,toJSON:function(){return this.data},fromJSON:function(t){return this.data=t,this},_all:function(t,e){for(var i=[];t;)t.leaf?e.push.apply(e,t.children):i.push.apply(i,t.children),t=i.pop();return e},_build:function(t,e,i,n){var o,s=i-e+1,a=this._maxEntries;if(s<=a)return r(o=g(t.slice(e,i+1)),this.toBBox),o;n||(n=Math.ceil(Math.log(s)/Math.log(a)),a=Math.ceil(s/Math.pow(a,n-1))),(o=g([])).leaf=!1,o.height=n;var h,l,c,u,p=Math.ceil(s/a),d=p*Math.ceil(Math.sqrt(a));for(_(t,e,i,d,this.compareMinX),h=e;h<=i;h+=d)for(_(t,h,c=Math.min(h+d-1,i),p,this.compareMinY),l=h;l<=c;l+=p)u=Math.min(l+p-1,c),o.children.push(this._build(t,l,u,n-1));return r(o,this.toBBox),o},_chooseSubtree:function(t,e,i,n){for(var o,s,r,a,h,l,c,p,d,f;n.push(e),!e.leaf&&n.length-1!==i;){for(c=p=1/0,o=0,s=e.children.length;o<s;o++)h=u(r=e.children[o]),d=t,f=r,(l=(Math.max(f.maxX,d.maxX)-Math.min(f.minX,d.minX))*(Math.max(f.maxY,d.maxY)-Math.min(f.minY,d.minY))-h)<p?(p=l,c=h<c?h:c,a=r):l===p&&h<c&&(c=h,a=r);e=a||e.children[0]}return e},_insert:function(t,e,i){var n=this.toBBox,o=i?t:n(t),s=[],r=this._chooseSubtree(o,this.data,e,s);for(r.children.push(t),h(r,o);e>=0&&s[e].children.length>this._maxEntries;)this._split(s,e),e--;this._adjustParentBBoxes(o,s,e)},_split:function(t,e){var i=t[e],n=i.children.length,o=this._minEntries;this._chooseSplitAxis(i,o,n);var s=this._chooseSplitIndex(i,o,n),a=g(i.children.splice(s,i.children.length-s));a.height=i.height,a.leaf=i.leaf,r(i,this.toBBox),r(a,this.toBBox),e?t[e-1].children.push(a):this._splitRoot(i,a)},_splitRoot:function(t,e){this.data=g([t,e]),this.data.height=t.height+1,this.data.leaf=!1,r(this.data,this.toBBox)},_chooseSplitIndex:function(t,e,i){var n,o,s,r,h,l,c,p,d,f,g,_,y,m;for(l=c=1/0,n=e;n<=i-e;n++)o=a(t,0,n,this.toBBox),s=a(t,n,i,this.toBBox),d=o,f=s,void 0,void 0,void 0,void 0,g=Math.max(d.minX,f.minX),_=Math.max(d.minY,f.minY),y=Math.min(d.maxX,f.maxX),m=Math.min(d.maxY,f.maxY),r=Math.max(0,y-g)*Math.max(0,m-_),h=u(o)+u(s),r<l?(l=r,p=n,c=h<c?h:c):r===l&&h<c&&(c=h,p=n);return p},_chooseSplitAxis:function(t,e,i){var n=t.leaf?this.compareMinX:l,o=t.leaf?this.compareMinY:c;this._allDistMargin(t,e,i,n)<this._allDistMargin(t,e,i,o)&&t.children.sort(n)},_allDistMargin:function(t,e,i,n){t.children.sort(n);var o,s,r=this.toBBox,l=a(t,0,e,r),c=a(t,i-e,i,r),u=p(l)+p(c);for(o=e;o<i-e;o++)s=t.children[o],h(l,t.leaf?r(s):s),u+=p(l);for(o=i-e-1;o>=e;o--)s=t.children[o],h(c,t.leaf?r(s):s),u+=p(c);return u},_adjustParentBBoxes:function(t,e,i){for(var n=i;n>=0;n--)h(e[n],t)},_condense:function(t){for(var e,i=t.length-1;i>=0;i--)0===t[i].children.length?i>0?(e=t[i-1].children).splice(e.indexOf(t[i]),1):this.clear():r(t[i],this.toBBox)},_initFormat:function(t){var e=[\"return a\",\" - b\",\";\"];this.compareMinX=new Function(\"a\",\"b\",e.join(t[0])),this.compareMinY=new Function(\"a\",\"b\",e.join(t[1])),this.toBBox=new Function(\"a\",\"return {minX: a\"+t[0]+\", minY: a\"+t[1]+\", maxX: a\"+t[2]+\", maxY: a\"+t[3]+\"};\")}}},function(t,e,i){\"use strict\";i.r(e);i(8);const n=[\"experimental-webgl\",\"webgl\",\"webkit-3d\",\"moz-webgl\"];let o,s,r=!1;if(\"undefined\"!=typeof window&&\"WebGLRenderingContext\"in window)try{const t=function(t,e){const i=n.length;for(let o=0;o<i;++o)try{const i=t.getContext(n[o],e);if(i)return i}catch(t){}return null}(document.createElement(\"CANVAS\"),{failIfMajorPerformanceCaveat:!0});t&&(r=!0,o=t.getParameter(t.MAX_TEXTURE_SIZE),s=t.getSupportedExtensions())}catch(t){}function a(t,e){t.prototype=Object.create(e.prototype),t.prototype.constructor=t}let h=0;function l(t){return t.ol_uid||(t.ol_uid=++h)}const c=function(t){const e=\"v4.6.4\".split(\"-\")[0];this.message=\"Assertion failed. See https://openlayers.org/en/\"+e+\"/doc/errors/#\"+t+\" for details.\",this.code=t,this.name=\"AssertionError\"};a(c,Error);var u=c;function p(t,e){if(!t)throw new u(e)}const d=\"function\"==typeof Object.assign?Object.assign:function(t,e){if(void 0===t||null===t)throw new TypeError(\"Cannot convert undefined or null to object\");const i=Object(t);for(let t=1,e=arguments.length;t<e;++t){const e=arguments[t];if(void 0!==e&&null!==e)for(const t in e)e.hasOwnProperty(t)&&(i[t]=e[t])}return i};function f(t){for(const e in t)delete t[e]}function g(t){const e=[];for(const i in t)e.push(t[i]);return e}function _(t){let e;for(e in t)return!1;return!e}function y(t,e,i,n){let o;for(let s=0,r=t.length;s<r;++s)if((o=t[s]).listener===e&&o.bindTo===i)return n&&(o.deleteIndex=s),o}function m(t,e){const i=t.ol_lm;return i?i[e]:void 0}function v(t){let e=t.ol_lm;return e||(e=t.ol_lm={}),e}function x(t,e){const i=m(t,e);if(i){for(let n=0,o=i.length;n<o;++n)t.removeEventListener(e,i[n].boundListener),f(i[n]);i.length=0;const n=t.ol_lm;n&&(delete n[e],0===Object.keys(n).length&&delete t.ol_lm)}}function C(t,e,i,n,o){const s=v(t);let r=s[e];r||(r=s[e]=[]);let a=y(r,i,n,!1);return a?o||(a.callOnce=!1):(a={bindTo:n,callOnce:!!o,listener:i,target:t,type:e},t.addEventListener(e,function(t){const e=function(e){const i=t.listener,n=t.bindTo||t.target;return t.callOnce&&S(t),i.call(n,e)};return t.boundListener=e,e}(a)),r.push(a)),a}function E(t,e,i,n){return C(t,e,i,n,!0)}function T(t,e,i,n){const o=m(t,e);if(o){const t=y(o,i,n,!0);t&&S(t)}}function S(t){if(t&&t.target){t.target.removeEventListener(t.type,t.boundListener);const e=m(t.target,t.type);if(e){const i=\"deleteIndex\"in t?t.deleteIndex:e.indexOf(t);-1!==i&&e.splice(i,1),0===e.length&&x(t.target,t.type)}f(t)}}var w={CHANGE:\"change\",CLEAR:\"clear\",CONTEXTMENU:\"contextmenu\",CLICK:\"click\",DBLCLICK:\"dblclick\",DRAGENTER:\"dragenter\",DRAGOVER:\"dragover\",DROP:\"drop\",ERROR:\"error\",KEYDOWN:\"keydown\",KEYPRESS:\"keypress\",LOAD:\"load\",MOUSEDOWN:\"mousedown\",MOUSEMOVE:\"mousemove\",MOUSEOUT:\"mouseout\",MOUSEUP:\"mouseup\",MOUSEWHEEL:\"mousewheel\",MSPOINTERDOWN:\"MSPointerDown\",RESIZE:\"resize\",TOUCHSTART:\"touchstart\",TOUCHMOVE:\"touchmove\",TOUCHEND:\"touchend\",WHEEL:\"wheel\"},R=\"propertychange\";function I(){return!0}function F(){return!1}function P(){}const L=function(){};L.prototype.disposed_=!1,L.prototype.dispose=function(){this.disposed_||(this.disposed_=!0,this.disposeInternal())},L.prototype.disposeInternal=P;var M=L;const b=function(t){this.propagationStopped,this.type=t,this.target=null};function O(t){t.stopPropagation()}b.prototype.preventDefault=b.prototype.stopPropagation=function(){this.propagationStopped=!0};var k=b;const A=function(){M.call(this),this.pendingRemovals_={},this.dispatching_={},this.listeners_={}};a(A,M),A.prototype.addEventListener=function(t,e){let i=this.listeners_[t];i||(i=this.listeners_[t]=[]),-1===i.indexOf(e)&&i.push(e)},A.prototype.dispatchEvent=function(t){const e=\"string\"==typeof t?new k(t):t,i=e.type;e.target=this;const n=this.listeners_[i];let o;if(n){i in this.dispatching_||(this.dispatching_[i]=0,this.pendingRemovals_[i]=0),++this.dispatching_[i];for(let t=0,i=n.length;t<i;++t)if(!1===n[t].call(this,e)||e.propagationStopped){o=!1;break}if(--this.dispatching_[i],0===this.dispatching_[i]){let t=this.pendingRemovals_[i];for(delete this.pendingRemovals_[i];t--;)this.removeEventListener(i,P);delete this.dispatching_[i]}return o}},A.prototype.disposeInternal=function(){!function(t){const e=v(t);for(const i in e)x(t,i)}(this)},A.prototype.getListeners=function(t){return this.listeners_[t]},A.prototype.hasListener=function(t){return t?t in this.listeners_:Object.keys(this.listeners_).length>0},A.prototype.removeEventListener=function(t,e){const i=this.listeners_[t];if(i){const n=i.indexOf(e);t in this.pendingRemovals_?(i[n]=P,++this.pendingRemovals_[t]):(i.splice(n,1),0===i.length&&delete this.listeners_[t])}};var G=A;const D=function(){G.call(this),this.revision_=0};a(D,G),D.prototype.changed=function(){++this.revision_,this.dispatchEvent(w.CHANGE)},D.prototype.dispatchEvent,D.prototype.getRevision=function(){return this.revision_},D.prototype.on=function(t,e){if(Array.isArray(t)){const i=t.length,n=new Array(i);for(let o=0;o<i;++o)n[o]=C(this,t[o],e);return n}return C(this,t,e)},D.prototype.once=function(t,e){if(Array.isArray(t)){const i=t.length,n=new Array(i);for(let o=0;o<i;++o)n[o]=E(this,t[o],e);return n}return E(this,t,e)},D.prototype.un=function(t,e){if(Array.isArray(t))for(let i=0,n=t.length;i<n;++i)T(this,t[i],e);else T(this,t,e)};var N=D;const Y=function(t,e,i){k.call(this,t),this.key=e,this.oldValue=i};a(Y,k);const X=function(t){N.call(this),l(this),this.values_={},void 0!==t&&this.setProperties(t)};a(X,N);const z={};function W(t){return z.hasOwnProperty(t)?z[t]:z[t]=\"change:\"+t}X.prototype.get=function(t){let e;return this.values_.hasOwnProperty(t)&&(e=this.values_[t]),e},X.prototype.getKeys=function(){return Object.keys(this.values_)},X.prototype.getProperties=function(){return d({},this.values_)},X.prototype.notify=function(t,e){let i;i=W(t),this.dispatchEvent(new Y(i,t,e)),i=R,this.dispatchEvent(new Y(i,t,e))},X.prototype.set=function(t,e,i){if(i)this.values_[t]=e;else{const i=this.values_[t];this.values_[t]=e,i!==e&&this.notify(t,i)}},X.prototype.setProperties=function(t,e){for(const i in t)this.set(i,t[i],e)},X.prototype.unset=function(t,e){if(t in this.values_){const i=this.values_[t];delete this.values_[t],e||this.notify(t,i)}};var K=X,U={BOTTOM_LEFT:\"bottom-left\",BOTTOM_RIGHT:\"bottom-right\",TOP_LEFT:\"top-left\",TOP_RIGHT:\"top-right\"},B={UNKNOWN:0,INTERSECTING:1,ABOVE:2,RIGHT:4,BELOW:8,LEFT:16};function j(t){const e=tt();for(let i=0,n=t.length;i<n;++i)at(e,t[i]);return e}function H(t,e,i){return i?(i[0]=t[0]-e,i[1]=t[1]-e,i[2]=t[2]+e,i[3]=t[3]+e,i):[t[0]-e,t[1]-e,t[2]+e,t[3]+e]}function V(t,e){return e?(e[0]=t[0],e[1]=t[1],e[2]=t[2],e[3]=t[3],e):t.slice()}function Z(t,e,i){let n,o;return(n=e<t[0]?t[0]-e:t[2]<e?e-t[2]:0)*n+(o=i<t[1]?t[1]-i:t[3]<i?i-t[3]:0)*o}function q(t,e){return Q(t,e[0],e[1])}function J(t,e){return t[0]<=e[0]&&e[2]<=t[2]&&t[1]<=e[1]&&e[3]<=t[3]}function Q(t,e,i){return t[0]<=e&&e<=t[2]&&t[1]<=i&&i<=t[3]}function $(t,e){const i=t[0],n=t[1],o=t[2],s=t[3],r=e[0],a=e[1];let h=B.UNKNOWN;return r<i?h|=B.LEFT:r>o&&(h|=B.RIGHT),a<n?h|=B.BELOW:a>s&&(h|=B.ABOVE),h===B.UNKNOWN&&(h=B.INTERSECTING),h}function tt(){return[1/0,1/0,-1/0,-1/0]}function et(t,e,i,n,o){return o?(o[0]=t,o[1]=e,o[2]=i,o[3]=n,o):[t,e,i,n]}function it(t){return et(1/0,1/0,-1/0,-1/0,t)}function nt(t,e){const i=t[0],n=t[1];return et(i,n,i,n,e)}function ot(t,e,i,n,o){return lt(it(o),t,e,i,n)}function st(t,e){return t[0]==e[0]&&t[2]==e[2]&&t[1]==e[1]&&t[3]==e[3]}function rt(t,e){return e[0]<t[0]&&(t[0]=e[0]),e[2]>t[2]&&(t[2]=e[2]),e[1]<t[1]&&(t[1]=e[1]),e[3]>t[3]&&(t[3]=e[3]),t}function at(t,e){e[0]<t[0]&&(t[0]=e[0]),e[0]>t[2]&&(t[2]=e[0]),e[1]<t[1]&&(t[1]=e[1]),e[1]>t[3]&&(t[3]=e[1])}function ht(t,e){for(let i=0,n=e.length;i<n;++i)at(t,e[i]);return t}function lt(t,e,i,n,o){for(;i<n;i+=o)ct(t,e[i],e[i+1]);return t}function ct(t,e,i){t[0]=Math.min(t[0],e),t[1]=Math.min(t[1],i),t[2]=Math.max(t[2],e),t[3]=Math.max(t[3],i)}function ut(t,e,i){let n;return(n=e.call(i,dt(t)))?n:(n=e.call(i,ft(t)))?n:(n=e.call(i,xt(t)))?n:(n=e.call(i,vt(t)))||!1}function pt(t){let e=0;return Tt(t)||(e=Ct(t)*yt(t)),e}function dt(t){return[t[0],t[1]]}function ft(t){return[t[2],t[1]]}function gt(t){return[(t[0]+t[2])/2,(t[1]+t[3])/2]}function _t(t,e,i,n,o){const s=e*n[0]/2,r=e*n[1]/2,a=Math.cos(i),h=Math.sin(i),l=s*a,c=s*h,u=r*a,p=r*h,d=t[0],f=t[1],g=d-l+p,_=d-l-p,y=d+l-p,m=d+l+p,v=f-c-u,x=f-c+u,C=f+c+u,E=f+c-u;return et(Math.min(g,_,y,m),Math.min(v,x,C,E),Math.max(g,_,y,m),Math.max(v,x,C,E),o)}function yt(t){return t[3]-t[1]}function mt(t,e,i){const n=i||[1/0,1/0,-1/0,-1/0];return Et(t,e)?(t[0]>e[0]?n[0]=t[0]:n[0]=e[0],t[1]>e[1]?n[1]=t[1]:n[1]=e[1],t[2]<e[2]?n[2]=t[2]:n[2]=e[2],t[3]<e[3]?n[3]=t[3]:n[3]=e[3]):it(n),n}function vt(t){return[t[0],t[3]]}function xt(t){return[t[2],t[3]]}function Ct(t){return t[2]-t[0]}function Et(t,e){return t[0]<=e[2]&&t[2]>=e[0]&&t[1]<=e[3]&&t[3]>=e[1]}function Tt(t){return t[2]<t[0]||t[3]<t[1]}function St(t,e,i){const n=[t[0],t[1],t[0],t[3],t[2],t[1],t[2],t[3]];return e(n,n,2),function(t,e,i){return et(Math.min.apply(null,t),Math.min.apply(null,e),Math.max.apply(null,t),Math.max.apply(null,e),i)}([n[0],n[2],n[4],n[6]],[n[1],n[3],n[5],n[7]],i)}function wt(t,e,i,n,o,s){const r=s||[];let a=0;for(let s=e;s<i;s+=n){const e=t[s],i=t[s+1];r[a++]=o[0]*e+o[2]*i+o[4],r[a++]=o[1]*e+o[3]*i+o[5]}return s&&r.length!=a&&(r.length=a),r}function Rt(t,e,i){return Math.min(Math.max(t,e),i)}const It=function(){let t;return t=\"cosh\"in Math?Math.cosh:function(t){const e=Math.exp(t);return(e+1/e)/2}}();function Ft(t,e,i,n,o,s){const r=o-i,a=s-n;if(0!==r||0!==a){const h=((t-i)*r+(e-n)*a)/(r*r+a*a);h>1?(i=o,n=s):h>0&&(i+=r*h,n+=a*h)}return Pt(t,e,i,n)}function Pt(t,e,i,n){const o=i-t,s=n-e;return o*o+s*s}function Lt(t){return t*Math.PI/180}function Mt(t,e){const i=t%e;return i*e<0?i+e:i}function bt(t,e,i){return t+i*(e-t)}var Ot={POINT:\"Point\",LINE_STRING:\"LineString\",LINEAR_RING:\"LinearRing\",POLYGON:\"Polygon\",MULTI_POINT:\"MultiPoint\",MULTI_LINE_STRING:\"MultiLineString\",MULTI_POLYGON:\"MultiPolygon\",GEOMETRY_COLLECTION:\"GeometryCollection\",CIRCLE:\"Circle\"};\n/**\n * @license\n * Latitude/longitude spherical geodesy formulae taken from\n * http://www.movable-type.co.uk/scripts/latlong.html\n * Licensed under CC-BY-3.0.\n */const kt=6371008.8;function At(t,e,i){const n=i||kt,o=Lt(t[1]),s=Lt(e[1]),r=(s-o)/2,a=Lt(e[0]-t[0])/2,h=Math.sin(r)*Math.sin(r)+Math.sin(a)*Math.sin(a)*Math.cos(o)*Math.cos(s);return 2*n*Math.atan2(Math.sqrt(h),Math.sqrt(1-h))}const Gt={DEGREES:\"degrees\",FEET:\"ft\",METERS:\"m\",PIXELS:\"pixels\",TILE_PIXELS:\"tile-pixels\",USFEET:\"us-ft\"},Dt={};Dt[Gt.DEGREES]=2*Math.PI*6370997/360,Dt[Gt.FEET]=.3048,Dt[Gt.METERS]=1,Dt[Gt.USFEET]=1200/3937;var Nt=Gt;const Yt=function(t){this.code_=t.code,this.units_=t.units,this.extent_=void 0!==t.extent?t.extent:null,this.worldExtent_=void 0!==t.worldExtent?t.worldExtent:null,this.axisOrientation_=void 0!==t.axisOrientation?t.axisOrientation:\"enu\",this.global_=void 0!==t.global&&t.global,this.canWrapX_=!(!this.global_||!this.extent_),this.getPointResolutionFunc_=t.getPointResolution,this.defaultTileGrid_=null,this.metersPerUnit_=t.metersPerUnit};Yt.prototype.canWrapX=function(){return this.canWrapX_},Yt.prototype.getCode=function(){return this.code_},Yt.prototype.getExtent=function(){return this.extent_},Yt.prototype.getUnits=function(){return this.units_},Yt.prototype.getMetersPerUnit=function(){return this.metersPerUnit_||Dt[this.units_]},Yt.prototype.getWorldExtent=function(){return this.worldExtent_},Yt.prototype.getAxisOrientation=function(){return this.axisOrientation_},Yt.prototype.isGlobal=function(){return this.global_},Yt.prototype.setGlobal=function(t){this.global_=t,this.canWrapX_=!(!t||!this.extent_)},Yt.prototype.getDefaultTileGrid=function(){return this.defaultTileGrid_},Yt.prototype.setDefaultTileGrid=function(t){this.defaultTileGrid_=t},Yt.prototype.setExtent=function(t){this.extent_=t,this.canWrapX_=!(!this.global_||!t)},Yt.prototype.setWorldExtent=function(t){this.worldExtent_=t},Yt.prototype.setGetPointResolution=function(t){this.getPointResolutionFunc_=t},Yt.prototype.getPointResolutionFunc=function(){return this.getPointResolutionFunc_};var Xt=Yt;const zt=6378137,Wt=Math.PI*zt,Kt=[-Wt,-Wt,Wt,Wt],Ut=[-180,-85,180,85];function Bt(t){Xt.call(this,{code:t,units:Nt.METERS,extent:Kt,global:!0,worldExtent:Ut,getPointResolution:function(t,e){return t/It(e[1]/zt)}})}a(Bt,Xt);const jt=[new Bt(\"EPSG:3857\"),new Bt(\"EPSG:102100\"),new Bt(\"EPSG:102113\"),new Bt(\"EPSG:900913\"),new Bt(\"urn:ogc:def:crs:EPSG:6.18:3:3857\"),new Bt(\"urn:ogc:def:crs:EPSG::3857\"),new Bt(\"http://www.opengis.net/gml/srs/epsg.xml#3857\")];function Ht(t,e,i){const n=t.length,o=i>1?i:2;let s=e;void 0===s&&(s=o>2?t.slice():new Array(n));const r=Wt;for(let e=0;e<n;e+=o){s[e]=r*t[e]/180;let i=zt*Math.log(Math.tan(Math.PI*(t[e+1]+90)/360));i>r?i=r:i<-r&&(i=-r),s[e+1]=i}return s}function Vt(t,e,i){const n=t.length,o=i>1?i:2;let s=e;void 0===s&&(s=o>2?t.slice():new Array(n));for(let e=0;e<n;e+=o)s[e]=180*t[e]/Wt,s[e+1]=360*Math.atan(Math.exp(t[e+1]/zt))/Math.PI-90;return s}const Zt=[-180,-90,180,90],qt=6378137*Math.PI/180;function Jt(t,e){Xt.call(this,{code:t,units:Nt.DEGREES,extent:Zt,axisOrientation:e,global:!0,metersPerUnit:qt,worldExtent:Zt})}a(Jt,Xt);const Qt=[new Jt(\"CRS:84\"),new Jt(\"EPSG:4326\",\"neu\"),new Jt(\"urn:ogc:def:crs:EPSG::4326\",\"neu\"),new Jt(\"urn:ogc:def:crs:EPSG:6.6:4326\",\"neu\"),new Jt(\"urn:ogc:def:crs:OGC:1.3:CRS84\"),new Jt(\"urn:ogc:def:crs:OGC:2:84\"),new Jt(\"http://www.opengis.net/gml/srs/epsg.xml#4326\",\"neu\"),new Jt(\"urn:x-ogc:def:crs:EPSG:4326\",\"neu\")];let $t={};let te={};function ee(t,e,i){const n=t.getCode(),o=e.getCode();n in te||(te[n]={}),te[n][o]=i}function ie(t,e,i){let n;if(void 0!==e){for(let i=0,n=t.length;i<n;++i)e[i]=t[i];n=e}else n=t.slice();return n}function ne(t,e,i){if(void 0!==e&&t!==e){for(let i=0,n=t.length;i<n;++i)e[i]=t[i];t=e}return t}function oe(t){!function(t,e){$t[t]=e}(t.getCode(),t),ee(t,t,ie)}function se(t){let e=null;if(t instanceof Xt)e=t;else if(\"string\"==typeof t){e=$t[t]||null}return e}function re(t,e,i,n){let o;const s=(t=se(t)).getPointResolutionFunc();if(s)o=s(e,i);else{if(t.getUnits()==Nt.DEGREES&&!n||n==Nt.DEGREES)o=e;else{const s=ce(t,se(\"EPSG:4326\"));let r=[i[0]-e/2,i[1],i[0]+e/2,i[1],i[0],i[1]-e/2,i[0],i[1]+e/2];o=(At((r=s(r,r,2)).slice(0,2),r.slice(2,4))+At(r.slice(4,6),r.slice(6,8)))/2;const a=n?Dt[n]:t.getMetersPerUnit();void 0!==a&&(o/=a)}}return o}function ae(t){!function(t){t.forEach(oe)}(t),t.forEach(function(e){t.forEach(function(t){e!==t&&ee(e,t,ie)})})}function he(t,e){return t?\"string\"==typeof t?se(t):t:se(e)}function le(t,e){if(t===e)return!0;const i=t.getUnits()===e.getUnits();if(t.getCode()===e.getCode())return i;return ce(t,e)===ie&&i}function ce(t,e){let i=function(t,e){let i;return t in te&&e in te[t]&&(i=te[t][e]),i}(t.getCode(),e.getCode());return i||(i=ne),i}function ue(t,e){return ce(se(t),se(e))}function pe(t,e,i){return ue(e,i)(t,void 0,t.length)}var de,fe,ge;ae(jt),ae(Qt),de=jt,fe=Ht,ge=Vt,Qt.forEach(function(t){de.forEach(function(e){ee(t,e,fe),ee(e,t,ge)})});const _e=new Array(6);function ye(t,e){const i=t[0],n=t[1],o=t[2],s=t[3],r=t[4],a=t[5],h=e[0],l=e[1],c=e[2],u=e[3],p=e[4],d=e[5];return t[0]=i*h+o*l,t[1]=n*h+s*l,t[2]=i*c+o*u,t[3]=n*c+s*u,t[4]=i*p+o*d+r,t[5]=n*p+s*d+a,t}function me(t,e,i,n,o,s,r){return t[0]=e,t[1]=i,t[2]=n,t[3]=o,t[4]=s,t[5]=r,t}function ve(t,e){return t[0]=e[0],t[1]=e[1],t[2]=e[2],t[3]=e[3],t[4]=e[4],t[5]=e[5],t}function xe(t,e){const i=e[0],n=e[1];return e[0]=t[0]*i+t[2]*n+t[4],e[1]=t[1]*i+t[3]*n+t[5],e}function Ce(t,e,i){return ye(t,me(_e,e,0,0,i,0,0))}function Ee(t,e,i){return ye(t,me(_e,1,0,0,1,e,i))}function Te(t,e,i,n,o,s,r,a){const h=Math.sin(s),l=Math.cos(s);return t[0]=n*l,t[1]=o*h,t[2]=-n*h,t[3]=o*l,t[4]=r*n*l-a*n*h+e,t[5]=r*o*h+a*o*l+i,t}const Se=function(){K.call(this),this.extent_=[1/0,1/0,-1/0,-1/0],this.extentRevision_=-1,this.simplifiedGeometryCache={},this.simplifiedGeometryMaxMinSquaredTolerance=0,this.simplifiedGeometryRevision=0};a(Se,K);const we=[1,0,0,1,0,0];Se.prototype.clone=function(){},Se.prototype.closestPointXY=function(t,e,i,n){},Se.prototype.getClosestPoint=function(t,e){const i=e||[NaN,NaN];return this.closestPointXY(t[0],t[1],i,1/0),i},Se.prototype.intersectsCoordinate=function(t){return this.containsXY(t[0],t[1])},Se.prototype.computeExtent=function(t){},Se.prototype.containsXY=F,Se.prototype.getExtent=function(t){return this.extentRevision_!=this.getRevision()&&(this.extent_=this.computeExtent(this.extent_),this.extentRevision_=this.getRevision()),function(t,e){return e?(e[0]=t[0],e[1]=t[1],e[2]=t[2],e[3]=t[3],e):t}(this.extent_,t)},Se.prototype.rotate=function(t,e){},Se.prototype.scale=function(t,e,i){},Se.prototype.simplify=function(t){return this.getSimplifiedGeometry(t*t)},Se.prototype.getSimplifiedGeometry=function(t){},Se.prototype.getType=function(){},Se.prototype.applyTransform=function(t){},Se.prototype.intersectsExtent=function(t){},Se.prototype.translate=function(t,e){},Se.prototype.transform=function(t,e){const i=(t=se(t)).getUnits()==Nt.TILE_PIXELS?function(i,n,o){const s=t.getExtent(),r=t.getWorldExtent(),a=yt(r)/yt(s);return Te(we,r[0],r[3],a,-a,0,0,0),wt(i,0,i.length,o,we,n),ue(t,e)(i,n,o)}:ue(t,e);return this.applyTransform(i),this};var Re=Se;const Ie=/^#([a-f0-9]{3}|[a-f0-9]{4}(?:[a-f0-9]{2}){0,2})$/i,Fe=/^([a-z]*)$/i;function Pe(t){return\"string\"==typeof t?t:be(t)}const Le=function(){const t={};let e=0;return function(i){let n;if(t.hasOwnProperty(i))n=t[i];else{if(e>=1024){let i=0;for(const n in t)0==(3&i++)&&(delete t[n],--e)}n=function(t){let e,i,n,o,s;Fe.exec(t)&&(t=function(t){const e=document.createElement(\"div\");if(e.style.color=t,\"\"!==e.style.color){document.body.appendChild(e);const t=getComputedStyle(e).color;return document.body.removeChild(e),t}return\"\"}(t));if(Ie.exec(t)){const r=t.length-1;let a;a=r<=4?1:2;const h=4===r||8===r;e=parseInt(t.substr(1+0*a,a),16),i=parseInt(t.substr(1+1*a,a),16),n=parseInt(t.substr(1+2*a,a),16),o=h?parseInt(t.substr(1+3*a,a),16):255,1==a&&(e=(e<<4)+e,i=(i<<4)+i,n=(n<<4)+n,h&&(o=(o<<4)+o)),s=[e,i,n,o/255]}else 0==t.indexOf(\"rgba(\")?Me(s=t.slice(5,-1).split(\",\").map(Number)):0==t.indexOf(\"rgb(\")?((s=t.slice(4,-1).split(\",\").map(Number)).push(1),Me(s)):p(!1,14);return s}(i),t[i]=n,++e}return n}}();function Me(t){return t[0]=Rt(t[0]+.5|0,0,255),t[1]=Rt(t[1]+.5|0,0,255),t[2]=Rt(t[2]+.5|0,0,255),t[3]=Rt(t[3],0,1),t}function be(t){let e=t[0];e!=(0|e)&&(e=e+.5|0);let i=t[1];i!=(0|i)&&(i=i+.5|0);let n=t[2];return n!=(0|n)&&(n=n+.5|0),\"rgba(\"+e+\",\"+i+\",\"+n+\",\"+(void 0===t[3]?1:t[3])+\")\"}function Oe(t){return function(t){return\"string\"==typeof t||t instanceof CanvasPattern||t instanceof CanvasGradient}(t)?t:be(t)}function ke(t,e){const i=document.createElement(\"CANVAS\");return t&&(i.width=t),e&&(i.height=e),i.getContext(\"2d\")}function Ae(t,e){const i=e.parentNode;i&&i.replaceChild(t,e)}function Ge(t){return t&&t.parentNode?t.parentNode.removeChild(t):null}function De(t){for(;t.lastChild;)t.removeChild(t.lastChild)}const Ne=\"undefined\"!=typeof navigator?navigator.userAgent.toLowerCase():\"\",Ye=-1!==Ne.indexOf(\"firefox\"),Xe=-1!==Ne.indexOf(\"safari\")&&-1==Ne.indexOf(\"chrom\"),ze=-1!==Ne.indexOf(\"webkit\")&&-1==Ne.indexOf(\"edge\"),We=-1!==Ne.indexOf(\"macintosh\"),Ke=window.devicePixelRatio||1,Ue=function(){let t=!1;try{t=!!document.createElement(\"CANVAS\").getContext(\"2d\").setLineDash}catch(t){}return t}(),Be=(navigator,\"ontouchstart\"in window),je=\"PointerEvent\"in window,He=!!navigator.msPointerEnabled;var Ve={IDLE:0,LOADING:1,LOADED:2,ERROR:3};const Ze=\"ol-hidden\",qe=function(){let t;const e={};return function(i){if(t||(t=document.createElement(\"div\").style),!(i in e)){t.font=i;const n=t.fontFamily;if(t.font=\"\",!n)return null;e[i]=n.split(/,\\s?/)}return e[i]}}(),Je=function(t){G.call(this),this.highWaterMark=void 0!==t?t:2048,this.count_=0,this.entries_={},this.oldest_=null,this.newest_=null};a(Je,G),Je.prototype.canExpireCache=function(){return this.getCount()>this.highWaterMark},Je.prototype.clear=function(){this.count_=0,this.entries_={},this.oldest_=null,this.newest_=null,this.dispatchEvent(w.CLEAR)},Je.prototype.containsKey=function(t){return this.entries_.hasOwnProperty(t)},Je.prototype.forEach=function(t,e){let i=this.oldest_;for(;i;)t.call(e,i.value_,i.key_,this),i=i.newer},Je.prototype.get=function(t){const e=this.entries_[t];return p(void 0!==e,15),e===this.newest_?e.value_:(e===this.oldest_?(this.oldest_=this.oldest_.newer,this.oldest_.older=null):(e.newer.older=e.older,e.older.newer=e.newer),e.newer=null,e.older=this.newest_,this.newest_.newer=e,this.newest_=e,e.value_)},Je.prototype.remove=function(t){const e=this.entries_[t];return p(void 0!==e,15),e===this.newest_?(this.newest_=e.older,this.newest_&&(this.newest_.newer=null)):e===this.oldest_?(this.oldest_=e.newer,this.oldest_&&(this.oldest_.older=null)):(e.newer.older=e.older,e.older.newer=e.newer),delete this.entries_[t],--this.count_,e.value_},Je.prototype.getCount=function(){return this.count_},Je.prototype.getKeys=function(){const t=new Array(this.count_);let e,i=0;for(e=this.newest_;e;e=e.older)t[i++]=e.key_;return t},Je.prototype.getValues=function(){const t=new Array(this.count_);let e,i=0;for(e=this.newest_;e;e=e.older)t[i++]=e.value_;return t},Je.prototype.peekLast=function(){return this.oldest_.value_},Je.prototype.peekLastKey=function(){return this.oldest_.key_},Je.prototype.peekFirstKey=function(){return this.newest_.key_},Je.prototype.pop=function(){const t=this.oldest_;return delete this.entries_[t.key_],t.newer&&(t.newer.older=null),this.oldest_=t.newer,this.oldest_||(this.newest_=null),--this.count_,t.value_},Je.prototype.replace=function(t,e){this.get(t),this.entries_[t].value_=e},Je.prototype.set=function(t,e){p(!(t in this.entries_),16);const i={key_:t,newer:null,older:this.newest_,value_:e};this.newest_?this.newest_.newer=i:this.oldest_=i,this.newest_=i,this.entries_[t]=i,++this.count_},Je.prototype.setSize=function(t){this.highWaterMark=t},Je.prototype.prune=function(){for(;this.canExpireCache();)this.pop()};var Qe=Je;const $e=[0,0,0,1],ti=[],ei=[0,0,0,1],ii=[0,0,0,0],ni=new Qe,oi={};let si=null;const ri={},ai=function(){const t=60,e=oi,i=\"32px \",n=[\"monospace\",\"serif\"],o=n.length,s=\"wmytzilWMYTZIL@#/&?$%10\";let r,a;function h(t){const e=hi();let r=!0;for(let h=0;h<o;++h){const o=n[h];if(e.font=i+o,a=e.measureText(s).width,t!=o){e.font=i+t+\",\"+o;const n=e.measureText(s).width;r=r&&n!=a}}return r}function l(){let i=!0;for(const n in e)e[n]<t&&(h(n)?(e[n]=t,f(ri),si=null,ni.clear()):(++e[n],i=!1));i&&(clearInterval(r),r=void 0)}return function(i){const n=qe(i);if(n)for(let i=0,o=n.length;i<o;++i){const o=n[i];o in e||(e[o]=t,h(o)||(e[o]=0,void 0===r&&(r=setInterval(l,32))))}}}();function hi(){return si||(si=ke(1,1)),si}const li=function(){let t;const e=ri;return function(i){let n=e[i];return void 0==n&&(t||((t=document.createElement(\"span\")).textContent=\"M\",t.style.margin=t.style.padding=\"0 !important\",t.style.position=\"absolute !important\",t.style.left=\"-99999px !important\"),t.style.font=i,document.body.appendChild(t),n=e[i]=t.offsetHeight,document.body.removeChild(t)),n}}();function ci(t,e){const i=hi();return t!=i.font&&(i.font=t),i.measureText(e).width}function ui(t,e,i,n){0!==e&&(t.translate(i,n),t.rotate(e),t.translate(-i,-n))}const pi=[1,0,0,1,0,0];function di(t,e,i,n,o,s,r,a,h,l,c){let u;1!=i&&(u=t.globalAlpha,t.globalAlpha=u*i),e&&t.setTransform.apply(t,e),t.drawImage(n,o,s,r,a,h,l,r*c,a*c),u&&(t.globalAlpha=u),e&&t.setTransform.apply(t,pi)}const fi=function(t){this.opacity_=t.opacity,this.rotateWithView_=t.rotateWithView,this.rotation_=t.rotation,this.scale_=t.scale,this.snapToPixel_=t.snapToPixel};fi.prototype.getOpacity=function(){return this.opacity_},fi.prototype.getRotateWithView=function(){return this.rotateWithView_},fi.prototype.getRotation=function(){return this.rotation_},fi.prototype.getScale=function(){return this.scale_},fi.prototype.getSnapToPixel=function(){return this.snapToPixel_},fi.prototype.getAnchor=function(){},fi.prototype.getImage=function(t){},fi.prototype.getHitDetectionImage=function(t){},fi.prototype.getImageState=function(){},fi.prototype.getImageSize=function(){},fi.prototype.getHitDetectionImageSize=function(){},fi.prototype.getOrigin=function(){},fi.prototype.getSize=function(){},fi.prototype.setOpacity=function(t){this.opacity_=t},fi.prototype.setRotateWithView=function(t){this.rotateWithView_=t},fi.prototype.setRotation=function(t){this.rotation_=t},fi.prototype.setScale=function(t){this.scale_=t},fi.prototype.setSnapToPixel=function(t){this.snapToPixel_=t},fi.prototype.listenImageChange=function(t,e){},fi.prototype.load=function(){},fi.prototype.unlistenImageChange=function(t,e){};var gi=fi;const _i=function(t){this.checksums_=null,this.canvas_=null,this.hitDetectionCanvas_=null,this.fill_=void 0!==t.fill?t.fill:null,this.origin_=[0,0],this.points_=t.points,this.radius_=void 0!==t.radius?t.radius:t.radius1,this.radius2_=t.radius2,this.angle_=void 0!==t.angle?t.angle:0,this.stroke_=void 0!==t.stroke?t.stroke:null,this.anchor_=null,this.size_=null,this.imageSize_=null,this.hitDetectionImageSize_=null,this.atlasManager_=t.atlasManager,this.render_(this.atlasManager_);const e=void 0===t.snapToPixel||t.snapToPixel,i=void 0!==t.rotateWithView&&t.rotateWithView;gi.call(this,{opacity:1,rotateWithView:i,rotation:void 0!==t.rotation?t.rotation:0,scale:1,snapToPixel:e})};a(_i,gi),_i.prototype.clone=function(){const t=new _i({fill:this.getFill()?this.getFill().clone():void 0,points:this.getPoints(),radius:this.getRadius(),radius2:this.getRadius2(),angle:this.getAngle(),snapToPixel:this.getSnapToPixel(),stroke:this.getStroke()?this.getStroke().clone():void 0,rotation:this.getRotation(),rotateWithView:this.getRotateWithView(),atlasManager:this.atlasManager_});return t.setOpacity(this.getOpacity()),t.setScale(this.getScale()),t},_i.prototype.getAnchor=function(){return this.anchor_},_i.prototype.getAngle=function(){return this.angle_},_i.prototype.getFill=function(){return this.fill_},_i.prototype.getHitDetectionImage=function(t){return this.hitDetectionCanvas_},_i.prototype.getImage=function(t){return this.canvas_},_i.prototype.getImageSize=function(){return this.imageSize_},_i.prototype.getHitDetectionImageSize=function(){return this.hitDetectionImageSize_},_i.prototype.getImageState=function(){return Ve.LOADED},_i.prototype.getOrigin=function(){return this.origin_},_i.prototype.getPoints=function(){return this.points_},_i.prototype.getRadius=function(){return this.radius_},_i.prototype.getRadius2=function(){return this.radius2_},_i.prototype.getSize=function(){return this.size_},_i.prototype.getStroke=function(){return this.stroke_},_i.prototype.listenImageChange=function(t,e){},_i.prototype.load=function(){},_i.prototype.unlistenImageChange=function(t,e){},_i.prototype.render_=function(t){let e,i,n=\"\",o=\"\",s=0,r=null,a=0,h=0;this.stroke_&&(null===(i=this.stroke_.getColor())&&(i=ei),i=Oe(i),void 0===(h=this.stroke_.getWidth())&&(h=1),r=this.stroke_.getLineDash(),a=this.stroke_.getLineDashOffset(),Ue||(r=null,a=0),void 0===(o=this.stroke_.getLineJoin())&&(o=\"round\"),void 0===(n=this.stroke_.getLineCap())&&(n=\"round\"),void 0===(s=this.stroke_.getMiterLimit())&&(s=10));let l=2*(this.radius_+h)+1;const c={strokeStyle:i,strokeWidth:h,size:l,lineCap:n,lineDash:r,lineDashOffset:a,lineJoin:o,miterLimit:s};if(void 0===t){const t=ke(l,l);this.canvas_=t.canvas,e=l=this.canvas_.width,this.draw_(c,t,0,0),this.createHitDetectionCanvas_(c)}else{l=Math.round(l);const i=!this.fill_;let n;i&&(n=this.drawHitDetectionCanvas_.bind(this,c));const o=this.getChecksum(),s=t.add(o,l,l,this.draw_.bind(this,c),n);this.canvas_=s.image,this.origin_=[s.offsetX,s.offsetY],e=s.image.width,i?(this.hitDetectionCanvas_=s.hitImage,this.hitDetectionImageSize_=[s.hitImage.width,s.hitImage.height]):(this.hitDetectionCanvas_=this.canvas_,this.hitDetectionImageSize_=[e,e])}this.anchor_=[l/2,l/2],this.size_=[l,l],this.imageSize_=[e,e]},_i.prototype.draw_=function(t,e,i,n){let o,s,r;e.setTransform(1,0,0,1,0,0),e.translate(i,n),e.beginPath();let a=this.points_;if(a===1/0)e.arc(t.size/2,t.size/2,this.radius_,0,2*Math.PI,!0);else{const i=void 0!==this.radius2_?this.radius2_:this.radius_;for(i!==this.radius_&&(a*=2),o=0;o<=a;o++)s=2*o*Math.PI/a-Math.PI/2+this.angle_,r=o%2==0?this.radius_:i,e.lineTo(t.size/2+r*Math.cos(s),t.size/2+r*Math.sin(s))}if(this.fill_){let t=this.fill_.getColor();null===t&&(t=$e),e.fillStyle=Oe(t),e.fill()}this.stroke_&&(e.strokeStyle=t.strokeStyle,e.lineWidth=t.strokeWidth,t.lineDash&&(e.setLineDash(t.lineDash),e.lineDashOffset=t.lineDashOffset),e.lineCap=t.lineCap,e.lineJoin=t.lineJoin,e.miterLimit=t.miterLimit,e.stroke()),e.closePath()},_i.prototype.createHitDetectionCanvas_=function(t){if(this.hitDetectionImageSize_=[t.size,t.size],this.fill_)return void(this.hitDetectionCanvas_=this.canvas_);const e=ke(t.size,t.size);this.hitDetectionCanvas_=e.canvas,this.drawHitDetectionCanvas_(t,e,0,0)},_i.prototype.drawHitDetectionCanvas_=function(t,e,i,n){e.setTransform(1,0,0,1,0,0),e.translate(i,n),e.beginPath();let o=this.points_;if(o===1/0)e.arc(t.size/2,t.size/2,this.radius_,0,2*Math.PI,!0);else{const i=void 0!==this.radius2_?this.radius2_:this.radius_;let n,s,r;for(i!==this.radius_&&(o*=2),n=0;n<=o;n++)r=2*n*Math.PI/o-Math.PI/2+this.angle_,s=n%2==0?this.radius_:i,e.lineTo(t.size/2+s*Math.cos(r),t.size/2+s*Math.sin(r))}e.fillStyle=$e,e.fill(),this.stroke_&&(e.strokeStyle=t.strokeStyle,e.lineWidth=t.strokeWidth,t.lineDash&&(e.setLineDash(t.lineDash),e.lineDashOffset=t.lineDashOffset),e.stroke()),e.closePath()},_i.prototype.getChecksum=function(){const t=this.stroke_?this.stroke_.getChecksum():\"-\",e=this.fill_?this.fill_.getChecksum():\"-\";if(!this.checksums_||t!=this.checksums_[1]||e!=this.checksums_[2]||this.radius_!=this.checksums_[3]||this.radius2_!=this.checksums_[4]||this.angle_!=this.checksums_[5]||this.points_!=this.checksums_[6]){const i=\"r\"+t+e+(void 0!==this.radius_?this.radius_.toString():\"-\")+(void 0!==this.radius2_?this.radius2_.toString():\"-\")+(void 0!==this.angle_?this.angle_.toString():\"-\")+(void 0!==this.points_?this.points_.toString():\"-\");this.checksums_=[i,t,e,this.radius_,this.radius2_,this.angle_,this.points_]}return this.checksums_[0]};var yi=_i;const mi=function(t){const e=t||{};yi.call(this,{points:1/0,fill:e.fill,radius:e.radius,snapToPixel:e.snapToPixel,stroke:e.stroke,atlasManager:e.atlasManager})};a(mi,yi),mi.prototype.clone=function(){const t=new mi({fill:this.getFill()?this.getFill().clone():void 0,stroke:this.getStroke()?this.getStroke().clone():void 0,radius:this.getRadius(),snapToPixel:this.getSnapToPixel(),atlasManager:this.atlasManager_});return t.setOpacity(this.getOpacity()),t.setScale(this.getScale()),t},mi.prototype.setRadius=function(t){this.radius_=t,this.render_(this.atlasManager_)};var vi=mi;const xi=function(t){const e=t||{};this.color_=void 0!==e.color?e.color:null,this.checksum_=void 0};xi.prototype.clone=function(){const t=this.getColor();return new xi({color:t&&t.slice?t.slice():t||void 0})},xi.prototype.getColor=function(){return this.color_},xi.prototype.setColor=function(t){this.color_=t,this.checksum_=void 0},xi.prototype.getChecksum=function(){return void 0===this.checksum_&&(this.color_ instanceof CanvasPattern||this.color_ instanceof CanvasGradient?this.checksum_=l(this.color_).toString():this.checksum_=\"f\"+(this.color_?Pe(this.color_):\"-\")),this.checksum_};var Ci=xi;const Ei=function(t){const e=t||{};this.color_=void 0!==e.color?e.color:null,this.lineCap_=e.lineCap,this.lineDash_=void 0!==e.lineDash?e.lineDash:null,this.lineDashOffset_=e.lineDashOffset,this.lineJoin_=e.lineJoin,this.miterLimit_=e.miterLimit,this.width_=e.width,this.checksum_=void 0};Ei.prototype.clone=function(){const t=this.getColor();return new Ei({color:t&&t.slice?t.slice():t||void 0,lineCap:this.getLineCap(),lineDash:this.getLineDash()?this.getLineDash().slice():void 0,lineDashOffset:this.getLineDashOffset(),lineJoin:this.getLineJoin(),miterLimit:this.getMiterLimit(),width:this.getWidth()})},Ei.prototype.getColor=function(){return this.color_},Ei.prototype.getLineCap=function(){return this.lineCap_},Ei.prototype.getLineDash=function(){return this.lineDash_},Ei.prototype.getLineDashOffset=function(){return this.lineDashOffset_},Ei.prototype.getLineJoin=function(){return this.lineJoin_},Ei.prototype.getMiterLimit=function(){return this.miterLimit_},Ei.prototype.getWidth=function(){return this.width_},Ei.prototype.setColor=function(t){this.color_=t,this.checksum_=void 0},Ei.prototype.setLineCap=function(t){this.lineCap_=t,this.checksum_=void 0},Ei.prototype.setLineDash=function(t){this.lineDash_=t,this.checksum_=void 0},Ei.prototype.setLineDashOffset=function(t){this.lineDashOffset_=t,this.checksum_=void 0},Ei.prototype.setLineJoin=function(t){this.lineJoin_=t,this.checksum_=void 0},Ei.prototype.setMiterLimit=function(t){this.miterLimit_=t,this.checksum_=void 0},Ei.prototype.setWidth=function(t){this.width_=t,this.checksum_=void 0},Ei.prototype.getChecksum=function(){return void 0===this.checksum_&&(this.checksum_=\"s\",this.color_?\"string\"==typeof this.color_?this.checksum_+=this.color_:this.checksum_+=l(this.color_).toString():this.checksum_+=\"-\",this.checksum_+=\",\"+(void 0!==this.lineCap_?this.lineCap_.toString():\"-\")+\",\"+(this.lineDash_?this.lineDash_.toString():\"-\")+\",\"+(void 0!==this.lineDashOffset_?this.lineDashOffset_:\"-\")+\",\"+(void 0!==this.lineJoin_?this.lineJoin_:\"-\")+\",\"+(void 0!==this.miterLimit_?this.miterLimit_.toString():\"-\")+\",\"+(void 0!==this.width_?this.width_.toString():\"-\")),this.checksum_};var Ti=Ei;const Si=function(t){const e=t||{};this.geometry_=null,this.geometryFunction_=Fi,void 0!==e.geometry&&this.setGeometry(e.geometry),this.fill_=void 0!==e.fill?e.fill:null,this.image_=void 0!==e.image?e.image:null,this.renderer_=void 0!==e.renderer?e.renderer:null,this.stroke_=void 0!==e.stroke?e.stroke:null,this.text_=void 0!==e.text?e.text:null,this.zIndex_=e.zIndex};Si.prototype.clone=function(){let t=this.getGeometry();return t&&t.clone&&(t=t.clone()),new Si({geometry:t,fill:this.getFill()?this.getFill().clone():void 0,image:this.getImage()?this.getImage().clone():void 0,stroke:this.getStroke()?this.getStroke().clone():void 0,text:this.getText()?this.getText().clone():void 0,zIndex:this.getZIndex()})},Si.prototype.getRenderer=function(){return this.renderer_},Si.prototype.setRenderer=function(t){this.renderer_=t},Si.prototype.getGeometry=function(){return this.geometry_},Si.prototype.getGeometryFunction=function(){return this.geometryFunction_},Si.prototype.getFill=function(){return this.fill_},Si.prototype.setFill=function(t){this.fill_=t},Si.prototype.getImage=function(){return this.image_},Si.prototype.setImage=function(t){this.image_=t},Si.prototype.getStroke=function(){return this.stroke_},Si.prototype.setStroke=function(t){this.stroke_=t},Si.prototype.getText=function(){return this.text_},Si.prototype.setText=function(t){this.text_=t},Si.prototype.getZIndex=function(){return this.zIndex_},Si.prototype.setGeometry=function(t){\"function\"==typeof t?this.geometryFunction_=t:\"string\"==typeof t?this.geometryFunction_=function(e){return e.get(t)}:t?void 0!==t&&(this.geometryFunction_=function(){return t}):this.geometryFunction_=Fi,this.geometry_=t},Si.prototype.setZIndex=function(t){this.zIndex_=t};let wi=null;function Ri(t,e){if(!wi){const t=new Ci({color:\"rgba(255,255,255,0.4)\"}),e=new Ti({color:\"#3399CC\",width:1.25});wi=[new Si({image:new vi({fill:t,stroke:e,radius:5}),fill:t,stroke:e})]}return wi}function Ii(){const t={},e=[255,255,255,1],i=[0,153,255,1];return t[Ot.POLYGON]=[new Si({fill:new Ci({color:[255,255,255,.5]})})],t[Ot.MULTI_POLYGON]=t[Ot.POLYGON],t[Ot.LINE_STRING]=[new Si({stroke:new Ti({color:e,width:5})}),new Si({stroke:new Ti({color:i,width:3})})],t[Ot.MULTI_LINE_STRING]=t[Ot.LINE_STRING],t[Ot.CIRCLE]=t[Ot.POLYGON].concat(t[Ot.LINE_STRING]),t[Ot.POINT]=[new Si({image:new vi({radius:6,fill:new Ci({color:i}),stroke:new Ti({color:e,width:1.5})}),zIndex:1/0})],t[Ot.MULTI_POINT]=t[Ot.POINT],t[Ot.GEOMETRY_COLLECTION]=t[Ot.POLYGON].concat(t[Ot.LINE_STRING],t[Ot.POINT]),t}function Fi(t){return t.getGeometry()}var Pi=Si;const Li=function(t){if(K.call(this),this.id_=void 0,this.geometryName_=\"geometry\",this.style_=null,this.styleFunction_=void 0,this.geometryChangeKey_=null,C(this,W(this.geometryName_),this.handleGeometryChanged_,this),void 0!==t)if(t instanceof Re||!t){const e=t;this.setGeometry(e)}else{const e=t;this.setProperties(e)}};a(Li,K),Li.prototype.clone=function(){const t=new Li(this.getProperties());t.setGeometryName(this.getGeometryName());const e=this.getGeometry();e&&t.setGeometry(e.clone());const i=this.getStyle();return i&&t.setStyle(i),t},Li.prototype.getGeometry=function(){return this.get(this.geometryName_)},Li.prototype.getId=function(){return this.id_},Li.prototype.getGeometryName=function(){return this.geometryName_},Li.prototype.getStyle=function(){return this.style_},Li.prototype.getStyleFunction=function(){return this.styleFunction_},Li.prototype.handleGeometryChange_=function(){this.changed()},Li.prototype.handleGeometryChanged_=function(){this.geometryChangeKey_&&(S(this.geometryChangeKey_),this.geometryChangeKey_=null);const t=this.getGeometry();t&&(this.geometryChangeKey_=C(t,w.CHANGE,this.handleGeometryChange_,this)),this.changed()},Li.prototype.setGeometry=function(t){this.set(this.geometryName_,t)},Li.prototype.setStyle=function(t){this.style_=t,this.styleFunction_=t?function(t){if(\"function\"==typeof t)return t;{let e;return Array.isArray(t)?e=t:(p(t instanceof Pi,41),e=[t]),function(){return e}}}(t):void 0,this.changed()},Li.prototype.setId=function(t){this.id_=t,this.changed()},Li.prototype.setGeometryName=function(t){T(this,W(this.geometryName_),this.handleGeometryChanged_,this),this.geometryName_=t,C(this,W(this.geometryName_),this.handleGeometryChanged_,this),this.handleGeometryChanged_()};var Mi=Li;const bi=function(){this.defaultDataProjection=null,this.defaultFeatureProjection=null};bi.prototype.getReadOptions=function(t,e){let i;return e&&(i={dataProjection:e.dataProjection?e.dataProjection:this.readProjection(t),featureProjection:e.featureProjection}),this.adaptOptions(i)},bi.prototype.adaptOptions=function(t){return d({dataProjection:this.defaultDataProjection,featureProjection:this.defaultFeatureProjection},t)},bi.prototype.getLastExtent=function(){return null},bi.prototype.getType=function(){},bi.prototype.readFeature=function(t,e){},bi.prototype.readFeatures=function(t,e){},bi.prototype.readGeometry=function(t,e){},bi.prototype.readProjection=function(t){},bi.prototype.writeFeature=function(t,e){},bi.prototype.writeFeatures=function(t,e){},bi.prototype.writeGeometry=function(t,e){};var Oi=bi;function ki(t,e,i){const n=i?se(i.featureProjection):null,o=i?se(i.dataProjection):null;let s;if(s=n&&o&&!le(n,o)?t instanceof Re?(e?t.clone():t).transform(e?n:o,e?o:n):St(t,ue(o,n)):t,e&&i&&void 0!==i.decimals){const e=Math.pow(10,i.decimals),n=function(t){for(let i=0,n=t.length;i<n;++i)t[i]=Math.round(t[i]*e)/e;return t};s===t&&(s=s.clone()),s.applyTransform(n)}return s}var Ai={ARRAY_BUFFER:\"arraybuffer\",JSON:\"json\",TEXT:\"text\",XML:\"xml\"};const Gi=function(){Oi.call(this)};function Di(t){if(\"string\"==typeof t){const e=JSON.parse(t);return e||null}return null!==t?t:null}a(Gi,Oi),Gi.prototype.getType=function(){return Ai.JSON},Gi.prototype.readFeature=function(t,e){return this.readFeatureFromObject(Di(t),this.getReadOptions(t,e))},Gi.prototype.readFeatures=function(t,e){return this.readFeaturesFromObject(Di(t),this.getReadOptions(t,e))},Gi.prototype.readFeatureFromObject=function(t,e){},Gi.prototype.readFeaturesFromObject=function(t,e){},Gi.prototype.readGeometry=function(t,e){return this.readGeometryFromObject(Di(t),this.getReadOptions(t,e))},Gi.prototype.readGeometryFromObject=function(t,e){},Gi.prototype.readProjection=function(t){return this.readProjectionFromObject(Di(t))},Gi.prototype.readProjectionFromObject=function(t){},Gi.prototype.writeFeature=function(t,e){return JSON.stringify(this.writeFeatureObject(t,e))},Gi.prototype.writeFeatureObject=function(t,e){},Gi.prototype.writeFeatures=function(t,e){return JSON.stringify(this.writeFeaturesObject(t,e))},Gi.prototype.writeFeaturesObject=function(t,e){},Gi.prototype.writeGeometry=function(t,e){return JSON.stringify(this.writeGeometryObject(t,e))},Gi.prototype.writeGeometryObject=function(t,e){};var Ni=Gi;const Yi=function(t){Re.call(this),this.geometries_=t||null,this.listenGeometriesChange_()};function Xi(t){const e=[];for(let i=0,n=t.length;i<n;++i)e.push(t[i].clone());return e}a(Yi,Re),Yi.prototype.unlistenGeometriesChange_=function(){if(this.geometries_)for(let t=0,e=this.geometries_.length;t<e;++t)T(this.geometries_[t],w.CHANGE,this.changed,this)},Yi.prototype.listenGeometriesChange_=function(){if(this.geometries_)for(let t=0,e=this.geometries_.length;t<e;++t)C(this.geometries_[t],w.CHANGE,this.changed,this)},Yi.prototype.clone=function(){const t=new Yi(null);return t.setGeometries(this.geometries_),t},Yi.prototype.closestPointXY=function(t,e,i,n){if(n<Z(this.getExtent(),t,e))return n;const o=this.geometries_;for(let s=0,r=o.length;s<r;++s)n=o[s].closestPointXY(t,e,i,n);return n},Yi.prototype.containsXY=function(t,e){const i=this.geometries_;for(let n=0,o=i.length;n<o;++n)if(i[n].containsXY(t,e))return!0;return!1},Yi.prototype.computeExtent=function(t){it(t);const e=this.geometries_;for(let i=0,n=e.length;i<n;++i)rt(t,e[i].getExtent());return t},Yi.prototype.getGeometries=function(){return Xi(this.geometries_)},Yi.prototype.getGeometriesArray=function(){return this.geometries_},Yi.prototype.getSimplifiedGeometry=function(t){if(this.simplifiedGeometryRevision!=this.getRevision()&&(f(this.simplifiedGeometryCache),this.simplifiedGeometryMaxMinSquaredTolerance=0,this.simplifiedGeometryRevision=this.getRevision()),t<0||0!==this.simplifiedGeometryMaxMinSquaredTolerance&&t<this.simplifiedGeometryMaxMinSquaredTolerance)return this;const e=t.toString();if(this.simplifiedGeometryCache.hasOwnProperty(e))return this.simplifiedGeometryCache[e];{const i=[],n=this.geometries_;let o=!1;for(let e=0,s=n.length;e<s;++e){const s=n[e],r=s.getSimplifiedGeometry(t);i.push(r),r!==s&&(o=!0)}if(o){const t=new Yi(null);return t.setGeometriesArray(i),this.simplifiedGeometryCache[e]=t,t}return this.simplifiedGeometryMaxMinSquaredTolerance=t,this}},Yi.prototype.getType=function(){return Ot.GEOMETRY_COLLECTION},Yi.prototype.intersectsExtent=function(t){const e=this.geometries_;for(let i=0,n=e.length;i<n;++i)if(e[i].intersectsExtent(t))return!0;return!1},Yi.prototype.isEmpty=function(){return 0===this.geometries_.length},Yi.prototype.rotate=function(t,e){const i=this.geometries_;for(let n=0,o=i.length;n<o;++n)i[n].rotate(t,e);this.changed()},Yi.prototype.scale=function(t,e,i){let n=i;n||(n=gt(this.getExtent()));const o=this.geometries_;for(let i=0,s=o.length;i<s;++i)o[i].scale(t,e,n);this.changed()},Yi.prototype.setGeometries=function(t){this.setGeometriesArray(Xi(t))},Yi.prototype.setGeometriesArray=function(t){this.unlistenGeometriesChange_(),this.geometries_=t,this.listenGeometriesChange_(),this.changed()},Yi.prototype.applyTransform=function(t){const e=this.geometries_;for(let i=0,n=e.length;i<n;++i)e[i].applyTransform(t);this.changed()},Yi.prototype.translate=function(t,e){const i=this.geometries_;for(let n=0,o=i.length;n<o;++n)i[n].translate(t,e);this.changed()},Yi.prototype.disposeInternal=function(){this.unlistenGeometriesChange_(),Re.prototype.disposeInternal.call(this)};var zi=Yi;function Wi(t,e){return t>e?1:t<e?-1:0}function Ki(t,e){return t.indexOf(e)>=0}function Ui(t,e,i){const n=t.length;if(t[0]<=e)return 0;if(e<=t[n-1])return n-1;{let o;if(i>0){for(o=1;o<n;++o)if(t[o]<e)return o-1}else if(i<0){for(o=1;o<n;++o)if(t[o]<=e)return o}else for(o=1;o<n;++o){if(t[o]==e)return o;if(t[o]<e)return t[o-1]-e<e-t[o]?o-1:o}return n-1}}function Bi(t,e,i){for(;e<i;){const n=t[e];t[e]=t[i],t[i]=n,++e,--i}}function ji(t,e){const i=Array.isArray(e)?e:[e],n=i.length;for(let e=0;e<n;e++)t[t.length]=i[e]}function Hi(t,e){const i=t.length;if(i!==e.length)return!1;for(let n=0;n<i;n++)if(t[n]!==e[n])return!1;return!0}var Vi={XY:\"XY\",XYZ:\"XYZ\",XYM:\"XYM\",XYZM:\"XYZM\"};const Zi=function(){Re.call(this),this.layout=Vi.XY,this.stride=2,this.flatCoordinates=null};function qi(t){let e;return t==Vi.XY?e=2:t==Vi.XYZ||t==Vi.XYM?e=3:t==Vi.XYZM&&(e=4),e}a(Zi,Re),Zi.prototype.containsXY=F,Zi.prototype.computeExtent=function(t){return ot(this.flatCoordinates,0,this.flatCoordinates.length,this.stride,t)},Zi.prototype.getCoordinates=function(){},Zi.prototype.getFirstCoordinate=function(){return this.flatCoordinates.slice(0,this.stride)},Zi.prototype.getFlatCoordinates=function(){return this.flatCoordinates},Zi.prototype.getLastCoordinate=function(){return this.flatCoordinates.slice(this.flatCoordinates.length-this.stride)},Zi.prototype.getLayout=function(){return this.layout},Zi.prototype.getSimplifiedGeometry=function(t){if(this.simplifiedGeometryRevision!=this.getRevision()&&(f(this.simplifiedGeometryCache),this.simplifiedGeometryMaxMinSquaredTolerance=0,this.simplifiedGeometryRevision=this.getRevision()),t<0||0!==this.simplifiedGeometryMaxMinSquaredTolerance&&t<=this.simplifiedGeometryMaxMinSquaredTolerance)return this;const e=t.toString();if(this.simplifiedGeometryCache.hasOwnProperty(e))return this.simplifiedGeometryCache[e];{const i=this.getSimplifiedGeometryInternal(t);return i.getFlatCoordinates().length<this.flatCoordinates.length?(this.simplifiedGeometryCache[e]=i,i):(this.simplifiedGeometryMaxMinSquaredTolerance=t,this)}},Zi.prototype.getSimplifiedGeometryInternal=function(t){return this},Zi.prototype.getStride=function(){return this.stride},Zi.prototype.setFlatCoordinatesInternal=function(t,e){this.stride=qi(t),this.layout=t,this.flatCoordinates=e},Zi.prototype.setCoordinates=function(t,e){},Zi.prototype.setLayout=function(t,e,i){let n;if(t)n=qi(t);else{for(let t=0;t<i;++t){if(0===e.length)return this.layout=Vi.XY,void(this.stride=2);e=e[0]}t=function(t){let e;return 2==t?e=Vi.XY:3==t?e=Vi.XYZ:4==t&&(e=Vi.XYZM),e}(n=e.length)}this.layout=t,this.stride=n},Zi.prototype.applyTransform=function(t){this.flatCoordinates&&(t(this.flatCoordinates,this.flatCoordinates,this.stride),this.changed())},Zi.prototype.rotate=function(t,e){const i=this.getFlatCoordinates();if(i){const n=this.getStride();!function(t,e,i,n,o,s,r){const a=r||[],h=Math.cos(o),l=Math.sin(o),c=s[0],u=s[1];let p=0;for(let o=e;o<i;o+=n){const e=t[o]-c,i=t[o+1]-u;a[p++]=c+e*h-i*l,a[p++]=u+e*l+i*h;for(let e=o+2;e<o+n;++e)a[p++]=t[e]}r&&a.length!=p&&(a.length=p)}(i,0,i.length,n,t,e,i),this.changed()}},Zi.prototype.scale=function(t,e,i){let n=e;void 0===n&&(n=t);let o=i;o||(o=gt(this.getExtent()));const s=this.getFlatCoordinates();if(s){const e=this.getStride();!function(t,e,i,n,o,s,r,a){const h=a||[],l=r[0],c=r[1];let u=0;for(let r=e;r<i;r+=n){const e=t[r]-l,i=t[r+1]-c;h[u++]=l+o*e,h[u++]=c+s*i;for(let e=r+2;e<r+n;++e)h[u++]=t[e]}a&&h.length!=u&&(h.length=u)}(s,0,s.length,e,t,n,o,s),this.changed()}},Zi.prototype.translate=function(t,e){const i=this.getFlatCoordinates();if(i){const n=this.getStride();!function(t,e,i,n,o,s,r){const a=r||[];let h=0;for(let r=e;r<i;r+=n){a[h++]=t[r]+o,a[h++]=t[r+1]+s;for(let e=r+2;e<r+n;++e)a[h++]=t[e]}r&&a.length!=h&&(a.length=h)}(i,0,i.length,n,t,e,i),this.changed()}};var Ji=Zi;function Qi(t,e,i,n,o,s,r){const a=t[e],h=t[e+1],l=t[i]-a,c=t[i+1]-h;let u;if(0===l&&0===c)u=e;else{const p=((o-a)*l+(s-h)*c)/(l*l+c*c);if(p>1)u=i;else{if(p>0){for(let o=0;o<n;++o)r[o]=bt(t[e+o],t[i+o],p);return void(r.length=n)}u=e}}for(let e=0;e<n;++e)r[e]=t[u+e];r.length=n}function $i(t,e,i,n,o){let s=t[e],r=t[e+1];for(e+=n;e<i;e+=n){const i=t[e],n=t[e+1],a=Pt(s,r,i,n);a>o&&(o=a),s=i,r=n}return o}function tn(t,e,i,n,o){for(let s=0,r=i.length;s<r;++s){const r=i[s];o=$i(t,e,r,n,o),e=r}return o}function en(t,e,i,n,o,s,r,a,h,l,c){if(e==i)return l;let u,p;if(0===o){if((p=Pt(r,a,t[e],t[e+1]))<l){for(u=0;u<n;++u)h[u]=t[e+u];return h.length=n,p}return l}const d=c||[NaN,NaN];let f=e+n;for(;f<i;)if(Qi(t,f-n,f,n,r,a,d),(p=Pt(r,a,d[0],d[1]))<l){for(l=p,u=0;u<n;++u)h[u]=d[u];h.length=n,f+=n}else f+=n*Math.max((Math.sqrt(p)-Math.sqrt(l))/o|0,1);if(s&&(Qi(t,i-n,e,n,r,a,d),(p=Pt(r,a,d[0],d[1]))<l)){for(l=p,u=0;u<n;++u)h[u]=d[u];h.length=n}return l}function nn(t,e,i,n,o,s,r,a,h,l,c){const u=c||[NaN,NaN];for(let c=0,p=i.length;c<p;++c){const p=i[c];l=en(t,e,p,n,o,s,r,a,h,l,u),e=p}return l}function on(t,e,i,n){for(let n=0,o=i.length;n<o;++n)t[e++]=i[n];return e}function sn(t,e,i,n){for(let o=0,s=i.length;o<s;++o){const s=i[o];for(let i=0;i<n;++i)t[e++]=s[i]}return e}function rn(t,e,i,n,o){const s=o||[];let r=0;for(let o=0,a=i.length;o<a;++o){const a=sn(t,e,i[o],n);s[r++]=a,e=a}return s.length=r,s}function an(t,e,i,n,o){const s=void 0!==o?o:[];let r=0;for(let o=e;o<i;o+=n)s[r++]=t.slice(o,o+n);return s.length=r,s}function hn(t,e,i,n,o){const s=void 0!==o?o:[];let r=0;for(let o=0,a=i.length;o<a;++o){const a=i[o];s[r++]=an(t,e,a,n,s[r]),e=a}return s.length=r,s}function ln(t,e,i,n,o){const s=void 0!==o?o:[];let r=0;for(let o=0,a=i.length;o<a;++o){const a=i[o];s[r++]=hn(t,e,a,n,s[r]),e=a[a.length-1]}return s.length=r,s}function cn(t,e,i,n,o,s){let r=NaN,a=NaN;const h=(i-e)/n;if(1===h)r=t[e],a=t[e+1];else if(2==h)r=(1-o)*t[e]+o*t[e+n],a=(1-o)*t[e+1]+o*t[e+n+1];else if(0!==h){let s=t[e],h=t[e+1],l=0;const c=[0];for(let o=e+n;o<i;o+=n){const e=t[o],i=t[o+1];l+=Math.sqrt((e-s)*(e-s)+(i-h)*(i-h)),c.push(l),s=e,h=i}const u=o*l,p=function(t,e,i){let n,o;const s=i||Wi;let r=0,a=t.length,h=!1;for(;r<a;)(o=+s(t[n=r+(a-r>>1)],e))<0?r=n+1:(a=n,h=!o);return h?r:~r}(c,u);if(p<0){const i=(u-c[-p-2])/(c[-p-1]-c[-p-2]),o=e+(-p-2)*n;r=bt(t[o],t[o+n],i),a=bt(t[o+1],t[o+n+1],i)}else r=t[e+p*n],a=t[e+p*n+1]}return s?(s[0]=r,s[1]=a,s):[r,a]}function un(t,e,i,n,o,s){if(i==e)return null;let r;if(o<t[e+n-1])return s?((r=t.slice(e,e+n))[n-1]=o,r):null;if(t[i-1]<o)return s?((r=t.slice(i-n,i))[n-1]=o,r):null;if(o==t[e+n-1])return t.slice(e,e+n);let a=e/n,h=i/n;for(;a<h;){const e=a+h>>1;o<t[(e+1)*n-1]?h=e:a=e+1}const l=t[a*n-1];if(o==l)return t.slice((a-1)*n,(a-1)*n+n);const c=(o-l)/(t[(a+1)*n-1]-l);r=[];for(let e=0;e<n-1;++e)r.push(bt(t[(a-1)*n+e],t[a*n+e],c));return r.push(o),r}function pn(t,e,i,n,o){return!ut(o,function(o){return!dn(t,e,i,n,o[0],o[1])})}function dn(t,e,i,n,o,s){let r=0,a=t[i-n],h=t[i-n+1];for(;e<i;e+=n){const i=t[e],n=t[e+1];h<=s?n>s&&(i-a)*(s-h)-(o-a)*(n-h)>0&&r++:n<=s&&(i-a)*(s-h)-(o-a)*(n-h)<0&&r--,a=i,h=n}return 0!==r}function fn(t,e,i,n,o,s){if(0===i.length)return!1;if(!dn(t,e,i[0],n,o,s))return!1;for(let e=1,r=i.length;e<r;++e)if(dn(t,i[e-1],i[e],n,o,s))return!1;return!0}function gn(t,e,i,n,o,s){const r=[t[e],t[e+1]],a=[];let h;for(;e+n<i;e+=n){if(a[0]=t[e+n],a[1]=t[e+n+1],h=o.call(s,r,a))return h;r[0]=a[0],r[1]=a[1]}return!1}function _n(t,e,i,n,o){const s=lt([1/0,1/0,-1/0,-1/0],t,e,i,n);return!!Et(o,s)&&(!!J(o,s)||(s[0]>=o[0]&&s[2]<=o[2]||(s[1]>=o[1]&&s[3]<=o[3]||gn(t,e,i,n,function(t,e){return function(t,e,i){let n=!1;const o=$(t,e),s=$(t,i);if(o===B.INTERSECTING||s===B.INTERSECTING)n=!0;else{const r=t[0],a=t[1],h=t[2],l=t[3],c=e[0],u=e[1],p=i[0],d=i[1],f=(d-u)/(p-c);let g,_;s&B.ABOVE&&!(o&B.ABOVE)&&(n=(g=p-(d-l)/f)>=r&&g<=h),n||!(s&B.RIGHT)||o&B.RIGHT||(n=(_=d-(p-h)*f)>=a&&_<=l),n||!(s&B.BELOW)||o&B.BELOW||(n=(g=p-(d-a)/f)>=r&&g<=h),n||!(s&B.LEFT)||o&B.LEFT||(n=(_=d-(p-r)*f)>=a&&_<=l)}return n}(o,t,e)}))))}function yn(t,e,i,n,o){if(!function(t,e,i,n,o){return!!(_n(t,e,i,n,o)||dn(t,e,i,n,o[0],o[1])||dn(t,e,i,n,o[0],o[3])||dn(t,e,i,n,o[2],o[1])||dn(t,e,i,n,o[2],o[3]))}(t,e,i[0],n,o))return!1;if(1===i.length)return!0;for(let e=1,s=i.length;e<s;++e)if(pn(t,i[e-1],i[e],n,o))return!1;return!0}function mn(t,e,i,n){let o=t[e],s=t[e+1],r=0;for(let a=e+n;a<i;a+=n){const e=t[a],i=t[a+1];r+=Math.sqrt((e-o)*(e-o)+(i-s)*(i-s)),o=e,s=i}return r}function vn(t,e,i,n,o,s,r){const a=(i-e)/n;if(a<3){for(;e<i;e+=n)s[r++]=t[e],s[r++]=t[e+1];return r}const h=new Array(a);h[0]=1,h[a-1]=1;const l=[e,i-n];let c=0;for(;l.length>0;){const i=l.pop(),s=l.pop();let r=0;const a=t[s],u=t[s+1],p=t[i],d=t[i+1];for(let e=s+n;e<i;e+=n){const i=Ft(t[e],t[e+1],a,u,p,d);i>r&&(c=e,r=i)}r>o&&(h[(c-e)/n]=1,s+n<c&&l.push(s,c),c+n<i&&l.push(c,i))}for(let i=0;i<a;++i)h[i]&&(s[r++]=t[e+i*n],s[r++]=t[e+i*n+1]);return r}function xn(t,e,i,n,o,s,r,a){for(let h=0,l=i.length;h<l;++h){const l=i[h];r=vn(t,e,l,n,o,s,r),a.push(r),e=l}return r}function Cn(t,e){return e*Math.round(t/e)}function En(t,e,i,n,o,s,r){if(e==i)return r;let a,h,l=Cn(t[e],o),c=Cn(t[e+1],o);e+=n,s[r++]=l,s[r++]=c;do{if(a=Cn(t[e],o),h=Cn(t[e+1],o),(e+=n)==i)return s[r++]=a,s[r++]=h,r}while(a==l&&h==c);for(;e<i;){const i=Cn(t[e],o),u=Cn(t[e+1],o);if(e+=n,i==a&&u==h)continue;const p=a-l,d=h-c,f=i-l,g=u-c;p*g==d*f&&(p<0&&f<p||p==f||p>0&&f>p)&&(d<0&&g<d||d==g||d>0&&g>d)?(a=i,h=u):(s[r++]=a,s[r++]=h,l=a,c=h,a=i,h=u)}return s[r++]=a,s[r++]=h,r}function Tn(t,e,i,n,o,s,r,a){for(let h=0,l=i.length;h<l;++h){const l=i[h];r=En(t,e,l,n,o,s,r),a.push(r),e=l}return r}const Sn=function(t,e){Ji.call(this),this.flatMidpoint_=null,this.flatMidpointRevision_=-1,this.maxDelta_=-1,this.maxDeltaRevision_=-1,this.setCoordinates(t,e)};a(Sn,Ji),Sn.prototype.appendCoordinate=function(t){this.flatCoordinates?ji(this.flatCoordinates,t):this.flatCoordinates=t.slice(),this.changed()},Sn.prototype.clone=function(){const t=new Sn(null);return t.setFlatCoordinates(this.layout,this.flatCoordinates.slice()),t},Sn.prototype.closestPointXY=function(t,e,i,n){return n<Z(this.getExtent(),t,e)?n:(this.maxDeltaRevision_!=this.getRevision()&&(this.maxDelta_=Math.sqrt($i(this.flatCoordinates,0,this.flatCoordinates.length,this.stride,0)),this.maxDeltaRevision_=this.getRevision()),en(this.flatCoordinates,0,this.flatCoordinates.length,this.stride,this.maxDelta_,!1,t,e,i,n))},Sn.prototype.forEachSegment=function(t){return gn(this.flatCoordinates,0,this.flatCoordinates.length,this.stride,t)},Sn.prototype.getCoordinateAtM=function(t,e){if(this.layout!=Vi.XYM&&this.layout!=Vi.XYZM)return null;const i=void 0!==e&&e;return un(this.flatCoordinates,0,this.flatCoordinates.length,this.stride,t,i)},Sn.prototype.getCoordinates=function(){return an(this.flatCoordinates,0,this.flatCoordinates.length,this.stride)},Sn.prototype.getCoordinateAt=function(t,e){return cn(this.flatCoordinates,0,this.flatCoordinates.length,this.stride,t,e)},Sn.prototype.getLength=function(){return mn(this.flatCoordinates,0,this.flatCoordinates.length,this.stride)},Sn.prototype.getFlatMidpoint=function(){return this.flatMidpointRevision_!=this.getRevision()&&(this.flatMidpoint_=this.getCoordinateAt(.5,this.flatMidpoint_),this.flatMidpointRevision_=this.getRevision()),this.flatMidpoint_},Sn.prototype.getSimplifiedGeometryInternal=function(t){const e=[];e.length=vn(this.flatCoordinates,0,this.flatCoordinates.length,this.stride,t,e,0);const i=new Sn(null);return i.setFlatCoordinates(Vi.XY,e),i},Sn.prototype.getType=function(){return Ot.LINE_STRING},Sn.prototype.intersectsExtent=function(t){return _n(this.flatCoordinates,0,this.flatCoordinates.length,this.stride,t)},Sn.prototype.setCoordinates=function(t,e){t?(this.setLayout(e,t,1),this.flatCoordinates||(this.flatCoordinates=[]),this.flatCoordinates.length=sn(this.flatCoordinates,0,t,this.stride),this.changed()):this.setFlatCoordinates(Vi.XY,null)},Sn.prototype.setFlatCoordinates=function(t,e){this.setFlatCoordinatesInternal(t,e),this.changed()};var wn=Sn;const Rn=function(t,e){Ji.call(this),this.ends_=[],this.maxDelta_=-1,this.maxDeltaRevision_=-1,this.setCoordinates(t,e)};a(Rn,Ji),Rn.prototype.appendLineString=function(t){this.flatCoordinates?ji(this.flatCoordinates,t.getFlatCoordinates().slice()):this.flatCoordinates=t.getFlatCoordinates().slice(),this.ends_.push(this.flatCoordinates.length),this.changed()},Rn.prototype.clone=function(){const t=new Rn(null);return t.setFlatCoordinates(this.layout,this.flatCoordinates.slice(),this.ends_.slice()),t},Rn.prototype.closestPointXY=function(t,e,i,n){return n<Z(this.getExtent(),t,e)?n:(this.maxDeltaRevision_!=this.getRevision()&&(this.maxDelta_=Math.sqrt(tn(this.flatCoordinates,0,this.ends_,this.stride,0)),this.maxDeltaRevision_=this.getRevision()),nn(this.flatCoordinates,0,this.ends_,this.stride,this.maxDelta_,!1,t,e,i,n))},Rn.prototype.getCoordinateAtM=function(t,e,i){if(this.layout!=Vi.XYM&&this.layout!=Vi.XYZM||0===this.flatCoordinates.length)return null;const n=void 0!==e&&e,o=void 0!==i&&i;return function(t,e,i,n,o,s,r){if(r)return un(t,e,i[i.length-1],n,o,s);let a;if(o<t[n-1])return s?((a=t.slice(0,n))[n-1]=o,a):null;if(t[t.length-1]<o)return s?((a=t.slice(t.length-n))[n-1]=o,a):null;for(let s=0,r=i.length;s<r;++s){const r=i[s];if(e!=r){if(o<t[e+n-1])return null;if(o<=t[r-1])return un(t,e,r,n,o,!1);e=r}}return null}(this.flatCoordinates,0,this.ends_,this.stride,t,n,o)},Rn.prototype.getCoordinates=function(){return hn(this.flatCoordinates,0,this.ends_,this.stride)},Rn.prototype.getEnds=function(){return this.ends_},Rn.prototype.getLineString=function(t){if(t<0||this.ends_.length<=t)return null;const e=new wn(null);return e.setFlatCoordinates(this.layout,this.flatCoordinates.slice(0===t?0:this.ends_[t-1],this.ends_[t])),e},Rn.prototype.getLineStrings=function(){const t=this.flatCoordinates,e=this.ends_,i=this.layout,n=[];let o=0;for(let s=0,r=e.length;s<r;++s){const r=e[s],a=new wn(null);a.setFlatCoordinates(i,t.slice(o,r)),n.push(a),o=r}return n},Rn.prototype.getFlatMidpoints=function(){const t=[],e=this.flatCoordinates;let i=0;const n=this.ends_,o=this.stride;for(let s=0,r=n.length;s<r;++s){const r=n[s];ji(t,cn(e,i,r,o,.5)),i=r}return t},Rn.prototype.getSimplifiedGeometryInternal=function(t){const e=[],i=[];e.length=xn(this.flatCoordinates,0,this.ends_,this.stride,t,e,0,i);const n=new Rn(null);return n.setFlatCoordinates(Vi.XY,e,i),n},Rn.prototype.getType=function(){return Ot.MULTI_LINE_STRING},Rn.prototype.intersectsExtent=function(t){return function(t,e,i,n,o){for(let s=0,r=i.length;s<r;++s){if(_n(t,e,i[s],n,o))return!0;e=i[s]}return!1}(this.flatCoordinates,0,this.ends_,this.stride,t)},Rn.prototype.setCoordinates=function(t,e){if(t){this.setLayout(e,t,2),this.flatCoordinates||(this.flatCoordinates=[]);const i=rn(this.flatCoordinates,0,t,this.stride,this.ends_);this.flatCoordinates.length=0===i.length?0:i[i.length-1],this.changed()}else this.setFlatCoordinates(Vi.XY,null,this.ends_)},Rn.prototype.setFlatCoordinates=function(t,e,i){this.setFlatCoordinatesInternal(t,e),this.ends_=i,this.changed()},Rn.prototype.setLineStrings=function(t){let e=this.getLayout();const i=[],n=[];for(let o=0,s=t.length;o<s;++o){const s=t[o];0===o&&(e=s.getLayout()),ji(i,s.getFlatCoordinates()),n.push(i.length)}this.setFlatCoordinates(e,i,n)};var In=Rn;const Fn=function(t,e){Ji.call(this),this.setCoordinates(t,e)};a(Fn,Ji),Fn.prototype.clone=function(){const t=new Fn(null);return t.setFlatCoordinates(this.layout,this.flatCoordinates.slice()),t},Fn.prototype.closestPointXY=function(t,e,i,n){const o=this.flatCoordinates,s=Pt(t,e,o[0],o[1]);if(s<n){const t=this.stride;for(let e=0;e<t;++e)i[e]=o[e];return i.length=t,s}return n},Fn.prototype.getCoordinates=function(){return this.flatCoordinates?this.flatCoordinates.slice():[]},Fn.prototype.computeExtent=function(t){return nt(this.flatCoordinates,t)},Fn.prototype.getType=function(){return Ot.POINT},Fn.prototype.intersectsExtent=function(t){return Q(t,this.flatCoordinates[0],this.flatCoordinates[1])},Fn.prototype.setCoordinates=function(t,e){t?(this.setLayout(e,t,0),this.flatCoordinates||(this.flatCoordinates=[]),this.flatCoordinates.length=on(this.flatCoordinates,0,t,this.stride),this.changed()):this.setFlatCoordinates(Vi.XY,null)},Fn.prototype.setFlatCoordinates=function(t,e){this.setFlatCoordinatesInternal(t,e),this.changed()};var Pn=Fn;const Ln=function(t,e){Ji.call(this),this.setCoordinates(t,e)};a(Ln,Ji),Ln.prototype.appendPoint=function(t){this.flatCoordinates?ji(this.flatCoordinates,t.getFlatCoordinates()):this.flatCoordinates=t.getFlatCoordinates().slice(),this.changed()},Ln.prototype.clone=function(){const t=new Ln(null);return t.setFlatCoordinates(this.layout,this.flatCoordinates.slice()),t},Ln.prototype.closestPointXY=function(t,e,i,n){if(n<Z(this.getExtent(),t,e))return n;const o=this.flatCoordinates,s=this.stride;for(let r=0,a=o.length;r<a;r+=s){const a=Pt(t,e,o[r],o[r+1]);if(a<n){n=a;for(let t=0;t<s;++t)i[t]=o[r+t];i.length=s}}return n},Ln.prototype.getCoordinates=function(){return an(this.flatCoordinates,0,this.flatCoordinates.length,this.stride)},Ln.prototype.getPoint=function(t){const e=this.flatCoordinates?this.flatCoordinates.length/this.stride:0;if(t<0||e<=t)return null;const i=new Pn(null);return i.setFlatCoordinates(this.layout,this.flatCoordinates.slice(t*this.stride,(t+1)*this.stride)),i},Ln.prototype.getPoints=function(){const t=this.flatCoordinates,e=this.layout,i=this.stride,n=[];for(let o=0,s=t.length;o<s;o+=i){const s=new Pn(null);s.setFlatCoordinates(e,t.slice(o,o+i)),n.push(s)}return n},Ln.prototype.getType=function(){return Ot.MULTI_POINT},Ln.prototype.intersectsExtent=function(t){const e=this.flatCoordinates,i=this.stride;for(let n=0,o=e.length;n<o;n+=i){if(Q(t,e[n],e[n+1]))return!0}return!1},Ln.prototype.setCoordinates=function(t,e){t?(this.setLayout(e,t,1),this.flatCoordinates||(this.flatCoordinates=[]),this.flatCoordinates.length=sn(this.flatCoordinates,0,t,this.stride),this.changed()):this.setFlatCoordinates(Vi.XY,null)},Ln.prototype.setFlatCoordinates=function(t,e){this.setFlatCoordinatesInternal(t,e),this.changed()};var Mn=Ln;function bn(t,e,i,n){let o=0,s=t[i-n],r=t[i-n+1];for(;e<i;e+=n){const i=t[e],n=t[e+1];o+=r*i-s*n,s=i,r=n}return o/2}function On(t,e,i,n){let o=0;for(let s=0,r=i.length;s<r;++s){const r=i[s];o+=bn(t,e,r,n),e=r}return o}const kn=function(t,e){Ji.call(this),this.maxDelta_=-1,this.maxDeltaRevision_=-1,this.setCoordinates(t,e)};a(kn,Ji),kn.prototype.clone=function(){const t=new kn(null);return t.setFlatCoordinates(this.layout,this.flatCoordinates.slice()),t},kn.prototype.closestPointXY=function(t,e,i,n){return n<Z(this.getExtent(),t,e)?n:(this.maxDeltaRevision_!=this.getRevision()&&(this.maxDelta_=Math.sqrt($i(this.flatCoordinates,0,this.flatCoordinates.length,this.stride,0)),this.maxDeltaRevision_=this.getRevision()),en(this.flatCoordinates,0,this.flatCoordinates.length,this.stride,this.maxDelta_,!0,t,e,i,n))},kn.prototype.getArea=function(){return bn(this.flatCoordinates,0,this.flatCoordinates.length,this.stride)},kn.prototype.getCoordinates=function(){return an(this.flatCoordinates,0,this.flatCoordinates.length,this.stride)},kn.prototype.getSimplifiedGeometryInternal=function(t){const e=[];e.length=vn(this.flatCoordinates,0,this.flatCoordinates.length,this.stride,t,e,0);const i=new kn(null);return i.setFlatCoordinates(Vi.XY,e),i},kn.prototype.getType=function(){return Ot.LINEAR_RING},kn.prototype.intersectsExtent=function(t){},kn.prototype.setCoordinates=function(t,e){t?(this.setLayout(e,t,1),this.flatCoordinates||(this.flatCoordinates=[]),this.flatCoordinates.length=sn(this.flatCoordinates,0,t,this.stride),this.changed()):this.setFlatCoordinates(Vi.XY,null)},kn.prototype.setFlatCoordinates=function(t,e){this.setFlatCoordinatesInternal(t,e),this.changed()};var An=kn;function Gn(t,e,i,n,o,s,r){let a,h,l,c,u,p,d;const f=o[s+1],g=[];for(let o=0,s=i.length;o<s;++o){const s=i[o];for(c=t[s-n],p=t[s-n+1],a=e;a<s;a+=n)u=t[a],d=t[a+1],(f<=p&&d<=f||p<=f&&f<=d)&&(l=(f-p)/(d-p)*(u-c)+c,g.push(l)),c=u,p=d}let _=NaN,y=-1/0;for(g.sort(Wi),c=g[0],a=1,h=g.length;a<h;++a){u=g[a];const o=Math.abs(u-c);o>y&&fn(t,e,i,n,l=(c+u)/2,f)&&(_=l,y=o),c=u}return isNaN(_)&&(_=o[s]),r?(r.push(_,f,y),r):[_,f,y]}function Dn(t,e,i,n){for(;e<i-n;){for(let o=0;o<n;++o){const s=t[e+o];t[e+o]=t[i-n+o],t[i-n+o]=s}e+=n,i-=n}}function Nn(t,e,i,n){let o=0,s=t[i-n],r=t[i-n+1];for(;e<i;e+=n){const i=t[e],n=t[e+1];o+=(i-s)*(n+r),s=i,r=n}return o>0}function Yn(t,e,i,n,o){const s=void 0!==o&&o;for(let o=0,r=i.length;o<r;++o){const r=i[o],a=Nn(t,e,r,n);if(0===o){if(s&&a||!s&&!a)return!1}else if(s&&!a||!s&&a)return!1;e=r}return!0}function Xn(t,e,i,n,o){const s=void 0!==o&&o;for(let o=0,r=i.length;o<r;++o){const r=i[o],a=Nn(t,e,r,n);(0===o?s&&a||!s&&!a:s&&!a||!s&&a)&&Dn(t,e,r,n),e=r}return e}function zn(t,e,i,n,o){for(let s=0,r=i.length;s<r;++s)e=Xn(t,e,i[s],n,o);return e}const Wn=function(t,e){Ji.call(this),this.ends_=[],this.flatInteriorPointRevision_=-1,this.flatInteriorPoint_=null,this.maxDelta_=-1,this.maxDeltaRevision_=-1,this.orientedRevision_=-1,this.orientedFlatCoordinates_=null,this.setCoordinates(t,e)};a(Wn,Ji),Wn.prototype.appendLinearRing=function(t){this.flatCoordinates?ji(this.flatCoordinates,t.getFlatCoordinates()):this.flatCoordinates=t.getFlatCoordinates().slice(),this.ends_.push(this.flatCoordinates.length),this.changed()},Wn.prototype.clone=function(){const t=new Wn(null);return t.setFlatCoordinates(this.layout,this.flatCoordinates.slice(),this.ends_.slice()),t},Wn.prototype.closestPointXY=function(t,e,i,n){return n<Z(this.getExtent(),t,e)?n:(this.maxDeltaRevision_!=this.getRevision()&&(this.maxDelta_=Math.sqrt(tn(this.flatCoordinates,0,this.ends_,this.stride,0)),this.maxDeltaRevision_=this.getRevision()),nn(this.flatCoordinates,0,this.ends_,this.stride,this.maxDelta_,!0,t,e,i,n))},Wn.prototype.containsXY=function(t,e){return fn(this.getOrientedFlatCoordinates(),0,this.ends_,this.stride,t,e)},Wn.prototype.getArea=function(){return On(this.getOrientedFlatCoordinates(),0,this.ends_,this.stride)},Wn.prototype.getCoordinates=function(t){let e;return void 0!==t?Xn(e=this.getOrientedFlatCoordinates().slice(),0,this.ends_,this.stride,t):e=this.flatCoordinates,hn(e,0,this.ends_,this.stride)},Wn.prototype.getEnds=function(){return this.ends_},Wn.prototype.getFlatInteriorPoint=function(){if(this.flatInteriorPointRevision_!=this.getRevision()){const t=gt(this.getExtent());this.flatInteriorPoint_=Gn(this.getOrientedFlatCoordinates(),0,this.ends_,this.stride,t,0),this.flatInteriorPointRevision_=this.getRevision()}return this.flatInteriorPoint_},Wn.prototype.getInteriorPoint=function(){return new Pn(this.getFlatInteriorPoint(),Vi.XYM)},Wn.prototype.getLinearRingCount=function(){return this.ends_.length},Wn.prototype.getLinearRing=function(t){if(t<0||this.ends_.length<=t)return null;const e=new An(null);return e.setFlatCoordinates(this.layout,this.flatCoordinates.slice(0===t?0:this.ends_[t-1],this.ends_[t])),e},Wn.prototype.getLinearRings=function(){const t=this.layout,e=this.flatCoordinates,i=this.ends_,n=[];let o=0;for(let s=0,r=i.length;s<r;++s){const r=i[s],a=new An(null);a.setFlatCoordinates(t,e.slice(o,r)),n.push(a),o=r}return n},Wn.prototype.getOrientedFlatCoordinates=function(){if(this.orientedRevision_!=this.getRevision()){const t=this.flatCoordinates;Yn(t,0,this.ends_,this.stride)?this.orientedFlatCoordinates_=t:(this.orientedFlatCoordinates_=t.slice(),this.orientedFlatCoordinates_.length=Xn(this.orientedFlatCoordinates_,0,this.ends_,this.stride)),this.orientedRevision_=this.getRevision()}return this.orientedFlatCoordinates_},Wn.prototype.getSimplifiedGeometryInternal=function(t){const e=[],i=[];e.length=Tn(this.flatCoordinates,0,this.ends_,this.stride,Math.sqrt(t),e,0,i);const n=new Wn(null);return n.setFlatCoordinates(Vi.XY,e,i),n},Wn.prototype.getType=function(){return Ot.POLYGON},Wn.prototype.intersectsExtent=function(t){return yn(this.getOrientedFlatCoordinates(),0,this.ends_,this.stride,t)},Wn.prototype.setCoordinates=function(t,e){if(t){this.setLayout(e,t,2),this.flatCoordinates||(this.flatCoordinates=[]);const i=rn(this.flatCoordinates,0,t,this.stride,this.ends_);this.flatCoordinates.length=0===i.length?0:i[i.length-1],this.changed()}else this.setFlatCoordinates(Vi.XY,null,this.ends_)},Wn.prototype.setFlatCoordinates=function(t,e,i){this.setFlatCoordinatesInternal(t,e),this.ends_=i,this.changed()};var Kn=Wn;function Un(t){const e=t[0],i=t[1],n=t[2],o=t[3],s=[e,i,e,o,n,o,n,i,e,i],r=new Wn(null);return r.setFlatCoordinates(Vi.XY,s,[s.length]),r}function Bn(t,e,i){const n=e||32,o=t.getStride(),s=t.getLayout(),r=new Wn(null,s),a=o*(n+1),h=new Array(a);for(let t=0;t<a;t++)h[t]=0;const l=[h.length];return r.setFlatCoordinates(s,h,l),jn(r,t.getCenter(),t.getRadius(),i),r}function jn(t,e,i,n){const o=t.getFlatCoordinates(),s=t.getLayout(),r=t.getStride(),a=t.getEnds(),h=o.length/r-1,l=n||0;for(let t=0;t<=h;++t){const n=t*r,s=l+2*Mt(t,h)*Math.PI/h;o[n]=e[0]+i*Math.cos(s),o[n+1]=e[1]+i*Math.sin(s)}t.setFlatCoordinates(s,o,a)}const Hn=function(t,e){Ji.call(this),this.endss_=[],this.flatInteriorPointsRevision_=-1,this.flatInteriorPoints_=null,this.maxDelta_=-1,this.maxDeltaRevision_=-1,this.orientedRevision_=-1,this.orientedFlatCoordinates_=null,this.setCoordinates(t,e)};a(Hn,Ji),Hn.prototype.appendPolygon=function(t){let e;if(this.flatCoordinates){const i=this.flatCoordinates.length;ji(this.flatCoordinates,t.getFlatCoordinates());for(let n=0,o=(e=t.getEnds().slice()).length;n<o;++n)e[n]+=i}else this.flatCoordinates=t.getFlatCoordinates().slice(),e=t.getEnds().slice(),this.endss_.push();this.endss_.push(e),this.changed()},Hn.prototype.clone=function(){const t=new Hn(null),e=this.endss_.length,i=new Array(e);for(let t=0;t<e;++t)i[t]=this.endss_[t].slice();return t.setFlatCoordinates(this.layout,this.flatCoordinates.slice(),i),t},Hn.prototype.closestPointXY=function(t,e,i,n){return n<Z(this.getExtent(),t,e)?n:(this.maxDeltaRevision_!=this.getRevision()&&(this.maxDelta_=Math.sqrt(function(t,e,i,n,o){for(let s=0,r=i.length;s<r;++s){const r=i[s];o=tn(t,e,r,n,o),e=r[r.length-1]}return o}(this.flatCoordinates,0,this.endss_,this.stride,0)),this.maxDeltaRevision_=this.getRevision()),function(t,e,i,n,o,s,r,a,h,l,c){const u=c||[NaN,NaN];for(let c=0,p=i.length;c<p;++c){const p=i[c];l=nn(t,e,p,n,o,s,r,a,h,l,u),e=p[p.length-1]}return l}(this.getOrientedFlatCoordinates(),0,this.endss_,this.stride,this.maxDelta_,!0,t,e,i,n))},Hn.prototype.containsXY=function(t,e){return function(t,e,i,n,o,s){if(0===i.length)return!1;for(let r=0,a=i.length;r<a;++r){const a=i[r];if(fn(t,e,a,n,o,s))return!0;e=a[a.length-1]}return!1}(this.getOrientedFlatCoordinates(),0,this.endss_,this.stride,t,e)},Hn.prototype.getArea=function(){return function(t,e,i,n){let o=0;for(let s=0,r=i.length;s<r;++s){const r=i[s];o+=On(t,e,r,n),e=r[r.length-1]}return o}(this.getOrientedFlatCoordinates(),0,this.endss_,this.stride)},Hn.prototype.getCoordinates=function(t){let e;return void 0!==t?zn(e=this.getOrientedFlatCoordinates().slice(),0,this.endss_,this.stride,t):e=this.flatCoordinates,ln(e,0,this.endss_,this.stride)},Hn.prototype.getEndss=function(){return this.endss_},Hn.prototype.getFlatInteriorPoints=function(){if(this.flatInteriorPointsRevision_!=this.getRevision()){const t=function(t,e,i,n){const o=[];let s=[1/0,1/0,-1/0,-1/0];for(let r=0,a=i.length;r<a;++r){const a=i[r];s=ot(t,e,a[0],n),o.push((s[0]+s[2])/2,(s[1]+s[3])/2),e=a[a.length-1]}return o}(this.flatCoordinates,0,this.endss_,this.stride);this.flatInteriorPoints_=function(t,e,i,n,o){let s=[];for(let r=0,a=i.length;r<a;++r){const a=i[r];s=Gn(t,e,a,n,o,2*r,s),e=a[a.length-1]}return s}(this.getOrientedFlatCoordinates(),0,this.endss_,this.stride,t),this.flatInteriorPointsRevision_=this.getRevision()}return this.flatInteriorPoints_},Hn.prototype.getInteriorPoints=function(){const t=new Mn(null);return t.setFlatCoordinates(Vi.XYM,this.getFlatInteriorPoints().slice()),t},Hn.prototype.getOrientedFlatCoordinates=function(){if(this.orientedRevision_!=this.getRevision()){const t=this.flatCoordinates;!function(t,e,i,n,o){for(let s=0,r=i.length;s<r;++s)if(!Yn(t,e,i[s],n,o))return!1;return!0}(t,0,this.endss_,this.stride)?(this.orientedFlatCoordinates_=t.slice(),this.orientedFlatCoordinates_.length=zn(this.orientedFlatCoordinates_,0,this.endss_,this.stride)):this.orientedFlatCoordinates_=t,this.orientedRevision_=this.getRevision()}return this.orientedFlatCoordinates_},Hn.prototype.getSimplifiedGeometryInternal=function(t){const e=[],i=[];e.length=function(t,e,i,n,o,s,r,a){for(let h=0,l=i.length;h<l;++h){const l=i[h],c=[];r=Tn(t,e,l,n,o,s,r,c),a.push(c),e=l[l.length-1]}return r}(this.flatCoordinates,0,this.endss_,this.stride,Math.sqrt(t),e,0,i);const n=new Hn(null);return n.setFlatCoordinates(Vi.XY,e,i),n},Hn.prototype.getPolygon=function(t){if(t<0||this.endss_.length<=t)return null;let e;if(0===t)e=0;else{const i=this.endss_[t-1];e=i[i.length-1]}const i=this.endss_[t].slice(),n=i[i.length-1];if(0!==e)for(let t=0,n=i.length;t<n;++t)i[t]-=e;const o=new Kn(null);return o.setFlatCoordinates(this.layout,this.flatCoordinates.slice(e,n),i),o},Hn.prototype.getPolygons=function(){const t=this.layout,e=this.flatCoordinates,i=this.endss_,n=[];let o=0;for(let s=0,r=i.length;s<r;++s){const r=i[s].slice(),a=r[r.length-1];if(0!==o)for(let t=0,e=r.length;t<e;++t)r[t]-=o;const h=new Kn(null);h.setFlatCoordinates(t,e.slice(o,a),r),n.push(h),o=a}return n},Hn.prototype.getType=function(){return Ot.MULTI_POLYGON},Hn.prototype.intersectsExtent=function(t){return function(t,e,i,n,o){for(let s=0,r=i.length;s<r;++s){const r=i[s];if(yn(t,e,r,n,o))return!0;e=r[r.length-1]}return!1}(this.getOrientedFlatCoordinates(),0,this.endss_,this.stride,t)},Hn.prototype.setCoordinates=function(t,e){if(t){this.setLayout(e,t,3),this.flatCoordinates||(this.flatCoordinates=[]);const i=function(t,e,i,n,o){const s=o||[];let r=0;for(let o=0,a=i.length;o<a;++o){const a=rn(t,e,i[o],n,s[r]);s[r++]=a,e=a[a.length-1]}return s.length=r,s}(this.flatCoordinates,0,t,this.stride,this.endss_);if(0===i.length)this.flatCoordinates.length=0;else{const t=i[i.length-1];this.flatCoordinates.length=0===t.length?0:t[t.length-1]}this.changed()}else this.setFlatCoordinates(Vi.XY,null,this.endss_)},Hn.prototype.setFlatCoordinates=function(t,e,i){this.setFlatCoordinatesInternal(t,e),this.endss_=i,this.changed()},Hn.prototype.setPolygons=function(t){let e=this.getLayout();const i=[],n=[];for(let o=0,s=t.length;o<s;++o){const s=t[o];0===o&&(e=s.getLayout());const r=i.length,a=s.getEnds();for(let t=0,e=a.length;t<e;++t)a[t]+=r;ji(i,s.getFlatCoordinates()),n.push(a)}this.setFlatCoordinates(e,i,n)};var Vn=Hn;const Zn=function(t){const e=t||{};Ni.call(this),this.defaultDataProjection=se(e.defaultDataProjection?e.defaultDataProjection:\"EPSG:4326\"),e.featureProjection&&(this.defaultFeatureProjection=se(e.featureProjection)),this.geometryName_=e.geometryName,this.extractGeometryName_=e.extractGeometryName};a(Zn,Ni);const qn={Point:function(t){return new Pn(t.coordinates)},LineString:function(t){return new wn(t.coordinates)},Polygon:function(t){return new Kn(t.coordinates)},MultiPoint:function(t){return new Mn(t.coordinates)},MultiLineString:function(t){return new In(t.coordinates)},MultiPolygon:function(t){return new Vn(t.coordinates)},GeometryCollection:function(t,e){const i=t.geometries.map(function(t){return Qn(t,e)});return new zi(i)}},Jn={Point:function(t,e){return{type:\"Point\",coordinates:t.getCoordinates()}},LineString:function(t,e){return{type:\"LineString\",coordinates:t.getCoordinates()}},Polygon:function(t,e){let i;e&&(i=e.rightHanded);return{type:\"Polygon\",coordinates:t.getCoordinates(i)}},MultiPoint:function(t,e){return{type:\"MultiPoint\",coordinates:t.getCoordinates()}},MultiLineString:function(t,e){return{type:\"MultiLineString\",coordinates:t.getCoordinates()}},MultiPolygon:function(t,e){let i;e&&(i=e.rightHanded);return{type:\"MultiPolygon\",coordinates:t.getCoordinates(i)}},GeometryCollection:function(t,e){return{type:\"GeometryCollection\",geometries:t.getGeometriesArray().map(function(t){const i=d({},e);return delete i.featureProjection,$n(t,i)})}},Circle:function(t){return{type:\"GeometryCollection\",geometries:[]}}};function Qn(t,e){if(!t)return null;return ki((0,qn[t.type])(t),!1,e)}function $n(t,e){return(0,Jn[t.getType()])(ki(t,!0,e),e)}Zn.prototype.readFeature,Zn.prototype.readFeatures,Zn.prototype.readFeatureFromObject=function(t,e){let i=null;const n=Qn((i=\"Feature\"===t.type?t:{type:\"Feature\",geometry:t}).geometry,e),o=new Mi;return this.geometryName_?o.setGeometryName(this.geometryName_):this.extractGeometryName_&&void 0!==i.geometry_name&&o.setGeometryName(i.geometry_name),o.setGeometry(n),void 0!==i.id&&o.setId(i.id),i.properties&&o.setProperties(i.properties),o},Zn.prototype.readFeaturesFromObject=function(t,e){let i=null;if(\"FeatureCollection\"===t.type){i=[];const n=t.features;for(let t=0,o=n.length;t<o;++t)i.push(this.readFeatureFromObject(n[t],e))}else i=[this.readFeatureFromObject(t,e)];return i},Zn.prototype.readGeometry,Zn.prototype.readGeometryFromObject=function(t,e){return Qn(t,e)},Zn.prototype.readProjection,Zn.prototype.readProjectionFromObject=function(t){const e=t.crs;let i;return e?\"name\"==e.type?i=se(e.properties.name):p(!1,36):i=this.defaultDataProjection,i},Zn.prototype.writeFeature,Zn.prototype.writeFeatureObject=function(t,e){e=this.adaptOptions(e);const i={type:\"Feature\"},n=t.getId();void 0!==n&&(i.id=n);const o=t.getGeometry();i.geometry=o?$n(o,e):null;const s=t.getProperties();return delete s[t.getGeometryName()],_(s)?i.properties=null:i.properties=s,i},Zn.prototype.writeFeatures,Zn.prototype.writeFeaturesObject=function(t,e){e=this.adaptOptions(e);const i=[];for(let n=0,o=t.length;n<o;++n)i.push(this.writeFeatureObject(t[n],e));return{type:\"FeatureCollection\",features:i}},Zn.prototype.writeGeometry,Zn.prototype.writeGeometryObject=function(t,e){return $n(t,this.adaptOptions(e))};var to=Zn,eo=\"add\",io=\"remove\";const no=\"length\",oo=function(t,e){k.call(this,t),this.element=e};a(oo,k);const so=function(t,e){K.call(this);const i=e||{};if(this.unique_=!!i.unique,this.array_=t||[],this.unique_)for(let t=0,e=this.array_.length;t<e;++t)this.assertUnique_(this.array_[t],t);this.updateLength_()};a(so,K),so.prototype.clear=function(){for(;this.getLength()>0;)this.pop()},so.prototype.extend=function(t){for(let e=0,i=t.length;e<i;++e)this.push(t[e]);return this},so.prototype.forEach=function(t){const e=this.array_;for(let i=0,n=e.length;i<n;++i)t(e[i],i,e)},so.prototype.getArray=function(){return this.array_},so.prototype.item=function(t){return this.array_[t]},so.prototype.getLength=function(){return this.get(no)},so.prototype.insertAt=function(t,e){this.unique_&&this.assertUnique_(e),this.array_.splice(t,0,e),this.updateLength_(),this.dispatchEvent(new oo(eo,e))},so.prototype.pop=function(){return this.removeAt(this.getLength()-1)},so.prototype.push=function(t){this.unique_&&this.assertUnique_(t);const e=this.getLength();return this.insertAt(e,t),this.getLength()},so.prototype.remove=function(t){const e=this.array_;for(let i=0,n=e.length;i<n;++i)if(e[i]===t)return this.removeAt(i)},so.prototype.removeAt=function(t){const e=this.array_[t];return this.array_.splice(t,1),this.updateLength_(),this.dispatchEvent(new oo(io,e)),e},so.prototype.setAt=function(t,e){const i=this.getLength();if(t<i){this.unique_&&this.assertUnique_(e,t);const i=this.array_[t];this.array_[t]=e,this.dispatchEvent(new oo(io,i)),this.dispatchEvent(new oo(eo,e))}else{for(let e=i;e<t;++e)this.insertAt(e,void 0);this.insertAt(t,e)}},so.prototype.updateLength_=function(){this.set(no,this.array_.length)},so.prototype.assertUnique_=function(t,e){for(let i=0,n=this.array_.length;i<n;++i)if(this.array_[i]===t&&i!==e)throw new u(58)};var ro=so;const ao=function(t,e,i){k.call(this,t),this.map=e,this.frameState=void 0!==i?i:null};a(ao,k);var ho=ao;const lo=function(t,e,i,n,o){ho.call(this,t,e,o),this.originalEvent=i,this.pixel=e.getEventPixel(i),this.coordinate=e.getCoordinateFromPixel(this.pixel),this.dragging=void 0!==n&&n};a(lo,ho),lo.prototype.preventDefault=function(){ho.prototype.preventDefault.call(this),this.originalEvent.preventDefault()},lo.prototype.stopPropagation=function(){ho.prototype.stopPropagation.call(this),this.originalEvent.stopPropagation()};var co=lo,uo={SINGLECLICK:\"singleclick\",CLICK:w.CLICK,DBLCLICK:w.DBLCLICK,POINTERDRAG:\"pointerdrag\",POINTERMOVE:\"pointermove\",POINTERDOWN:\"pointerdown\",POINTERUP:\"pointerup\",POINTEROVER:\"pointerover\",POINTEROUT:\"pointerout\",POINTERENTER:\"pointerenter\",POINTERLEAVE:\"pointerleave\",POINTERCANCEL:\"pointercancel\"};const po=function(t,e,i,n,o){co.call(this,t,e,i.originalEvent,n,o),this.pointerEvent=i};a(po,co);var fo=po,go=\"pointermove\",_o=\"pointerdown\",yo=\"pointerup\",mo=\"pointerover\",vo=\"pointerout\",xo=\"pointerenter\",Co=\"pointerleave\",Eo=\"pointercancel\";const To=function(t,e){this.dispatcher=t,this.mapping_=e};To.prototype.getEvents=function(){return Object.keys(this.mapping_)},To.prototype.getHandlerForEvent=function(t){return this.mapping_[t]};var So=To;const wo=function(t){const e={mousedown:this.mousedown,mousemove:this.mousemove,mouseup:this.mouseup,mouseover:this.mouseover,mouseout:this.mouseout};So.call(this,t,e),this.pointerMap=t.pointerMap,this.lastTouches=[]};a(wo,So);const Ro=1,Io=\"mouse\";function Fo(t,e){const i=e.cloneEvent(t,t),n=i.preventDefault;return i.preventDefault=function(){t.preventDefault(),n()},i.pointerId=Ro,i.isPrimary=!0,i.pointerType=Io,i}wo.prototype.isEventSimulatedFromTouch_=function(t){const e=this.lastTouches,i=t.clientX,n=t.clientY;for(let t,o=0,s=e.length;o<s&&(t=e[o]);o++){const e=Math.abs(i-t[0]),o=Math.abs(n-t[1]);if(e<=25&&o<=25)return!0}return!1},wo.prototype.mousedown=function(t){if(!this.isEventSimulatedFromTouch_(t)){Ro.toString()in this.pointerMap&&this.cancel(t);const e=Fo(t,this.dispatcher);this.pointerMap[Ro.toString()]=t,this.dispatcher.down(e,t)}},wo.prototype.mousemove=function(t){if(!this.isEventSimulatedFromTouch_(t)){const e=Fo(t,this.dispatcher);this.dispatcher.move(e,t)}},wo.prototype.mouseup=function(t){if(!this.isEventSimulatedFromTouch_(t)){const e=this.pointerMap[Ro.toString()];if(e&&e.button===t.button){const e=Fo(t,this.dispatcher);this.dispatcher.up(e,t),this.cleanupMouse()}}},wo.prototype.mouseover=function(t){if(!this.isEventSimulatedFromTouch_(t)){const e=Fo(t,this.dispatcher);this.dispatcher.enterOver(e,t)}},wo.prototype.mouseout=function(t){if(!this.isEventSimulatedFromTouch_(t)){const e=Fo(t,this.dispatcher);this.dispatcher.leaveOut(e,t)}},wo.prototype.cancel=function(t){const e=Fo(t,this.dispatcher);this.dispatcher.cancel(e,t),this.cleanupMouse()},wo.prototype.cleanupMouse=function(){delete this.pointerMap[Ro.toString()]};var Po=wo;const Lo=function(t){const e={MSPointerDown:this.msPointerDown,MSPointerMove:this.msPointerMove,MSPointerUp:this.msPointerUp,MSPointerOut:this.msPointerOut,MSPointerOver:this.msPointerOver,MSPointerCancel:this.msPointerCancel,MSGotPointerCapture:this.msGotPointerCapture,MSLostPointerCapture:this.msLostPointerCapture};So.call(this,t,e),this.pointerMap=t.pointerMap};a(Lo,So);const Mo=[\"\",\"unavailable\",\"touch\",\"pen\",\"mouse\"];Lo.prototype.prepareEvent_=function(t){let e=t;return\"number\"==typeof t.pointerType&&((e=this.dispatcher.cloneEvent(t,t)).pointerType=Mo[t.pointerType]),e},Lo.prototype.cleanup=function(t){delete this.pointerMap[t.toString()]},Lo.prototype.msPointerDown=function(t){this.pointerMap[t.pointerId.toString()]=t;const e=this.prepareEvent_(t);this.dispatcher.down(e,t)},Lo.prototype.msPointerMove=function(t){const e=this.prepareEvent_(t);this.dispatcher.move(e,t)},Lo.prototype.msPointerUp=function(t){const e=this.prepareEvent_(t);this.dispatcher.up(e,t),this.cleanup(t.pointerId)},Lo.prototype.msPointerOut=function(t){const e=this.prepareEvent_(t);this.dispatcher.leaveOut(e,t)},Lo.prototype.msPointerOver=function(t){const e=this.prepareEvent_(t);this.dispatcher.enterOver(e,t)},Lo.prototype.msPointerCancel=function(t){const e=this.prepareEvent_(t);this.dispatcher.cancel(e,t),this.cleanup(t.pointerId)},Lo.prototype.msLostPointerCapture=function(t){const e=this.dispatcher.makeEvent(\"lostpointercapture\",t,t);this.dispatcher.dispatchEvent(e)},Lo.prototype.msGotPointerCapture=function(t){const e=this.dispatcher.makeEvent(\"gotpointercapture\",t,t);this.dispatcher.dispatchEvent(e)};var bo=Lo;const Oo=function(t){const e={pointerdown:this.pointerDown,pointermove:this.pointerMove,pointerup:this.pointerUp,pointerout:this.pointerOut,pointerover:this.pointerOver,pointercancel:this.pointerCancel,gotpointercapture:this.gotPointerCapture,lostpointercapture:this.lostPointerCapture};So.call(this,t,e)};a(Oo,So),Oo.prototype.pointerDown=function(t){this.dispatcher.fireNativeEvent(t)},Oo.prototype.pointerMove=function(t){this.dispatcher.fireNativeEvent(t)},Oo.prototype.pointerUp=function(t){this.dispatcher.fireNativeEvent(t)},Oo.prototype.pointerOut=function(t){this.dispatcher.fireNativeEvent(t)},Oo.prototype.pointerOver=function(t){this.dispatcher.fireNativeEvent(t)},Oo.prototype.pointerCancel=function(t){this.dispatcher.fireNativeEvent(t)},Oo.prototype.lostPointerCapture=function(t){this.dispatcher.fireNativeEvent(t)},Oo.prototype.gotPointerCapture=function(t){this.dispatcher.fireNativeEvent(t)};var ko=Oo;const Ao=function(t,e,i){k.call(this,t),this.originalEvent=e;const n=i||{};this.buttons=this.getButtons_(n),this.pressure=this.getPressure_(n,this.buttons),this.bubbles=\"bubbles\"in n&&n.bubbles,this.cancelable=\"cancelable\"in n&&n.cancelable,this.view=\"view\"in n?n.view:null,this.detail=\"detail\"in n?n.detail:null,this.screenX=\"screenX\"in n?n.screenX:0,this.screenY=\"screenY\"in n?n.screenY:0,this.clientX=\"clientX\"in n?n.clientX:0,this.clientY=\"clientY\"in n?n.clientY:0,this.ctrlKey=\"ctrlKey\"in n&&n.ctrlKey,this.altKey=\"altKey\"in n&&n.altKey,this.shiftKey=\"shiftKey\"in n&&n.shiftKey,this.metaKey=\"metaKey\"in n&&n.metaKey,this.button=\"button\"in n?n.button:0,this.relatedTarget=\"relatedTarget\"in n?n.relatedTarget:null,this.pointerId=\"pointerId\"in n?n.pointerId:0,this.width=\"width\"in n?n.width:0,this.height=\"height\"in n?n.height:0,this.tiltX=\"tiltX\"in n?n.tiltX:0,this.tiltY=\"tiltY\"in n?n.tiltY:0,this.pointerType=\"pointerType\"in n?n.pointerType:\"\",this.hwTimestamp=\"hwTimestamp\"in n?n.hwTimestamp:0,this.isPrimary=\"isPrimary\"in n&&n.isPrimary,e.preventDefault&&(this.preventDefault=function(){e.preventDefault()})};a(Ao,k);let Go=!1;Ao.prototype.getButtons_=function(t){let e;if(t.buttons||Go)e=t.buttons;else switch(t.which){case 1:e=1;break;case 2:e=4;break;case 3:e=2;break;default:e=0}return e},Ao.prototype.getPressure_=function(t,e){let i=0;return i=t.pressure?t.pressure:e?.5:0},function(){try{const t=new MouseEvent(\"click\",{buttons:1});Go=1===t.buttons}catch(t){}}();var Do=Ao;const No=function(t,e){const i={touchstart:this.touchstart,touchmove:this.touchmove,touchend:this.touchend,touchcancel:this.touchcancel};So.call(this,t,i),this.pointerMap=t.pointerMap,this.mouseSource=e,this.firstTouchId_=void 0,this.clickCount_=0,this.resetId_=void 0,this.dedupTimeout_=2500};a(No,So);No.prototype.isPrimaryTouch_=function(t){return this.firstTouchId_===t.identifier},No.prototype.setPrimaryTouch_=function(t){const e=Object.keys(this.pointerMap).length;(0===e||1===e&&Ro.toString()in this.pointerMap)&&(this.firstTouchId_=t.identifier,this.cancelResetClickCount_())},No.prototype.removePrimaryPointer_=function(t){t.isPrimary&&(this.firstTouchId_=void 0,this.resetClickCount_())},No.prototype.resetClickCount_=function(){this.resetId_=setTimeout(this.resetClickCountHandler_.bind(this),200)},No.prototype.resetClickCountHandler_=function(){this.clickCount_=0,this.resetId_=void 0},No.prototype.cancelResetClickCount_=function(){void 0!==this.resetId_&&clearTimeout(this.resetId_)},No.prototype.touchToPointer_=function(t,e){const i=this.dispatcher.cloneEvent(t,e);return i.pointerId=e.identifier+2,i.bubbles=!0,i.cancelable=!0,i.detail=this.clickCount_,i.button=0,i.buttons=1,i.width=e.webkitRadiusX||e.radiusX||0,i.height=e.webkitRadiusY||e.radiusY||0,i.pressure=e.webkitForce||e.force||.5,i.isPrimary=this.isPrimaryTouch_(e),i.pointerType=\"touch\",i.clientX=e.clientX,i.clientY=e.clientY,i.screenX=e.screenX,i.screenY=e.screenY,i},No.prototype.processTouches_=function(t,e){const i=Array.prototype.slice.call(t.changedTouches),n=i.length;function o(){t.preventDefault()}for(let s=0;s<n;++s){const n=this.touchToPointer_(t,i[s]);n.preventDefault=o,e.call(this,t,n)}},No.prototype.findTouch_=function(t,e){const i=t.length;for(let n=0;n<i;n++){if(t[n].identifier===e)return!0}return!1},No.prototype.vacuumTouches_=function(t){const e=t.touches,i=Object.keys(this.pointerMap),n=i.length;if(n>=e.length){const o=[];for(let t=0;t<n;++t){const n=i[t],s=this.pointerMap[n];n==Ro||this.findTouch_(e,n-2)||o.push(s.out)}for(let e=0;e<o.length;++e)this.cancelOut_(t,o[e])}},No.prototype.touchstart=function(t){this.vacuumTouches_(t),this.setPrimaryTouch_(t.changedTouches[0]),this.dedupSynthMouse_(t),this.clickCount_++,this.processTouches_(t,this.overDown_)},No.prototype.overDown_=function(t,e){this.pointerMap[e.pointerId]={target:e.target,out:e,outTarget:e.target},this.dispatcher.over(e,t),this.dispatcher.enter(e,t),this.dispatcher.down(e,t)},No.prototype.touchmove=function(t){t.preventDefault(),this.processTouches_(t,this.moveOverOut_)},No.prototype.moveOverOut_=function(t,e){const i=e,n=this.pointerMap[i.pointerId];if(!n)return;const o=n.out,s=n.outTarget;this.dispatcher.move(i,t),o&&s!==i.target&&(o.relatedTarget=i.target,i.relatedTarget=s,o.target=s,i.target?(this.dispatcher.leaveOut(o,t),this.dispatcher.enterOver(i,t)):(i.target=s,i.relatedTarget=null,this.cancelOut_(t,i))),n.out=i,n.outTarget=i.target},No.prototype.touchend=function(t){this.dedupSynthMouse_(t),this.processTouches_(t,this.upOut_)},No.prototype.upOut_=function(t,e){this.dispatcher.up(e,t),this.dispatcher.out(e,t),this.dispatcher.leave(e,t),this.cleanUpPointer_(e)},No.prototype.touchcancel=function(t){this.processTouches_(t,this.cancelOut_)},No.prototype.cancelOut_=function(t,e){this.dispatcher.cancel(e,t),this.dispatcher.out(e,t),this.dispatcher.leave(e,t),this.cleanUpPointer_(e)},No.prototype.cleanUpPointer_=function(t){delete this.pointerMap[t.pointerId],this.removePrimaryPointer_(t)},No.prototype.dedupSynthMouse_=function(t){const e=this.mouseSource.lastTouches,i=t.changedTouches[0];if(this.isPrimaryTouch_(i)){const t=[i.clientX,i.clientY];e.push(t),setTimeout(function(){!function(t,e){const i=t.indexOf(e),n=i>-1;n&&t.splice(i,1)}(e,t)},this.dedupTimeout_)}};var Yo=No;const Xo=function(t){G.call(this),this.element_=t,this.pointerMap={},this.eventMap_={},this.eventSourceList_=[],this.registerSources()};a(Xo,G);const zo=[[\"bubbles\",!1],[\"cancelable\",!1],[\"view\",null],[\"detail\",null],[\"screenX\",0],[\"screenY\",0],[\"clientX\",0],[\"clientY\",0],[\"ctrlKey\",!1],[\"altKey\",!1],[\"shiftKey\",!1],[\"metaKey\",!1],[\"button\",0],[\"relatedTarget\",null],[\"buttons\",0],[\"pointerId\",0],[\"width\",0],[\"height\",0],[\"pressure\",0],[\"tiltX\",0],[\"tiltY\",0],[\"pointerType\",\"\"],[\"hwTimestamp\",0],[\"isPrimary\",!1],[\"type\",\"\"],[\"target\",null],[\"currentTarget\",null],[\"which\",0]];Xo.prototype.registerSources=function(){if(je)this.registerSource(\"native\",new ko(this));else if(He)this.registerSource(\"ms\",new bo(this));else{const t=new Po(this);this.registerSource(\"mouse\",t),Be&&this.registerSource(\"touch\",new Yo(this,t))}this.register_()},Xo.prototype.registerSource=function(t,e){const i=e,n=i.getEvents();n&&(n.forEach(function(t){const e=i.getHandlerForEvent(t);e&&(this.eventMap_[t]=e.bind(i))}.bind(this)),this.eventSourceList_.push(i))},Xo.prototype.register_=function(){const t=this.eventSourceList_.length;for(let e=0;e<t;e++){const t=this.eventSourceList_[e];this.addEvents_(t.getEvents())}},Xo.prototype.unregister_=function(){const t=this.eventSourceList_.length;for(let e=0;e<t;e++){const t=this.eventSourceList_[e];this.removeEvents_(t.getEvents())}},Xo.prototype.eventHandler_=function(t){const e=t.type,i=this.eventMap_[e];i&&i(t)},Xo.prototype.addEvents_=function(t){t.forEach(function(t){C(this.element_,t,this.eventHandler_,this)}.bind(this))},Xo.prototype.removeEvents_=function(t){t.forEach(function(t){T(this.element_,t,this.eventHandler_,this)}.bind(this))},Xo.prototype.cloneEvent=function(t,e){const i={};for(let n=0,o=zo.length;n<o;n++){const o=zo[n][0];i[o]=t[o]||e[o]||zo[n][1]}return i},Xo.prototype.down=function(t,e){this.fireEvent(_o,t,e)},Xo.prototype.move=function(t,e){this.fireEvent(go,t,e)},Xo.prototype.up=function(t,e){this.fireEvent(yo,t,e)},Xo.prototype.enter=function(t,e){t.bubbles=!1,this.fireEvent(xo,t,e)},Xo.prototype.leave=function(t,e){t.bubbles=!1,this.fireEvent(Co,t,e)},Xo.prototype.over=function(t,e){t.bubbles=!0,this.fireEvent(mo,t,e)},Xo.prototype.out=function(t,e){t.bubbles=!0,this.fireEvent(vo,t,e)},Xo.prototype.cancel=function(t,e){this.fireEvent(Eo,t,e)},Xo.prototype.leaveOut=function(t,e){this.out(t,e),this.contains_(t.target,t.relatedTarget)||this.leave(t,e)},Xo.prototype.enterOver=function(t,e){this.over(t,e),this.contains_(t.target,t.relatedTarget)||this.enter(t,e)},Xo.prototype.contains_=function(t,e){return!(!t||!e)&&t.contains(e)},Xo.prototype.makeEvent=function(t,e,i){return new Do(t,i,e)},Xo.prototype.fireEvent=function(t,e,i){const n=this.makeEvent(t,e,i);this.dispatchEvent(n)},Xo.prototype.fireNativeEvent=function(t){const e=this.makeEvent(t.type,t,t);this.dispatchEvent(e)},Xo.prototype.wrapMouseEvent=function(t,e){return this.makeEvent(t,Po.prepareEvent(e,this),e)},Xo.prototype.disposeInternal=function(){this.unregister_(),G.prototype.disposeInternal.call(this)};var Wo=Xo;const Ko=function(t,e){G.call(this),this.map_=t,this.clickTimeoutId_=0,this.dragging_=!1,this.dragListenerKeys_=[],this.moveTolerance_=e?e*Ke:Ke,this.down_=null;const i=this.map_.getViewport();this.activePointers_=0,this.trackedTouches_={},this.pointerEventHandler_=new Wo(i),this.documentPointerEventHandler_=null,this.pointerdownListenerKey_=C(this.pointerEventHandler_,_o,this.handlePointerDown_,this),this.relayedListenerKey_=C(this.pointerEventHandler_,go,this.relayEvent_,this)};a(Ko,G),Ko.prototype.emulateClick_=function(t){let e=new fo(uo.CLICK,this.map_,t);this.dispatchEvent(e),0!==this.clickTimeoutId_?(clearTimeout(this.clickTimeoutId_),this.clickTimeoutId_=0,e=new fo(uo.DBLCLICK,this.map_,t),this.dispatchEvent(e)):this.clickTimeoutId_=setTimeout(function(){this.clickTimeoutId_=0;const e=new fo(uo.SINGLECLICK,this.map_,t);this.dispatchEvent(e)}.bind(this),250)},Ko.prototype.updateActivePointers_=function(t){const e=t;e.type==uo.POINTERUP||e.type==uo.POINTERCANCEL?delete this.trackedTouches_[e.pointerId]:e.type==uo.POINTERDOWN&&(this.trackedTouches_[e.pointerId]=!0),this.activePointers_=Object.keys(this.trackedTouches_).length},Ko.prototype.handlePointerUp_=function(t){this.updateActivePointers_(t);const e=new fo(uo.POINTERUP,this.map_,t);this.dispatchEvent(e),e.propagationStopped||this.dragging_||!this.isMouseActionButton_(t)||this.emulateClick_(this.down_),0===this.activePointers_&&(this.dragListenerKeys_.forEach(S),this.dragListenerKeys_.length=0,this.dragging_=!1,this.down_=null,this.documentPointerEventHandler_.dispose(),this.documentPointerEventHandler_=null)},Ko.prototype.isMouseActionButton_=function(t){return 0===t.button},Ko.prototype.handlePointerDown_=function(t){this.updateActivePointers_(t);const e=new fo(uo.POINTERDOWN,this.map_,t);this.dispatchEvent(e),this.down_=t,0===this.dragListenerKeys_.length&&(this.documentPointerEventHandler_=new Wo(document),this.dragListenerKeys_.push(C(this.documentPointerEventHandler_,uo.POINTERMOVE,this.handlePointerMove_,this),C(this.documentPointerEventHandler_,uo.POINTERUP,this.handlePointerUp_,this),C(this.pointerEventHandler_,uo.POINTERCANCEL,this.handlePointerUp_,this)))},Ko.prototype.handlePointerMove_=function(t){if(this.isMoving_(t)){this.dragging_=!0;const e=new fo(uo.POINTERDRAG,this.map_,t,this.dragging_);this.dispatchEvent(e)}t.preventDefault()},Ko.prototype.relayEvent_=function(t){const e=!(!this.down_||!this.isMoving_(t));this.dispatchEvent(new fo(t.type,this.map_,t,e))},Ko.prototype.isMoving_=function(t){return this.dragging_||Math.abs(t.clientX-this.down_.clientX)>this.moveTolerance_||Math.abs(t.clientY-this.down_.clientY)>this.moveTolerance_},Ko.prototype.disposeInternal=function(){this.relayedListenerKey_&&(S(this.relayedListenerKey_),this.relayedListenerKey_=null),this.pointerdownListenerKey_&&(S(this.pointerdownListenerKey_),this.pointerdownListenerKey_=null),this.dragListenerKeys_.forEach(S),this.dragListenerKeys_.length=0,this.documentPointerEventHandler_&&(this.documentPointerEventHandler_.dispose(),this.documentPointerEventHandler_=null),this.pointerEventHandler_&&(this.pointerEventHandler_.dispose(),this.pointerEventHandler_=null),G.prototype.disposeInternal.call(this)};var Uo=Ko,Bo=\"postrender\",jo=\"movestart\",Ho=\"moveend\",Vo={LAYERGROUP:\"layergroup\",SIZE:\"size\",TARGET:\"target\",VIEW:\"view\"},Zo=0,qo=1,Jo=2,Qo=3,$o=4,ts=5;const es=function(t,e){this.priorityFunction_=t,this.keyFunction_=e,this.elements_=[],this.priorities_=[],this.queuedElements_={}};es.prototype.clear=function(){this.elements_.length=0,this.priorities_.length=0,f(this.queuedElements_)},es.prototype.dequeue=function(){const t=this.elements_,e=this.priorities_,i=t[0];1==t.length?(t.length=0,e.length=0):(t[0]=t.pop(),e[0]=e.pop(),this.siftUp_(0));const n=this.keyFunction_(i);return delete this.queuedElements_[n],i},es.prototype.enqueue=function(t){p(!(this.keyFunction_(t)in this.queuedElements_),31);const e=this.priorityFunction_(t);return e!=1/0&&(this.elements_.push(t),this.priorities_.push(e),this.queuedElements_[this.keyFunction_(t)]=!0,this.siftDown_(0,this.elements_.length-1),!0)},es.prototype.getCount=function(){return this.elements_.length},es.prototype.getLeftChildIndex_=function(t){return 2*t+1},es.prototype.getRightChildIndex_=function(t){return 2*t+2},es.prototype.getParentIndex_=function(t){return t-1>>1},es.prototype.heapify_=function(){let t;for(t=(this.elements_.length>>1)-1;t>=0;t--)this.siftUp_(t)},es.prototype.isEmpty=function(){return 0===this.elements_.length},es.prototype.isKeyQueued=function(t){return t in this.queuedElements_},es.prototype.isQueued=function(t){return this.isKeyQueued(this.keyFunction_(t))},es.prototype.siftUp_=function(t){const e=this.elements_,i=this.priorities_,n=e.length,o=e[t],s=i[t],r=t;for(;t<n>>1;){const o=this.getLeftChildIndex_(t),s=this.getRightChildIndex_(t),r=s<n&&i[s]<i[o]?s:o;e[t]=e[r],i[t]=i[r],t=r}e[t]=o,i[t]=s,this.siftDown_(r,t)},es.prototype.siftDown_=function(t,e){const i=this.elements_,n=this.priorities_,o=i[e],s=n[e];for(;e>t;){const t=this.getParentIndex_(e);if(!(n[t]>s))break;i[e]=i[t],n[e]=n[t],e=t}i[e]=o,n[e]=s},es.prototype.reprioritize=function(){const t=this.priorityFunction_,e=this.elements_,i=this.priorities_;let n=0;const o=e.length;let s,r,a;for(r=0;r<o;++r)(a=t(s=e[r]))==1/0?delete this.queuedElements_[this.keyFunction_(s)]:(i[n]=a,e[n++]=s);e.length=n,i.length=n,this.heapify_()};var is=es;const ns=function(t,e){is.call(this,function(e){return t.apply(null,e)},function(t){return t[0].getKey()}),this.tileChangeCallback_=e,this.tilesLoading_=0,this.tilesLoadingKeys_={}};a(ns,is),ns.prototype.enqueue=function(t){const e=is.prototype.enqueue.call(this,t);if(e){C(t[0],w.CHANGE,this.handleTileChange,this)}return e},ns.prototype.getTilesLoading=function(){return this.tilesLoading_},ns.prototype.handleTileChange=function(t){const e=t.target,i=e.getState();if(i===Jo||i===Qo||i===$o||i===ts){T(e,w.CHANGE,this.handleTileChange,this);const t=e.getKey();t in this.tilesLoadingKeys_&&(delete this.tilesLoadingKeys_[t],--this.tilesLoading_),this.tileChangeCallback_()}},ns.prototype.loadMoreTiles=function(t,e){let i,n,o,s=0,r=!1;for(;this.tilesLoading_<t&&s<e&&this.getCount()>0;)o=(n=this.dequeue()[0]).getKey(),(i=n.getState())===ts?r=!0:i!==Zo||o in this.tilesLoadingKeys_||(this.tilesLoadingKeys_[o]=!0,++this.tilesLoading_,++s,n.load());0===s&&r&&this.tileChangeCallback_()};var os=ns;const ss=42,rs=256;function as(t){return t}function hs(t,e){return void 0!==t?0:void 0}function ls(t,e){return void 0!==t?t+e:void 0}var cs={ANIMATING:0,INTERACTING:1},us=\"center\",ps=\"resolution\",ds=\"rotation\";function fs(t,e){return t[0]+=e[0],t[1]+=e[1],t}function gs(t,e){const i=t[0],n=t[1],o=e[0],s=e[1],r=o[0],a=o[1],h=s[0],l=s[1],c=h-r,u=l-a,p=0===c&&0===u?0:(c*(i-r)+u*(n-a))/(c*c+u*u||0);let d,f;return p<=0?(d=r,f=a):p>=1?(d=h,f=l):(d=r+p*c,f=a+p*u),[d,f]}function _s(t,e){let i=!0;for(let n=t.length-1;n>=0;--n)if(t[n]!=e[n]){i=!1;break}return i}function ys(t,e){const i=Math.cos(e),n=Math.sin(e),o=t[0]*i-t[1]*n,s=t[1]*i+t[0]*n;return t[0]=o,t[1]=s,t}function ms(t,e){return t[0]*=e,t[1]*=e,t}function vs(t,e){const i=t[0]-e[0],n=t[1]-e[1];return i*i+n*n}function xs(t,e){return Math.sqrt(vs(t,e))}function Cs(t,e){return vs(t,gs(t,e))}function Es(t){return Math.pow(t,3)}function Ts(t){return 1-Es(1-t)}function Ss(t){return 3*t*t-2*t*t*t}function ws(t){return t}const Rs=0,Is=function(t){K.call(this);const e=d({},t);this.hints_=[0,0],this.animations_=[],this.updateAnimationKey_,this.updateAnimations_=this.updateAnimations_.bind(this),this.projection_=he(e.projection,\"EPSG:3857\"),this.applyOptions_(e)};function Fs(t){return!(t.sourceCenter&&t.targetCenter&&!_s(t.sourceCenter,t.targetCenter))&&(t.sourceResolution===t.targetResolution&&t.sourceRotation===t.targetRotation)}a(Is,K),Is.prototype.applyOptions_=function(t){const e={};e[us]=void 0!==t.center?t.center:null;const i=function(t){let e,i,n;let o=void 0!==t.minZoom?t.minZoom:Rs,s=void 0!==t.maxZoom?t.maxZoom:28;const r=void 0!==t.zoomFactor?t.zoomFactor:2;if(void 0!==t.resolutions){const r=t.resolutions;i=r[o],n=void 0!==r[s]?r[s]:r[r.length-1],r=r,e=function(t,e,i){if(void 0!==t){let n=Ui(r,t,i);n=Rt(n+e,0,r.length-1);const o=Math.floor(n);if(n!=o&&o<r.length-1){const t=r[o]/r[o+1];return r[o]/Math.pow(t,n-o)}return r[o]}}}else{const a=he(t.projection,\"EPSG:3857\"),h=a.getExtent(),l=h?Math.max(Ct(h),yt(h)):360*Dt[Nt.DEGREES]/a.getMetersPerUnit(),c=l/rs/Math.pow(2,Rs),u=c/Math.pow(2,28-Rs);void 0!==(i=t.maxResolution)?o=0:i=c/Math.pow(r,o),void 0===(n=t.minResolution)&&(n=void 0!==t.maxZoom?void 0!==t.maxResolution?i/Math.pow(r,s):c/Math.pow(r,s):u),s=o+Math.floor(Math.log(i/n)/Math.log(r)),n=i/Math.pow(r,s-o),e=function(t,e,i){return function(n,o,s){if(void 0!==n){const r=-s/2+.5,a=Math.floor(Math.log(e/n)/Math.log(t)+r);let h=Math.max(a+o,0);return void 0!==i&&(h=Math.min(h,i)),e/Math.pow(t,h)}}}(r,i,s-o)}var a;return{constraint:e,maxResolution:i,minResolution:n,minZoom:o,zoomFactor:r}}(t);this.maxResolution_=i.maxResolution,this.minResolution_=i.minResolution,this.zoomFactor_=i.zoomFactor,this.resolutions_=t.resolutions,this.minZoom_=i.minZoom;const n=function(t){return void 0!==t.extent?(e=t.extent,function(t){return t?[Rt(t[0],e[0],e[2]),Rt(t[1],e[1],e[3])]:void 0}):as;var e}(t),o=i.constraint,s=function(t){if(void 0===t.enableRotation||t.enableRotation){const e=t.constrainRotation;return void 0===e||!0===e?function(t){const e=t||Lt(5);return function(t,i){return void 0!==t?Math.abs(t+i)<=e?0:t+i:void 0}}():!1===e?ls:\"number\"==typeof e?function(t){const e=2*Math.PI/t;return function(t,i){return void 0!==t?t=Math.floor((t+i)/e+.5)*e:void 0}}(e):ls}return hs}(t);this.constraints_={center:n,resolution:o,rotation:s},void 0!==t.resolution?e[ps]=t.resolution:void 0!==t.zoom&&(e[ps]=this.constrainResolution(this.maxResolution_,t.zoom-this.minZoom_),this.resolutions_&&(e[ps]=Rt(Number(this.getResolution()||e[ps]),this.minResolution_,this.maxResolution_))),e[ds]=void 0!==t.rotation?t.rotation:0,this.setProperties(e),this.options_=t},Is.prototype.getUpdatedOptions_=function(t){const e=d({},this.options_);return void 0!==e.resolution?e.resolution=this.getResolution():e.zoom=this.getZoom(),e.center=this.getCenter(),e.rotation=this.getRotation(),d({},e,t)},Is.prototype.animate=function(t){let e,i=arguments.length;if(i>1&&\"function\"==typeof arguments[i-1]&&(e=arguments[i-1],--i),!this.isDef()){const t=arguments[i-1];return t.center&&this.setCenter(t.center),void 0!==t.zoom&&this.setZoom(t.zoom),void 0!==t.rotation&&this.setRotation(t.rotation),void(e&&setTimeout(function(){e(!0)},0))}let n=Date.now(),o=this.getCenter().slice(),s=this.getResolution(),r=this.getRotation();const a=[];for(let t=0;t<i;++t){const i=arguments[t],h={start:n,complete:!1,anchor:i.anchor,duration:void 0!==i.duration?i.duration:1e3,easing:i.easing||Ss};if(i.center&&(h.sourceCenter=o,h.targetCenter=i.center,o=h.targetCenter),void 0!==i.zoom?(h.sourceResolution=s,h.targetResolution=this.constrainResolution(this.maxResolution_,i.zoom-this.minZoom_,0),s=h.targetResolution):i.resolution&&(h.sourceResolution=s,h.targetResolution=i.resolution,s=h.targetResolution),void 0!==i.rotation){h.sourceRotation=r;const t=Mt(i.rotation-r+Math.PI,2*Math.PI)-Math.PI;h.targetRotation=r+t,r=h.targetRotation}h.callback=e,Fs(h)?h.complete=!0:n+=h.duration,a.push(h)}this.animations_.push(a),this.setHint(cs.ANIMATING,1),this.updateAnimations_()},Is.prototype.getAnimating=function(){return this.hints_[cs.ANIMATING]>0},Is.prototype.getInteracting=function(){return this.hints_[cs.INTERACTING]>0},Is.prototype.cancelAnimations=function(){this.setHint(cs.ANIMATING,-this.hints_[cs.ANIMATING]);for(let t=0,e=this.animations_.length;t<e;++t){const e=this.animations_[t];e[0].callback&&e[0].callback(!1)}this.animations_.length=0},Is.prototype.updateAnimations_=function(){if(void 0!==this.updateAnimationKey_&&(cancelAnimationFrame(this.updateAnimationKey_),this.updateAnimationKey_=void 0),!this.getAnimating())return;const t=Date.now();let e=!1;for(let i=this.animations_.length-1;i>=0;--i){const n=this.animations_[i];let o=!0;for(let i=0,s=n.length;i<s;++i){const s=n[i];if(s.complete)continue;const r=t-s.start;let a=s.duration>0?r/s.duration:1;a>=1?(s.complete=!0,a=1):o=!1;const h=s.easing(a);if(s.sourceCenter){const t=s.sourceCenter[0],e=s.sourceCenter[1],i=t+h*(s.targetCenter[0]-t),n=e+h*(s.targetCenter[1]-e);this.set(us,[i,n])}if(s.sourceResolution&&s.targetResolution){const t=1===h?s.targetResolution:s.sourceResolution+h*(s.targetResolution-s.sourceResolution);s.anchor&&this.set(us,this.calculateCenterZoom(t,s.anchor)),this.set(ps,t)}if(void 0!==s.sourceRotation&&void 0!==s.targetRotation){const t=1===h?Mt(s.targetRotation+Math.PI,2*Math.PI)-Math.PI:s.sourceRotation+h*(s.targetRotation-s.sourceRotation);s.anchor&&this.set(us,this.calculateCenterRotate(t,s.anchor)),this.set(ds,t)}if(e=!0,!s.complete)break}if(o){this.animations_[i]=null,this.setHint(cs.ANIMATING,-1);const t=n[0].callback;t&&setTimeout(function(){t(!0)},0)}}this.animations_=this.animations_.filter(Boolean),e&&void 0===this.updateAnimationKey_&&(this.updateAnimationKey_=requestAnimationFrame(this.updateAnimations_))},Is.prototype.calculateCenterRotate=function(t,e){let i;const n=this.getCenter();return void 0!==n&&(ys(i=[n[0]-e[0],n[1]-e[1]],t-this.getRotation()),fs(i,e)),i},Is.prototype.calculateCenterZoom=function(t,e){let i;const n=this.getCenter(),o=this.getResolution();if(void 0!==n&&void 0!==o){i=[e[0]-t*(e[0]-n[0])/o,e[1]-t*(e[1]-n[1])/o]}return i},Is.prototype.getSizeFromViewport_=function(){const t=[100,100],e='.ol-viewport[data-view=\"'+l(this)+'\"]',i=document.querySelector(e);if(i){const e=getComputedStyle(i);t[0]=parseInt(e.width,10),t[1]=parseInt(e.height,10)}return t},Is.prototype.constrainCenter=function(t){return this.constraints_.center(t)},Is.prototype.constrainResolution=function(t,e,i){const n=e||0,o=i||0;return this.constraints_.resolution(t,n,o)},Is.prototype.constrainRotation=function(t,e){const i=e||0;return this.constraints_.rotation(t,i)},Is.prototype.getCenter=function(){return this.get(us)},Is.prototype.getConstraints=function(){return this.constraints_},Is.prototype.getHints=function(t){return void 0!==t?(t[0]=this.hints_[0],t[1]=this.hints_[1],t):this.hints_.slice()},Is.prototype.calculateExtent=function(t){const e=t||this.getSizeFromViewport_(),i=this.getCenter();p(i,1);const n=this.getResolution();p(void 0!==n,2);const o=this.getRotation();return p(void 0!==o,3),_t(i,n,o,e)},Is.prototype.getMaxResolution=function(){return this.maxResolution_},Is.prototype.getMinResolution=function(){return this.minResolution_},Is.prototype.getMaxZoom=function(){return this.getZoomForResolution(this.minResolution_)},Is.prototype.setMaxZoom=function(t){this.applyOptions_(this.getUpdatedOptions_({maxZoom:t}))},Is.prototype.getMinZoom=function(){return this.getZoomForResolution(this.maxResolution_)},Is.prototype.setMinZoom=function(t){this.applyOptions_(this.getUpdatedOptions_({minZoom:t}))},Is.prototype.getProjection=function(){return this.projection_},Is.prototype.getResolution=function(){return this.get(ps)},Is.prototype.getResolutions=function(){return this.resolutions_},Is.prototype.getResolutionForExtent=function(t,e){const i=e||this.getSizeFromViewport_(),n=Ct(t)/i[0],o=yt(t)/i[1];return Math.max(n,o)},Is.prototype.getResolutionForValueFunction=function(t){const e=t||2,i=this.maxResolution_,n=this.minResolution_,o=Math.log(i/n)/Math.log(e);return function(t){return i/Math.pow(e,t*o)}},Is.prototype.getRotation=function(){return this.get(ds)},Is.prototype.getValueForResolutionFunction=function(t){const e=t||2,i=this.maxResolution_,n=this.minResolution_,o=Math.log(i/n)/Math.log(e);return function(t){return Math.log(i/t)/Math.log(e)/o}},Is.prototype.getState=function(){const t=this.getCenter(),e=this.getProjection(),i=this.getResolution(),n=this.getRotation();return{center:t.slice(),projection:void 0!==e?e:null,resolution:i,rotation:n,zoom:this.getZoom()}},Is.prototype.getZoom=function(){let t;const e=this.getResolution();return void 0!==e&&(t=this.getZoomForResolution(e)),t},Is.prototype.getZoomForResolution=function(t){let e,i,n=this.minZoom_||0;if(this.resolutions_){const o=Ui(this.resolutions_,t,1);n=o,e=this.resolutions_[o],i=o==this.resolutions_.length-1?2:e/this.resolutions_[o+1]}else e=this.maxResolution_,i=this.zoomFactor_;return n+Math.log(e/t)/Math.log(i)},Is.prototype.getResolutionForZoom=function(t){return this.constrainResolution(this.maxResolution_,t-this.minZoom_,0)},Is.prototype.fit=function(t,e){const i=e||{};let n,o=i.size;o||(o=this.getSizeFromViewport_()),t instanceof Ji?t.getType()===Ot.CIRCLE?(n=Un(t=t.getExtent())).rotate(this.getRotation(),gt(t)):n=t:(p(Array.isArray(t),24),p(!Tt(t),25),n=Un(t));const s=void 0!==i.padding?i.padding:[0,0,0,0],r=void 0===i.constrainResolution||i.constrainResolution,a=void 0!==i.nearest&&i.nearest;let h;h=void 0!==i.minResolution?i.minResolution:void 0!==i.maxZoom?this.constrainResolution(this.maxResolution_,i.maxZoom-this.minZoom_,0):0;const l=n.getFlatCoordinates(),c=this.getRotation(),u=Math.cos(-c);let d=Math.sin(-c),f=1/0,g=1/0,_=-1/0,y=-1/0;const m=n.getStride();for(let t=0,e=l.length;t<e;t+=m){const e=l[t]*u-l[t+1]*d,i=l[t]*d+l[t+1]*u;f=Math.min(f,e),g=Math.min(g,i),_=Math.max(_,e),y=Math.max(y,i)}let v=this.getResolutionForExtent([f,g,_,y],[o[0]-s[1]-s[3],o[1]-s[0]-s[2]]);if(v=isNaN(v)?h:Math.max(v,h),r){let t=this.constrainResolution(v,0,0);!a&&t<v&&(t=this.constrainResolution(t,-1,0)),v=t}d=-d;let x=(f+_)/2,C=(g+y)/2;const E=[(x+=(s[1]-s[3])/2*v)*u-(C+=(s[0]-s[2])/2*v)*d,C*u+x*d],T=i.callback?i.callback:P;void 0!==i.duration?this.animate({resolution:v,center:E,duration:i.duration,easing:i.easing},T):(this.setResolution(v),this.setCenter(E),setTimeout(T.bind(void 0,!0),0))},Is.prototype.centerOn=function(t,e,i){const n=this.getRotation(),o=Math.cos(-n);let s=Math.sin(-n),r=t[0]*o-t[1]*s,a=t[1]*o+t[0]*s;const h=this.getResolution(),l=(r+=(e[0]/2-i[0])*h)*o-(a+=(i[1]-e[1]/2)*h)*(s=-s),c=a*o+r*s;this.setCenter([l,c])},Is.prototype.isDef=function(){return!!this.getCenter()&&void 0!==this.getResolution()},Is.prototype.rotate=function(t,e){if(void 0!==e){const i=this.calculateCenterRotate(t,e);this.setCenter(i)}this.setRotation(t)},Is.prototype.setCenter=function(t){this.set(us,t),this.getAnimating()&&this.cancelAnimations()},Is.prototype.setHint=function(t,e){return this.hints_[t]+=e,this.changed(),this.hints_[t]},Is.prototype.setResolution=function(t){this.set(ps,t),this.getAnimating()&&this.cancelAnimations()},Is.prototype.setRotation=function(t){this.set(ds,t),this.getAnimating()&&this.cancelAnimations()},Is.prototype.setZoom=function(t){this.setResolution(this.getResolutionForZoom(t))};var Ps=Is,Ls=\"opacity\",Ms=\"visible\",bs=\"extent\",Os=\"zIndex\",ks=\"maxResolution\",As=\"minResolution\",Gs=\"source\";const Ds=function(t){K.call(this);const e=d({},t);e[Ls]=void 0!==t.opacity?t.opacity:1,e[Ms]=void 0===t.visible||t.visible,e[Os]=void 0!==t.zIndex?t.zIndex:0,e[ks]=void 0!==t.maxResolution?t.maxResolution:1/0,e[As]=void 0!==t.minResolution?t.minResolution:0,this.setProperties(e),this.state_={layer:this,managed:!0},this.type};a(Ds,K),Ds.prototype.getType=function(){return this.type},Ds.prototype.getLayerState=function(){return this.state_.opacity=Rt(this.getOpacity(),0,1),this.state_.sourceState=this.getSourceState(),this.state_.visible=this.getVisible(),this.state_.extent=this.getExtent(),this.state_.zIndex=this.getZIndex(),this.state_.maxResolution=this.getMaxResolution(),this.state_.minResolution=Math.max(this.getMinResolution(),0),this.state_},Ds.prototype.getLayersArray=function(t){},Ds.prototype.getLayerStatesArray=function(t){},Ds.prototype.getExtent=function(){return this.get(bs)},Ds.prototype.getMaxResolution=function(){return this.get(ks)},Ds.prototype.getMinResolution=function(){return this.get(As)},Ds.prototype.getOpacity=function(){return this.get(Ls)},Ds.prototype.getSourceState=function(){},Ds.prototype.getVisible=function(){return this.get(Ms)},Ds.prototype.getZIndex=function(){return this.get(Os)},Ds.prototype.setExtent=function(t){this.set(bs,t)},Ds.prototype.setMaxResolution=function(t){this.set(ks,t)},Ds.prototype.setMinResolution=function(t){this.set(As,t)},Ds.prototype.setOpacity=function(t){this.set(Ls,t)},Ds.prototype.setVisible=function(t){this.set(Ms,t)},Ds.prototype.setZIndex=function(t){this.set(Os,t)};var Ns=Ds,Ys=\"undefined\",Xs=\"ready\";const zs=\"layers\",Ws=function(t){const e=t||{},i=d({},e);delete i.layers;let n=e.layers;Ns.call(this,i),this.layersListenerKeys_=[],this.listenerKeys_={},C(this,W(zs),this.handleLayersChanged_,this),n?Array.isArray(n)?n=new ro(n.slice(),{unique:!0}):(p(n instanceof ro,43),n=n):n=new ro(void 0,{unique:!0}),this.setLayers(n)};a(Ws,Ns),Ws.prototype.handleLayerChange_=function(){this.changed()},Ws.prototype.handleLayersChanged_=function(t){this.layersListenerKeys_.forEach(S),this.layersListenerKeys_.length=0;const e=this.getLayers();this.layersListenerKeys_.push(C(e,eo,this.handleLayersAdd_,this),C(e,io,this.handleLayersRemove_,this));for(const t in this.listenerKeys_)this.listenerKeys_[t].forEach(S);f(this.listenerKeys_);const i=e.getArray();for(let t=0,e=i.length;t<e;t++){const e=i[t];this.listenerKeys_[l(e).toString()]=[C(e,R,this.handleLayerChange_,this),C(e,w.CHANGE,this.handleLayerChange_,this)]}this.changed()},Ws.prototype.handleLayersAdd_=function(t){const e=t.element,i=l(e).toString();this.listenerKeys_[i]=[C(e,R,this.handleLayerChange_,this),C(e,w.CHANGE,this.handleLayerChange_,this)],this.changed()},Ws.prototype.handleLayersRemove_=function(t){const e=l(t.element).toString();this.listenerKeys_[e].forEach(S),delete this.listenerKeys_[e],this.changed()},Ws.prototype.getLayers=function(){return this.get(zs)},Ws.prototype.setLayers=function(t){this.set(zs,t)},Ws.prototype.getLayersArray=function(t){const e=void 0!==t?t:[];return this.getLayers().forEach(function(t){t.getLayersArray(e)}),e},Ws.prototype.getLayerStatesArray=function(t){const e=void 0!==t?t:[],i=e.length;this.getLayers().forEach(function(t){t.getLayerStatesArray(e)});const n=this.getLayerState();for(let t=i,o=e.length;t<o;t++){const i=e[t];i.opacity*=n.opacity,i.visible=i.visible&&n.visible,i.maxResolution=Math.min(i.maxResolution,n.maxResolution),i.minResolution=Math.max(i.minResolution,n.minResolution),void 0!==n.extent&&(void 0!==i.extent?i.extent=mt(i.extent,n.extent):i.extent=n.extent)}return e},Ws.prototype.getSourceState=function(){return Xs};var Ks=Ws;function Us(t,e){return Array.isArray(t)?t:(void 0===e?e=[t,t]:e[0]=e[1]=t,e)}const Bs=function(t){K.call(this);const e=function(t){let e=null;void 0!==t.keyboardEventTarget&&(e=\"string\"==typeof t.keyboardEventTarget?document.getElementById(t.keyboardEventTarget):t.keyboardEventTarget);const i={},n=t.layers instanceof Ks?t.layers:new Ks({layers:t.layers});let o,s,r;i[Vo.LAYERGROUP]=n,i[Vo.TARGET]=t.target,i[Vo.VIEW]=void 0!==t.view?t.view:new Ps,void 0!==t.controls&&(Array.isArray(t.controls)?o=new ro(t.controls.slice()):(p(t.controls instanceof ro,47),o=t.controls));void 0!==t.interactions&&(Array.isArray(t.interactions)?s=new ro(t.interactions.slice()):(p(t.interactions instanceof ro,48),s=t.interactions));void 0!==t.overlays?Array.isArray(t.overlays)?r=new ro(t.overlays.slice()):(p(t.overlays instanceof ro,49),r=t.overlays):r=new ro;return{controls:o,interactions:s,keyboardEventTarget:e,overlays:r,values:i}}(t);this.maxTilesLoading_=void 0!==t.maxTilesLoading?t.maxTilesLoading:16,this.loadTilesWhileAnimating_=void 0!==t.loadTilesWhileAnimating&&t.loadTilesWhileAnimating,this.loadTilesWhileInteracting_=void 0!==t.loadTilesWhileInteracting&&t.loadTilesWhileInteracting,this.pixelRatio_=void 0!==t.pixelRatio?t.pixelRatio:Ke,this.animationDelayKey_,this.animationDelay_=function(){this.animationDelayKey_=void 0,this.renderFrame_.call(this,Date.now())}.bind(this),this.coordinateToPixelTransform_=[1,0,0,1,0,0],this.pixelToCoordinateTransform_=[1,0,0,1,0,0],this.frameIndex_=0,this.frameState_=null,this.previousExtent_=null,this.viewPropertyListenerKey_=null,this.viewChangeListenerKey_=null,this.layerGroupPropertyListenerKeys_=null,this.viewport_=document.createElement(\"DIV\"),this.viewport_.className=\"ol-viewport\"+(Be?\" ol-touch\":\"\"),this.viewport_.style.position=\"relative\",this.viewport_.style.overflow=\"hidden\",this.viewport_.style.width=\"100%\",this.viewport_.style.height=\"100%\",this.viewport_.style.msTouchAction=\"none\",this.viewport_.style.touchAction=\"none\",this.overlayContainer_=document.createElement(\"DIV\"),this.overlayContainer_.className=\"ol-overlaycontainer\",this.viewport_.appendChild(this.overlayContainer_),this.overlayContainerStopEvent_=document.createElement(\"DIV\"),this.overlayContainerStopEvent_.className=\"ol-overlaycontainer-stopevent\";const i=[w.CLICK,w.DBLCLICK,w.MOUSEDOWN,w.TOUCHSTART,w.MSPOINTERDOWN,uo.POINTERDOWN,w.MOUSEWHEEL,w.WHEEL];for(let t=0,e=i.length;t<e;++t)C(this.overlayContainerStopEvent_,i[t],O);this.viewport_.appendChild(this.overlayContainerStopEvent_),this.mapBrowserEventHandler_=new Uo(this,t.moveTolerance);for(const t in uo)C(this.mapBrowserEventHandler_,uo[t],this.handleMapBrowserEvent,this);this.keyboardEventTarget_=e.keyboardEventTarget,this.keyHandlerKeys_=null,C(this.viewport_,w.CONTEXTMENU,this.handleBrowserEvent,this),C(this.viewport_,w.WHEEL,this.handleBrowserEvent,this),C(this.viewport_,w.MOUSEWHEEL,this.handleBrowserEvent,this),this.controls=e.controls||new ro,this.interactions=e.interactions||new ro,this.overlays_=e.overlays,this.overlayIdIndex_={},this.renderer_=this.createRenderer(this.viewport_,this),this.handleResize_,this.focus_=null,this.postRenderFunctions_=[],this.tileQueue_=new os(this.getTilePriority.bind(this),this.handleTileChange_.bind(this)),this.skippedFeatureUids_={},C(this,W(Vo.LAYERGROUP),this.handleLayerGroupChanged_,this),C(this,W(Vo.VIEW),this.handleViewChanged_,this),C(this,W(Vo.SIZE),this.handleSizeChanged_,this),C(this,W(Vo.TARGET),this.handleTargetChanged_,this),this.setProperties(e.values),this.controls.forEach(function(t){t.setMap(this)}.bind(this)),C(this.controls,eo,function(t){t.element.setMap(this)},this),C(this.controls,io,function(t){t.element.setMap(null)},this),this.interactions.forEach(function(t){t.setMap(this)}.bind(this)),C(this.interactions,eo,function(t){t.element.setMap(this)},this),C(this.interactions,io,function(t){t.element.setMap(null)},this),this.overlays_.forEach(this.addOverlayInternal_.bind(this)),C(this.overlays_,eo,function(t){this.addOverlayInternal_(t.element)},this),C(this.overlays_,io,function(t){const e=t.element.getId();void 0!==e&&delete this.overlayIdIndex_[e.toString()],t.element.setMap(null)},this)};a(Bs,K),Bs.prototype.createRenderer=function(){throw new Error(\"Use a map type that has a createRenderer method\")},Bs.prototype.addControl=function(t){this.getControls().push(t)},Bs.prototype.addInteraction=function(t){this.getInteractions().push(t)},Bs.prototype.addLayer=function(t){this.getLayerGroup().getLayers().push(t)},Bs.prototype.addOverlay=function(t){this.getOverlays().push(t)},Bs.prototype.addOverlayInternal_=function(t){const e=t.getId();void 0!==e&&(this.overlayIdIndex_[e.toString()]=t),t.setMap(this)},Bs.prototype.disposeInternal=function(){this.mapBrowserEventHandler_.dispose(),T(this.viewport_,w.CONTEXTMENU,this.handleBrowserEvent,this),T(this.viewport_,w.WHEEL,this.handleBrowserEvent,this),T(this.viewport_,w.MOUSEWHEEL,this.handleBrowserEvent,this),void 0!==this.handleResize_&&(removeEventListener(w.RESIZE,this.handleResize_,!1),this.handleResize_=void 0),this.animationDelayKey_&&(cancelAnimationFrame(this.animationDelayKey_),this.animationDelayKey_=void 0),this.setTarget(null),K.prototype.disposeInternal.call(this)},Bs.prototype.forEachFeatureAtPixel=function(t,e,i){if(!this.frameState_)return;const n=this.getCoordinateFromPixel(t),o=void 0!==(i=void 0!==i?i:{}).hitTolerance?i.hitTolerance*this.frameState_.pixelRatio:0,s=void 0!==i.layerFilter?i.layerFilter:I;return this.renderer_.forEachFeatureAtCoordinate(n,this.frameState_,o,e,null,s,null)},Bs.prototype.getFeaturesAtPixel=function(t,e){let i=null;return this.forEachFeatureAtPixel(t,function(t){i||(i=[]),i.push(t)},e),i},Bs.prototype.forEachLayerAtPixel=function(t,e,i,n,o){if(!this.frameState_)return;const s=void 0!==i?i:null,r=void 0!==n?n:I,a=void 0!==o?o:null;return this.renderer_.forEachLayerAtPixel(t,this.frameState_,e,s,r,a)},Bs.prototype.hasFeatureAtPixel=function(t,e){if(!this.frameState_)return!1;const i=this.getCoordinateFromPixel(t),n=void 0!==(e=void 0!==e?e:{}).layerFilter?e.layerFilter:I,o=void 0!==e.hitTolerance?e.hitTolerance*this.frameState_.pixelRatio:0;return this.renderer_.hasFeatureAtCoordinate(i,this.frameState_,o,n,null)},Bs.prototype.getEventCoordinate=function(t){return this.getCoordinateFromPixel(this.getEventPixel(t))},Bs.prototype.getEventPixel=function(t){const e=this.viewport_.getBoundingClientRect(),i=t.changedTouches?t.changedTouches[0]:t;return[i.clientX-e.left,i.clientY-e.top]},Bs.prototype.getTarget=function(){return this.get(Vo.TARGET)},Bs.prototype.getTargetElement=function(){const t=this.getTarget();return void 0!==t?\"string\"==typeof t?document.getElementById(t):t:null},Bs.prototype.getCoordinateFromPixel=function(t){const e=this.frameState_;return e?xe(e.pixelToCoordinateTransform,t.slice()):null},Bs.prototype.getControls=function(){return this.controls},Bs.prototype.getOverlays=function(){return this.overlays_},Bs.prototype.getOverlayById=function(t){const e=this.overlayIdIndex_[t.toString()];return void 0!==e?e:null},Bs.prototype.getInteractions=function(){return this.interactions},Bs.prototype.getLayerGroup=function(){return this.get(Vo.LAYERGROUP)},Bs.prototype.getLayers=function(){return this.getLayerGroup().getLayers()},Bs.prototype.getPixelFromCoordinate=function(t){const e=this.frameState_;return e?xe(e.coordinateToPixelTransform,t.slice(0,2)):null},Bs.prototype.getRenderer=function(){return this.renderer_},Bs.prototype.getSize=function(){return this.get(Vo.SIZE)},Bs.prototype.getView=function(){return this.get(Vo.VIEW)},Bs.prototype.getViewport=function(){return this.viewport_},Bs.prototype.getOverlayContainer=function(){return this.overlayContainer_},Bs.prototype.getOverlayContainerStopEvent=function(){return this.overlayContainerStopEvent_},Bs.prototype.getTilePriority=function(t,e,i,n){const o=this.frameState_;if(!(o&&e in o.wantedTiles))return 1/0;if(!o.wantedTiles[e][t.getKey()])return 1/0;const s=i[0]-o.focus[0],r=i[1]-o.focus[1];return 65536*Math.log(n)+Math.sqrt(s*s+r*r)/n},Bs.prototype.handleBrowserEvent=function(t,e){const i=e||t.type,n=new co(i,this,t);this.handleMapBrowserEvent(n)},Bs.prototype.handleMapBrowserEvent=function(t){if(!this.frameState_)return;this.focus_=t.coordinate,t.frameState=this.frameState_;const e=this.getInteractions().getArray();if(!1!==this.dispatchEvent(t))for(let i=e.length-1;i>=0;i--){const n=e[i];if(n.getActive()&&!n.handleEvent(t))break}},Bs.prototype.handlePostRender=function(){const t=this.frameState_,e=this.tileQueue_;if(!e.isEmpty()){let i=this.maxTilesLoading_,n=i;if(t){const e=t.viewHints;e[cs.ANIMATING]&&(i=this.loadTilesWhileAnimating_?8:0,n=2),e[cs.INTERACTING]&&(i=this.loadTilesWhileInteracting_?8:0,n=2)}e.getTilesLoading()<i&&(e.reprioritize(),e.loadMoreTiles(i,n))}const i=this.postRenderFunctions_;for(let e=0,n=i.length;e<n;++e)i[e](this,t);i.length=0},Bs.prototype.handleSizeChanged_=function(){this.render()},Bs.prototype.handleTargetChanged_=function(){let t;if(this.getTarget()&&(t=this.getTargetElement()),this.keyHandlerKeys_){for(let t=0,e=this.keyHandlerKeys_.length;t<e;++t)S(this.keyHandlerKeys_[t]);this.keyHandlerKeys_=null}if(t){t.appendChild(this.viewport_);const e=this.keyboardEventTarget_?this.keyboardEventTarget_:t;this.keyHandlerKeys_=[C(e,w.KEYDOWN,this.handleBrowserEvent,this),C(e,w.KEYPRESS,this.handleBrowserEvent,this)],this.handleResize_||(this.handleResize_=this.updateSize.bind(this),addEventListener(w.RESIZE,this.handleResize_,!1))}else this.renderer_.removeLayerRenderers(),Ge(this.viewport_),void 0!==this.handleResize_&&(removeEventListener(w.RESIZE,this.handleResize_,!1),this.handleResize_=void 0);this.updateSize()},Bs.prototype.handleTileChange_=function(){this.render()},Bs.prototype.handleViewPropertyChanged_=function(){this.render()},Bs.prototype.handleViewChanged_=function(){this.viewPropertyListenerKey_&&(S(this.viewPropertyListenerKey_),this.viewPropertyListenerKey_=null),this.viewChangeListenerKey_&&(S(this.viewChangeListenerKey_),this.viewChangeListenerKey_=null);const t=this.getView();t&&(this.viewport_.setAttribute(\"data-view\",l(t)),this.viewPropertyListenerKey_=C(t,R,this.handleViewPropertyChanged_,this),this.viewChangeListenerKey_=C(t,w.CHANGE,this.handleViewPropertyChanged_,this)),this.render()},Bs.prototype.handleLayerGroupChanged_=function(){this.layerGroupPropertyListenerKeys_&&(this.layerGroupPropertyListenerKeys_.forEach(S),this.layerGroupPropertyListenerKeys_=null);const t=this.getLayerGroup();t&&(this.layerGroupPropertyListenerKeys_=[C(t,R,this.render,this),C(t,w.CHANGE,this.render,this)]),this.render()},Bs.prototype.isRendered=function(){return!!this.frameState_},Bs.prototype.renderSync=function(){this.animationDelayKey_&&cancelAnimationFrame(this.animationDelayKey_),this.animationDelay_()},Bs.prototype.render=function(){void 0===this.animationDelayKey_&&(this.animationDelayKey_=requestAnimationFrame(this.animationDelay_))},Bs.prototype.removeControl=function(t){return this.getControls().remove(t)},Bs.prototype.removeInteraction=function(t){return this.getInteractions().remove(t)},Bs.prototype.removeLayer=function(t){return this.getLayerGroup().getLayers().remove(t)},Bs.prototype.removeOverlay=function(t){return this.getOverlays().remove(t)},Bs.prototype.renderFrame_=function(t){let e;const i=this.getSize(),n=this.getView(),o=[1/0,1/0,-1/0,-1/0],s=this.frameState_;let r=null;if(void 0!==i&&function(t){return t[0]>0&&t[1]>0}(i)&&n&&n.isDef()){const s=n.getHints(this.frameState_?this.frameState_.viewHints:void 0),a=this.getLayerGroup().getLayerStatesArray(),h={};for(let t=0,e=a.length;t<e;++t)h[l(a[t].layer)]=a[t];e=n.getState();let c=this.focus_;if(!c){c=e.center;const t=e.resolution/this.pixelRatio_;c[0]=Math.round(c[0]/t)*t,c[1]=Math.round(c[1]/t)*t}r={animate:!1,coordinateToPixelTransform:this.coordinateToPixelTransform_,extent:o,focus:c,index:this.frameIndex_++,layerStates:h,layerStatesArray:a,pixelRatio:this.pixelRatio_,pixelToCoordinateTransform:this.pixelToCoordinateTransform_,postRenderFunctions:[],size:i,skippedFeatureUids:this.skippedFeatureUids_,tileQueue:this.tileQueue_,time:t,usedTiles:{},viewState:e,viewHints:s,wantedTiles:{}}}if(r&&(r.extent=_t(e.center,e.resolution,e.rotation,r.size,o)),this.frameState_=r,this.renderer_.renderFrame(r),r){if(r.animate&&this.render(),Array.prototype.push.apply(this.postRenderFunctions_,r.postRenderFunctions),s){(!this.previousExtent_||!Tt(this.previousExtent_)&&!st(r.extent,this.previousExtent_))&&(this.dispatchEvent(new ho(jo,this,s)),this.previousExtent_=it(this.previousExtent_))}this.previousExtent_&&!r.viewHints[cs.ANIMATING]&&!r.viewHints[cs.INTERACTING]&&!st(r.extent,this.previousExtent_)&&(this.dispatchEvent(new ho(Ho,this,r)),V(r.extent,this.previousExtent_))}this.dispatchEvent(new ho(Bo,this,r)),setTimeout(this.handlePostRender.bind(this),0)},Bs.prototype.setLayerGroup=function(t){this.set(Vo.LAYERGROUP,t)},Bs.prototype.setSize=function(t){this.set(Vo.SIZE,t)},Bs.prototype.setTarget=function(t){this.set(Vo.TARGET,t)},Bs.prototype.setView=function(t){this.set(Vo.VIEW,t)},Bs.prototype.skipFeature=function(t){const e=l(t).toString();this.skippedFeatureUids_[e]=!0,this.render()},Bs.prototype.updateSize=function(){const t=this.getTargetElement();if(t){const e=getComputedStyle(t);this.setSize([t.offsetWidth-parseFloat(e.borderLeftWidth)-parseFloat(e.paddingLeft)-parseFloat(e.paddingRight)-parseFloat(e.borderRightWidth),t.offsetHeight-parseFloat(e.borderTopWidth)-parseFloat(e.paddingTop)-parseFloat(e.paddingBottom)-parseFloat(e.borderBottomWidth)])}else this.setSize(void 0)},Bs.prototype.unskipFeature=function(t){const e=l(t).toString();delete this.skippedFeatureUids_[e],this.render()};var js=Bs;const Hs=function(t){K.call(this),this.element=t.element?t.element:null,this.target_=null,this.map_=null,this.listenerKeys=[],this.render=t.render?t.render:P,t.target&&this.setTarget(t.target)};a(Hs,K),Hs.prototype.disposeInternal=function(){Ge(this.element),K.prototype.disposeInternal.call(this)},Hs.prototype.getMap=function(){return this.map_},Hs.prototype.setMap=function(t){this.map_&&Ge(this.element);for(let t=0,e=this.listenerKeys.length;t<e;++t)S(this.listenerKeys[t]);if(this.listenerKeys.length=0,this.map_=t,this.map_){(this.target_?this.target_:t.getOverlayContainerStopEvent()).appendChild(this.element),this.render!==P&&this.listenerKeys.push(C(t,Bo,this.render,this)),t.render()}},Hs.prototype.setTarget=function(t){this.target_=\"string\"==typeof t?document.getElementById(t):t};var Vs=Hs,Zs=\"postcompose\",qs=\"precompose\",Js=\"render\";const Qs=function(t){const e=d({},t);delete e.source,Ns.call(this,e),this.mapPrecomposeKey_=null,this.mapRenderKey_=null,this.sourceChangeKey_=null,t.map&&this.setMap(t.map),C(this,W(Gs),this.handleSourcePropertyChange_,this);const i=t.source?t.source:null;this.setSource(i)};function $s(t,e){return t.visible&&e>=t.minResolution&&e<t.maxResolution}a(Qs,Ns),Qs.prototype.getLayersArray=function(t){const e=t||[];return e.push(this),e},Qs.prototype.getLayerStatesArray=function(t){const e=t||[];return e.push(this.getLayerState()),e},Qs.prototype.getSource=function(){return this.get(Gs)||null},Qs.prototype.getSourceState=function(){const t=this.getSource();return t?t.getState():Ys},Qs.prototype.handleSourceChange_=function(){this.changed()},Qs.prototype.handleSourcePropertyChange_=function(){this.sourceChangeKey_&&(S(this.sourceChangeKey_),this.sourceChangeKey_=null);const t=this.getSource();t&&(this.sourceChangeKey_=C(t,w.CHANGE,this.handleSourceChange_,this)),this.changed()},Qs.prototype.setMap=function(t){this.mapPrecomposeKey_&&(S(this.mapPrecomposeKey_),this.mapPrecomposeKey_=null),t||this.changed(),this.mapRenderKey_&&(S(this.mapRenderKey_),this.mapRenderKey_=null),t&&(this.mapPrecomposeKey_=C(t,qs,function(t){const e=this.getLayerState();e.managed=!1,e.zIndex=1/0,t.frameState.layerStatesArray.push(e),t.frameState.layerStates[l(this)]=e},this),this.mapRenderKey_=C(this,w.CHANGE,t.render,t),this.changed())},Qs.prototype.setSource=function(t){this.set(Gs,t)};var tr=Qs;const er=function(t){const e=t||{};this.ulElement_=document.createElement(\"UL\"),this.collapsed_=void 0===e.collapsed||e.collapsed,this.collapsible_=void 0===e.collapsible||e.collapsible,this.collapsible_||(this.collapsed_=!1);const i=void 0!==e.className?e.className:\"ol-attribution\",n=void 0!==e.tipLabel?e.tipLabel:\"Attributions\",o=void 0!==e.collapseLabel?e.collapseLabel:\"\";\"string\"==typeof o?(this.collapseLabel_=document.createElement(\"span\"),this.collapseLabel_.textContent=o):this.collapseLabel_=o;const s=void 0!==e.label?e.label:\"i\";\"string\"==typeof s?(this.label_=document.createElement(\"span\"),this.label_.textContent=s):this.label_=s;const r=this.collapsible_&&!this.collapsed_?this.collapseLabel_:this.label_,a=document.createElement(\"button\");a.setAttribute(\"type\",\"button\"),a.title=n,a.appendChild(r),C(a,w.CLICK,this.handleClick_,this);const h=i+\" ol-unselectable ol-control\"+(this.collapsed_&&this.collapsible_?\" ol-collapsed\":\"\")+(this.collapsible_?\"\":\" ol-uncollapsible\"),l=document.createElement(\"div\");l.className=h,l.appendChild(this.ulElement_),l.appendChild(a),Vs.call(this,{element:l,render:e.render||ir,target:e.target}),this.renderedAttributions_=[],this.renderedVisible_=!0};function ir(t){this.updateElement_(t.frameState)}a(er,Vs),er.prototype.getSourceAttributions_=function(t){const e={},i=[],n=t.layerStatesArray,o=t.viewState.resolution;for(let s=0,r=n.length;s<r;++s){const r=n[s];if(!$s(r,o))continue;const a=r.layer.getSource();if(!a)continue;const h=a.getAttributions();if(!h)continue;const l=h(t);if(l)if(Array.isArray(l))for(let t=0,n=l.length;t<n;++t)l[t]in e||(i.push(l[t]),e[l[t]]=!0);else l in e||(i.push(l),e[l]=!0)}return i},er.prototype.updateElement_=function(t){if(!t)return void(this.renderedVisible_&&(this.element.style.display=\"none\",this.renderedVisible_=!1));const e=this.getSourceAttributions_(t),i=e.length>0;if(this.renderedVisible_!=i&&(this.element.style.display=i?\"\":\"none\",this.renderedVisible_=i),!Hi(e,this.renderedAttributions_)){De(this.ulElement_);for(let t=0,i=e.length;t<i;++t){const i=document.createElement(\"LI\");i.innerHTML=e[t],this.ulElement_.appendChild(i)}this.renderedAttributions_=e}},er.prototype.handleClick_=function(t){t.preventDefault(),this.handleToggle_()},er.prototype.handleToggle_=function(){this.element.classList.toggle(\"ol-collapsed\"),this.collapsed_?Ae(this.collapseLabel_,this.label_):Ae(this.label_,this.collapseLabel_),this.collapsed_=!this.collapsed_},er.prototype.getCollapsible=function(){return this.collapsible_},er.prototype.setCollapsible=function(t){this.collapsible_!==t&&(this.collapsible_=t,this.element.classList.toggle(\"ol-uncollapsible\"),!t&&this.collapsed_&&this.handleToggle_())},er.prototype.setCollapsed=function(t){this.collapsible_&&this.collapsed_!==t&&this.handleToggle_()},er.prototype.getCollapsed=function(){return this.collapsed_};var nr=er;const or=function(t){const e=t||{},i=void 0!==e.className?e.className:\"ol-rotate\",n=void 0!==e.label?e.label:\"\";this.label_=null,\"string\"==typeof n?(this.label_=document.createElement(\"span\"),this.label_.className=\"ol-compass\",this.label_.textContent=n):(this.label_=n,this.label_.classList.add(\"ol-compass\"));const o=e.tipLabel?e.tipLabel:\"Reset rotation\",s=document.createElement(\"button\");s.className=i+\"-reset\",s.setAttribute(\"type\",\"button\"),s.title=o,s.appendChild(this.label_),C(s,w.CLICK,or.prototype.handleClick_,this);const r=i+\" ol-unselectable ol-control\",a=document.createElement(\"div\");a.className=r,a.appendChild(s),this.callResetNorth_=e.resetNorth?e.resetNorth:void 0,Vs.call(this,{element:a,render:e.render||sr,target:e.target}),this.duration_=void 0!==e.duration?e.duration:250,this.autoHide_=void 0===e.autoHide||e.autoHide,this.rotation_=void 0,this.autoHide_&&this.element.classList.add(Ze)};function sr(t){const e=t.frameState;if(!e)return;const i=e.viewState.rotation;if(i!=this.rotation_){const t=\"rotate(\"+i+\"rad)\";if(this.autoHide_){const t=this.element.classList.contains(Ze);t||0!==i?t&&0!==i&&this.element.classList.remove(Ze):this.element.classList.add(Ze)}this.label_.style.msTransform=t,this.label_.style.webkitTransform=t,this.label_.style.transform=t}this.rotation_=i}a(or,Vs),or.prototype.handleClick_=function(t){t.preventDefault(),void 0!==this.callResetNorth_?this.callResetNorth_():this.resetNorth_()},or.prototype.resetNorth_=function(){const t=this.getMap().getView();t&&void 0!==t.getRotation()&&(this.duration_>0?t.animate({rotation:0,duration:this.duration_,easing:Ts}):t.setRotation(0))};var rr=or;const ar=function(t){const e=t||{},i=void 0!==e.className?e.className:\"ol-zoom\",n=void 0!==e.delta?e.delta:1,o=void 0!==e.zoomInLabel?e.zoomInLabel:\"+\",s=void 0!==e.zoomOutLabel?e.zoomOutLabel:\"\",r=void 0!==e.zoomInTipLabel?e.zoomInTipLabel:\"Zoom in\",a=void 0!==e.zoomOutTipLabel?e.zoomOutTipLabel:\"Zoom out\",h=document.createElement(\"button\");h.className=i+\"-in\",h.setAttribute(\"type\",\"button\"),h.title=r,h.appendChild(\"string\"==typeof o?document.createTextNode(o):o),C(h,w.CLICK,ar.prototype.handleClick_.bind(this,n));const l=document.createElement(\"button\");l.className=i+\"-out\",l.setAttribute(\"type\",\"button\"),l.title=a,l.appendChild(\"string\"==typeof s?document.createTextNode(s):s),C(l,w.CLICK,ar.prototype.handleClick_.bind(this,-n));const c=i+\" ol-unselectable ol-control\",u=document.createElement(\"div\");u.className=c,u.appendChild(h),u.appendChild(l),Vs.call(this,{element:u,target:e.target}),this.duration_=void 0!==e.duration?e.duration:250};a(ar,Vs),ar.prototype.handleClick_=function(t,e){e.preventDefault(),this.zoomByDelta_(t)},ar.prototype.zoomByDelta_=function(t){const e=this.getMap().getView();if(!e)return;const i=e.getResolution();if(i){const n=e.constrainResolution(i,t);this.duration_>0?(e.getAnimating()&&e.cancelAnimations(),e.animate({resolution:n,duration:this.duration_,easing:Ts})):e.setResolution(n)}};var hr=ar;const lr=function(t,e,i){this.decay_=t,this.minVelocity_=e,this.delay_=i,this.points_=[],this.angle_=0,this.initialVelocity_=0};lr.prototype.begin=function(){this.points_.length=0,this.angle_=0,this.initialVelocity_=0},lr.prototype.update=function(t,e){this.points_.push(t,e,Date.now())},lr.prototype.end=function(){if(this.points_.length<6)return!1;const t=Date.now()-this.delay_,e=this.points_.length-3;if(this.points_[e+2]<t)return!1;let i=e-3;for(;i>0&&this.points_[i+2]>t;)i-=3;const n=this.points_[e+2]-this.points_[i+2];if(n<1e3/60)return!1;const o=this.points_[e]-this.points_[i],s=this.points_[e+1]-this.points_[i+1];return this.angle_=Math.atan2(s,o),this.initialVelocity_=Math.sqrt(o*o+s*s)/n,this.initialVelocity_>this.minVelocity_},lr.prototype.getDistance=function(){return(this.minVelocity_-this.initialVelocity_)/this.decay_},lr.prototype.getAngle=function(){return this.angle_};var cr=lr,ur=\"active\";const pr=function(t){K.call(this),this.map_=null,this.setActive(!0),this.handleEvent=t.handleEvent};function dr(t,e,i,n){fr(t,e=t.constrainRotation(e,0),i,n)}function fr(t,e,i,n){if(void 0!==e){const o=t.getRotation(),s=t.getCenter();void 0!==o&&s&&n>0?t.animate({rotation:e,anchor:i,duration:n,easing:Ts}):t.rotate(e,i)}}function gr(t,e,i,n,o){yr(t,e=t.constrainResolution(e,0,o),i,n)}function _r(t,e,i,n){const o=t.getResolution();let s=t.constrainResolution(o,e,0);if(void 0!==s){const e=t.getResolutions();s=Rt(s,t.getMinResolution()||e[e.length-1],t.getMaxResolution()||e[0])}if(i&&void 0!==s&&s!==o){const e=t.getCenter();let n=t.calculateCenterZoom(s,i);n=t.constrainCenter(n),i=[(s*e[0]-o*n[0])/(s-o),(s*e[1]-o*n[1])/(s-o)]}yr(t,s,i,n)}function yr(t,e,i,n){if(e){const o=t.getResolution(),s=t.getCenter();if(void 0!==o&&s&&e!==o&&n)t.animate({resolution:e,anchor:i,duration:n,easing:Ts});else{if(i){const n=t.calculateCenterZoom(e,i);t.setCenter(n)}t.setResolution(e)}}}a(pr,K),pr.prototype.getActive=function(){return this.get(ur)},pr.prototype.getMap=function(){return this.map_},pr.prototype.setActive=function(t){this.set(ur,t)},pr.prototype.setMap=function(t){this.map_=t};var mr=pr;const vr=function(t){const e=t||{};this.delta_=e.delta?e.delta:1,mr.call(this,{handleEvent:xr}),this.duration_=void 0!==e.duration?e.duration:250};function xr(t){let e=!1;const i=t.originalEvent;if(t.type==uo.DBLCLICK){const n=t.map,o=t.coordinate,s=i.shiftKey?-this.delta_:this.delta_;_r(n.getView(),s,o,this.duration_),t.preventDefault(),e=!0}return!e}a(vr,mr);var Cr=vr;const Er=function(t){const e=t.originalEvent;return e.altKey&&!(e.metaKey||e.ctrlKey)&&e.shiftKey},Tr=I,Sr=function(t){const e=t.originalEvent;return 0==e.button&&!(ze&&We&&e.ctrlKey)},wr=F,Rr=function(t){return\"pointermove\"==t.type},Ir=function(t){return t.type==uo.SINGLECLICK},Fr=function(t){const e=t.originalEvent;return!e.altKey&&!(e.metaKey||e.ctrlKey)&&!e.shiftKey},Pr=function(t){const e=t.originalEvent;return!e.altKey&&!(e.metaKey||e.ctrlKey)&&e.shiftKey},Lr=function(t){const e=t.originalEvent.target.tagName;return\"INPUT\"!==e&&\"SELECT\"!==e&&\"TEXTAREA\"!==e},Mr=function(t){return p(t.pointerEvent,56),\"mouse\"==t.pointerEvent.pointerType},br=function(t){const e=t.pointerEvent;return e.isPrimary&&0===e.button},Or=P,kr=F,Ar=F,Gr=P,Dr=function(t){const e=t||{};mr.call(this,{handleEvent:e.handleEvent||Yr}),this.handleDownEvent_=e.handleDownEvent?e.handleDownEvent:Ar,this.handleDragEvent_=e.handleDragEvent?e.handleDragEvent:Or,this.handleMoveEvent_=e.handleMoveEvent?e.handleMoveEvent:Gr,this.handleUpEvent_=e.handleUpEvent?e.handleUpEvent:kr,this.handlingDownUpSequence=!1,this.trackedPointers_={},this.targetPointers=[]};function Nr(t){const e=t.length;let i=0,n=0;for(let o=0;o<e;o++)i+=t[o].clientX,n+=t[o].clientY;return[i/e,n/e]}function Yr(t){if(!(t instanceof fo))return!0;let e=!1;if(this.updateTrackedPointers_(t),this.handlingDownUpSequence){if(t.type==uo.POINTERDRAG)this.handleDragEvent_(t);else if(t.type==uo.POINTERUP){const e=this.handleUpEvent_(t);this.handlingDownUpSequence=e&&this.targetPointers.length>0}}else if(t.type==uo.POINTERDOWN){const i=this.handleDownEvent_(t);this.handlingDownUpSequence=i,e=this.shouldStopEvent(i)}else t.type==uo.POINTERMOVE&&this.handleMoveEvent_(t);return!e}a(Dr,mr),Dr.prototype.updateTrackedPointers_=function(t){if(function(t){const e=t.type;return e===uo.POINTERDOWN||e===uo.POINTERDRAG||e===uo.POINTERUP}(t)){const e=t.pointerEvent,i=e.pointerId.toString();t.type==uo.POINTERUP?delete this.trackedPointers_[i]:t.type==uo.POINTERDOWN?this.trackedPointers_[i]=e:i in this.trackedPointers_&&(this.trackedPointers_[i]=e),this.targetPointers=g(this.trackedPointers_)}},Dr.prototype.shouldStopEvent=function(t){return t};var Xr=Dr;const zr=function(t){Xr.call(this,{handleDownEvent:Ur,handleDragEvent:Wr,handleUpEvent:Kr});const e=t||{};this.kinetic_=e.kinetic,this.lastCentroid=null,this.lastPointersCount_,this.condition_=e.condition?e.condition:Fr,this.noKinetic_=!1};function Wr(t){const e=this.targetPointers,i=Nr(e);if(e.length==this.lastPointersCount_){if(this.kinetic_&&this.kinetic_.update(i[0],i[1]),this.lastCentroid){const e=this.lastCentroid[0]-i[0],n=i[1]-this.lastCentroid[1],o=t.map.getView();let s=[e,n];ms(s,o.getResolution()),ys(s,o.getRotation()),fs(s,o.getCenter()),s=o.constrainCenter(s),o.setCenter(s)}}else this.kinetic_&&this.kinetic_.begin();this.lastCentroid=i,this.lastPointersCount_=e.length}function Kr(t){const e=t.map,i=e.getView();if(0===this.targetPointers.length){if(!this.noKinetic_&&this.kinetic_&&this.kinetic_.end()){const t=this.kinetic_.getDistance(),n=this.kinetic_.getAngle(),o=i.getCenter(),s=e.getPixelFromCoordinate(o),r=e.getCoordinateFromPixel([s[0]-t*Math.cos(n),s[1]-t*Math.sin(n)]);i.animate({center:i.constrainCenter(r),duration:500,easing:Ts})}return i.setHint(cs.INTERACTING,-1),!1}return this.kinetic_&&this.kinetic_.begin(),this.lastCentroid=null,!0}function Ur(t){if(this.targetPointers.length>0&&this.condition_(t)){const e=t.map.getView();return this.lastCentroid=null,this.handlingDownUpSequence||e.setHint(cs.INTERACTING,1),e.getAnimating()&&e.setCenter(t.frameState.viewState.center),this.kinetic_&&this.kinetic_.begin(),this.noKinetic_=this.targetPointers.length>1,!0}return!1}a(zr,Xr),zr.prototype.shouldStopEvent=F;var Br=zr;const jr=function(t){const e=t||{};Xr.call(this,{handleDownEvent:Zr,handleDragEvent:Hr,handleUpEvent:Vr}),this.condition_=e.condition?e.condition:Er,this.lastAngle_=void 0,this.duration_=void 0!==e.duration?e.duration:250};function Hr(t){if(!Mr(t))return;const e=t.map,i=e.getView();if(i.getConstraints().rotation===hs)return;const n=e.getSize(),o=t.pixel,s=Math.atan2(n[1]/2-o[1],o[0]-n[0]/2);if(void 0!==this.lastAngle_){const t=s-this.lastAngle_;fr(i,i.getRotation()-t)}this.lastAngle_=s}function Vr(t){if(!Mr(t))return!0;const e=t.map.getView();return e.setHint(cs.INTERACTING,-1),dr(e,e.getRotation(),void 0,this.duration_),!1}function Zr(t){if(!Mr(t))return!1;if(Sr(t)&&this.condition_(t)){return t.map.getView().setHint(cs.INTERACTING,1),this.lastAngle_=void 0,!0}return!1}a(jr,Xr),jr.prototype.shouldStopEvent=F;var qr=jr;const Jr=function(t){this.geometry_=null,this.element_=document.createElement(\"div\"),this.element_.style.position=\"absolute\",this.element_.className=\"ol-box \"+t,this.map_=null,this.startPixel_=null,this.endPixel_=null};a(Jr,M),Jr.prototype.disposeInternal=function(){this.setMap(null)},Jr.prototype.render_=function(){const t=this.startPixel_,e=this.endPixel_,i=this.element_.style;i.left=Math.min(t[0],e[0])+\"px\",i.top=Math.min(t[1],e[1])+\"px\",i.width=Math.abs(e[0]-t[0])+\"px\",i.height=Math.abs(e[1]-t[1])+\"px\"},Jr.prototype.setMap=function(t){if(this.map_){this.map_.getOverlayContainer().removeChild(this.element_);const t=this.element_.style;t.left=t.top=t.width=t.height=\"inherit\"}this.map_=t,this.map_&&this.map_.getOverlayContainer().appendChild(this.element_)},Jr.prototype.setPixels=function(t,e){this.startPixel_=t,this.endPixel_=e,this.createOrUpdateGeometry(),this.render_()},Jr.prototype.createOrUpdateGeometry=function(){const t=this.startPixel_,e=this.endPixel_,i=[t,[t[0],e[1]],e,[e[0],t[1]]].map(this.map_.getCoordinateFromPixel,this.map_);i[4]=i[0].slice(),this.geometry_?this.geometry_.setCoordinates([i]):this.geometry_=new Kn([i])},Jr.prototype.getGeometry=function(){return this.geometry_};var Qr=Jr;const $r={BOXSTART:\"boxstart\",BOXDRAG:\"boxdrag\",BOXEND:\"boxend\"},ta=function(t,e,i){k.call(this,t),this.coordinate=e,this.mapBrowserEvent=i};a(ta,k);const ea=function(t){Xr.call(this,{handleDownEvent:sa,handleDragEvent:na,handleUpEvent:oa});const e=t||{};this.box_=new Qr(e.className||\"ol-dragbox\"),this.minArea_=void 0!==e.minArea?e.minArea:64,this.startPixel_=null,this.condition_=e.condition?e.condition:Tr,this.boxEndCondition_=e.boxEndCondition?e.boxEndCondition:ia};function ia(t,e,i){const n=i[0]-e[0],o=i[1]-e[1];return n*n+o*o>=this.minArea_}function na(t){Mr(t)&&(this.box_.setPixels(this.startPixel_,t.pixel),this.dispatchEvent(new ta($r.BOXDRAG,t.coordinate,t)))}function oa(t){return!Mr(t)||(this.box_.setMap(null),this.boxEndCondition_(t,this.startPixel_,t.pixel)&&(this.onBoxEnd(t),this.dispatchEvent(new ta($r.BOXEND,t.coordinate,t))),!1)}function sa(t){return!!Mr(t)&&(!(!Sr(t)||!this.condition_(t))&&(this.startPixel_=t.pixel,this.box_.setMap(t.map),this.box_.setPixels(this.startPixel_,this.startPixel_),this.dispatchEvent(new ta($r.BOXSTART,t.coordinate,t)),!0))}a(ea,Xr),ea.prototype.getGeometry=function(){return this.box_.getGeometry()},ea.prototype.onBoxEnd=P;var ra=ea;const aa=function(t){const e=t||{},i=e.condition?e.condition:Pr;this.duration_=void 0!==e.duration?e.duration:200,this.out_=void 0!==e.out&&e.out,ra.call(this,{condition:i,className:e.className||\"ol-dragzoom\"})};a(aa,ra),aa.prototype.onBoxEnd=function(){const t=this.getMap(),e=t.getView(),i=t.getSize();let n=this.getGeometry().getExtent();if(this.out_){const r=e.calculateExtent(i),a=(o=[t.getPixelFromCoordinate(dt(n)),t.getPixelFromCoordinate(xt(n))],ht(it(s),o));!function(t,e){const i=(t[2]-t[0])/2*(e-1),n=(t[3]-t[1])/2*(e-1);t[0]-=i,t[2]+=i,t[1]-=n,t[3]+=n}(r,1/e.getResolutionForExtent(a,i)),n=r}var o,s;const r=e.constrainResolution(e.getResolutionForExtent(n,i));let a=gt(n);a=e.constrainCenter(a),e.animate({resolution:r,center:a,duration:this.duration_,easing:Ts})};var ha=aa,la={LEFT:37,UP:38,RIGHT:39,DOWN:40};const ca=function(t){mr.call(this,{handleEvent:ua});const e=t||{};this.defaultCondition_=function(t){return Fr(t)&&Lr(t)},this.condition_=void 0!==e.condition?e.condition:this.defaultCondition_,this.duration_=void 0!==e.duration?e.duration:100,this.pixelDelta_=void 0!==e.pixelDelta?e.pixelDelta:128};function ua(t){let e=!1;if(t.type==w.KEYDOWN){const i=t.originalEvent.keyCode;if(this.condition_(t)&&(i==la.DOWN||i==la.LEFT||i==la.RIGHT||i==la.UP)){const n=t.map.getView(),o=n.getResolution()*this.pixelDelta_;let s=0,r=0;i==la.DOWN?r=-o:i==la.LEFT?s=-o:i==la.RIGHT?s=o:r=o;const a=[s,r];ys(a,n.getRotation()),function(t,e,i){const n=t.getCenter();if(n){const o=t.constrainCenter([n[0]+e[0],n[1]+e[1]]);i?t.animate({duration:i,easing:ws,center:o}):t.setCenter(o)}}(n,a,this.duration_),t.preventDefault(),e=!0}}return!e}a(ca,mr);var pa=ca;const da=function(t){mr.call(this,{handleEvent:fa});const e=t||{};this.condition_=e.condition?e.condition:Lr,this.delta_=e.delta?e.delta:1,this.duration_=void 0!==e.duration?e.duration:100};function fa(t){let e=!1;if(t.type==w.KEYDOWN||t.type==w.KEYPRESS){const i=t.originalEvent.charCode;if(this.condition_(t)&&(i==\"+\".charCodeAt(0)||i==\"-\".charCodeAt(0))){const n=t.map,o=i==\"+\".charCodeAt(0)?this.delta_:-this.delta_;_r(n.getView(),o,void 0,this.duration_),t.preventDefault(),e=!0}}return!e}a(da,mr);var ga=da;const _a={TRACKPAD:\"trackpad\",WHEEL:\"wheel\"},ya=function(t){mr.call(this,{handleEvent:ma});const e=t||{};this.delta_=0,this.duration_=void 0!==e.duration?e.duration:250,this.timeout_=void 0!==e.timeout?e.timeout:80,this.useAnchor_=void 0===e.useAnchor||e.useAnchor,this.constrainResolution_=e.constrainResolution||!1,this.condition_=e.condition?e.condition:Tr,this.lastAnchor_=null,this.startTime_=void 0,this.timeoutId_=void 0,this.mode_=void 0,this.trackpadEventGap_=400,this.trackpadTimeoutId_=void 0,this.trackpadDeltaPerZoom_=300,this.trackpadZoomBuffer_=1.5};function ma(t){if(!this.condition_(t))return!0;const e=t.type;if(e!==w.WHEEL&&e!==w.MOUSEWHEEL)return!0;t.preventDefault();const i=t.map,n=t.originalEvent;let o;if(this.useAnchor_&&(this.lastAnchor_=t.coordinate),t.type==w.WHEEL?(o=n.deltaY,Ye&&n.deltaMode===WheelEvent.DOM_DELTA_PIXEL&&(o/=Ke),n.deltaMode===WheelEvent.DOM_DELTA_LINE&&(o*=40)):t.type==w.MOUSEWHEEL&&(o=-n.wheelDeltaY,Xe&&(o/=3)),0===o)return!1;const s=Date.now();if(void 0===this.startTime_&&(this.startTime_=s),(!this.mode_||s-this.startTime_>this.trackpadEventGap_)&&(this.mode_=Math.abs(o)<4?_a.TRACKPAD:_a.WHEEL),this.mode_===_a.TRACKPAD){const t=i.getView();this.trackpadTimeoutId_?clearTimeout(this.trackpadTimeoutId_):t.setHint(cs.INTERACTING,1),this.trackpadTimeoutId_=setTimeout(this.decrementInteractingHint_.bind(this),this.trackpadEventGap_);let e=t.getResolution()*Math.pow(2,o/this.trackpadDeltaPerZoom_);const n=t.getMinResolution(),r=t.getMaxResolution();let a=0;if(e<n?(e=Math.max(e,n/this.trackpadZoomBuffer_),a=1):e>r&&(e=Math.min(e,r*this.trackpadZoomBuffer_),a=-1),this.lastAnchor_){const i=t.calculateCenterZoom(e,this.lastAnchor_);t.setCenter(t.constrainCenter(i))}return t.setResolution(e),0===a&&this.constrainResolution_&&t.animate({resolution:t.constrainResolution(e,o>0?-1:1),easing:Ts,anchor:this.lastAnchor_,duration:this.duration_}),a>0?t.animate({resolution:n,easing:Ts,anchor:this.lastAnchor_,duration:500}):a<0&&t.animate({resolution:r,easing:Ts,anchor:this.lastAnchor_,duration:500}),this.startTime_=s,!1}this.delta_+=o;const r=Math.max(this.timeout_-(s-this.startTime_),0);return clearTimeout(this.timeoutId_),this.timeoutId_=setTimeout(this.handleWheelZoom_.bind(this,i),r),!1}a(ya,mr),ya.prototype.decrementInteractingHint_=function(){this.trackpadTimeoutId_=void 0,this.getMap().getView().setHint(cs.INTERACTING,-1)},ya.prototype.handleWheelZoom_=function(t){const e=t.getView();e.getAnimating()&&e.cancelAnimations();_r(e,-Rt(this.delta_,-1,1),this.lastAnchor_,this.duration_),this.mode_=void 0,this.delta_=0,this.lastAnchor_=null,this.startTime_=void 0,this.timeoutId_=void 0},ya.prototype.setMouseAnchor=function(t){this.useAnchor_=t,t||(this.lastAnchor_=null)};var va=ya;const xa=function(t){Xr.call(this,{handleDownEvent:Ta,handleDragEvent:Ca,handleUpEvent:Ea});const e=t||{};this.anchor_=null,this.lastAngle_=void 0,this.rotating_=!1,this.rotationDelta_=0,this.threshold_=void 0!==e.threshold?e.threshold:.3,this.duration_=void 0!==e.duration?e.duration:250};function Ca(t){let e=0;const i=this.targetPointers[0],n=this.targetPointers[1],o=Math.atan2(n.clientY-i.clientY,n.clientX-i.clientX);if(void 0!==this.lastAngle_){const t=o-this.lastAngle_;this.rotationDelta_+=t,!this.rotating_&&Math.abs(this.rotationDelta_)>this.threshold_&&(this.rotating_=!0),e=t}this.lastAngle_=o;const s=t.map,r=s.getView();if(r.getConstraints().rotation===hs)return;const a=s.getViewport().getBoundingClientRect(),h=Nr(this.targetPointers);if(h[0]-=a.left,h[1]-=a.top,this.anchor_=s.getCoordinateFromPixel(h),this.rotating_){const t=r.getRotation();s.render(),fr(r,t+e,this.anchor_)}}function Ea(t){if(this.targetPointers.length<2){const e=t.map.getView();if(e.setHint(cs.INTERACTING,-1),this.rotating_){dr(e,e.getRotation(),this.anchor_,this.duration_)}return!1}return!0}function Ta(t){if(this.targetPointers.length>=2){const e=t.map;return this.anchor_=null,this.lastAngle_=void 0,this.rotating_=!1,this.rotationDelta_=0,this.handlingDownUpSequence||e.getView().setHint(cs.INTERACTING,1),!0}return!1}a(xa,Xr),xa.prototype.shouldStopEvent=F;var Sa=xa;const wa=function(t){Xr.call(this,{handleDownEvent:Fa,handleDragEvent:Ra,handleUpEvent:Ia});const e=t||{};this.constrainResolution_=e.constrainResolution||!1,this.anchor_=null,this.duration_=void 0!==e.duration?e.duration:400,this.lastDistance_=void 0,this.lastScaleDelta_=1};function Ra(t){let e=1;const i=this.targetPointers[0],n=this.targetPointers[1],o=i.clientX-n.clientX,s=i.clientY-n.clientY,r=Math.sqrt(o*o+s*s);void 0!==this.lastDistance_&&(e=this.lastDistance_/r),this.lastDistance_=r;const a=t.map,h=a.getView(),l=h.getResolution(),c=h.getMaxResolution(),u=h.getMinResolution();let p=l*e;p>c?(e=c/l,p=c):p<u&&(e=u/l,p=u),1!=e&&(this.lastScaleDelta_=e);const d=a.getViewport().getBoundingClientRect(),f=Nr(this.targetPointers);f[0]-=d.left,f[1]-=d.top,this.anchor_=a.getCoordinateFromPixel(f),a.render(),yr(h,p,this.anchor_)}function Ia(t){if(this.targetPointers.length<2){const e=t.map.getView();e.setHint(cs.INTERACTING,-1);const i=e.getResolution();if(this.constrainResolution_||i<e.getMinResolution()||i>e.getMaxResolution()){const t=this.lastScaleDelta_-1;gr(e,i,this.anchor_,this.duration_,t)}return!1}return!0}function Fa(t){if(this.targetPointers.length>=2){const e=t.map;return this.anchor_=null,this.lastDistance_=void 0,this.lastScaleDelta_=1,this.handlingDownUpSequence||e.getView().setHint(cs.INTERACTING,1),!0}return!1}a(wa,Xr),wa.prototype.shouldStopEvent=F;var Pa=wa;const La=\"addfeatures\",Ma=function(t,e,i,n){k.call(this,t),this.features=i,this.file=e,this.projection=n};a(Ma,k);const ba=function(t){const e=t||{};mr.call(this,{handleEvent:I}),this.formatConstructors_=e.formatConstructors?e.formatConstructors:[],this.projection_=e.projection?se(e.projection):null,this.dropListenKeys_=null,this.source_=e.source||null,this.target=e.target?e.target:null};function Oa(t){const e=t.dataTransfer.files;for(let t=0,i=e.length;t<i;++t){const i=e.item(t),n=new FileReader;n.addEventListener(w.LOAD,this.handleResult_.bind(this,i)),n.readAsText(i)}}function ka(t){t.stopPropagation(),t.preventDefault(),t.dataTransfer.dropEffect=\"copy\"}a(ba,mr),ba.prototype.handleResult_=function(t,e){const i=e.target.result,n=this.getMap();let o=this.projection_;if(!o){o=n.getView().getProjection()}const s=this.formatConstructors_;let r=[];for(let t=0,e=s.length;t<e;++t){const e=new(0,s[t]);if((r=this.tryReadFeatures_(e,i,{featureProjection:o}))&&r.length>0)break}this.source_&&(this.source_.clear(),this.source_.addFeatures(r)),this.dispatchEvent(new Ma(La,t,r,o))},ba.prototype.registerListeners_=function(){const t=this.getMap();if(t){const e=this.target?this.target:t.getViewport();this.dropListenKeys_=[C(e,w.DROP,Oa,this),C(e,w.DRAGENTER,ka,this),C(e,w.DRAGOVER,ka,this),C(e,w.DROP,ka,this)]}},ba.prototype.setActive=function(t){mr.prototype.setActive.call(this,t),t?this.registerListeners_():this.unregisterListeners_()},ba.prototype.setMap=function(t){this.unregisterListeners_(),mr.prototype.setMap.call(this,t),this.getActive()&&this.registerListeners_()},ba.prototype.tryReadFeatures_=function(t,e,i){try{return t.readFeatures(e,i)}catch(t){return null}},ba.prototype.unregisterListeners_=function(){this.dropListenKeys_&&(this.dropListenKeys_.forEach(S),this.dropListenKeys_=null)};const Aa=function(t){const e=t||{};Xr.call(this,{handleDownEvent:Na,handleDragEvent:Ga,handleUpEvent:Da}),this.condition_=e.condition?e.condition:Pr,this.lastAngle_=void 0,this.lastMagnitude_=void 0,this.lastScaleDelta_=0,this.duration_=void 0!==e.duration?e.duration:400};function Ga(t){if(!Mr(t))return;const e=t.map,i=e.getSize(),n=t.pixel,o=n[0]-i[0]/2,s=i[1]/2-n[1],r=Math.atan2(s,o),a=Math.sqrt(o*o+s*s),h=e.getView();if(h.getConstraints().rotation!==hs&&void 0!==this.lastAngle_){const t=r-this.lastAngle_;fr(h,h.getRotation()-t)}if(this.lastAngle_=r,void 0!==this.lastMagnitude_){yr(h,this.lastMagnitude_*(h.getResolution()/a))}void 0!==this.lastMagnitude_&&(this.lastScaleDelta_=this.lastMagnitude_/a),this.lastMagnitude_=a}function Da(t){if(!Mr(t))return!0;const e=t.map.getView();e.setHint(cs.INTERACTING,-1);const i=this.lastScaleDelta_-1;return dr(e,e.getRotation()),gr(e,e.getResolution(),void 0,this.duration_,i),this.lastScaleDelta_=0,!1}function Na(t){return!!Mr(t)&&(!!this.condition_(t)&&(t.map.getView().setHint(cs.INTERACTING,1),this.lastAngle_=void 0,this.lastMagnitude_=void 0,!0))}a(Aa,Xr);const Ya=function(t,e,i){Ji.call(this);const n=e||0;this.setCenterAndRadius(t,n,i)};a(Ya,Ji),Ya.prototype.clone=function(){const t=new Ya(null);return t.setFlatCoordinates(this.layout,this.flatCoordinates.slice()),t},Ya.prototype.closestPointXY=function(t,e,i,n){const o=this.flatCoordinates,s=t-o[0],r=e-o[1],a=s*s+r*r;if(a<n){if(0===a)for(let t=0;t<this.stride;++t)i[t]=o[t];else{const t=this.getRadius()/Math.sqrt(a);i[0]=o[0]+t*s,i[1]=o[1]+t*r;for(let t=2;t<this.stride;++t)i[t]=o[t]}return i.length=this.stride,a}return n},Ya.prototype.containsXY=function(t,e){const i=this.flatCoordinates,n=t-i[0],o=e-i[1];return n*n+o*o<=this.getRadiusSquared_()},Ya.prototype.getCenter=function(){return this.flatCoordinates.slice(0,this.stride)},Ya.prototype.computeExtent=function(t){const e=this.flatCoordinates,i=e[this.stride]-e[0];return et(e[0]-i,e[1]-i,e[0]+i,e[1]+i,t)},Ya.prototype.getRadius=function(){return Math.sqrt(this.getRadiusSquared_())},Ya.prototype.getRadiusSquared_=function(){const t=this.flatCoordinates[this.stride]-this.flatCoordinates[0],e=this.flatCoordinates[this.stride+1]-this.flatCoordinates[1];return t*t+e*e},Ya.prototype.getType=function(){return Ot.CIRCLE},Ya.prototype.intersectsExtent=function(t){if(Et(t,this.getExtent())){const e=this.getCenter();return t[0]<=e[0]&&t[2]>=e[0]||(t[1]<=e[1]&&t[3]>=e[1]||ut(t,this.intersectsCoordinate,this))}return!1},Ya.prototype.setCenter=function(t){const e=this.stride,i=this.flatCoordinates[e]-this.flatCoordinates[0],n=t.slice();n[e]=n[0]+i;for(let i=1;i<e;++i)n[e+i]=t[i];this.setFlatCoordinates(this.layout,n)},Ya.prototype.setCenterAndRadius=function(t,e,i){if(t){this.setLayout(i,t,0),this.flatCoordinates||(this.flatCoordinates=[]);const n=this.flatCoordinates;let o=on(n,0,t,this.stride);n[o++]=n[0]+e;for(let t=1,e=this.stride;t<e;++t)n[o++]=n[t];n.length=o,this.changed()}else this.setFlatCoordinates(Vi.XY,null)},Ya.prototype.getCoordinates=function(){},Ya.prototype.setCoordinates=function(t,e){},Ya.prototype.setFlatCoordinates=function(t,e){this.setFlatCoordinatesInternal(t,e),this.changed()},Ya.prototype.setRadius=function(t){this.flatCoordinates[this.stride]=this.flatCoordinates[0]+t,this.changed()},Ya.prototype.transform;var Xa=Ya,za=\"IMAGE\",Wa=\"TILE\",Ka=\"VECTOR_TILE\",Ua=\"VECTOR\",Ba=\"image\",ja=\"vector\";const Ha=\"renderOrder\",Va=function(t){const e=t||{},i=d({},e);delete i.style,delete i.renderBuffer,delete i.updateWhileAnimating,delete i.updateWhileInteracting,tr.call(this,i),this.declutter_=void 0!==e.declutter&&e.declutter,this.renderBuffer_=void 0!==e.renderBuffer?e.renderBuffer:100,this.style_=null,this.styleFunction_=void 0,this.setStyle(e.style),this.updateWhileAnimating_=void 0!==e.updateWhileAnimating&&e.updateWhileAnimating,this.updateWhileInteracting_=void 0!==e.updateWhileInteracting&&e.updateWhileInteracting,this.renderMode_=e.renderMode||ja,this.type=Ua};a(Va,tr),Va.prototype.getDeclutter=function(){return this.declutter_},Va.prototype.setDeclutter=function(t){this.declutter_=t},Va.prototype.getRenderBuffer=function(){return this.renderBuffer_},Va.prototype.getRenderOrder=function(){return this.get(Ha)},Va.prototype.getSource,Va.prototype.getStyle=function(){return this.style_},Va.prototype.getStyleFunction=function(){return this.styleFunction_},Va.prototype.getUpdateWhileAnimating=function(){return this.updateWhileAnimating_},Va.prototype.getUpdateWhileInteracting=function(){return this.updateWhileInteracting_},Va.prototype.setRenderOrder=function(t){this.set(Ha,t)},Va.prototype.setStyle=function(t){this.style_=void 0!==t?t:Ri,this.styleFunction_=null===t?void 0:function(t){let e;if(\"function\"==typeof t)e=t;else{let i;Array.isArray(t)?i=t:(p(t instanceof Si,41),i=[t]),e=function(){return i}}return e}(this.style_),this.changed()},Va.prototype.getRenderMode=function(){return this.renderMode_};var Za=Va;function qa(t,e){return function(t,e,i,n){return function(o,s,r){const a=new XMLHttpRequest;a.open(\"GET\",\"function\"==typeof t?t(o,s,r):t,!0),e.getType()==Ai.ARRAY_BUFFER&&(a.responseType=\"arraybuffer\"),a.onload=function(t){if(!a.status||a.status>=200&&a.status<300){const t=e.getType();let o;t==Ai.JSON||t==Ai.TEXT?o=a.responseText:t==Ai.XML?(o=a.responseXML)||(o=(new DOMParser).parseFromString(a.responseText,\"application/xml\")):t==Ai.ARRAY_BUFFER&&(o=a.response),o?i.call(this,e.readFeatures(o,{featureProjection:r}),e.readProjection(o),e.getLastExtent()):n.call(this)}else n.call(this)}.bind(this),a.onerror=function(){n.call(this)}.bind(this),a.send()}}(t,e,function(t,e){this.addFeatures(t)},P)}function Ja(t,e){return[[-1/0,-1/0,1/0,1/0]]}const Qa=function(t){K.call(this),this.projection_=se(t.projection),this.attributions_=this.adaptAttributions_(t.attributions),this.state_=void 0!==t.state?t.state:Xs,this.wrapX_=void 0!==t.wrapX&&t.wrapX};a(Qa,K),Qa.prototype.adaptAttributions_=function(t){return t?Array.isArray(t)?function(e){return t}:\"function\"==typeof t?t:function(e){return[t]}:null},Qa.prototype.forEachFeatureAtCoordinate=P,Qa.prototype.getAttributions=function(){return this.attributions_},Qa.prototype.getProjection=function(){return this.projection_},Qa.prototype.getResolutions=function(){},Qa.prototype.getState=function(){return this.state_},Qa.prototype.getWrapX=function(){return this.wrapX_},Qa.prototype.refresh=function(){this.changed()},Qa.prototype.setAttributions=function(t){this.attributions_=this.adaptAttributions_(t),this.changed()},Qa.prototype.setState=function(t){this.state_=t,this.changed()};var $a=Qa,th=\"addfeature\",eh=\"changefeature\",ih=\"clear\",nh=\"removefeature\",oh=i(0),sh=i.n(oh);const rh=function(t){this.rbush_=sh()(t,void 0),this.items_={}};rh.prototype.insert=function(t,e){const i={minX:t[0],minY:t[1],maxX:t[2],maxY:t[3],value:e};this.rbush_.insert(i),this.items_[l(e)]=i},rh.prototype.load=function(t,e){const i=new Array(e.length);for(let n=0,o=e.length;n<o;n++){const o=t[n],s=e[n],r={minX:o[0],minY:o[1],maxX:o[2],maxY:o[3],value:s};i[n]=r,this.items_[l(s)]=r}this.rbush_.load(i)},rh.prototype.remove=function(t){const e=l(t),i=this.items_[e];return delete this.items_[e],null!==this.rbush_.remove(i)},rh.prototype.update=function(t,e){const i=this.items_[l(e)];st([i.minX,i.minY,i.maxX,i.maxY],t)||(this.remove(e),this.insert(t,e))},rh.prototype.getAll=function(){return this.rbush_.all().map(function(t){return t.value})},rh.prototype.getInExtent=function(t){const e={minX:t[0],minY:t[1],maxX:t[2],maxY:t[3]};return this.rbush_.search(e).map(function(t){return t.value})},rh.prototype.forEach=function(t,e){return this.forEach_(this.getAll(),t,e)},rh.prototype.forEachInExtent=function(t,e,i){return this.forEach_(this.getInExtent(t),e,i)},rh.prototype.forEach_=function(t,e,i){let n;for(let o=0,s=t.length;o<s;o++)if(n=e.call(i,t[o]))return n;return n},rh.prototype.isEmpty=function(){return _(this.items_)},rh.prototype.clear=function(){this.rbush_.clear(),this.items_={}},rh.prototype.getExtent=function(t){const e=this.rbush_.data;return et(e.minX,e.minY,e.maxX,e.maxY,t)},rh.prototype.concat=function(t){this.rbush_.load(t.rbush_.all());for(const e in t.items_)this.items_[0|e]=t.items_[0|e]};var ah=rh;const hh=function(t,e){k.call(this,t),this.feature=e};a(hh,k);const lh=function(t){const e=t||{};$a.call(this,{attributions:e.attributions,projection:void 0,state:Xs,wrapX:void 0===e.wrapX||e.wrapX}),this.loader_=P,this.format_=e.format,this.overlaps_=void 0==e.overlaps||e.overlaps,this.url_=e.url,void 0!==e.loader?this.loader_=e.loader:void 0!==this.url_&&(p(this.format_,7),this.loader_=qa(this.url_,this.format_)),this.strategy_=void 0!==e.strategy?e.strategy:Ja;const i=void 0===e.useSpatialIndex||e.useSpatialIndex;let n,o;this.featuresRtree_=i?new ah:null,this.loadedExtentsRtree_=new ah,this.nullGeometryFeatures_={},this.idIndex_={},this.undefIdIndex_={},this.featureChangeKeys_={},this.featuresCollection_=null,e.features instanceof ro?o=(n=e.features).getArray():Array.isArray(e.features)&&(o=e.features),i||void 0!==n||(n=new ro(o)),void 0!==o&&this.addFeaturesInternal(o),void 0!==n&&this.bindFeaturesCollection_(n)};a(lh,$a),lh.prototype.addFeature=function(t){this.addFeatureInternal(t),this.changed()},lh.prototype.addFeatureInternal=function(t){const e=l(t).toString();if(!this.addToIndex_(e,t))return;this.setupChangeEvents_(e,t);const i=t.getGeometry();if(i){const e=i.getExtent();this.featuresRtree_&&this.featuresRtree_.insert(e,t)}else this.nullGeometryFeatures_[e]=t;this.dispatchEvent(new hh(th,t))},lh.prototype.setupChangeEvents_=function(t,e){this.featureChangeKeys_[t]=[C(e,w.CHANGE,this.handleFeatureChange_,this),C(e,R,this.handleFeatureChange_,this)]},lh.prototype.addToIndex_=function(t,e){let i=!0;const n=e.getId();return void 0!==n?n.toString()in this.idIndex_?i=!1:this.idIndex_[n.toString()]=e:(p(!(t in this.undefIdIndex_),30),this.undefIdIndex_[t]=e),i},lh.prototype.addFeatures=function(t){this.addFeaturesInternal(t),this.changed()},lh.prototype.addFeaturesInternal=function(t){const e=[],i=[],n=[];for(let e=0,n=t.length;e<n;e++){const n=t[e],o=l(n).toString();this.addToIndex_(o,n)&&i.push(n)}for(let t=0,o=i.length;t<o;t++){const o=i[t],s=l(o).toString();this.setupChangeEvents_(s,o);const r=o.getGeometry();if(r){const t=r.getExtent();e.push(t),n.push(o)}else this.nullGeometryFeatures_[s]=o}this.featuresRtree_&&this.featuresRtree_.load(e,n);for(let t=0,e=i.length;t<e;t++)this.dispatchEvent(new hh(th,i[t]))},lh.prototype.bindFeaturesCollection_=function(t){let e=!1;C(this,th,function(i){e||(e=!0,t.push(i.feature),e=!1)}),C(this,nh,function(i){e||(e=!0,t.remove(i.feature),e=!1)}),C(t,eo,function(t){e||(e=!0,this.addFeature(t.element),e=!1)},this),C(t,io,function(t){e||(e=!0,this.removeFeature(t.element),e=!1)},this),this.featuresCollection_=t},lh.prototype.clear=function(t){if(t){for(const t in this.featureChangeKeys_){this.featureChangeKeys_[t].forEach(S)}this.featuresCollection_||(this.featureChangeKeys_={},this.idIndex_={},this.undefIdIndex_={})}else if(this.featuresRtree_){this.featuresRtree_.forEach(this.removeFeatureInternal,this);for(const t in this.nullGeometryFeatures_)this.removeFeatureInternal(this.nullGeometryFeatures_[t])}this.featuresCollection_&&this.featuresCollection_.clear(),this.featuresRtree_&&this.featuresRtree_.clear(),this.loadedExtentsRtree_.clear(),this.nullGeometryFeatures_={};const e=new hh(ih);this.dispatchEvent(e),this.changed()},lh.prototype.forEachFeature=function(t){return this.featuresRtree_?this.featuresRtree_.forEach(t):this.featuresCollection_?this.featuresCollection_.forEach(t):void 0},lh.prototype.forEachFeatureAtCoordinateDirect=function(t,e){const i=[t[0],t[1],t[0],t[1]];return this.forEachFeatureInExtent(i,function(i){return i.getGeometry().intersectsCoordinate(t)?e(i):void 0})},lh.prototype.forEachFeatureInExtent=function(t,e){return this.featuresRtree_?this.featuresRtree_.forEachInExtent(t,e):this.featuresCollection_?this.featuresCollection_.forEach(e):void 0},lh.prototype.forEachFeatureIntersectingExtent=function(t,e){return this.forEachFeatureInExtent(t,function(i){if(i.getGeometry().intersectsExtent(t)){const t=e(i);if(t)return t}})},lh.prototype.getFeaturesCollection=function(){return this.featuresCollection_},lh.prototype.getFeatures=function(){let t;return this.featuresCollection_?t=this.featuresCollection_.getArray():this.featuresRtree_&&(t=this.featuresRtree_.getAll(),_(this.nullGeometryFeatures_)||ji(t,g(this.nullGeometryFeatures_))),t},lh.prototype.getFeaturesAtCoordinate=function(t){const e=[];return this.forEachFeatureAtCoordinateDirect(t,function(t){e.push(t)}),e},lh.prototype.getFeaturesInExtent=function(t){return this.featuresRtree_.getInExtent(t)},lh.prototype.getClosestFeatureToCoordinate=function(t,e){const i=t[0],n=t[1];let o=null;const s=[NaN,NaN];let r=1/0;const a=[-1/0,-1/0,1/0,1/0],h=e||I;return this.featuresRtree_.forEachInExtent(a,function(t){if(h(t)){const e=t.getGeometry(),h=r;if((r=e.closestPointXY(i,n,s,r))<h){o=t;const e=Math.sqrt(r);a[0]=i-e,a[1]=n-e,a[2]=i+e,a[3]=n+e}}}),o},lh.prototype.getExtent=function(t){return this.featuresRtree_.getExtent(t)},lh.prototype.getFeatureById=function(t){const e=this.idIndex_[t.toString()];return void 0!==e?e:null},lh.prototype.getFormat=function(){return this.format_},lh.prototype.getOverlaps=function(){return this.overlaps_},lh.prototype.getResolutions=function(){},lh.prototype.getUrl=function(){return this.url_},lh.prototype.handleFeatureChange_=function(t){const e=t.target,i=l(e).toString(),n=e.getGeometry();if(n){const t=n.getExtent();i in this.nullGeometryFeatures_?(delete this.nullGeometryFeatures_[i],this.featuresRtree_&&this.featuresRtree_.insert(t,e)):this.featuresRtree_&&this.featuresRtree_.update(t,e)}else i in this.nullGeometryFeatures_||(this.featuresRtree_&&this.featuresRtree_.remove(e),this.nullGeometryFeatures_[i]=e);const o=e.getId();if(void 0!==o){const t=o.toString();i in this.undefIdIndex_?(delete this.undefIdIndex_[i],this.idIndex_[t]=e):this.idIndex_[t]!==e&&(this.removeFromIdIndex_(e),this.idIndex_[t]=e)}else i in this.undefIdIndex_||(this.removeFromIdIndex_(e),this.undefIdIndex_[i]=e);this.changed(),this.dispatchEvent(new hh(eh,e))},lh.prototype.hasFeature=function(t){const e=t.getId();if(void 0!==e)return e in this.idIndex_;return l(t).toString()in this.undefIdIndex_},lh.prototype.isEmpty=function(){return this.featuresRtree_.isEmpty()&&_(this.nullGeometryFeatures_)},lh.prototype.loadFeatures=function(t,e,i){const n=this.loadedExtentsRtree_,o=this.strategy_(t,e);for(let t=0,s=o.length;t<s;++t){const s=o[t];n.forEachInExtent(s,function(t){return J(t.extent,s)})||(this.loader_.call(this,s,e,i),n.insert(s,{extent:s.slice()}))}},lh.prototype.removeLoadedExtent=function(t){const e=this.loadedExtentsRtree_;let i;e.forEachInExtent(t,function(e){if(st(e.extent,t))return i=e,!0}),i&&e.remove(i)},lh.prototype.removeFeature=function(t){const e=l(t).toString();e in this.nullGeometryFeatures_?delete this.nullGeometryFeatures_[e]:this.featuresRtree_&&this.featuresRtree_.remove(t),this.removeFeatureInternal(t),this.changed()},lh.prototype.removeFeatureInternal=function(t){const e=l(t).toString();this.featureChangeKeys_[e].forEach(S),delete this.featureChangeKeys_[e];const i=t.getId();void 0!==i?delete this.idIndex_[i.toString()]:delete this.undefIdIndex_[e],this.dispatchEvent(new hh(nh,t))},lh.prototype.removeFromIdIndex_=function(t){let e=!1;for(const i in this.idIndex_)if(this.idIndex_[i]===t){delete this.idIndex_[i],e=!0;break}return e},lh.prototype.setLoader=function(t){this.loader_=t};var ch=lh;const uh={POINT:\"Point\",LINE_STRING:\"LineString\",POLYGON:\"Polygon\",CIRCLE:\"Circle\"},ph=\"drawstart\",dh=\"drawend\",fh=function(t,e){k.call(this,t),this.feature=e};a(fh,k);const gh=function(t){Xr.call(this,{handleDownEvent:yh,handleEvent:_h,handleUpEvent:mh}),this.shouldHandle_=!1,this.downPx_=null,this.downTimeout_,this.lastDragTime_,this.freehand_=!1,this.source_=t.source?t.source:null,this.features_=t.features?t.features:null,this.snapTolerance_=t.snapTolerance?t.snapTolerance:12,this.type_=t.type,this.mode_=function(t){let e;t===Ot.POINT||t===Ot.MULTI_POINT?e=uh.POINT:t===Ot.LINE_STRING||t===Ot.MULTI_LINE_STRING?e=uh.LINE_STRING:t===Ot.POLYGON||t===Ot.MULTI_POLYGON?e=uh.POLYGON:t===Ot.CIRCLE&&(e=uh.CIRCLE);return e}(this.type_),this.stopClick_=!!t.stopClick,this.minPoints_=t.minPoints?t.minPoints:this.mode_===uh.POLYGON?3:2,this.maxPoints_=t.maxPoints?t.maxPoints:1/0,this.finishCondition_=t.finishCondition?t.finishCondition:I;let e=t.geometryFunction;if(!e)if(this.type_===Ot.CIRCLE)e=function(t,e){const i=e||new Xa([NaN,NaN]),n=vs(t[0],t[1]);return i.setCenterAndRadius(t[0],Math.sqrt(n)),i};else{let t;const i=this.mode_;i===uh.POINT?t=Pn:i===uh.LINE_STRING?t=wn:i===uh.POLYGON&&(t=Kn),e=function(e,n){let o=n;return o?i===uh.POLYGON?e[0].length?o.setCoordinates([e[0].concat([e[0][0]])]):o.setCoordinates([]):o.setCoordinates(e):o=new t(e),o}}this.geometryFunction_=e,this.dragVertexDelay_=void 0!==t.dragVertexDelay?t.dragVertexDelay:500,this.finishCoordinate_=null,this.sketchFeature_=null,this.sketchPoint_=null,this.sketchCoords_=null,this.sketchLine_=null,this.sketchLineCoords_=null,this.squaredClickTolerance_=t.clickTolerance?t.clickTolerance*t.clickTolerance:36,this.overlay_=new Za({source:new ch({useSpatialIndex:!1,wrapX:!!t.wrapX&&t.wrapX}),style:t.style?t.style:function(){const t=Ii();return function(e,i){return t[e.getGeometry().getType()]}}(),updateWhileInteracting:!0}),this.geometryName_=t.geometryName,this.condition_=t.condition?t.condition:Fr,this.freehandCondition_,t.freehand?this.freehandCondition_=Tr:this.freehandCondition_=t.freehandCondition?t.freehandCondition:Pr,C(this,W(ur),this.updateState_,this)};function _h(t){t.originalEvent.type===w.CONTEXTMENU&&t.preventDefault(),this.freehand_=this.mode_!==uh.POINT&&this.freehandCondition_(t);let e=t.type===uo.POINTERMOVE,i=!0;if(this.lastDragTime_&&t.type===uo.POINTERDRAG){Date.now()-this.lastDragTime_>=this.dragVertexDelay_?(this.downPx_=t.pixel,this.shouldHandle_=!this.freehand_,e=!0):this.lastDragTime_=void 0,this.shouldHandle_&&this.downTimeout_&&(clearTimeout(this.downTimeout_),this.downTimeout_=void 0)}return this.freehand_&&t.type===uo.POINTERDRAG&&null!==this.sketchFeature_?(this.addToDrawing_(t),i=!1):this.freehand_&&t.type===uo.POINTERDOWN?i=!1:e?(i=t.type===uo.POINTERMOVE)&&this.freehand_?i=this.handlePointerMove_(t):(t.pointerEvent.pointerType==Io||t.type===uo.POINTERDRAG&&!this.downTimeout_)&&this.handlePointerMove_(t):t.type===uo.DBLCLICK&&(i=!1),Yr.call(this,t)&&i}function yh(t){return this.shouldHandle_=!this.freehand_,this.freehand_?(this.downPx_=t.pixel,this.finishCoordinate_||this.startDrawing_(t),!0):!!this.condition_(t)&&(this.lastDragTime_=Date.now(),this.downTimeout_=setTimeout(function(){this.handlePointerMove_(new fo(uo.POINTERMOVE,t.map,t.pointerEvent,t.frameState))}.bind(this),this.dragVertexDelay_),this.downPx_=t.pixel,!0)}function mh(t){let e=!0;this.downTimeout_&&(clearTimeout(this.downTimeout_),this.downTimeout_=void 0),this.handlePointerMove_(t);const i=this.mode_===uh.CIRCLE;return this.shouldHandle_?(this.finishCoordinate_?this.freehand_||i?this.finishDrawing():this.atFinish_(t)?this.finishCondition_(t)&&this.finishDrawing():this.addToDrawing_(t):(this.startDrawing_(t),this.mode_===uh.POINT&&this.finishDrawing()),e=!1):this.freehand_&&(this.finishCoordinate_=null,this.abortDrawing_()),!e&&this.stopClick_&&t.stopPropagation(),e}a(gh,Xr),gh.prototype.setMap=function(t){Xr.prototype.setMap.call(this,t),this.updateState_()},gh.prototype.handlePointerMove_=function(t){if(this.downPx_&&(!this.freehand_&&this.shouldHandle_||this.freehand_&&!this.shouldHandle_)){const e=this.downPx_,i=t.pixel,n=e[0]-i[0],o=e[1]-i[1],s=n*n+o*o;if(this.shouldHandle_=this.freehand_?s>this.squaredClickTolerance_:s<=this.squaredClickTolerance_,!this.shouldHandle_)return!0}return this.finishCoordinate_?this.modifyDrawing_(t):this.createOrUpdateSketchPoint_(t),!0},gh.prototype.atFinish_=function(t){let e=!1;if(this.sketchFeature_){let i=!1,n=[this.finishCoordinate_];if(this.mode_===uh.LINE_STRING?i=this.sketchCoords_.length>this.minPoints_:this.mode_===uh.POLYGON&&(i=this.sketchCoords_[0].length>this.minPoints_,n=[this.sketchCoords_[0][0],this.sketchCoords_[0][this.sketchCoords_[0].length-2]]),i){const i=t.map;for(let o=0,s=n.length;o<s;o++){const s=n[o],r=i.getPixelFromCoordinate(s),a=t.pixel,h=a[0]-r[0],l=a[1]-r[1],c=this.freehand_?1:this.snapTolerance_;if(e=Math.sqrt(h*h+l*l)<=c){this.finishCoordinate_=s;break}}}}return e},gh.prototype.createOrUpdateSketchPoint_=function(t){const e=t.coordinate.slice();if(this.sketchPoint_){this.sketchPoint_.getGeometry().setCoordinates(e)}else this.sketchPoint_=new Mi(new Pn(e)),this.updateSketchFeatures_()},gh.prototype.startDrawing_=function(t){const e=t.coordinate;this.finishCoordinate_=e,this.mode_===uh.POINT?this.sketchCoords_=e.slice():this.mode_===uh.POLYGON?(this.sketchCoords_=[[e.slice(),e.slice()]],this.sketchLineCoords_=this.sketchCoords_[0]):this.sketchCoords_=[e.slice(),e.slice()],this.sketchLineCoords_&&(this.sketchLine_=new Mi(new wn(this.sketchLineCoords_)));const i=this.geometryFunction_(this.sketchCoords_);this.sketchFeature_=new Mi,this.geometryName_&&this.sketchFeature_.setGeometryName(this.geometryName_),this.sketchFeature_.setGeometry(i),this.updateSketchFeatures_(),this.dispatchEvent(new fh(ph,this.sketchFeature_))},gh.prototype.modifyDrawing_=function(t){let e=t.coordinate;const i=this.sketchFeature_.getGeometry();let n,o,s;if(this.mode_===uh.POINT?o=this.sketchCoords_:this.mode_===uh.POLYGON?(o=(n=this.sketchCoords_[0])[n.length-1],this.atFinish_(t)&&(e=this.finishCoordinate_.slice())):o=(n=this.sketchCoords_)[n.length-1],o[0]=e[0],o[1]=e[1],this.geometryFunction_(this.sketchCoords_,i),this.sketchPoint_){this.sketchPoint_.getGeometry().setCoordinates(e)}if(i instanceof Kn&&this.mode_!==uh.POLYGON){this.sketchLine_||(this.sketchLine_=new Mi(new wn(null)));const t=i.getLinearRing(0);(s=this.sketchLine_.getGeometry()).setFlatCoordinates(t.getLayout(),t.getFlatCoordinates())}else this.sketchLineCoords_&&(s=this.sketchLine_.getGeometry()).setCoordinates(this.sketchLineCoords_);this.updateSketchFeatures_()},gh.prototype.addToDrawing_=function(t){const e=t.coordinate,i=this.sketchFeature_.getGeometry();let n,o;this.mode_===uh.LINE_STRING?(this.finishCoordinate_=e.slice(),(o=this.sketchCoords_).length>=this.maxPoints_&&(this.freehand_?o.pop():n=!0),o.push(e.slice()),this.geometryFunction_(o,i)):this.mode_===uh.POLYGON&&((o=this.sketchCoords_[0]).length>=this.maxPoints_&&(this.freehand_?o.pop():n=!0),o.push(e.slice()),n&&(this.finishCoordinate_=o[0]),this.geometryFunction_(this.sketchCoords_,i)),this.updateSketchFeatures_(),n&&this.finishDrawing()},gh.prototype.removeLastPoint=function(){if(!this.sketchFeature_)return;const t=this.sketchFeature_.getGeometry();let e,i;this.mode_===uh.LINE_STRING?((e=this.sketchCoords_).splice(-2,1),this.geometryFunction_(e,t),e.length>=2&&(this.finishCoordinate_=e[e.length-2].slice())):this.mode_===uh.POLYGON&&((e=this.sketchCoords_[0]).splice(-2,1),(i=this.sketchLine_.getGeometry()).setCoordinates(e),this.geometryFunction_(this.sketchCoords_,t)),0===e.length&&(this.finishCoordinate_=null),this.updateSketchFeatures_()},gh.prototype.finishDrawing=function(){const t=this.abortDrawing_();if(!t)return;let e=this.sketchCoords_;const i=t.getGeometry();this.mode_===uh.LINE_STRING?(e.pop(),this.geometryFunction_(e,i)):this.mode_===uh.POLYGON&&(e[0].pop(),this.geometryFunction_(e,i),e=i.getCoordinates()),this.type_===Ot.MULTI_POINT?t.setGeometry(new Mn([e])):this.type_===Ot.MULTI_LINE_STRING?t.setGeometry(new In([e])):this.type_===Ot.MULTI_POLYGON&&t.setGeometry(new Vn([e])),this.dispatchEvent(new fh(dh,t)),this.features_&&this.features_.push(t),this.source_&&this.source_.addFeature(t)},gh.prototype.abortDrawing_=function(){this.finishCoordinate_=null;const t=this.sketchFeature_;return t&&(this.sketchFeature_=null,this.sketchPoint_=null,this.sketchLine_=null,this.overlay_.getSource().clear(!0)),t},gh.prototype.extend=function(t){const e=t.getGeometry();this.sketchFeature_=t,this.sketchCoords_=e.getCoordinates();const i=this.sketchCoords_[this.sketchCoords_.length-1];this.finishCoordinate_=i.slice(),this.sketchCoords_.push(i.slice()),this.updateSketchFeatures_(),this.dispatchEvent(new fh(ph,this.sketchFeature_))},gh.prototype.shouldStopEvent=F,gh.prototype.updateSketchFeatures_=function(){const t=[];this.sketchFeature_&&t.push(this.sketchFeature_),this.sketchLine_&&t.push(this.sketchLine_),this.sketchPoint_&&t.push(this.sketchPoint_);const e=this.overlay_.getSource();e.clear(!0),e.addFeatures(t)},gh.prototype.updateState_=function(){const t=this.getMap(),e=this.getActive();t&&e||this.abortDrawing_(),this.overlay_.setMap(e?t:null)};const vh=\"extentchanged\",xh=function(t){k.call(this,vh),this.extent=t};a(xh,k);const Ch=function(t){const e=t||{};this.extent_=null,this.pointerHandler_=null,this.pixelTolerance_=void 0!==e.pixelTolerance?e.pixelTolerance:10,this.snappedToVertex_=!1,this.extentFeature_=null,this.vertexFeature_=null,t||(t={}),Xr.call(this,{handleDownEvent:Th,handleDragEvent:Sh,handleEvent:Eh,handleUpEvent:wh}),this.extentOverlay_=new Za({source:new ch({useSpatialIndex:!1,wrapX:!!t.wrapX}),style:t.boxStyle?t.boxStyle:function(){const t=Ii();return function(e,i){return t[Ot.POLYGON]}}(),updateWhileAnimating:!0,updateWhileInteracting:!0}),this.vertexOverlay_=new Za({source:new ch({useSpatialIndex:!1,wrapX:!!t.wrapX}),style:t.pointerStyle?t.pointerStyle:function(){const t=Ii();return function(e,i){return t[Ot.POINT]}}(),updateWhileAnimating:!0,updateWhileInteracting:!0}),t.extent&&this.setExtent(t.extent)};function Eh(t){return!(t instanceof fo)||(t.type!=uo.POINTERMOVE||this.handlingDownUpSequence||this.handlePointerMove_(t),Yr.call(this,t),!1)}function Th(t){const e=t.pixel,i=t.map,n=this.getExtent();let o=this.snapToVertex_(e,i);const s=function(t){let e=null,i=null;return t[0]==n[0]?e=n[2]:t[0]==n[2]&&(e=n[0]),t[1]==n[1]?i=n[3]:t[1]==n[3]&&(i=n[1]),null!==e&&null!==i?[e,i]:null};if(o&&n){const t=o[0]==n[0]||o[0]==n[2]?o[0]:null,e=o[1]==n[1]||o[1]==n[3]?o[1]:null;null!==t&&null!==e?this.pointerHandler_=Rh(s(o)):null!==t?this.pointerHandler_=Ih(s([t,n[1]]),s([t,n[3]])):null!==e&&(this.pointerHandler_=Ih(s([n[0],e]),s([n[2],e])))}else o=i.getCoordinateFromPixel(e),this.setExtent([o[0],o[1],o[0],o[1]]),this.pointerHandler_=Rh(o);return!0}function Sh(t){if(this.pointerHandler_){const e=t.coordinate;this.setExtent(this.pointerHandler_(e)),this.createOrUpdatePointerFeature_(e)}return!0}function wh(t){this.pointerHandler_=null;const e=this.getExtent();return e&&0!==pt(e)||this.setExtent(null),!1}function Rh(t){return function(e){return j([t,e])}}function Ih(t,e){return t[0]==e[0]?function(i){return j([t,[i[0],e[1]]])}:t[1]==e[1]?function(i){return j([t,[e[0],i[1]]])}:null}a(Ch,Xr),Ch.prototype.snapToVertex_=function(t,e){const i=e.getCoordinateFromPixel(t),n=function(t,e){return Cs(i,t)-Cs(i,e)},o=this.getExtent();if(o){const s=function(t){return[[[t[0],t[1]],[t[0],t[3]]],[[t[0],t[3]],[t[2],t[3]]],[[t[2],t[3]],[t[2],t[1]]],[[t[2],t[1]],[t[0],t[1]]]]}(o);s.sort(n);const r=s[0];let a=gs(i,r);const h=e.getPixelFromCoordinate(a);if(xs(t,h)<=this.pixelTolerance_){const t=e.getPixelFromCoordinate(r[0]),i=e.getPixelFromCoordinate(r[1]),n=vs(h,t),o=vs(h,i),s=Math.sqrt(Math.min(n,o));return this.snappedToVertex_=s<=this.pixelTolerance_,this.snappedToVertex_&&(a=n>o?r[1]:r[0]),a}}return null},Ch.prototype.handlePointerMove_=function(t){const e=t.pixel,i=t.map;let n=this.snapToVertex_(e,i);n||(n=i.getCoordinateFromPixel(e)),this.createOrUpdatePointerFeature_(n)},Ch.prototype.createOrUpdateExtentFeature_=function(t){let e=this.extentFeature_;return e?t?e.setGeometry(Un(t)):e.setGeometry(void 0):(e=new Mi(t?Un(t):{}),this.extentFeature_=e,this.extentOverlay_.getSource().addFeature(e)),e},Ch.prototype.createOrUpdatePointerFeature_=function(t){let e=this.vertexFeature_;if(e){e.getGeometry().setCoordinates(t)}else e=new Mi(new Pn(t)),this.vertexFeature_=e,this.vertexOverlay_.getSource().addFeature(e);return e},Ch.prototype.setMap=function(t){this.extentOverlay_.setMap(t),this.vertexOverlay_.setMap(t),Xr.prototype.setMap.call(this,t)},Ch.prototype.getExtent=function(){return this.extent_},Ch.prototype.setExtent=function(t){this.extent_=t||null,this.createOrUpdateExtentFeature_(t),this.dispatchEvent(new xh(this.extent_))};const Fh={MODIFYSTART:\"modifystart\",MODIFYEND:\"modifyend\"},Ph=function(t,e,i){k.call(this,t),this.features=e,this.mapBrowserEvent=i};a(Ph,k);const Lh=function(t){let e;if(Xr.call(this,{handleDownEvent:kh,handleDragEvent:Ah,handleEvent:Dh,handleUpEvent:Gh}),this.condition_=t.condition?t.condition:br,this.defaultDeleteCondition_=function(t){return function(t){const e=t.originalEvent;return e.altKey&&!(e.metaKey||e.ctrlKey)&&!e.shiftKey}(t)&&Ir(t)},this.deleteCondition_=t.deleteCondition?t.deleteCondition:this.defaultDeleteCondition_,this.insertVertexCondition_=t.insertVertexCondition?t.insertVertexCondition:Tr,this.vertexFeature_=null,this.vertexSegments_=null,this.lastPixel_=[0,0],this.ignoreNextSingleClick_=!1,this.modified_=!1,this.rBush_=new ah,this.pixelTolerance_=void 0!==t.pixelTolerance?t.pixelTolerance:10,this.snappedToVertex_=!1,this.changingFeature_=!1,this.dragSegments_=[],this.overlay_=new Za({source:new ch({useSpatialIndex:!1,wrapX:!!t.wrapX}),style:t.style?t.style:function(){const t=Ii();return function(e,i){return t[Ot.POINT]}}(),updateWhileAnimating:!0,updateWhileInteracting:!0}),this.SEGMENT_WRITERS_={Point:this.writePointGeometry_,LineString:this.writeLineStringGeometry_,LinearRing:this.writeLineStringGeometry_,Polygon:this.writePolygonGeometry_,MultiPoint:this.writeMultiPointGeometry_,MultiLineString:this.writeMultiLineStringGeometry_,MultiPolygon:this.writeMultiPolygonGeometry_,Circle:this.writeCircleGeometry_,GeometryCollection:this.writeGeometryCollectionGeometry_},this.source_=null,t.source?(this.source_=t.source,e=new ro(this.source_.getFeatures()),C(this.source_,th,this.handleSourceAdd_,this),C(this.source_,nh,this.handleSourceRemove_,this)):e=t.features,!e)throw new Error(\"The modify interaction requires features or a source\");this.features_=e,this.features_.forEach(this.addFeature_.bind(this)),C(this.features_,eo,this.handleFeatureAdd_,this),C(this.features_,io,this.handleFeatureRemove_,this),this.lastPointerEvent_=null};a(Lh,Xr);const Mh=0,bh=1;function Oh(t,e){return t.index-e.index}function kh(t){if(!this.condition_(t))return!1;this.handlePointerAtPixel_(t.pixel,t.map);const e=t.map.getCoordinateFromPixel(t.pixel);this.dragSegments_.length=0,this.modified_=!1;const i=this.vertexFeature_;if(i){const n=[],o=i.getGeometry().getCoordinates(),s=j([o]),r=this.rBush_.getInExtent(s),a={};r.sort(Oh);for(let i=0,s=r.length;i<s;++i){const s=r[i],h=s.segment;let c=l(s.feature);const u=s.depth;if(u&&(c+=\"-\"+u.join(\"-\")),a[c]||(a[c]=new Array(2)),s.geometry.getType()===Ot.CIRCLE&&s.index===bh){_s(Yh(e,s),o)&&!a[c][0]&&(this.dragSegments_.push([s,0]),a[c][0]=s)}else if(_s(h[0],o)&&!a[c][0])this.dragSegments_.push([s,0]),a[c][0]=s;else if(_s(h[1],o)&&!a[c][1]){if((s.geometry.getType()===Ot.LINE_STRING||s.geometry.getType()===Ot.MULTI_LINE_STRING)&&a[c][0]&&0===a[c][0].index)continue;this.dragSegments_.push([s,1]),a[c][1]=s}else this.insertVertexCondition_(t)&&l(h)in this.vertexSegments_&&!a[c][0]&&!a[c][1]&&n.push([s,o])}n.length&&this.willModifyFeatures_(t);for(let t=n.length-1;t>=0;--t)this.insertVertex_.apply(this,n[t])}return!!this.vertexFeature_}function Ah(t){this.ignoreNextSingleClick_=!1,this.willModifyFeatures_(t);const e=t.coordinate;for(let t=0,i=this.dragSegments_.length;t<i;++t){const i=this.dragSegments_[t],n=i[0],o=n.depth,s=n.geometry;let r;const a=n.segment,h=i[1];for(;e.length<s.getStride();)e.push(a[h][e.length]);switch(s.getType()){case Ot.POINT:r=e,a[0]=a[1]=e;break;case Ot.MULTI_POINT:(r=s.getCoordinates())[n.index]=e,a[0]=a[1]=e;break;case Ot.LINE_STRING:(r=s.getCoordinates())[n.index+h]=e,a[h]=e;break;case Ot.MULTI_LINE_STRING:case Ot.POLYGON:(r=s.getCoordinates())[o[0]][n.index+h]=e,a[h]=e;break;case Ot.MULTI_POLYGON:(r=s.getCoordinates())[o[1]][o[0]][n.index+h]=e,a[h]=e;break;case Ot.CIRCLE:a[0]=a[1]=e,n.index===Mh?(this.changingFeature_=!0,s.setCenter(e),this.changingFeature_=!1):(this.changingFeature_=!0,s.setRadius(xs(s.getCenter(),e)),this.changingFeature_=!1)}r&&this.setGeometryCoordinates_(s,r)}this.createOrUpdateVertexFeature_(e)}function Gh(t){for(let t=this.dragSegments_.length-1;t>=0;--t){const e=this.dragSegments_[t][0],i=e.geometry;if(i.getType()===Ot.CIRCLE){const t=i.getCenter(),n=e.featureSegments[0],o=e.featureSegments[1];n.segment[0]=n.segment[1]=t,o.segment[0]=o.segment[1]=t,this.rBush_.update(nt(t),n),this.rBush_.update(i.getExtent(),o)}else this.rBush_.update(j(e.segment),e)}return this.modified_&&(this.dispatchEvent(new Ph(Fh.MODIFYEND,this.features_,t)),this.modified_=!1),!1}function Dh(t){if(!(t instanceof fo))return!0;let e;return this.lastPointerEvent_=t,t.map.getView().getInteracting()||t.type!=uo.POINTERMOVE||this.handlingDownUpSequence||this.handlePointerMove_(t),this.vertexFeature_&&this.deleteCondition_(t)&&(e=!(t.type!=uo.SINGLECLICK||!this.ignoreNextSingleClick_)||this.removePoint()),t.type==uo.SINGLECLICK&&(this.ignoreNextSingleClick_=!1),Yr.call(this,t)&&!e}function Nh(t,e){const i=e.geometry;if(i.getType()===Ot.CIRCLE){const n=i;if(e.index===bh){const e=vs(n.getCenter(),t),i=Math.sqrt(e)-n.getRadius();return i*i}}return Cs(t,e.segment)}function Yh(t,e){const i=e.geometry;return i.getType()===Ot.CIRCLE&&e.index===bh?i.getClosestPoint(t):gs(t,e.segment)}Lh.prototype.addFeature_=function(t){const e=t.getGeometry();e&&e.getType()in this.SEGMENT_WRITERS_&&this.SEGMENT_WRITERS_[e.getType()].call(this,t,e);const i=this.getMap();i&&i.isRendered()&&this.getActive()&&this.handlePointerAtPixel_(this.lastPixel_,i),C(t,w.CHANGE,this.handleFeatureChange_,this)},Lh.prototype.willModifyFeatures_=function(t){this.modified_||(this.modified_=!0,this.dispatchEvent(new Ph(Fh.MODIFYSTART,this.features_,t)))},Lh.prototype.removeFeature_=function(t){this.removeFeatureSegmentData_(t),this.vertexFeature_&&0===this.features_.getLength()&&(this.overlay_.getSource().removeFeature(this.vertexFeature_),this.vertexFeature_=null),T(t,w.CHANGE,this.handleFeatureChange_,this)},Lh.prototype.removeFeatureSegmentData_=function(t){const e=this.rBush_,i=[];e.forEach(function(e){t===e.feature&&i.push(e)});for(let t=i.length-1;t>=0;--t)e.remove(i[t])},Lh.prototype.setActive=function(t){this.vertexFeature_&&!t&&(this.overlay_.getSource().removeFeature(this.vertexFeature_),this.vertexFeature_=null),Xr.prototype.setActive.call(this,t)},Lh.prototype.setMap=function(t){this.overlay_.setMap(t),Xr.prototype.setMap.call(this,t)},Lh.prototype.handleSourceAdd_=function(t){t.feature&&this.features_.push(t.feature)},Lh.prototype.handleSourceRemove_=function(t){t.feature&&this.features_.remove(t.feature)},Lh.prototype.handleFeatureAdd_=function(t){this.addFeature_(t.element)},Lh.prototype.handleFeatureChange_=function(t){if(!this.changingFeature_){const e=t.target;this.removeFeature_(e),this.addFeature_(e)}},Lh.prototype.handleFeatureRemove_=function(t){const e=t.element;this.removeFeature_(e)},Lh.prototype.writePointGeometry_=function(t,e){const i=e.getCoordinates(),n={feature:t,geometry:e,segment:[i,i]};this.rBush_.insert(e.getExtent(),n)},Lh.prototype.writeMultiPointGeometry_=function(t,e){const i=e.getCoordinates();for(let n=0,o=i.length;n<o;++n){const o=i[n],s={feature:t,geometry:e,depth:[n],index:n,segment:[o,o]};this.rBush_.insert(e.getExtent(),s)}},Lh.prototype.writeLineStringGeometry_=function(t,e){const i=e.getCoordinates();for(let n=0,o=i.length-1;n<o;++n){const o=i.slice(n,n+2),s={feature:t,geometry:e,index:n,segment:o};this.rBush_.insert(j(o),s)}},Lh.prototype.writeMultiLineStringGeometry_=function(t,e){const i=e.getCoordinates();for(let n=0,o=i.length;n<o;++n){const o=i[n];for(let i=0,s=o.length-1;i<s;++i){const s=o.slice(i,i+2),r={feature:t,geometry:e,depth:[n],index:i,segment:s};this.rBush_.insert(j(s),r)}}},Lh.prototype.writePolygonGeometry_=function(t,e){const i=e.getCoordinates();for(let n=0,o=i.length;n<o;++n){const o=i[n];for(let i=0,s=o.length-1;i<s;++i){const s=o.slice(i,i+2),r={feature:t,geometry:e,depth:[n],index:i,segment:s};this.rBush_.insert(j(s),r)}}},Lh.prototype.writeMultiPolygonGeometry_=function(t,e){const i=e.getCoordinates();for(let n=0,o=i.length;n<o;++n){const o=i[n];for(let i=0,s=o.length;i<s;++i){const s=o[i];for(let o=0,r=s.length-1;o<r;++o){const r=s.slice(o,o+2),a={feature:t,geometry:e,depth:[i,n],index:o,segment:r};this.rBush_.insert(j(r),a)}}}},Lh.prototype.writeCircleGeometry_=function(t,e){const i=e.getCenter(),n={feature:t,geometry:e,index:Mh,segment:[i,i]},o={feature:t,geometry:e,index:bh,segment:[i,i]},s=[n,o];n.featureSegments=o.featureSegments=s,this.rBush_.insert(nt(i),n),this.rBush_.insert(e.getExtent(),o)},Lh.prototype.writeGeometryCollectionGeometry_=function(t,e){const i=e.getGeometriesArray();for(let e=0;e<i.length;++e)this.SEGMENT_WRITERS_[i[e].getType()].call(this,t,i[e])},Lh.prototype.createOrUpdateVertexFeature_=function(t){let e=this.vertexFeature_;if(e){e.getGeometry().setCoordinates(t)}else e=new Mi(new Pn(t)),this.vertexFeature_=e,this.overlay_.getSource().addFeature(e);return e},Lh.prototype.handlePointerMove_=function(t){this.lastPixel_=t.pixel,this.handlePointerAtPixel_(t.pixel,t.map)},Lh.prototype.handlePointerAtPixel_=function(t,e){const i=e.getCoordinateFromPixel(t),n=function(t,e){return Nh(i,t)-Nh(i,e)},o=H(nt(i),e.getView().getResolution()*this.pixelTolerance_),s=this.rBush_.getInExtent(o);if(s.length>0){s.sort(n);const o=s[0],r=o.segment;let a=Yh(i,o);const h=e.getPixelFromCoordinate(a);let c=xs(t,h);if(c<=this.pixelTolerance_){const t={};if(o.geometry.getType()===Ot.CIRCLE&&o.index===bh)this.snappedToVertex_=!0,this.createOrUpdateVertexFeature_(a);else{const i=e.getPixelFromCoordinate(r[0]),n=e.getPixelFromCoordinate(r[1]),o=vs(h,i),u=vs(h,n);c=Math.sqrt(Math.min(o,u)),this.snappedToVertex_=c<=this.pixelTolerance_,this.snappedToVertex_&&(a=o>u?r[1]:r[0]),this.createOrUpdateVertexFeature_(a);for(let e=1,i=s.length;e<i;++e){const i=s[e].segment;if(!(_s(r[0],i[0])&&_s(r[1],i[1])||_s(r[0],i[1])&&_s(r[1],i[0])))break;t[l(i)]=!0}}return t[l(r)]=!0,void(this.vertexSegments_=t)}}this.vertexFeature_&&(this.overlay_.getSource().removeFeature(this.vertexFeature_),this.vertexFeature_=null)},Lh.prototype.insertVertex_=function(t,e){const i=t.segment,n=t.feature,o=t.geometry,s=t.depth,r=t.index;let a;for(;e.length<o.getStride();)e.push(0);switch(o.getType()){case Ot.MULTI_LINE_STRING:case Ot.POLYGON:(a=o.getCoordinates())[s[0]].splice(r+1,0,e);break;case Ot.MULTI_POLYGON:(a=o.getCoordinates())[s[1]][s[0]].splice(r+1,0,e);break;case Ot.LINE_STRING:(a=o.getCoordinates()).splice(r+1,0,e);break;default:return}this.setGeometryCoordinates_(o,a);const h=this.rBush_;h.remove(t),this.updateSegmentIndices_(o,r,s,1);const l={segment:[i[0],e],feature:n,geometry:o,depth:s,index:r};h.insert(j(l.segment),l),this.dragSegments_.push([l,1]);const c={segment:[e,i[1]],feature:n,geometry:o,depth:s,index:r+1};h.insert(j(c.segment),c),this.dragSegments_.push([c,0]),this.ignoreNextSingleClick_=!0},Lh.prototype.removePoint=function(){if(this.lastPointerEvent_&&this.lastPointerEvent_.type!=uo.POINTERDRAG){const t=this.lastPointerEvent_;return this.willModifyFeatures_(t),this.removeVertex_(),this.dispatchEvent(new Ph(Fh.MODIFYEND,this.features_,t)),this.modified_=!1,!0}return!1},Lh.prototype.removeVertex_=function(){const t=this.dragSegments_,e={};let i,n,o,s,r,a,h,c,u,p,d,f=!1;for(r=t.length-1;r>=0;--r)d=l((p=(o=t[r])[0]).feature),p.depth&&(d+=\"-\"+p.depth.join(\"-\")),d in e||(e[d]={}),0===o[1]?(e[d].right=p,e[d].index=p.index):1==o[1]&&(e[d].left=p,e[d].index=p.index+1);for(d in e){switch(u=e[d].right,h=e[d].left,c=(a=e[d].index)-1,p=void 0!==h?h:u,c<0&&(c=0),i=n=(s=p.geometry).getCoordinates(),f=!1,s.getType()){case Ot.MULTI_LINE_STRING:n[p.depth[0]].length>2&&(n[p.depth[0]].splice(a,1),f=!0);break;case Ot.LINE_STRING:n.length>2&&(n.splice(a,1),f=!0);break;case Ot.MULTI_POLYGON:i=i[p.depth[1]];case Ot.POLYGON:(i=i[p.depth[0]]).length>4&&(a==i.length-1&&(a=0),i.splice(a,1),f=!0,0===a&&(i.pop(),i.push(i[0]),c=i.length-1))}if(f){this.setGeometryCoordinates_(s,n);const e=[];if(void 0!==h&&(this.rBush_.remove(h),e.push(h.segment[0])),void 0!==u&&(this.rBush_.remove(u),e.push(u.segment[1])),void 0!==h&&void 0!==u){const t={depth:p.depth,feature:p.feature,geometry:p.geometry,index:c,segment:e};this.rBush_.insert(j(t.segment),t)}this.updateSegmentIndices_(s,a,p.depth,-1),this.vertexFeature_&&(this.overlay_.getSource().removeFeature(this.vertexFeature_),this.vertexFeature_=null),t.length=0}}return f},Lh.prototype.setGeometryCoordinates_=function(t,e){this.changingFeature_=!0,t.setCoordinates(e),this.changingFeature_=!1},Lh.prototype.updateSegmentIndices_=function(t,e,i,n){this.rBush_.forEachInExtent(t.getExtent(),function(o){o.geometry===t&&(void 0===i||void 0===o.depth||Hi(o.depth,i))&&o.index>e&&(o.index+=n)})};const Xh={SELECT:\"select\"},zh=function(t,e,i,n){k.call(this,t),this.selected=e,this.deselected=i,this.mapBrowserEvent=n};a(zh,k);const Wh=function(t){mr.call(this,{handleEvent:Kh});const e=t||{};this.condition_=e.condition?e.condition:Ir,this.addCondition_=e.addCondition?e.addCondition:wr,this.removeCondition_=e.removeCondition?e.removeCondition:wr,this.toggleCondition_=e.toggleCondition?e.toggleCondition:Pr,this.multi_=!!e.multi&&e.multi,this.filter_=e.filter?e.filter:I,this.hitTolerance_=e.hitTolerance?e.hitTolerance:0;const i=new Za({source:new ch({useSpatialIndex:!1,features:e.features,wrapX:e.wrapX}),style:e.style?e.style:function(){const t=Ii();return ji(t[Ot.POLYGON],t[Ot.LINE_STRING]),ji(t[Ot.GEOMETRY_COLLECTION],t[Ot.LINE_STRING]),function(e,i){return e.getGeometry()?t[e.getGeometry().getType()]:null}}(),updateWhileAnimating:!0,updateWhileInteracting:!0});let n;if(this.featureOverlay_=i,e.layers)if(\"function\"==typeof e.layers)n=e.layers;else{const t=e.layers;n=function(e){return Ki(t,e)}}else n=I;this.layerFilter_=n,this.featureLayerAssociation_={};const o=this.featureOverlay_.getSource().getFeaturesCollection();C(o,eo,this.addFeature_,this),C(o,io,this.removeFeature_,this)};function Kh(t){if(!this.condition_(t))return!0;const e=this.addCondition_(t),i=this.removeCondition_(t),n=this.toggleCondition_(t),o=!e&&!i&&!n,s=t.map,r=this.featureOverlay_.getSource().getFeaturesCollection(),a=[],h=[];if(o){f(this.featureLayerAssociation_),s.forEachFeatureAtPixel(t.pixel,function(t,e){if(this.filter_(t,e))return h.push(t),this.addFeatureLayerAssociation_(t,e),!this.multi_}.bind(this),{layerFilter:this.layerFilter_,hitTolerance:this.hitTolerance_});for(let t=r.getLength()-1;t>=0;--t){const e=r.item(t),i=h.indexOf(e);i>-1?h.splice(i,1):(r.remove(e),a.push(e))}0!==h.length&&r.extend(h)}else{s.forEachFeatureAtPixel(t.pixel,function(t,o){if(this.filter_(t,o))return!e&&!n||Ki(r.getArray(),t)?(i||n)&&Ki(r.getArray(),t)&&(a.push(t),this.removeFeatureLayerAssociation_(t)):(h.push(t),this.addFeatureLayerAssociation_(t,o)),!this.multi_}.bind(this),{layerFilter:this.layerFilter_,hitTolerance:this.hitTolerance_});for(let t=a.length-1;t>=0;--t)r.remove(a[t]);r.extend(h)}return(h.length>0||a.length>0)&&this.dispatchEvent(new zh(Xh.SELECT,h,a,t)),Rr(t)}a(Wh,mr),Wh.prototype.addFeatureLayerAssociation_=function(t,e){const i=l(t);this.featureLayerAssociation_[i]=e},Wh.prototype.getFeatures=function(){return this.featureOverlay_.getSource().getFeaturesCollection()},Wh.prototype.getHitTolerance=function(){return this.hitTolerance_},Wh.prototype.getLayer=function(t){const e=l(t);return this.featureLayerAssociation_[e]},Wh.prototype.setHitTolerance=function(t){this.hitTolerance_=t},Wh.prototype.setMap=function(t){const e=this.getMap(),i=this.featureOverlay_.getSource().getFeaturesCollection();e&&i.forEach(e.unskipFeature.bind(e)),mr.prototype.setMap.call(this,t),this.featureOverlay_.setMap(t),t&&i.forEach(t.skipFeature.bind(t))},Wh.prototype.addFeature_=function(t){const e=this.getMap();e&&e.skipFeature(t.element)},Wh.prototype.removeFeature_=function(t){const e=this.getMap();e&&e.unskipFeature(t.element)},Wh.prototype.removeFeatureLayerAssociation_=function(t){const e=l(t);delete this.featureLayerAssociation_[e]};const Uh=function(t){Xr.call(this,{handleEvent:Bh,handleDownEvent:I,handleUpEvent:jh});const e=t||{};this.source_=e.source?e.source:null,this.vertex_=void 0===e.vertex||e.vertex,this.edge_=void 0===e.edge||e.edge,this.features_=e.features?e.features:null,this.featuresListenerKeys_=[],this.featureChangeListenerKeys_={},this.indexedFeaturesExtents_={},this.pendingFeatures_={},this.pixelCoordinate_=null,this.pixelTolerance_=void 0!==e.pixelTolerance?e.pixelTolerance:10,this.sortByDistance_=function(t,e){const i=Cs(this.pixelCoordinate_,t.segment),n=Cs(this.pixelCoordinate_,e.segment);return i-n}.bind(this),this.rBush_=new ah,this.SEGMENT_WRITERS_={Point:this.writePointGeometry_,LineString:this.writeLineStringGeometry_,LinearRing:this.writeLineStringGeometry_,Polygon:this.writePolygonGeometry_,MultiPoint:this.writeMultiPointGeometry_,MultiLineString:this.writeMultiLineStringGeometry_,MultiPolygon:this.writeMultiPolygonGeometry_,GeometryCollection:this.writeGeometryCollectionGeometry_,Circle:this.writeCircleGeometry_}};function Bh(t){const e=this.snapTo(t.pixel,t.coordinate,t.map);return e.snapped&&(t.coordinate=e.vertex.slice(0,2),t.pixel=e.vertexPixel),Yr.call(this,t)}function jh(t){const e=g(this.pendingFeatures_);return e.length&&(e.forEach(this.updateFeature_.bind(this)),this.pendingFeatures_={}),!1}a(Uh,Xr),Uh.prototype.addFeature=function(t,e){const i=void 0===e||e,n=l(t),o=t.getGeometry();if(o){const e=this.SEGMENT_WRITERS_[o.getType()];e&&(this.indexedFeaturesExtents_[n]=o.getExtent([1/0,1/0,-1/0,-1/0]),e.call(this,t,o))}i&&(this.featureChangeListenerKeys_[n]=C(t,w.CHANGE,this.handleFeatureChange_,this))},Uh.prototype.forEachFeatureAdd_=function(t){this.addFeature(t)},Uh.prototype.forEachFeatureRemove_=function(t){this.removeFeature(t)},Uh.prototype.getFeatures_=function(){let t;return this.features_?t=this.features_:this.source_&&(t=this.source_.getFeatures()),t},Uh.prototype.handleFeatureAdd_=function(t){let e;t instanceof hh?e=t.feature:t instanceof oo&&(e=t.element),this.addFeature(e)},Uh.prototype.handleFeatureRemove_=function(t){let e;t instanceof hh?e=t.feature:t instanceof oo&&(e=t.element),this.removeFeature(e)},Uh.prototype.handleFeatureChange_=function(t){const e=t.target;if(this.handlingDownUpSequence){const t=l(e);t in this.pendingFeatures_||(this.pendingFeatures_[t]=e)}else this.updateFeature_(e)},Uh.prototype.removeFeature=function(t,e){const i=void 0===e||e,n=l(t),o=this.indexedFeaturesExtents_[n];if(o){const e=this.rBush_,i=[];e.forEachInExtent(o,function(e){t===e.feature&&i.push(e)});for(let t=i.length-1;t>=0;--t)e.remove(i[t])}i&&(S(this.featureChangeListenerKeys_[n]),delete this.featureChangeListenerKeys_[n])},Uh.prototype.setMap=function(t){const e=this.getMap(),i=this.featuresListenerKeys_,n=this.getFeatures_();e&&(i.forEach(S),i.length=0,n.forEach(this.forEachFeatureRemove_.bind(this))),Xr.prototype.setMap.call(this,t),t&&(this.features_?i.push(C(this.features_,eo,this.handleFeatureAdd_,this),C(this.features_,io,this.handleFeatureRemove_,this)):this.source_&&i.push(C(this.source_,th,this.handleFeatureAdd_,this),C(this.source_,nh,this.handleFeatureRemove_,this)),n.forEach(this.forEachFeatureAdd_.bind(this)))},Uh.prototype.shouldStopEvent=F,Uh.prototype.snapTo=function(t,e,i){const n=j([i.getCoordinateFromPixel([t[0]-this.pixelTolerance_,t[1]+this.pixelTolerance_]),i.getCoordinateFromPixel([t[0]+this.pixelTolerance_,t[1]-this.pixelTolerance_])]);let o=this.rBush_.getInExtent(n);this.vertex_&&!this.edge_&&(o=o.filter(function(t){return t.feature.getGeometry().getType()!==Ot.CIRCLE}));let s,r,a,h,l,c=!1,u=!1,p=null,d=null;if(o.length>0){this.pixelCoordinate_=e,o.sort(this.sortByDistance_);const n=o[0].segment,f=o[0].feature.getGeometry().getType()===Ot.CIRCLE;this.vertex_&&!this.edge_?(r=i.getPixelFromCoordinate(n[0]),a=i.getPixelFromCoordinate(n[1]),h=vs(t,r),l=vs(t,a),(c=(s=Math.sqrt(Math.min(h,l)))<=this.pixelTolerance_)&&(u=!0,p=h>l?n[1]:n[0],d=i.getPixelFromCoordinate(p))):this.edge_&&(p=f?function(t,e){const i=e.getRadius(),n=e.getCenter(),o=n[0],s=n[1];let r=t[0]-o;const a=t[1]-s;0===r&&0===a&&(r=1);const h=Math.sqrt(r*r+a*a);return[o+i*r/h,s+i*a/h]}(e,o[0].feature.getGeometry()):gs(e,n),xs(t,d=i.getPixelFromCoordinate(p))<=this.pixelTolerance_&&(u=!0,this.vertex_&&!f&&(r=i.getPixelFromCoordinate(n[0]),a=i.getPixelFromCoordinate(n[1]),h=vs(d,r),l=vs(d,a),(c=(s=Math.sqrt(Math.min(h,l)))<=this.pixelTolerance_)&&(p=h>l?n[1]:n[0],d=i.getPixelFromCoordinate(p))))),u&&(d=[Math.round(d[0]),Math.round(d[1])])}return{snapped:u,vertex:p,vertexPixel:d}},Uh.prototype.updateFeature_=function(t){this.removeFeature(t,!1),this.addFeature(t,!1)},Uh.prototype.writeCircleGeometry_=function(t,e){const i=Bn(e).getCoordinates()[0];for(let e=0,n=i.length-1;e<n;++e){const n=i.slice(e,e+2),o={feature:t,segment:n};this.rBush_.insert(j(n),o)}},Uh.prototype.writeGeometryCollectionGeometry_=function(t,e){const i=e.getGeometriesArray();for(let e=0;e<i.length;++e){const n=this.SEGMENT_WRITERS_[i[e].getType()];n&&n.call(this,t,i[e])}},Uh.prototype.writeLineStringGeometry_=function(t,e){const i=e.getCoordinates();for(let e=0,n=i.length-1;e<n;++e){const n=i.slice(e,e+2),o={feature:t,segment:n};this.rBush_.insert(j(n),o)}},Uh.prototype.writeMultiLineStringGeometry_=function(t,e){const i=e.getCoordinates();for(let e=0,n=i.length;e<n;++e){const n=i[e];for(let e=0,i=n.length-1;e<i;++e){const i=n.slice(e,e+2),o={feature:t,segment:i};this.rBush_.insert(j(i),o)}}},Uh.prototype.writeMultiPointGeometry_=function(t,e){const i=e.getCoordinates();for(let n=0,o=i.length;n<o;++n){const o=i[n],s={feature:t,segment:[o,o]};this.rBush_.insert(e.getExtent(),s)}},Uh.prototype.writeMultiPolygonGeometry_=function(t,e){const i=e.getCoordinates();for(let e=0,n=i.length;e<n;++e){const n=i[e];for(let e=0,i=n.length;e<i;++e){const i=n[e];for(let e=0,n=i.length-1;e<n;++e){const n=i.slice(e,e+2),o={feature:t,segment:n};this.rBush_.insert(j(n),o)}}}},Uh.prototype.writePointGeometry_=function(t,e){const i=e.getCoordinates(),n={feature:t,segment:[i,i]};this.rBush_.insert(e.getExtent(),n)},Uh.prototype.writePolygonGeometry_=function(t,e){const i=e.getCoordinates();for(let e=0,n=i.length;e<n;++e){const n=i[e];for(let e=0,i=n.length-1;e<i;++e){const i=n.slice(e,e+2),o={feature:t,segment:i};this.rBush_.insert(j(i),o)}}};const Hh={TRANSLATESTART:\"translatestart\",TRANSLATING:\"translating\",TRANSLATEEND:\"translateend\"},Vh=function(t,e,i){k.call(this,t),this.features=e,this.coordinate=i};a(Vh,k);const Zh=function(t){Xr.call(this,{handleDownEvent:qh,handleDragEvent:Qh,handleMoveEvent:$h,handleUpEvent:Jh});const e=t||{};let i;if(this.lastCoordinate_=null,this.features_=void 0!==e.features?e.features:null,e.layers)if(\"function\"==typeof e.layers)i=e.layers;else{const t=e.layers;i=function(e){return Ki(t,e)}}else i=I;this.layerFilter_=i,this.hitTolerance_=e.hitTolerance?e.hitTolerance:0,this.lastFeature_=null,C(this,W(ur),this.handleActiveChanged_,this)};function qh(t){if(this.lastFeature_=this.featuresAtPixel_(t.pixel,t.map),!this.lastCoordinate_&&this.lastFeature_){this.lastCoordinate_=t.coordinate,$h.call(this,t);const e=this.features_||new ro([this.lastFeature_]);return this.dispatchEvent(new Vh(Hh.TRANSLATESTART,e,t.coordinate)),!0}return!1}function Jh(t){if(this.lastCoordinate_){this.lastCoordinate_=null,$h.call(this,t);const e=this.features_||new ro([this.lastFeature_]);return this.dispatchEvent(new Vh(Hh.TRANSLATEEND,e,t.coordinate)),!0}return!1}function Qh(t){if(this.lastCoordinate_){const e=t.coordinate,i=e[0]-this.lastCoordinate_[0],n=e[1]-this.lastCoordinate_[1],o=this.features_||new ro([this.lastFeature_]);o.forEach(function(t){const e=t.getGeometry();e.translate(i,n),t.setGeometry(e)}),this.lastCoordinate_=e,this.dispatchEvent(new Vh(Hh.TRANSLATING,o,e))}}function $h(t){const e=t.map.getViewport();this.featuresAtPixel_(t.pixel,t.map)?(e.classList.remove(this.lastCoordinate_?\"ol-grab\":\"ol-grabbing\"),e.classList.add(this.lastCoordinate_?\"ol-grabbing\":\"ol-grab\")):e.classList.remove(\"ol-grab\",\"ol-grabbing\")}a(Zh,Xr),Zh.prototype.featuresAtPixel_=function(t,e){return e.forEachFeatureAtPixel(t,function(t){if(!this.features_||Ki(this.features_.getArray(),t))return t}.bind(this),{layerFilter:this.layerFilter_,hitTolerance:this.hitTolerance_})},Zh.prototype.getHitTolerance=function(){return this.hitTolerance_},Zh.prototype.setHitTolerance=function(t){this.hitTolerance_=t},Zh.prototype.setMap=function(t){const e=this.getMap();Xr.prototype.setMap.call(this,t),this.updateState_(e)},Zh.prototype.handleActiveChanged_=function(){this.updateState_(null)},Zh.prototype.updateState_=function(t){let e=this.getMap();const i=this.getActive();if((!e||!i)&&(e=e||t)){e.getViewport().classList.remove(\"ol-grab\",\"ol-grabbing\")}};const tl=function(t,e,i,n){G.call(this),this.extent=t,this.pixelRatio_=i,this.resolution=e,this.state=n};a(tl,G),tl.prototype.changed=function(){this.dispatchEvent(w.CHANGE)},tl.prototype.getExtent=function(){return this.extent},tl.prototype.getImage=function(){},tl.prototype.getPixelRatio=function(){return this.pixelRatio_},tl.prototype.getResolution=function(){return this.resolution},tl.prototype.getState=function(){return this.state},tl.prototype.load=function(){};var el=tl;const il=function(t,e,i,n,o){this.loader_=void 0!==o?o:null;const s=void 0!==o?Ve.IDLE:Ve.LOADED;el.call(this,t,e,i,s),this.canvas_=n,this.error_=null};a(il,el),il.prototype.getError=function(){return this.error_},il.prototype.handleLoad_=function(t){t?(this.error_=t,this.state=Ve.ERROR):this.state=Ve.LOADED,this.changed()},il.prototype.load=function(){this.state==Ve.IDLE&&(this.state=Ve.LOADING,this.changed(),this.loader_(this.handleLoad_.bind(this)))},il.prototype.getImage=function(){return this.canvas_};var nl=il;const ol=function(t,e,i,n,o){k.call(this,t),this.vectorContext=e,this.frameState=i,this.context=n,this.glContext=o};a(ol,k);var sl=ol;const rl=function(){};rl.prototype.drawCustom=function(t,e,i){},rl.prototype.drawGeometry=function(t){},rl.prototype.setStyle=function(t){},rl.prototype.drawCircle=function(t,e){},rl.prototype.drawFeature=function(t,e){},rl.prototype.drawGeometryCollection=function(t,e){},rl.prototype.drawLineString=function(t,e){},rl.prototype.drawMultiLineString=function(t,e){},rl.prototype.drawMultiPoint=function(t,e){},rl.prototype.drawMultiPolygon=function(t,e){},rl.prototype.drawPoint=function(t,e){},rl.prototype.drawPolygon=function(t,e){},rl.prototype.drawText=function(t,e){},rl.prototype.setFillStrokeStyle=function(t,e){},rl.prototype.setImageStyle=function(t,e){},rl.prototype.setTextStyle=function(t,e){};var al=rl;const hl=function(t,e,i,n,o){al.call(this),this.context_=t,this.pixelRatio_=e,this.extent_=i,this.transform_=n,this.viewRotation_=o,this.contextFillState_=null,this.contextStrokeState_=null,this.contextTextState_=null,this.fillState_=null,this.strokeState_=null,this.image_=null,this.imageAnchorX_=0,this.imageAnchorY_=0,this.imageHeight_=0,this.imageOpacity_=0,this.imageOriginX_=0,this.imageOriginY_=0,this.imageRotateWithView_=!1,this.imageRotation_=0,this.imageScale_=0,this.imageSnapToPixel_=!1,this.imageWidth_=0,this.text_=\"\",this.textOffsetX_=0,this.textOffsetY_=0,this.textRotateWithView_=!1,this.textRotation_=0,this.textScale_=0,this.textFillState_=null,this.textStrokeState_=null,this.textState_=null,this.pixelCoordinates_=[],this.tmpLocalTransform_=[1,0,0,1,0,0]};a(hl,al),hl.prototype.drawImages_=function(t,e,i,n){if(!this.image_)return;const o=wt(t,e,i,2,this.transform_,this.pixelCoordinates_),s=this.context_,r=this.tmpLocalTransform_,a=s.globalAlpha;1!=this.imageOpacity_&&(s.globalAlpha=a*this.imageOpacity_);let h=this.imageRotation_;this.imageRotateWithView_&&(h+=this.viewRotation_);for(let t=0,e=o.length;t<e;t+=2){let e=o[t]-this.imageAnchorX_,i=o[t+1]-this.imageAnchorY_;if(this.imageSnapToPixel_&&(e=Math.round(e),i=Math.round(i)),0!==h||1!=this.imageScale_){const t=e+this.imageAnchorX_,n=i+this.imageAnchorY_;Te(r,t,n,this.imageScale_,this.imageScale_,h,-t,-n),s.setTransform.apply(s,r)}s.drawImage(this.image_,this.imageOriginX_,this.imageOriginY_,this.imageWidth_,this.imageHeight_,e,i,this.imageWidth_,this.imageHeight_)}0===h&&1==this.imageScale_||s.setTransform(1,0,0,1,0,0),1!=this.imageOpacity_&&(s.globalAlpha=a)},hl.prototype.drawText_=function(t,e,i,n){if(!this.textState_||\"\"===this.text_)return;this.textFillState_&&this.setContextFillState_(this.textFillState_),this.textStrokeState_&&this.setContextStrokeState_(this.textStrokeState_),this.setContextTextState_(this.textState_);const o=wt(t,e,i,n,this.transform_,this.pixelCoordinates_),s=this.context_;let r=this.textRotation_;for(this.textRotateWithView_&&(r+=this.viewRotation_);e<i;e+=n){const t=o[e]+this.textOffsetX_,i=o[e+1]+this.textOffsetY_;if(0!==r||1!=this.textScale_){const e=Te(this.tmpLocalTransform_,t,i,this.textScale_,this.textScale_,r,-t,-i);s.setTransform.apply(s,e)}this.textStrokeState_&&s.strokeText(this.text_,t,i),this.textFillState_&&s.fillText(this.text_,t,i)}0===r&&1==this.textScale_||s.setTransform(1,0,0,1,0,0)},hl.prototype.moveToLineTo_=function(t,e,i,n,o){const s=this.context_,r=wt(t,e,i,n,this.transform_,this.pixelCoordinates_);s.moveTo(r[0],r[1]);let a=r.length;o&&(a-=2);for(let t=2;t<a;t+=2)s.lineTo(r[t],r[t+1]);return o&&s.closePath(),i},hl.prototype.drawRings_=function(t,e,i,n){for(let o=0,s=i.length;o<s;++o)e=this.moveToLineTo_(t,e,i[o],n,!0);return e},hl.prototype.drawCircle=function(t){if(Et(this.extent_,t.getExtent())){if(this.fillState_||this.strokeState_){this.fillState_&&this.setContextFillState_(this.fillState_),this.strokeState_&&this.setContextStrokeState_(this.strokeState_);const e=function(t,e,i){const n=t.getFlatCoordinates();if(n){const o=t.getStride();return wt(n,0,n.length,o,e,i)}return null}(t,this.transform_,this.pixelCoordinates_),i=e[2]-e[0],n=e[3]-e[1],o=Math.sqrt(i*i+n*n),s=this.context_;s.beginPath(),s.arc(e[0],e[1],o,0,2*Math.PI),this.fillState_&&s.fill(),this.strokeState_&&s.stroke()}\"\"!==this.text_&&this.drawText_(t.getCenter(),0,2,2)}},hl.prototype.setStyle=function(t){this.setFillStrokeStyle(t.getFill(),t.getStroke()),this.setImageStyle(t.getImage()),this.setTextStyle(t.getText())},hl.prototype.drawGeometry=function(t){switch(t.getType()){case Ot.POINT:this.drawPoint(t);break;case Ot.LINE_STRING:this.drawLineString(t);break;case Ot.POLYGON:this.drawPolygon(t);break;case Ot.MULTI_POINT:this.drawMultiPoint(t);break;case Ot.MULTI_LINE_STRING:this.drawMultiLineString(t);break;case Ot.MULTI_POLYGON:this.drawMultiPolygon(t);break;case Ot.GEOMETRY_COLLECTION:this.drawGeometryCollection(t);break;case Ot.CIRCLE:this.drawCircle(t)}},hl.prototype.drawFeature=function(t,e){const i=e.getGeometryFunction()(t);i&&Et(this.extent_,i.getExtent())&&(this.setStyle(e),this.drawGeometry(i))},hl.prototype.drawGeometryCollection=function(t){const e=t.getGeometriesArray();for(let t=0,i=e.length;t<i;++t)this.drawGeometry(e[t])},hl.prototype.drawPoint=function(t){const e=t.getFlatCoordinates(),i=t.getStride();this.image_&&this.drawImages_(e,0,e.length,i),\"\"!==this.text_&&this.drawText_(e,0,e.length,i)},hl.prototype.drawMultiPoint=function(t){const e=t.getFlatCoordinates(),i=t.getStride();this.image_&&this.drawImages_(e,0,e.length,i),\"\"!==this.text_&&this.drawText_(e,0,e.length,i)},hl.prototype.drawLineString=function(t){if(Et(this.extent_,t.getExtent())){if(this.strokeState_){this.setContextStrokeState_(this.strokeState_);const e=this.context_,i=t.getFlatCoordinates();e.beginPath(),this.moveToLineTo_(i,0,i.length,t.getStride(),!1),e.stroke()}if(\"\"!==this.text_){const e=t.getFlatMidpoint();this.drawText_(e,0,2,2)}}},hl.prototype.drawMultiLineString=function(t){const e=t.getExtent();if(Et(this.extent_,e)){if(this.strokeState_){this.setContextStrokeState_(this.strokeState_);const e=this.context_,i=t.getFlatCoordinates();let n=0;const o=t.getEnds(),s=t.getStride();e.beginPath();for(let t=0,e=o.length;t<e;++t)n=this.moveToLineTo_(i,n,o[t],s,!1);e.stroke()}if(\"\"!==this.text_){const e=t.getFlatMidpoints();this.drawText_(e,0,e.length,2)}}},hl.prototype.drawPolygon=function(t){if(Et(this.extent_,t.getExtent())){if(this.strokeState_||this.fillState_){this.fillState_&&this.setContextFillState_(this.fillState_),this.strokeState_&&this.setContextStrokeState_(this.strokeState_);const e=this.context_;e.beginPath(),this.drawRings_(t.getOrientedFlatCoordinates(),0,t.getEnds(),t.getStride()),this.fillState_&&e.fill(),this.strokeState_&&e.stroke()}if(\"\"!==this.text_){const e=t.getFlatInteriorPoint();this.drawText_(e,0,2,2)}}},hl.prototype.drawMultiPolygon=function(t){if(Et(this.extent_,t.getExtent())){if(this.strokeState_||this.fillState_){this.fillState_&&this.setContextFillState_(this.fillState_),this.strokeState_&&this.setContextStrokeState_(this.strokeState_);const e=this.context_,i=t.getOrientedFlatCoordinates();let n=0;const o=t.getEndss(),s=t.getStride();e.beginPath();for(let t=0,e=o.length;t<e;++t){const e=o[t];n=this.drawRings_(i,n,e,s)}this.fillState_&&e.fill(),this.strokeState_&&e.stroke()}if(\"\"!==this.text_){const e=t.getFlatInteriorPoints();this.drawText_(e,0,e.length,2)}}},hl.prototype.setContextFillState_=function(t){const e=this.context_,i=this.contextFillState_;i?i.fillStyle!=t.fillStyle&&(i.fillStyle=e.fillStyle=t.fillStyle):(e.fillStyle=t.fillStyle,this.contextFillState_={fillStyle:t.fillStyle})},hl.prototype.setContextStrokeState_=function(t){const e=this.context_,i=this.contextStrokeState_;i?(i.lineCap!=t.lineCap&&(i.lineCap=e.lineCap=t.lineCap),Ue&&(Hi(i.lineDash,t.lineDash)||e.setLineDash(i.lineDash=t.lineDash),i.lineDashOffset!=t.lineDashOffset&&(i.lineDashOffset=e.lineDashOffset=t.lineDashOffset)),i.lineJoin!=t.lineJoin&&(i.lineJoin=e.lineJoin=t.lineJoin),i.lineWidth!=t.lineWidth&&(i.lineWidth=e.lineWidth=t.lineWidth),i.miterLimit!=t.miterLimit&&(i.miterLimit=e.miterLimit=t.miterLimit),i.strokeStyle!=t.strokeStyle&&(i.strokeStyle=e.strokeStyle=t.strokeStyle)):(e.lineCap=t.lineCap,Ue&&(e.setLineDash(t.lineDash),e.lineDashOffset=t.lineDashOffset),e.lineJoin=t.lineJoin,e.lineWidth=t.lineWidth,e.miterLimit=t.miterLimit,e.strokeStyle=t.strokeStyle,this.contextStrokeState_={lineCap:t.lineCap,lineDash:t.lineDash,lineDashOffset:t.lineDashOffset,lineJoin:t.lineJoin,lineWidth:t.lineWidth,miterLimit:t.miterLimit,strokeStyle:t.strokeStyle})},hl.prototype.setContextTextState_=function(t){const e=this.context_,i=this.contextTextState_,n=t.textAlign?t.textAlign:\"center\";i?(i.font!=t.font&&(i.font=e.font=t.font),i.textAlign!=n&&(i.textAlign=e.textAlign=n),i.textBaseline!=t.textBaseline&&(i.textBaseline=e.textBaseline=t.textBaseline)):(e.font=t.font,e.textAlign=n,e.textBaseline=t.textBaseline,this.contextTextState_={font:t.font,textAlign:n,textBaseline:t.textBaseline})},hl.prototype.setFillStrokeStyle=function(t,e){if(t){const e=t.getColor();this.fillState_={fillStyle:Oe(e||$e)}}else this.fillState_=null;if(e){const t=e.getColor(),i=e.getLineCap(),n=e.getLineDash(),o=e.getLineDashOffset(),s=e.getLineJoin(),r=e.getWidth(),a=e.getMiterLimit();this.strokeState_={lineCap:void 0!==i?i:\"round\",lineDash:n||ti,lineDashOffset:o||0,lineJoin:void 0!==s?s:\"round\",lineWidth:this.pixelRatio_*(void 0!==r?r:1),miterLimit:void 0!==a?a:10,strokeStyle:Oe(t||ei)}}else this.strokeState_=null},hl.prototype.setImageStyle=function(t){if(t){const e=t.getAnchor(),i=t.getImage(1),n=t.getOrigin(),o=t.getSize();this.imageAnchorX_=e[0],this.imageAnchorY_=e[1],this.imageHeight_=o[1],this.image_=i,this.imageOpacity_=t.getOpacity(),this.imageOriginX_=n[0],this.imageOriginY_=n[1],this.imageRotateWithView_=t.getRotateWithView(),this.imageRotation_=t.getRotation(),this.imageScale_=t.getScale()*this.pixelRatio_,this.imageSnapToPixel_=t.getSnapToPixel(),this.imageWidth_=o[0]}else this.image_=null},hl.prototype.setTextStyle=function(t){if(t){const e=t.getFill();if(e){const t=e.getColor();this.textFillState_={fillStyle:Oe(t||$e)}}else this.textFillState_=null;const i=t.getStroke();if(i){const t=i.getColor(),e=i.getLineCap(),n=i.getLineDash(),o=i.getLineDashOffset(),s=i.getLineJoin(),r=i.getWidth(),a=i.getMiterLimit();this.textStrokeState_={lineCap:void 0!==e?e:\"round\",lineDash:n||ti,lineDashOffset:o||0,lineJoin:void 0!==s?s:\"round\",lineWidth:void 0!==r?r:1,miterLimit:void 0!==a?a:10,strokeStyle:Oe(t||ei)}}else this.textStrokeState_=null;const n=t.getFont(),o=t.getOffsetX(),s=t.getOffsetY(),r=t.getRotateWithView(),a=t.getRotation(),h=t.getScale(),l=t.getText(),c=t.getTextAlign(),u=t.getTextBaseline();this.textState_={font:void 0!==n?n:\"10px sans-serif\",textAlign:void 0!==c?c:\"center\",textBaseline:void 0!==u?u:\"middle\"},this.text_=void 0!==l?l:\"\",this.textOffsetX_=void 0!==o?this.pixelRatio_*o:0,this.textOffsetY_=void 0!==s?this.pixelRatio_*s:0,this.textRotateWithView_=void 0!==r&&r,this.textRotation_=void 0!==a?a:0,this.textScale_=this.pixelRatio_*(void 0!==h?h:1)}else this.text_=\"\"};var ll=hl;const cl=function(){this.cache_={},this.cacheSize_=0,this.maxCacheSize_=32};function ul(t,e,i){return e+\":\"+t+\":\"+(i?Pe(i):\"null\")}cl.prototype.clear=function(){this.cache_={},this.cacheSize_=0},cl.prototype.expire=function(){if(this.cacheSize_>this.maxCacheSize_){let t=0;for(const e in this.cache_){const i=this.cache_[e];0!=(3&t++)||i.hasListener()||(delete this.cache_[e],--this.cacheSize_)}}},cl.prototype.get=function(t,e,i){const n=ul(t,e,i);return n in this.cache_?this.cache_[n]:null},cl.prototype.set=function(t,e,i,n){const o=ul(t,e,i);this.cache_[o]=n,++this.cacheSize_},cl.prototype.setSize=function(t){this.maxCacheSize_=t,this.expire()};const pl=new cl,dl=function(t){M.call(this),this.map_=t,this.layerRenderers_={},this.layerRendererListeners_={},this.layerRendererConstructors_=[]};function fl(t,e){pl.expire()}function gl(t,e){return t.zIndex-e.zIndex}a(dl,M),dl.prototype.registerLayerRenderers=function(t){this.layerRendererConstructors_.push.apply(this.layerRendererConstructors_,t)},dl.prototype.getLayerRendererConstructors=function(){return this.layerRendererConstructors_},dl.prototype.calculateMatrices2D=function(t){const e=t.viewState,i=t.coordinateToPixelTransform,n=t.pixelToCoordinateTransform;Te(i,t.size[0]/2,t.size[1]/2,1/e.resolution,-1/e.resolution,-e.rotation,-e.center[0],-e.center[1]),function(t){const e=(i=t)[0]*i[3]-i[1]*i[2];var i;p(0!==e,32);const n=t[0],o=t[1],s=t[2],r=t[3],a=t[4],h=t[5];t[0]=r/e,t[1]=-o/e,t[2]=-s/e,t[3]=n/e,t[4]=(s*h-r*a)/e,t[5]=-(n*h-o*a)/e}(ve(n,i))},dl.prototype.removeLayerRenderers=function(){for(const t in this.layerRenderers_)this.removeLayerRendererByKey_(t).dispose()},dl.prototype.forEachFeatureAtCoordinate=function(t,e,i,n,o,s,r){let a;const h=e.viewState,c=h.resolution;function u(t,i){const s=l(t).toString(),r=e.layerStates[l(i)].managed;if(!(s in e.skippedFeatureUids)||r)return n.call(o,t,r?i:null)}const p=h.projection;let d=t;if(p.canWrapX()){const e=p.getExtent(),i=Ct(e),n=t[0];if(n<e[0]||n>e[2]){d=[n+i*Math.ceil((e[0]-n)/i),t[1]]}}const f=e.layerStatesArray;let g;for(g=f.length-1;g>=0;--g){const n=f[g],h=n.layer;if($s(n,c)&&s.call(r,h)){const n=this.getLayerRenderer(h);if(h.getSource()&&(a=n.forEachFeatureAtCoordinate(h.getSource().getWrapX()?d:t,e,i,u,o)),a)return a}}},dl.prototype.forEachLayerAtPixel=function(t,e,i,n,o,s){},dl.prototype.hasFeatureAtCoordinate=function(t,e,i,n,o){return void 0!==this.forEachFeatureAtCoordinate(t,e,i,I,this,n,o)},dl.prototype.getLayerRenderer=function(t){const e=l(t).toString();if(e in this.layerRenderers_)return this.layerRenderers_[e];{let i;for(let e=0,n=this.layerRendererConstructors_.length;e<n;++e){const n=this.layerRendererConstructors_[e];if(n.handles(t)){i=n.create(this,t);break}}if(!i)throw new Error(\"Unable to create renderer for layer: \"+t.getType());return this.layerRenderers_[e]=i,this.layerRendererListeners_[e]=C(i,w.CHANGE,this.handleLayerRendererChange_,this),i}},dl.prototype.getLayerRendererByKey=function(t){return this.layerRenderers_[t]},dl.prototype.getLayerRenderers=function(){return this.layerRenderers_},dl.prototype.getMap=function(){return this.map_},dl.prototype.handleLayerRendererChange_=function(){this.map_.render()},dl.prototype.removeLayerRendererByKey_=function(t){const e=this.layerRenderers_[t];return delete this.layerRenderers_[t],S(this.layerRendererListeners_[t]),delete this.layerRendererListeners_[t],e},dl.prototype.renderFrame=P,dl.prototype.removeUnusedLayerRenderers_=function(t,e){for(const t in this.layerRenderers_)e&&t in e.layerStates||this.removeLayerRendererByKey_(t).dispose()},dl.prototype.scheduleExpireIconCache=function(t){t.postRenderFunctions.push(fl)},dl.prototype.scheduleRemoveUnusedLayerRenderers=function(t){for(const e in this.layerRenderers_)if(!(e in t.layerStates))return void t.postRenderFunctions.push(this.removeUnusedLayerRenderers_.bind(this))};var _l=dl;const yl=[],ml=function(t){_l.call(this,t);const e=t.getViewport();this.context_=ke(),this.canvas_=this.context_.canvas,this.canvas_.style.width=\"100%\",this.canvas_.style.height=\"100%\",this.canvas_.style.display=\"block\",this.canvas_.className=\"ol-unselectable\",e.insertBefore(this.canvas_,e.childNodes[0]||null),this.renderedVisible_=!0,this.transform_=[1,0,0,1,0,0]};a(ml,_l),ml.prototype.dispatchComposeEvent_=function(t,e){const i=this.getMap(),n=this.context_;if(i.hasListener(t)){const o=e.extent,s=e.pixelRatio,r=e.viewState.rotation,a=this.getTransform(e),h=new ll(n,s,o,a,r),l=new sl(t,h,e,n,null);i.dispatchEvent(l)}},ml.prototype.getTransform=function(t){const e=t.viewState,i=this.canvas_.width/2,n=this.canvas_.height/2,o=t.pixelRatio/e.resolution,s=-o,r=-e.rotation,a=-e.center[0],h=-e.center[1];return Te(this.transform_,i,n,o,s,r,a,h)},ml.prototype.renderFrame=function(t){if(!t)return void(this.renderedVisible_&&(this.canvas_.style.display=\"none\",this.renderedVisible_=!1));const e=this.context_,i=t.pixelRatio,n=Math.round(t.size[0]*i),o=Math.round(t.size[1]*i);this.canvas_.width!=n||this.canvas_.height!=o?(this.canvas_.width=n,this.canvas_.height=o):e.clearRect(0,0,n,o);const s=t.viewState.rotation;this.calculateMatrices2D(t),this.dispatchComposeEvent_(qs,t);const r=t.layerStatesArray;!function(t,e){const i=t.length,n=Array(t.length);let o;for(o=0;o<i;o++)n[o]={index:o,value:t[o]};for(n.sort(function(t,i){return e(t.value,i.value)||t.index-i.index}),o=0;o<t.length;o++)t[o]=n[o].value}(r,gl),s&&(e.save(),ui(e,s,n/2,o/2));const a=t.viewState.resolution;let h,l,c,u,p;for(h=0,l=r.length;h<l;++h)c=(p=r[h]).layer,u=this.getLayerRenderer(c),$s(p,a)&&p.sourceState==Xs&&u.prepareFrame(t,p)&&u.composeFrame(t,p,e);s&&e.restore(),this.dispatchComposeEvent_(Zs,t),this.renderedVisible_||(this.canvas_.style.display=\"\",this.renderedVisible_=!0),this.scheduleRemoveUnusedLayerRenderers(t),this.scheduleExpireIconCache(t)},ml.prototype.forEachLayerAtPixel=function(t,e,i,n,o,s){let r;const a=e.viewState.resolution,h=e.layerStatesArray,l=h.length,c=xe(e.pixelToCoordinateTransform,t.slice());let u;for(u=l-1;u>=0;--u){const t=h[u],l=t.layer;if($s(t,a)&&o.call(s,l)){if(r=this.getLayerRenderer(l).forEachLayerAtCoordinate(c,e,i,n))return r}}},ml.prototype.registerLayerRenderers=function(t){_l.prototype.registerLayerRenderers.call(this,t);for(let e=0,i=t.length;e<i;++e){const i=t[e];Ki(yl,i)||yl.push(i)}};var vl=ml;const xl=function(t){N.call(this),this.layer_=t};a(xl,N),xl.prototype.forEachFeatureAtCoordinate=P,xl.prototype.hasFeatureAtCoordinate=F,xl.prototype.createLoadedTileFinder=function(t,e,i){return function(n,o){return t.forEachLoadedTile(e,n,o,function(t){i[n]||(i[n]={}),i[n][t.tileCoord.toString()]=t})}},xl.prototype.getLayer=function(){return this.layer_},xl.prototype.handleImageChange_=function(t){t.target.getState()===Ve.LOADED&&this.renderIfReadyAndVisible()},xl.prototype.loadImage=function(t){let e=t.getState();return e!=Ve.LOADED&&e!=Ve.ERROR&&C(t,w.CHANGE,this.handleImageChange_,this),e==Ve.IDLE&&(t.load(),e=t.getState()),e==Ve.LOADED},xl.prototype.renderIfReadyAndVisible=function(){const t=this.getLayer();t.getVisible()&&t.getSourceState()==Xs&&this.changed()},xl.prototype.scheduleExpireCache=function(t,e){if(e.canExpireCache()){const i=function(t,e,i){const n=l(t).toString();n in i.usedTiles&&t.expireCache(i.viewState.projection,i.usedTiles[n])}.bind(null,e);t.postRenderFunctions.push(i)}},xl.prototype.updateUsedTiles=function(t,e,i,n){const o=l(e).toString(),s=i.toString();o in t?s in t[o]?t[o][s].extend(n):t[o][s]=n:(t[o]={},t[o][s]=n)},xl.prototype.manageTilePyramid=function(t,e,i,n,o,s,r,a,h,c){const u=l(e).toString();u in t.wantedTiles||(t.wantedTiles[u]={});const p=t.wantedTiles[u],d=t.tileQueue;let f,g,_,y,m,v;for(v=i.getMinZoom();v<=r;++v)for(g=i.getTileRangeForExtentAndZ(s,v,g),_=i.getResolution(v),y=g.minX;y<=g.maxX;++y)for(m=g.minY;m<=g.maxY;++m)r-v<=a?((f=e.getTile(v,y,m,n,o)).getState()==Zo&&(p[f.getKey()]=!0,d.isKeyQueued(f.getKey())||d.enqueue([f,u,i.getTileCoordCenter(f.tileCoord),_])),void 0!==h&&h.call(c,f)):e.useTile(v,y,m,o)};var Cl=xl;const El=function(t){Cl.call(this,t),this.renderedResolution,this.transform_=[1,0,0,1,0,0]};a(El,Cl),El.prototype.clip=function(t,e,i){const n=e.pixelRatio,o=e.size[0]*n,s=e.size[1]*n,r=e.viewState.rotation,a=vt(i),h=xt(i),l=ft(i),c=dt(i);xe(e.coordinateToPixelTransform,a),xe(e.coordinateToPixelTransform,h),xe(e.coordinateToPixelTransform,l),xe(e.coordinateToPixelTransform,c),t.save(),ui(t,-r,o/2,s/2),t.beginPath(),t.moveTo(a[0]*n,a[1]*n),t.lineTo(h[0]*n,h[1]*n),t.lineTo(l[0]*n,l[1]*n),t.lineTo(c[0]*n,c[1]*n),t.clip(),ui(t,r,o/2,s/2)},El.prototype.dispatchComposeEvent_=function(t,e,i,n){const o=this.getLayer();if(o.hasListener(t)){const s=i.size[0]*i.pixelRatio,r=i.size[1]*i.pixelRatio,a=i.viewState.rotation;ui(e,-a,s/2,r/2);const h=void 0!==n?n:this.getTransform(i,0),l=new ll(e,i.pixelRatio,i.extent,h,i.viewState.rotation),c=new sl(t,l,i,e,null);o.dispatchEvent(c),ui(e,a,s/2,r/2)}},El.prototype.forEachLayerAtCoordinate=function(t,e,i,n){return this.forEachFeatureAtCoordinate(t,e,0,I,this)?i.call(n,this.getLayer(),null):void 0},El.prototype.postCompose=function(t,e,i,n){this.dispatchComposeEvent_(Zs,t,e,n)},El.prototype.preCompose=function(t,e,i){this.dispatchComposeEvent_(qs,t,e,i)},El.prototype.dispatchRenderEvent=function(t,e,i){this.dispatchComposeEvent_(Js,t,e,i)},El.prototype.getTransform=function(t,e){const i=t.viewState,n=t.pixelRatio,o=n*t.size[0]/2,s=n*t.size[1]/2,r=n/i.resolution,a=-r,h=-i.rotation,l=-i.center[0]+e,c=-i.center[1];return Te(this.transform_,o,s,r,a,h,l,c)},El.prototype.composeFrame=function(t,e,i){},El.prototype.prepareFrame=function(t,e){};var Tl=El;const Sl=function(t){Tl.call(this,t),this.coordinateToCanvasPixelTransform=[1,0,0,1,0,0],this.hitCanvasContext_=null};a(Sl,Tl),Sl.prototype.composeFrame=function(t,e,i){this.preCompose(i,t);const n=this.getImage();if(n){const o=e.extent,s=void 0!==o&&!J(o,t.extent)&&Et(o,t.extent);s&&this.clip(i,t,o);const r=this.getImageTransform(),a=i.globalAlpha;i.globalAlpha=e.opacity;const h=r[4],l=r[5],c=n.width*r[0],u=n.height*r[3];i.drawImage(n,0,0,+n.width,+n.height,Math.round(h),Math.round(l),Math.round(c),Math.round(u)),i.globalAlpha=a,s&&i.restore()}this.postCompose(i,t,e)},Sl.prototype.getImage=function(){},Sl.prototype.getImageTransform=function(){},Sl.prototype.forEachFeatureAtCoordinate=function(t,e,i,n,o){const s=this.getLayer(),r=s.getSource(),a=e.viewState.resolution,h=e.viewState.rotation,l=e.skippedFeatureUids;return r.forEachFeatureAtCoordinate(t,a,h,i,l,function(t){return n.call(o,t,s)})},Sl.prototype.forEachLayerAtCoordinate=function(t,e,i,n){if(this.getImage()){if(this.getLayer().getSource().forEachFeatureAtCoordinate!==P)return Tl.prototype.forEachLayerAtCoordinate.apply(this,arguments);{const o=xe(this.coordinateToCanvasPixelTransform,t.slice());ms(o,e.viewState.resolution/this.renderedResolution),this.hitCanvasContext_||(this.hitCanvasContext_=ke(1,1)),this.hitCanvasContext_.clearRect(0,0,1,1),this.hitCanvasContext_.drawImage(this.getImage(),o[0],o[1],1,1,0,0,1,1);const s=this.hitCanvasContext_.getImageData(0,0,1,1).data;return s[3]>0?i.call(n,this.getLayer(),s):void 0}}};var wl=Sl;const Rl=function(t){if(wl.call(this,t),this.image_=null,this.imageTransform_=[1,0,0,1,0,0],this.skippedFeatures_=[],this.vectorRenderer_=null,t.getType()===Ua)for(let e=0,i=yl.length;e<i;++e){const i=yl[e];if(i!==Rl&&i.handles(t)){this.vectorRenderer_=new i(t);break}}};a(Rl,wl),Rl.handles=function(t){return t.getType()===za||t.getType()===Ua&&t.getRenderMode()===Ba},Rl.create=function(t,e){return new Rl(e)},Rl.prototype.disposeInternal=function(){this.vectorRenderer_&&this.vectorRenderer_.dispose(),wl.prototype.disposeInternal.call(this)},Rl.prototype.getImage=function(){return this.image_?this.image_.getImage():null},Rl.prototype.getImageTransform=function(){return this.imageTransform_},Rl.prototype.prepareFrame=function(t,e){const i=t.pixelRatio,n=t.size,o=t.viewState,s=o.center,r=o.resolution;let a;const h=this.getLayer().getSource(),l=t.viewHints,c=this.vectorRenderer_;let u=t.extent;if(c||void 0===e.extent||(u=mt(u,e.extent)),!l[cs.ANIMATING]&&!l[cs.INTERACTING]&&!Tt(u)){let n=o.projection;0;let s=this.skippedFeatures_;if(c){const n=c.context,o=d({},t,{size:[Ct(u)/r,yt(u)/r],viewState:d({},t.viewState,{rotation:0})}),h=Object.keys(o.skippedFeatureUids).sort();a=new nl(u,r,i,n.canvas,function(t){!c.prepareFrame(o,e)||!c.replayGroupChanged&&Hi(s,h)||(n.canvas.width=o.size[0]*i,n.canvas.height=o.size[1]*i,c.compose(n,o,e),s=h,t())})}else a=h.getImage(u,r,i,n);a&&this.loadImage(a)&&(this.image_=a,this.skippedFeatures_=s)}if(this.image_){const t=(a=this.image_).getExtent(),e=a.getResolution(),o=a.getPixelRatio(),h=i*e/(r*o),l=Te(this.imageTransform_,i*n[0]/2,i*n[1]/2,h,h,0,o*(t[0]-s[0])/e,o*(s[1]-t[3])/e);Te(this.coordinateToCanvasPixelTransform,i*n[0]/2-l[4],i*n[1]/2-l[5],i/r,-i/r,0,-s[0],-s[1]),this.renderedResolution=e*i/o}return!!this.image_},Rl.prototype.forEachFeatureAtCoordinate=function(t,e,i,n,o){return this.vectorRenderer_?this.vectorRenderer_.forEachFeatureAtCoordinate(t,e,i,n,o):wl.prototype.forEachFeatureAtCoordinate.call(this,t,e,i,n,o)};var Il=Rl;const Fl=function(t,e,i,n){this.minX=t,this.maxX=e,this.minY=i,this.maxY=n};function Pl(t,e,i,n,o){return void 0!==o?(o.minX=t,o.maxX=e,o.minY=i,o.maxY=n,o):new Fl(t,e,i,n)}Fl.prototype.contains=function(t){return this.containsXY(t[1],t[2])},Fl.prototype.containsTileRange=function(t){return this.minX<=t.minX&&t.maxX<=this.maxX&&this.minY<=t.minY&&t.maxY<=this.maxY},Fl.prototype.containsXY=function(t,e){return this.minX<=t&&t<=this.maxX&&this.minY<=e&&e<=this.maxY},Fl.prototype.equals=function(t){return this.minX==t.minX&&this.minY==t.minY&&this.maxX==t.maxX&&this.maxY==t.maxY},Fl.prototype.extend=function(t){t.minX<this.minX&&(this.minX=t.minX),t.maxX>this.maxX&&(this.maxX=t.maxX),t.minY<this.minY&&(this.minY=t.minY),t.maxY>this.maxY&&(this.maxY=t.maxY)},Fl.prototype.getHeight=function(){return this.maxY-this.minY+1},Fl.prototype.getSize=function(){return[this.getWidth(),this.getHeight()]},Fl.prototype.getWidth=function(){return this.maxX-this.minX+1},Fl.prototype.intersects=function(t){return this.minX<=t.maxX&&this.maxX>=t.minX&&this.minY<=t.maxY&&this.maxY>=t.minY};var Ll=Fl;const Ml=function(t){wl.call(this,t),this.context=null===this.context?null:ke(),this.oversampling_,this.renderedExtent_=null,this.renderedRevision,this.renderedTiles=[],this.newTiles_=!1,this.tmpExtent=[1/0,1/0,-1/0,-1/0],this.tmpTileRange_=new Ll(0,0,0,0),this.imageTransform_=[1,0,0,1,0,0],this.zDirection=0};a(Ml,wl),Ml.handles=function(t){return t.getType()===Wa},Ml.create=function(t,e){return new Ml(e)},Ml.prototype.isDrawableTile_=function(t){const e=t.getState(),i=this.getLayer().getUseInterimTilesOnError();return e==Jo||e==$o||e==Qo&&!i},Ml.prototype.getTile=function(t,e,i,n,o){const s=this.getLayer();let r=s.getSource().getTile(t,e,i,n,o);return r.getState()==Qo&&(s.getUseInterimTilesOnError()?s.getPreload()>0&&(this.newTiles_=!0):r.setState(Jo)),this.isDrawableTile_(r)||(r=r.getInterimTile()),r},Ml.prototype.prepareFrame=function(t,e){const i=t.pixelRatio,n=t.size,o=t.viewState,s=o.projection,r=o.resolution,a=o.center,h=this.getLayer(),c=h.getSource(),u=c.getRevision(),p=c.getTileGridForProjection(s),d=p.getZForResolution(r,this.zDirection),f=p.getResolution(d);let g=Math.round(r/f)||1,_=t.extent;if(void 0!==e.extent&&(_=mt(_,e.extent)),Tt(_))return!1;const y=p.getTileRangeForExtentAndZ(_,d),m=p.getTileRangeExtent(d,y),v=c.getTilePixelRatio(i),x={};x[d]={};const C=this.createLoadedTileFinder(c,s,x),E=t.viewHints,T=E[cs.ANIMATING]||E[cs.INTERACTING],S=this.tmpExtent,w=this.tmpTileRange_;let R,I,F;for(this.newTiles_=!1,I=y.minX;I<=y.maxX;++I)for(F=y.minY;F<=y.maxY;++F){if(Date.now()-t.time>16&&T)continue;if(R=this.getTile(d,I,F,i,s),this.isDrawableTile_(R)){const e=l(this);if(R.getState()==Jo){x[d][R.tileCoord.toString()]=R;const t=R.inTransition(e);this.newTiles_||!t&&-1!==this.renderedTiles.indexOf(R)||(this.newTiles_=!0)}if(1===R.getAlpha(e,t.time))continue}const e=p.getTileCoordChildTileRange(R.tileCoord,w,S);let n=!1;e&&(n=C(d+1,e)),n||p.forEachTileCoordParentTileRange(R.tileCoord,C,null,w,S)}const P=f*i/v*g;if(!(this.renderedResolution&&Date.now()-t.time>16&&T)&&(this.newTiles_||!this.renderedExtent_||!J(this.renderedExtent_,_)||this.renderedRevision!=u||g!=this.oversampling_||!T&&P!=this.renderedResolution)){const n=this.context;if(n){const t=c.getTilePixelSize(d,i,s),e=Math.round(y.getWidth()*t[0]/g),o=Math.round(y.getHeight()*t[1]/g),r=n.canvas;r.width!=e||r.height!=o?(this.oversampling_=g,r.width=e,r.height=o):(this.renderedExtent_&&!st(m,this.renderedExtent_)&&n.clearRect(0,0,e,o),g=this.oversampling_)}this.renderedTiles.length=0;const o=Object.keys(x).map(Number);let r,a,h,l,_,C,E,T,w,P,L;for(o.sort(function(t,e){return t===d?1:e===d?-1:t>e?1:t<e?-1:0}),_=0,C=o.length;_<C;++_){l=o[_],h=c.getTilePixelSize(l,i,s),a=(r=p.getResolution(l))/f,T=v*c.getGutter(s),w=x[l];for(const i in w)R=w[i],I=((E=p.getTileCoordExtent(R.getTileCoord(),S))[0]-m[0])/f*v/g,F=(m[3]-E[3])/f*v/g,P=h[0]*a/g,L=h[1]*a/g,this.drawTileImage(R,t,e,I,F,P,L,T,d===l),this.renderedTiles.push(R)}this.renderedRevision=u,this.renderedResolution=f*i/v*g,this.renderedExtent_=m}const L=this.renderedResolution/r,M=Te(this.imageTransform_,i*n[0]/2,i*n[1]/2,L,L,0,(this.renderedExtent_[0]-a[0])/this.renderedResolution*i,(a[1]-this.renderedExtent_[3])/this.renderedResolution*i);return Te(this.coordinateToCanvasPixelTransform,i*n[0]/2-M[4],i*n[1]/2-M[5],i/r,-i/r,0,-a[0],-a[1]),this.updateUsedTiles(t.usedTiles,c,d,y),this.manageTilePyramid(t,c,p,i,s,_,d,h.getPreload()),this.scheduleExpireCache(t,c),this.renderedTiles.length>0},Ml.prototype.drawTileImage=function(t,e,i,n,o,s,r,a,h){const c=t.getImage(this.getLayer());if(!c)return;const u=l(this),p=h?t.getAlpha(u,e.time):1;1!==p||this.getLayer().getSource().getOpaque(e.viewState.projection)||this.context.clearRect(n,o,s,r);const d=p!==this.context.globalAlpha;d&&(this.context.save(),this.context.globalAlpha=p),this.context.drawImage(c,a,a,c.width-2*a,c.height-2*a,n,o,s,r),d&&this.context.restore(),1!==p?e.animate=!0:h&&t.endTransition(u)},Ml.prototype.getImage=function(){const t=this.context;return t?t.canvas:null},Ml.prototype.getLayer,Ml.prototype.getImageTransform=function(){return this.imageTransform_};var bl=Ml;const Ol=function(){};Ol.prototype.getReplay=function(t,e){},Ol.prototype.isEmpty=function(){};var kl=Ol,Al={CIRCLE:\"Circle\",DEFAULT:\"Default\",IMAGE:\"Image\",LINE_STRING:\"LineString\",POLYGON:\"Polygon\",TEXT:\"Text\"};function Gl(t,e,i,n,o,s,r,a){const h=[],l=t[e]>t[i-n],c=o.length;let u,p,d,f=t[e],g=t[e+1],_=t[e+=n],y=t[e+1],m=0,v=Math.sqrt(Math.pow(_-f,2)+Math.pow(y-g,2)),x=\"\",C=0;for(let E=0;E<c;++E){p=l?c-E-1:E;const T=o.charAt(p),S=s(x=l?T+x:x+T)-C;C+=S;const w=r+S/2;for(;e<i-n&&m+v<w;)f=_,g=y,_=t[e+=n],y=t[e+1],m+=v,v=Math.sqrt(Math.pow(_-f,2)+Math.pow(y-g,2));const R=w-m;let I=Math.atan2(y-g,_-f);if(l&&(I+=I>0?-Math.PI:Math.PI),void 0!==d){let t=I-d;if(t+=t>Math.PI?-2*Math.PI:t<-Math.PI?2*Math.PI:0,Math.abs(t)>a)return null}const F=R/v,P=bt(f,_,F),L=bt(g,y,F);d==I?(l&&(u[0]=P,u[1]=L,u[2]=S/2),u[4]=x):(C=S,u=[P,L,S/2,I,x=T],l?h.unshift(u):h.push(u),d=I),r+=S}return h}const Dl={BEGIN_GEOMETRY:0,BEGIN_PATH:1,CIRCLE:2,CLOSE_PATH:3,CUSTOM:4,DRAW_CHARS:5,DRAW_IMAGE:6,END_GEOMETRY:7,FILL:8,MOVE_TO_LINE_TO:9,SET_FILL_STYLE:10,SET_STROKE_STYLE:11,STROKE:12},Nl=[Dl.FILL],Yl=[Dl.STROKE],Xl=[Dl.BEGIN_PATH],zl=[Dl.CLOSE_PATH];var Wl=Dl;const Kl=[Al.POLYGON,Al.CIRCLE,Al.LINE_STRING,Al.IMAGE,Al.TEXT,Al.DEFAULT],Ul={left:0,end:0,center:.5,right:1,start:1,top:0,middle:.5,hanging:.2,alphabetic:.8,ideographic:.8,bottom:1},Bl=function(t,e,i,n,o,s){al.call(this),this.declutterTree=s,this.tolerance=t,this.maxExtent=e,this.overlaps=o,this.pixelRatio=n,this.maxLineWidth=0,this.resolution=i,this.alignFill_,this.beginGeometryInstruction1_=null,this.beginGeometryInstruction2_=null,this.bufferedMaxExtent_=null,this.instructions=[],this.coordinates=[],this.coordinateCache_={},this.renderedTransform_=[1,0,0,1,0,0],this.hitDetectionInstructions=[],this.pixelCoordinates_=null,this.state={},this.viewRotation_=0};a(Bl,al);const jl=[1/0,1/0,-1/0,-1/0],Hl=[1,0,0,1,0,0];Bl.prototype.replayTextBackground_=function(t,e,i,n,o,s,r){t.beginPath(),t.moveTo.apply(t,e),t.lineTo.apply(t,i),t.lineTo.apply(t,n),t.lineTo.apply(t,o),t.lineTo.apply(t,e),s&&(this.alignFill_=s[2],this.fill_(t)),r&&(this.setStrokeStyle_(t,r),t.stroke())},Bl.prototype.replayImage_=function(t,e,i,n,o,s,r,a,h,l,c,u,p,d,f,g,_,y){const m=_||y;e-=o*=p,i-=s*=p;const v=f+l>n.width?n.width-l:f,x=a+c>n.height?n.height-c:a,C=g[3]+v*p+g[1],E=g[0]+x*p+g[2],T=e-g[3],S=i-g[0];let w,R,I,F;(m||0!==u)&&(w=[T,S],R=[T+C,S],I=[T+C,S+E],F=[T,S+E]);let P=null;if(0!==u){const t=e+o,n=i+s;P=Te(Hl,t,n,1,1,u,-t,-n),it(jl),at(jl,xe(Hl,w)),at(jl,xe(Hl,R)),at(jl,xe(Hl,I)),at(jl,xe(Hl,F))}else et(T,S,T+C,S+E,jl);const L=t.canvas,M=y?y[2]*p/2:0,b=jl[0]-M<=L.width&&jl[2]+M>=0&&jl[1]-M<=L.height&&jl[3]+M>=0;if(d&&(e=Math.round(e),i=Math.round(i)),r){if(!b&&1==r[4])return;rt(r,jl);const o=b?[t,P?P.slice(0):null,h,n,l,c,v,x,e,i,p]:null;o&&m&&o.push(_,y,w,R,I,F),r.push(o)}else b&&(m&&this.replayTextBackground_(t,w,R,I,F,_,y),di(t,P,h,n,l,c,v,x,e,i,p))},Bl.prototype.applyPixelRatio=function(t){const e=this.pixelRatio;return 1==e?t:t.map(function(t){return t*e})},Bl.prototype.appendFlatCoordinates=function(t,e,i,n,o,s){let r=this.coordinates.length;const a=this.getBufferedMaxExtent();s&&(e+=n);const h=[t[e],t[e+1]],l=[NaN,NaN];let c,u,p,d=!0;for(c=e+n;c<i;c+=n)l[0]=t[c],l[1]=t[c+1],(p=$(a,l))!==u?(d&&(this.coordinates[r++]=h[0],this.coordinates[r++]=h[1]),this.coordinates[r++]=l[0],this.coordinates[r++]=l[1],d=!1):p===B.INTERSECTING?(this.coordinates[r++]=l[0],this.coordinates[r++]=l[1],d=!1):d=!0,h[0]=l[0],h[1]=l[1],u=p;return(o&&d||c===e+n)&&(this.coordinates[r++]=h[0],this.coordinates[r++]=h[1]),r},Bl.prototype.drawCustomCoordinates_=function(t,e,i,n,o){for(let s=0,r=i.length;s<r;++s){const r=i[s],a=this.appendFlatCoordinates(t,e,r,n,!1,!1);o.push(a),e=r}return e},Bl.prototype.drawCustom=function(t,e,i){this.beginGeometry(t,e);const n=t.getType(),o=t.getStride(),s=this.coordinates.length;let r,a,h,l,c;if(n==Ot.MULTI_POLYGON){r=(t=t).getOrientedFlatCoordinates(),l=[];const e=t.getEndss();c=0;for(let t=0,i=e.length;t<i;++t){const i=[];c=this.drawCustomCoordinates_(r,c,e[t],o,i),l.push(i)}this.instructions.push([Wl.CUSTOM,s,l,t,i,ln])}else n==Ot.POLYGON||n==Ot.MULTI_LINE_STRING?(h=[],r=n==Ot.POLYGON?t.getOrientedFlatCoordinates():t.getFlatCoordinates(),c=this.drawCustomCoordinates_(r,0,t.getEnds(),o,h),this.instructions.push([Wl.CUSTOM,s,h,t,i,hn])):n==Ot.LINE_STRING||n==Ot.MULTI_POINT?(r=t.getFlatCoordinates(),a=this.appendFlatCoordinates(r,0,r.length,o,!1,!1),this.instructions.push([Wl.CUSTOM,s,a,t,i,an])):n==Ot.POINT&&(r=t.getFlatCoordinates(),this.coordinates.push(r[0],r[1]),a=this.coordinates.length,this.instructions.push([Wl.CUSTOM,s,a,t,i]));this.endGeometry(t,e)},Bl.prototype.beginGeometry=function(t,e){this.beginGeometryInstruction1_=[Wl.BEGIN_GEOMETRY,e,0],this.instructions.push(this.beginGeometryInstruction1_),this.beginGeometryInstruction2_=[Wl.BEGIN_GEOMETRY,e,0],this.hitDetectionInstructions.push(this.beginGeometryInstruction2_)},Bl.prototype.fill_=function(t){if(this.alignFill_){const e=xe(this.renderedTransform_,[0,0]),i=512*this.pixelRatio;t.translate(e[0]%i,e[1]%i),t.rotate(this.viewRotation_)}t.fill(),this.alignFill_&&t.setTransform.apply(t,pi)},Bl.prototype.setStrokeStyle_=function(t,e){t.strokeStyle=e[1],t.lineWidth=e[2],t.lineCap=e[3],t.lineJoin=e[4],t.miterLimit=e[5],Ue&&(t.lineDashOffset=e[7],t.setLineDash(e[6]))},Bl.prototype.renderDeclutter_=function(t,e){if(t&&t.length>5){const i=t[4];if(1==i||i==t.length-5){const i={minX:t[0],minY:t[1],maxX:t[2],maxY:t[3],value:e};if(!this.declutterTree.collides(i)){this.declutterTree.insert(i);for(let e=5,i=t.length;e<i;++e){const i=t[e];i&&(i.length>11&&this.replayTextBackground_(i[0],i[13],i[14],i[15],i[16],i[11],i[12]),di.apply(void 0,i))}}t.length=5,it(t)}}},Bl.prototype.replay_=function(t,e,i,n,o,s){let r;this.pixelCoordinates_&&Hi(e,this.renderedTransform_)?r=this.pixelCoordinates_:(this.pixelCoordinates_||(this.pixelCoordinates_=[]),r=wt(this.coordinates,0,this.coordinates.length,2,e,this.pixelCoordinates_),ve(this.renderedTransform_,e));const a=!_(i);let h=0;const c=n.length;let u,p,d,f,g,y,m,v,x,C=0,E=0,T=0,S=null,w=null;const R=this.coordinateCache_,I=this.viewRotation_,F={context:t,pixelRatio:this.pixelRatio,resolution:this.resolution,rotation:I},P=this.instructions!=n||this.overlaps?0:200;let L,M,b;for(;h<c;){const e=n[h];switch(e[0]){case Wl.BEGIN_GEOMETRY:L=e[1],a&&i[l(L).toString()]||!L.getGeometry()?h=e[2]:void 0===s||Et(s,L.getGeometry().getExtent())?++h:h=e[2]+1;break;case Wl.BEGIN_PATH:E>P&&(this.fill_(t),E=0),T>P&&(t.stroke(),T=0),E||T||(t.beginPath(),f=g=NaN),++h;break;case Wl.CIRCLE:const n=r[C=e[1]],c=r[C+1],_=r[C+2]-n,O=r[C+3]-c,k=Math.sqrt(_*_+O*O);t.moveTo(n+k,c),t.arc(n,c,k,0,2*Math.PI,!0),++h;break;case Wl.CLOSE_PATH:t.closePath(),++h;break;case Wl.CUSTOM:C=e[1],u=e[2];const A=e[3],G=e[4],D=6==e.length?e[5]:void 0;F.geometry=A,F.feature=L,h in R||(R[h]=[]);const N=R[h];D?D(r,C,u,2,N):(N[0]=r[C],N[1]=r[C+1],N.length=2),G(N,F),++h;break;case Wl.DRAW_IMAGE:C=e[1],u=e[2],x=e[3],p=e[4],d=e[5],v=o?null:e[6];const Y=e[7],X=e[8],z=e[9],W=e[10],K=e[11];let U=e[12];const B=e[13],j=e[14],H=e[15];let V,Z,q;for(e.length>16?(V=e[16],Z=e[17],q=e[18]):(V=ii,Z=q=!1),K&&(U+=I);C<u;C+=2)this.replayImage_(t,r[C],r[C+1],x,p,d,v,Y,X,z,W,U,B,j,H,V,Z?S:null,q?w:null);this.renderDeclutter_(v,L),++h;break;case Wl.DRAW_CHARS:const J=e[1],Q=e[2],$=e[3];v=o?null:e[4];const tt=e[5],et=e[6],it=e[7],nt=e[8],ot=e[9],st=e[10],rt=e[11],at=e[12],ht=e[13],lt=e[14],ct=mn(r,J,Q,2),ut=nt(at);if(tt||ut<=ct){const e=this.textStates[ht].textAlign,i=Gl(r,J,Q,2,at,nt,(ct-ut)*Ul[e],it);if(i){let e,n,o,s,r;if(st)for(e=0,n=i.length;e<n;++e)o=(r=i[e])[4],s=this.getImage(o,ht,\"\",st),p=r[2]+rt,d=$*s.height+2*(.5-$)*rt-ot,this.replayImage_(t,r[0],r[1],s,p,d,v,s.height,1,0,0,r[3],lt,!1,s.width,ii,null,null);if(et)for(e=0,n=i.length;e<n;++e)o=(r=i[e])[4],s=this.getImage(o,ht,et,\"\"),p=r[2],d=$*s.height-ot,this.replayImage_(t,r[0],r[1],s,p,d,v,s.height,1,0,0,r[3],lt,!1,s.width,ii,null,null)}}this.renderDeclutter_(v,L),++h;break;case Wl.END_GEOMETRY:if(void 0!==o){const t=o(L=e[1]);if(t)return t}++h;break;case Wl.FILL:P?E++:this.fill_(t),++h;break;case Wl.MOVE_TO_LINE_TO:for(C=e[1],u=e[2],M=r[C],m=(b=r[C+1])+.5|0,(y=M+.5|0)===f&&m===g||(t.moveTo(M,b),f=y,g=m),C+=2;C<u;C+=2)y=(M=r[C])+.5|0,m=(b=r[C+1])+.5|0,C!=u-2&&y===f&&m===g||(t.lineTo(M,b),f=y,g=m);++h;break;case Wl.SET_FILL_STYLE:S=e,this.alignFill_=e[2],E&&(this.fill_(t),E=0,T&&(t.stroke(),T=0)),t.fillStyle=e[1],++h;break;case Wl.SET_STROKE_STYLE:w=e,T&&(t.stroke(),T=0),this.setStrokeStyle_(t,e),++h;break;case Wl.STROKE:P?T++:t.stroke(),++h;break;default:++h}}E&&this.fill_(t),T&&t.stroke()},Bl.prototype.replay=function(t,e,i,n){this.viewRotation_=i,this.replay_(t,e,n,this.instructions,void 0,void 0)},Bl.prototype.replayHitDetection=function(t,e,i,n,o,s){return this.viewRotation_=i,this.replay_(t,e,n,this.hitDetectionInstructions,o,s)},Bl.prototype.reverseHitDetectionInstructions=function(){const t=this.hitDetectionInstructions;let e;t.reverse();const i=t.length;let n,o,s=-1;for(e=0;e<i;++e)(o=(n=t[e])[0])==Wl.END_GEOMETRY?s=e:o==Wl.BEGIN_GEOMETRY&&(n[2]=e,Bi(this.hitDetectionInstructions,s,e),s=-1)},Bl.prototype.setFillStrokeStyle=function(t,e){const i=this.state;if(t){const e=t.getColor();i.fillStyle=Oe(e||$e)}else i.fillStyle=void 0;if(e){const t=e.getColor();i.strokeStyle=Oe(t||ei);const n=e.getLineCap();i.lineCap=void 0!==n?n:\"round\";const o=e.getLineDash();i.lineDash=o?o.slice():ti;const s=e.getLineDashOffset();i.lineDashOffset=s||0;const r=e.getLineJoin();i.lineJoin=void 0!==r?r:\"round\";const a=e.getWidth();i.lineWidth=void 0!==a?a:1;const h=e.getMiterLimit();i.miterLimit=void 0!==h?h:10,i.lineWidth>this.maxLineWidth&&(this.maxLineWidth=i.lineWidth,this.bufferedMaxExtent_=null)}else i.strokeStyle=void 0,i.lineCap=void 0,i.lineDash=null,i.lineDashOffset=void 0,i.lineJoin=void 0,i.lineWidth=void 0,i.miterLimit=void 0},Bl.prototype.createFill=function(t,e){const i=t.fillStyle,n=[Wl.SET_FILL_STYLE,i];return\"string\"!=typeof i&&n.push(!0),n},Bl.prototype.applyStroke=function(t){this.instructions.push(this.createStroke(t))},Bl.prototype.createStroke=function(t){return[Wl.SET_STROKE_STYLE,t.strokeStyle,t.lineWidth*this.pixelRatio,t.lineCap,t.lineJoin,t.miterLimit,this.applyPixelRatio(t.lineDash),t.lineDashOffset*this.pixelRatio]},Bl.prototype.updateFillStyle=function(t,e,i){const n=t.fillStyle;\"string\"==typeof n&&t.currentFillStyle==n||(void 0!==n&&this.instructions.push(e.call(this,t,i)),t.currentFillStyle=n)},Bl.prototype.updateStrokeStyle=function(t,e){const i=t.strokeStyle,n=t.lineCap,o=t.lineDash,s=t.lineDashOffset,r=t.lineJoin,a=t.lineWidth,h=t.miterLimit;(t.currentStrokeStyle!=i||t.currentLineCap!=n||o!=t.currentLineDash&&!Hi(t.currentLineDash,o)||t.currentLineDashOffset!=s||t.currentLineJoin!=r||t.currentLineWidth!=a||t.currentMiterLimit!=h)&&(void 0!==i&&e.call(this,t),t.currentStrokeStyle=i,t.currentLineCap=n,t.currentLineDash=o,t.currentLineDashOffset=s,t.currentLineJoin=r,t.currentLineWidth=a,t.currentMiterLimit=h)},Bl.prototype.endGeometry=function(t,e){this.beginGeometryInstruction1_[2]=this.instructions.length,this.beginGeometryInstruction1_=null,this.beginGeometryInstruction2_[2]=this.hitDetectionInstructions.length,this.beginGeometryInstruction2_=null;const i=[Wl.END_GEOMETRY,e];this.instructions.push(i),this.hitDetectionInstructions.push(i)},Bl.prototype.finish=P,Bl.prototype.getBufferedMaxExtent=function(){if(!this.bufferedMaxExtent_&&(this.bufferedMaxExtent_=V(this.maxExtent),this.maxLineWidth>0)){const t=this.resolution*(this.maxLineWidth+1)/2;H(this.bufferedMaxExtent_,t,this.bufferedMaxExtent_)}return this.bufferedMaxExtent_};var Vl=Bl;const Zl=function(t,e,i,n,o,s){Vl.call(this,t,e,i,n,o,s),this.declutterGroup_=null,this.hitDetectionImage_=null,this.image_=null,this.anchorX_=void 0,this.anchorY_=void 0,this.height_=void 0,this.opacity_=void 0,this.originX_=void 0,this.originY_=void 0,this.rotateWithView_=void 0,this.rotation_=void 0,this.scale_=void 0,this.snapToPixel_=void 0,this.width_=void 0};a(Zl,Vl),Zl.prototype.drawCoordinates_=function(t,e,i,n){return this.appendFlatCoordinates(t,e,i,n,!1,!1)},Zl.prototype.drawPoint=function(t,e){if(!this.image_)return;this.beginGeometry(t,e);const i=t.getFlatCoordinates(),n=t.getStride(),o=this.coordinates.length,s=this.drawCoordinates_(i,0,i.length,n);this.instructions.push([Wl.DRAW_IMAGE,o,s,this.image_,this.anchorX_,this.anchorY_,this.declutterGroup_,this.height_,this.opacity_,this.originX_,this.originY_,this.rotateWithView_,this.rotation_,this.scale_*this.pixelRatio,this.snapToPixel_,this.width_]),this.hitDetectionInstructions.push([Wl.DRAW_IMAGE,o,s,this.hitDetectionImage_,this.anchorX_,this.anchorY_,this.declutterGroup_,this.height_,this.opacity_,this.originX_,this.originY_,this.rotateWithView_,this.rotation_,this.scale_,this.snapToPixel_,this.width_]),this.endGeometry(t,e)},Zl.prototype.drawMultiPoint=function(t,e){if(!this.image_)return;this.beginGeometry(t,e);const i=t.getFlatCoordinates(),n=t.getStride(),o=this.coordinates.length,s=this.drawCoordinates_(i,0,i.length,n);this.instructions.push([Wl.DRAW_IMAGE,o,s,this.image_,this.anchorX_,this.anchorY_,this.declutterGroup_,this.height_,this.opacity_,this.originX_,this.originY_,this.rotateWithView_,this.rotation_,this.scale_*this.pixelRatio,this.snapToPixel_,this.width_]),this.hitDetectionInstructions.push([Wl.DRAW_IMAGE,o,s,this.hitDetectionImage_,this.anchorX_,this.anchorY_,this.declutterGroup_,this.height_,this.opacity_,this.originX_,this.originY_,this.rotateWithView_,this.rotation_,this.scale_,this.snapToPixel_,this.width_]),this.endGeometry(t,e)},Zl.prototype.finish=function(){this.reverseHitDetectionInstructions(),this.anchorX_=void 0,this.anchorY_=void 0,this.hitDetectionImage_=null,this.image_=null,this.height_=void 0,this.scale_=void 0,this.opacity_=void 0,this.originX_=void 0,this.originY_=void 0,this.rotateWithView_=void 0,this.rotation_=void 0,this.snapToPixel_=void 0,this.width_=void 0},Zl.prototype.setImageStyle=function(t,e){const i=t.getAnchor(),n=t.getSize(),o=t.getHitDetectionImage(1),s=t.getImage(1),r=t.getOrigin();this.anchorX_=i[0],this.anchorY_=i[1],this.declutterGroup_=e,this.hitDetectionImage_=o,this.image_=s,this.height_=n[1],this.opacity_=t.getOpacity(),this.originX_=r[0],this.originY_=r[1],this.rotateWithView_=t.getRotateWithView(),this.rotation_=t.getRotation(),this.scale_=t.getScale(),this.snapToPixel_=t.getSnapToPixel(),this.width_=n[0]};var ql=Zl;const Jl=function(t,e,i,n,o,s){Vl.call(this,t,e,i,n,o,s)};a(Jl,Vl),Jl.prototype.drawFlatCoordinates_=function(t,e,i,n){const o=this.coordinates.length,s=this.appendFlatCoordinates(t,e,i,n,!1,!1),r=[Wl.MOVE_TO_LINE_TO,o,s];return this.instructions.push(r),this.hitDetectionInstructions.push(r),i},Jl.prototype.drawLineString=function(t,e){const i=this.state,n=i.strokeStyle,o=i.lineWidth;if(void 0===n||void 0===o)return;this.updateStrokeStyle(i,this.applyStroke),this.beginGeometry(t,e),this.hitDetectionInstructions.push([Wl.SET_STROKE_STYLE,i.strokeStyle,i.lineWidth,i.lineCap,i.lineJoin,i.miterLimit,i.lineDash,i.lineDashOffset],Xl);const s=t.getFlatCoordinates(),r=t.getStride();this.drawFlatCoordinates_(s,0,s.length,r),this.hitDetectionInstructions.push(Yl),this.endGeometry(t,e)},Jl.prototype.drawMultiLineString=function(t,e){const i=this.state,n=i.strokeStyle,o=i.lineWidth;if(void 0===n||void 0===o)return;this.updateStrokeStyle(i,this.applyStroke),this.beginGeometry(t,e),this.hitDetectionInstructions.push([Wl.SET_STROKE_STYLE,i.strokeStyle,i.lineWidth,i.lineCap,i.lineJoin,i.miterLimit,i.lineDash,i.lineDashOffset],Xl);const s=t.getEnds(),r=t.getFlatCoordinates(),a=t.getStride();let h=0;for(let t=0,e=s.length;t<e;++t)h=this.drawFlatCoordinates_(r,h,s[t],a);this.hitDetectionInstructions.push(Yl),this.endGeometry(t,e)},Jl.prototype.finish=function(){const t=this.state;void 0!=t.lastStroke&&t.lastStroke!=this.coordinates.length&&this.instructions.push(Yl),this.reverseHitDetectionInstructions(),this.state=null},Jl.prototype.applyStroke=function(t){void 0!=t.lastStroke&&t.lastStroke!=this.coordinates.length&&(this.instructions.push(Yl),t.lastStroke=this.coordinates.length),t.lastStroke=0,Vl.prototype.applyStroke.call(this,t),this.instructions.push(Xl)};var Ql=Jl;const $l=function(t,e,i,n,o,s){Vl.call(this,t,e,i,n,o,s)};a($l,Vl),$l.prototype.drawFlatCoordinatess_=function(t,e,i,n){const o=this.state,s=void 0!==o.fillStyle,r=void 0!=o.strokeStyle,a=i.length;this.instructions.push(Xl),this.hitDetectionInstructions.push(Xl);for(let o=0;o<a;++o){const s=i[o],a=this.coordinates.length,h=this.appendFlatCoordinates(t,e,s,n,!0,!r),l=[Wl.MOVE_TO_LINE_TO,a,h];this.instructions.push(l),this.hitDetectionInstructions.push(l),r&&(this.instructions.push(zl),this.hitDetectionInstructions.push(zl)),e=s}return this.hitDetectionInstructions.push(Nl),s&&this.instructions.push(Nl),r&&(this.instructions.push(Yl),this.hitDetectionInstructions.push(Yl)),e},$l.prototype.drawCircle=function(t,e){const i=this.state,n=i.fillStyle,o=i.strokeStyle;if(void 0===n&&void 0===o)return;this.setFillStrokeStyles_(t),this.beginGeometry(t,e),this.hitDetectionInstructions.push([Wl.SET_FILL_STYLE,Pe($e)]),void 0!==i.strokeStyle&&this.hitDetectionInstructions.push([Wl.SET_STROKE_STYLE,i.strokeStyle,i.lineWidth,i.lineCap,i.lineJoin,i.miterLimit,i.lineDash,i.lineDashOffset]);const s=t.getFlatCoordinates(),r=t.getStride(),a=this.coordinates.length;this.appendFlatCoordinates(s,0,s.length,r,!1,!1);const h=[Wl.CIRCLE,a];this.instructions.push(Xl,h),this.hitDetectionInstructions.push(Xl,h),this.hitDetectionInstructions.push(Nl),void 0!==i.fillStyle&&this.instructions.push(Nl),void 0!==i.strokeStyle&&(this.instructions.push(Yl),this.hitDetectionInstructions.push(Yl)),this.endGeometry(t,e)},$l.prototype.drawPolygon=function(t,e){const i=this.state;this.setFillStrokeStyles_(t),this.beginGeometry(t,e),this.hitDetectionInstructions.push([Wl.SET_FILL_STYLE,Pe($e)]),void 0!==i.strokeStyle&&this.hitDetectionInstructions.push([Wl.SET_STROKE_STYLE,i.strokeStyle,i.lineWidth,i.lineCap,i.lineJoin,i.miterLimit,i.lineDash,i.lineDashOffset]);const n=t.getEnds(),o=t.getOrientedFlatCoordinates(),s=t.getStride();this.drawFlatCoordinatess_(o,0,n,s),this.endGeometry(t,e)},$l.prototype.drawMultiPolygon=function(t,e){const i=this.state,n=i.fillStyle,o=i.strokeStyle;if(void 0===n&&void 0===o)return;this.setFillStrokeStyles_(t),this.beginGeometry(t,e),this.hitDetectionInstructions.push([Wl.SET_FILL_STYLE,Pe($e)]),void 0!==i.strokeStyle&&this.hitDetectionInstructions.push([Wl.SET_STROKE_STYLE,i.strokeStyle,i.lineWidth,i.lineCap,i.lineJoin,i.miterLimit,i.lineDash,i.lineDashOffset]);const s=t.getEndss(),r=t.getOrientedFlatCoordinates(),a=t.getStride();let h=0;for(let t=0,e=s.length;t<e;++t)h=this.drawFlatCoordinatess_(r,h,s[t],a);this.endGeometry(t,e)},$l.prototype.finish=function(){this.reverseHitDetectionInstructions(),this.state=null;const t=this.tolerance;if(0!==t){const e=this.coordinates;for(let i=0,n=e.length;i<n;++i)e[i]=Cn(e[i],t)}},$l.prototype.setFillStrokeStyles_=function(t){const e=this.state;void 0!==e.fillStyle&&this.updateFillStyle(e,this.createFill,t),void 0!==e.strokeStyle&&this.updateStrokeStyle(e,this.applyStroke)};var tc=$l;function ec(t,e,i,n,o){let s,r,a,h,l,c,u,p,d,f,g=i,_=i,y=0,m=0,v=i;for(r=i;r<n;r+=o){const i=e[r],n=e[r+1];void 0!==l&&(d=i-l,f=n-c,h=Math.sqrt(d*d+f*f),void 0!==u&&(m+=a,(s=Math.acos((u*d+p*f)/(a*h)))>t&&(m>y&&(y=m,g=v,_=r),m=0,v=r-o)),a=h,u=d,p=f),l=i,c=n}return(m+=h)>y?[v,r]:[g,_]}var ic=\"point\",nc=\"line\";const oc=function(t,e,i,n,o,s){Vl.call(this,t,e,i,n,o,s),this.declutterGroup_,this.labels_=null,this.text_=\"\",this.textOffsetX_=0,this.textOffsetY_=0,this.textRotateWithView_=void 0,this.textRotation_=0,this.textFillState_=null,this.fillStates={},this.textStrokeState_=null,this.strokeStates={},this.textState_={},this.textStates={},this.textKey_=\"\",this.fillKey_=\"\",this.strokeKey_=\"\",this.widths_={},ni.prune()};a(oc,Vl),oc.prototype.drawText=function(t,e){const i=this.textFillState_,n=this.textStrokeState_,o=this.textState_;if(\"\"===this.text_||!o||!i&&!n)return;let s=this.coordinates.length;const r=t.getType();let a,h,l=null,c=2,u=2;if(o.placement===nc){if(!Et(this.getBufferedMaxExtent(),t.getExtent()))return;let i;if(l=t.getFlatCoordinates(),u=t.getStride(),r==Ot.LINE_STRING)i=[l.length];else if(r==Ot.MULTI_LINE_STRING)i=t.getEnds();else if(r==Ot.POLYGON)i=t.getEnds().slice(0,1);else if(r==Ot.MULTI_POLYGON){const e=t.getEndss();for(i=[],a=0,h=e.length;a<h;++a)i.push(e[a][0])}this.beginGeometry(t,e);const n=o.textAlign;let p,d=0;for(let t=0,e=i.length;t<e;++t){if(void 0==n){const e=ec(o.maxAngle,l,d,i[t],u);d=e[0],p=e[1]}else p=i[t];for(a=d;a<p;a+=u)this.coordinates.push(l[a],l[a+1]);c=this.coordinates.length,d=i[t],this.drawChars_(s,c,this.declutterGroup_),s=c}this.endGeometry(t,e)}else{const i=this.getImage(this.text_,this.textKey_,this.fillKey_,this.strokeKey_),n=i.width/this.pixelRatio;switch(r){case Ot.POINT:case Ot.MULTI_POINT:c=(l=t.getFlatCoordinates()).length;break;case Ot.LINE_STRING:l=t.getFlatMidpoint();break;case Ot.CIRCLE:l=t.getCenter();break;case Ot.MULTI_LINE_STRING:c=(l=t.getFlatMidpoints()).length;break;case Ot.POLYGON:if(l=t.getFlatInteriorPoint(),!o.overflow&&l[2]/this.resolution<n)return;u=3;break;case Ot.MULTI_POLYGON:const e=t.getFlatInteriorPoints();for(l=[],a=0,h=e.length;a<h;a+=3)(o.overflow||e[a+2]/this.resolution>=n)&&l.push(e[a],e[a+1]);if(0==(c=l.length))return}c=this.appendFlatCoordinates(l,0,c,u,!1,!1),(o.backgroundFill||o.backgroundStroke)&&(this.setFillStrokeStyle(o.backgroundFill,o.backgroundStroke),o.backgroundFill&&(this.updateFillStyle(this.state,this.createFill,t),this.hitDetectionInstructions.push(this.createFill(this.state,t))),o.backgroundStroke&&(this.updateStrokeStyle(this.state,this.applyStroke),this.hitDetectionInstructions.push(this.createStroke(this.state)))),this.beginGeometry(t,e),this.drawTextImage_(i,s,c),this.endGeometry(t,e)}},oc.prototype.getImage=function(t,e,i,n){let o;const s=n+e+t+i+this.pixelRatio;if(!ni.containsKey(s)){const r=n?this.strokeStates[n]||this.textStrokeState_:null,a=i?this.fillStates[i]||this.textFillState_:null,h=this.textStates[e]||this.textState_,l=this.pixelRatio,c=h.scale*l,u=Ul[h.textAlign||\"center\"],p=n&&r.lineWidth?r.lineWidth:0,d=t.split(\"\\n\"),f=d.length,g=[],_=function(t,e,i){const n=e.length;let o=0;for(let s=0;s<n;++s){const n=ci(t,e[s]);o=Math.max(o,n),i.push(n)}return o}(h.font,d,g),y=li(h.font),m=y*f,v=_+p,x=ke(Math.ceil(v*c),Math.ceil((m+p)*c));o=x.canvas,ni.set(s,o),1!=c&&x.scale(c,c),x.font=h.font,n&&(x.strokeStyle=r.strokeStyle,x.lineWidth=p,x.lineCap=r.lineCap,x.lineJoin=r.lineJoin,x.miterLimit=r.miterLimit,Ue&&r.lineDash.length&&(x.setLineDash(r.lineDash),x.lineDashOffset=r.lineDashOffset)),i&&(x.fillStyle=a.fillStyle),x.textBaseline=\"middle\",x.textAlign=\"center\";const C=.5-u,E=u*o.width/c+C*p;let T;if(n)for(T=0;T<f;++T)x.strokeText(d[T],E+C*g[T],.5*(p+y)+T*y);if(i)for(T=0;T<f;++T)x.fillText(d[T],E+C*g[T],.5*(p+y)+T*y)}return ni.get(s)},oc.prototype.drawTextImage_=function(t,e,i){const n=this.textState_,o=this.textStrokeState_,s=this.pixelRatio,r=Ul[n.textAlign||\"center\"],a=Ul[n.textBaseline],h=o&&o.lineWidth?o.lineWidth:0,l=r*t.width/s+2*(.5-r)*h,c=a*t.height/s+2*(.5-a)*h;this.instructions.push([Wl.DRAW_IMAGE,e,i,t,(l-this.textOffsetX_)*s,(c-this.textOffsetY_)*s,this.declutterGroup_,t.height,1,0,0,this.textRotateWithView_,this.textRotation_,1,!0,t.width,n.padding==ii?ii:n.padding.map(function(t){return t*s}),!!n.backgroundFill,!!n.backgroundStroke]),this.hitDetectionInstructions.push([Wl.DRAW_IMAGE,e,i,t,(l-this.textOffsetX_)*s,(c-this.textOffsetY_)*s,this.declutterGroup_,t.height,1,0,0,this.textRotateWithView_,this.textRotation_,1/s,!0,t.width,n.padding,!!n.backgroundFill,!!n.backgroundStroke])},oc.prototype.drawChars_=function(t,e,i){const n=this.textStrokeState_,o=this.textState_,s=this.textFillState_,r=this.strokeKey_;n&&(r in this.strokeStates||(this.strokeStates[r]={strokeStyle:n.strokeStyle,lineCap:n.lineCap,lineDashOffset:n.lineDashOffset,lineWidth:n.lineWidth,lineJoin:n.lineJoin,miterLimit:n.miterLimit,lineDash:n.lineDash}));const a=this.textKey_;this.textKey_ in this.textStates||(this.textStates[this.textKey_]={font:o.font,textAlign:o.textAlign||\"center\",scale:o.scale});const h=this.fillKey_;s&&(h in this.fillStates||(this.fillStates[h]={fillStyle:s.fillStyle}));const l=this.pixelRatio,c=Ul[o.textBaseline],u=this.textOffsetY_*l,p=this.text_,d=o.font,f=o.scale,g=n?n.lineWidth*f/2:0;let _=this.widths_[d];_||(this.widths_[d]=_={}),this.instructions.push([Wl.DRAW_CHARS,t,e,c,i,o.overflow,h,o.maxAngle,function(t){let e=_[t];return e||(e=_[t]=ci(d,t)),e*f*l},u,r,g*l,p,a,1]),this.hitDetectionInstructions.push([Wl.DRAW_CHARS,t,e,c,i,o.overflow,h,o.maxAngle,function(t){let e=_[t];return e||(e=_[t]=ci(d,t)),e*f},u,r,g,p,a,1/l])},oc.prototype.setTextStyle=function(t,e){let i,n,o;if(t){this.declutterGroup_=e;const s=t.getFill();s?((n=this.textFillState_)||(n=this.textFillState_={}),n.fillStyle=Oe(s.getColor()||$e)):n=this.textFillState_=null;const r=t.getStroke();if(r){(o=this.textStrokeState_)||(o=this.textStrokeState_={});const t=r.getLineDash(),e=r.getLineDashOffset(),i=r.getWidth(),n=r.getMiterLimit();o.lineCap=r.getLineCap()||\"round\",o.lineDash=t?t.slice():ti,o.lineDashOffset=void 0===e?0:e,o.lineJoin=r.getLineJoin()||\"round\",o.lineWidth=void 0===i?1:i,o.miterLimit=void 0===n?10:n,o.strokeStyle=Oe(r.getColor()||ei)}else o=this.textStrokeState_=null;i=this.textState_;const a=t.getFont()||\"10px sans-serif\";ai(a);const h=t.getScale();i.overflow=t.getOverflow(),i.font=a,i.maxAngle=t.getMaxAngle(),i.placement=t.getPlacement(),i.textAlign=t.getTextAlign(),i.textBaseline=t.getTextBaseline()||\"middle\",i.backgroundFill=t.getBackgroundFill(),i.backgroundStroke=t.getBackgroundStroke(),i.padding=t.getPadding()||ii,i.scale=void 0===h?1:h;const c=t.getOffsetX(),u=t.getOffsetY(),p=t.getRotateWithView(),d=t.getRotation();this.text_=t.getText()||\"\",this.textOffsetX_=void 0===c?0:c,this.textOffsetY_=void 0===u?0:u,this.textRotateWithView_=void 0!==p&&p,this.textRotation_=void 0===d?0:d,this.strokeKey_=o?(\"string\"==typeof o.strokeStyle?o.strokeStyle:l(o.strokeStyle))+o.lineCap+o.lineDashOffset+\"|\"+o.lineWidth+o.lineJoin+o.miterLimit+\"[\"+o.lineDash.join()+\"]\":\"\",this.textKey_=i.font+i.scale+(i.textAlign||\"?\"),this.fillKey_=n?\"string\"==typeof n.fillStyle?n.fillStyle:\"|\"+l(n.fillStyle):\"\"}else this.text_=\"\"};const sc={Circle:tc,Default:Vl,Image:ql,LineString:Ql,Polygon:tc,Text:oc},rc=function(t,e,i,n,o,s,r){kl.call(this),this.declutterTree_=s,this.declutterGroup_=null,this.tolerance_=t,this.maxExtent_=e,this.overlaps_=o,this.pixelRatio_=n,this.resolution_=i,this.renderBuffer_=r,this.replaysByZIndex_={},this.hitDetectionContext_=ke(1,1),this.hitDetectionTransform_=[1,0,0,1,0,0]};a(rc,kl);const ac={0:[[!0]]};function hc(t,e,i){let n;const o=Math.floor(t.length/2);if(e>=o)for(n=o;n<e;n++)t[n][i]=!0;else if(e<o)for(n=e+1;n<o;n++)t[n][i]=!0}rc.prototype.addDeclutter=function(t){let e=null;return this.declutterTree_&&(t?(e=this.declutterGroup_)[4]++:(e=this.declutterGroup_=[1/0,1/0,-1/0,-1/0]).push(1)),e},rc.prototype.clip=function(t,e){const i=this.getClipCoords(e);t.beginPath(),t.moveTo(i[0],i[1]),t.lineTo(i[2],i[3]),t.lineTo(i[4],i[5]),t.lineTo(i[6],i[7]),t.clip()},rc.prototype.hasReplays=function(t){for(const e in this.replaysByZIndex_){const i=this.replaysByZIndex_[e];for(let e=0,n=t.length;e<n;++e)if(t[e]in i)return!0}return!1},rc.prototype.finish=function(){for(const t in this.replaysByZIndex_){const e=this.replaysByZIndex_[t];for(const t in e)e[t].finish()}},rc.prototype.forEachFeatureAtCoordinate=function(t,e,i,n,o,s,r){const a=2*(n=Math.round(n))+1,h=Te(this.hitDetectionTransform_,n+.5,n+.5,1/e,-1/e,-i,-t[0],-t[1]),l=this.hitDetectionContext_;let c;l.canvas.width!==a||l.canvas.height!==a?(l.canvas.width=a,l.canvas.height=a):l.clearRect(0,0,a,a),void 0!==this.renderBuffer_&&(at(c=[1/0,1/0,-1/0,-1/0],t),H(c,e*(this.renderBuffer_+n),c));const u=function(t){if(void 0!==ac[t])return ac[t];const e=2*t+1,i=new Array(e);for(let t=0;t<e;t++)i[t]=new Array(e);let n=t,o=0,s=0;for(;n>=o;)hc(i,t+n,t+o),hc(i,t+o,t+n),hc(i,t-o,t+n),hc(i,t-n,t+o),hc(i,t-n,t-o),hc(i,t-o,t-n),hc(i,t+o,t-n),hc(i,t+n,t-o),2*((s+=1+2*++o)-n)+1>0&&(s+=1-2*(n-=1));return ac[t]=i,i}(n);let p,d;function f(t){const e=l.getImageData(0,0,a,a).data;for(let i=0;i<a;i++)for(let n=0;n<a;n++)if(u[i][n]&&e[4*(n*a+i)+3]>0){let e;return(!p||d!=Al.IMAGE&&d!=Al.TEXT||-1!==p.indexOf(t))&&(e=s(t)),e||void l.clearRect(0,0,a,a)}}this.declutterTree_&&(p=this.declutterTree_.all().map(function(t){return t.value}));const g=Object.keys(this.replaysByZIndex_).map(Number);let _,y,m,v,x;for(g.sort(Wi),_=g.length-1;_>=0;--_){const t=g[_].toString();for(m=this.replaysByZIndex_[t],y=Kl.length-1;y>=0;--y)if(void 0!==(v=m[d=Kl[y]]))if(!r||d!=Al.IMAGE&&d!=Al.TEXT){if(x=v.replayHitDetection(l,h,i,o,f,c))return x}else{const e=r[t];e?e.push(v,h.slice(0)):r[t]=[v,h.slice(0)]}}},rc.prototype.getClipCoords=function(t){const e=this.maxExtent_,i=e[0],n=e[1],o=e[2],s=e[3],r=[i,n,i,s,o,s,o,n];return wt(r,0,8,2,t,r),r},rc.prototype.getReplay=function(t,e){const i=void 0!==t?t.toString():\"0\";let n=this.replaysByZIndex_[i];void 0===n&&(n={},this.replaysByZIndex_[i]=n);let o=n[e];if(void 0===o){o=new(0,sc[e])(this.tolerance_,this.maxExtent_,this.resolution_,this.pixelRatio_,this.overlaps_,this.declutterTree_),n[e]=o}return o},rc.prototype.getReplays=function(){return this.replaysByZIndex_},rc.prototype.isEmpty=function(){return _(this.replaysByZIndex_)},rc.prototype.replay=function(t,e,i,n,o,s){const r=Object.keys(this.replaysByZIndex_).map(Number);r.sort(Wi),t.save(),this.clip(t,e);const a=o||Kl;let h,l,c,u,p,d;for(h=0,l=r.length;h<l;++h){const o=r[h].toString();for(p=this.replaysByZIndex_[o],c=0,u=a.length;c<u;++c){const r=a[c];if(void 0!==(d=p[r]))if(!s||r!=Al.IMAGE&&r!=Al.TEXT)d.replay(t,e,i,n);else{const t=s[o];t?t.push(d,e.slice(0)):s[o]=[d,e.slice(0)]}}}t.restore()};var lc=rc;const cc=.5,uc={Point:function(t,e,i,n){const o=i.getImage();if(o){if(o.getImageState()!=Ve.LOADED)return;const s=t.getReplay(i.getZIndex(),Al.IMAGE);s.setImageStyle(o,t.addDeclutter(!1)),s.drawPoint(e,n)}const s=i.getText();if(s){const r=t.getReplay(i.getZIndex(),Al.TEXT);r.setTextStyle(s,t.addDeclutter(!!o)),r.drawText(e,n)}},LineString:function(t,e,i,n){const o=i.getStroke();if(o){const s=t.getReplay(i.getZIndex(),Al.LINE_STRING);s.setFillStrokeStyle(null,o),s.drawLineString(e,n)}const s=i.getText();if(s){const o=t.getReplay(i.getZIndex(),Al.TEXT);o.setTextStyle(s,t.addDeclutter(!1)),o.drawText(e,n)}},Polygon:function(t,e,i,n){const o=i.getFill(),s=i.getStroke();if(o||s){const r=t.getReplay(i.getZIndex(),Al.POLYGON);r.setFillStrokeStyle(o,s),r.drawPolygon(e,n)}const r=i.getText();if(r){const o=t.getReplay(i.getZIndex(),Al.TEXT);o.setTextStyle(r,t.addDeclutter(!1)),o.drawText(e,n)}},MultiPoint:function(t,e,i,n){const o=i.getImage();if(o){if(o.getImageState()!=Ve.LOADED)return;const s=t.getReplay(i.getZIndex(),Al.IMAGE);s.setImageStyle(o,t.addDeclutter(!1)),s.drawMultiPoint(e,n)}const s=i.getText();if(s){const r=t.getReplay(i.getZIndex(),Al.TEXT);r.setTextStyle(s,t.addDeclutter(!!o)),r.drawText(e,n)}},MultiLineString:function(t,e,i,n){const o=i.getStroke();if(o){const s=t.getReplay(i.getZIndex(),Al.LINE_STRING);s.setFillStrokeStyle(null,o),s.drawMultiLineString(e,n)}const s=i.getText();if(s){const o=t.getReplay(i.getZIndex(),Al.TEXT);o.setTextStyle(s,t.addDeclutter(!1)),o.drawText(e,n)}},MultiPolygon:function(t,e,i,n){const o=i.getFill(),s=i.getStroke();if(s||o){const r=t.getReplay(i.getZIndex(),Al.POLYGON);r.setFillStrokeStyle(o,s),r.drawMultiPolygon(e,n)}const r=i.getText();if(r){const o=t.getReplay(i.getZIndex(),Al.TEXT);o.setTextStyle(r,t.addDeclutter(!1)),o.drawText(e,n)}},GeometryCollection:function(t,e,i,n){const o=e.getGeometriesArray();let s,r;for(s=0,r=o.length;s<r;++s){const e=uc[o[s].getType()];e(t,o[s],i,n)}},Circle:function(t,e,i,n){const o=i.getFill(),s=i.getStroke();if(o||s){const r=t.getReplay(i.getZIndex(),Al.CIRCLE);r.setFillStrokeStyle(o,s),r.drawCircle(e,n)}const r=i.getText();if(r){const o=t.getReplay(i.getZIndex(),Al.TEXT);o.setTextStyle(r,t.addDeclutter(!1)),o.drawText(e,n)}}};function pc(t,e){return l(t)-l(e)}function dc(t,e){const i=fc(t,e);return i*i}function fc(t,e){return cc*t/e}function gc(t,e,i,n,o,s){let r=!1;const a=i.getImage();if(a){let t=a.getImageState();t==Ve.LOADED||t==Ve.ERROR?a.unlistenImageChange(o,s):(t==Ve.IDLE&&a.load(),t=a.getImageState(),a.listenImageChange(o,s),r=!0)}return function(t,e,i,n){const o=i.getGeometryFunction()(e);if(!o)return;const s=o.getSimplifiedGeometry(n);if(i.getRenderer())!function t(e,i,n,o){if(i.getType()==Ot.GEOMETRY_COLLECTION){const s=i.getGeometries();for(let i=0,r=s.length;i<r;++i)t(e,s[i],n,o);return}const s=e.getReplay(n.getZIndex(),Al.DEFAULT);s.drawCustom(i,o,n.getRenderer())}(t,s,i,e);else{const n=uc[s.getType()];n(t,s,i,e)}}(t,e,i,n),r}const _c=function(t){Tl.call(this,t),this.declutterTree_=t.getDeclutter()?sh()(9,void 0):null,this.dirty_=!1,this.renderedRevision_=-1,this.renderedResolution_=NaN,this.renderedExtent_=[1/0,1/0,-1/0,-1/0],this.renderedRenderOrder_=null,this.replayGroup_=null,this.replayGroupChanged=!0,this.context=ke(),C(ni,w.CLEAR,this.handleFontsChanged_,this)};a(_c,Tl),_c.handles=function(t){return t.getType()===Ua},_c.create=function(t,e){return new _c(e)},_c.prototype.disposeInternal=function(){T(ni,w.CLEAR,this.handleFontsChanged_,this),Tl.prototype.disposeInternal.call(this)},_c.prototype.compose=function(t,e,i){const n=e.extent,o=e.pixelRatio,s=i.managed?e.skippedFeatureUids:{},r=e.viewState,a=r.projection,h=r.rotation,l=a.getExtent(),c=this.getLayer().getSource();let u=this.getTransform(e,0);const p=i.extent,d=void 0!==p;d&&this.clip(t,e,p);const f=this.replayGroup_;if(f&&!f.isEmpty()){this.declutterTree_&&this.declutterTree_.clear();const r=this.getLayer();let p,d=0,g=0;const _=1!==i.opacity,y=r.hasListener(Js);if(_||y){let e=t.canvas.width,i=t.canvas.height;if(h){const t=Math.round(Math.sqrt(e*e+i*i));d=(t-e)/2,g=(t-i)/2,e=i=t}this.context.canvas.width=e,this.context.canvas.height=i,p=this.context}else p=t;const m=p.globalAlpha;_||(p.globalAlpha=i.opacity),p!=t&&p.translate(d,g);const v=e.size[0]*o,x=e.size[1]*o;if(ui(p,-h,v/2,x/2),f.replay(p,u,h,s),c.getWrapX()&&a.canWrapX()&&!J(l,n)){let t=n[0];const i=Ct(l);let o,r=0;for(;t<l[0];)o=i*--r,u=this.getTransform(e,o),f.replay(p,u,h,s),t+=i;for(r=0,t=n[2];t>l[2];)o=i*++r,u=this.getTransform(e,o),f.replay(p,u,h,s),t-=i}if(ui(p,h,v/2,x/2),p!=t){if(y&&this.dispatchRenderEvent(p,e,u),_){const e=t.globalAlpha;t.globalAlpha=i.opacity,t.drawImage(p.canvas,-d,-g),t.globalAlpha=e}else t.drawImage(p.canvas,-d,-g);p.translate(-d,-g)}_||(p.globalAlpha=m)}d&&t.restore()},_c.prototype.composeFrame=function(t,e,i){const n=this.getTransform(t,0);this.preCompose(i,t,n),this.compose(i,t,e),this.postCompose(i,t,e,n)},_c.prototype.forEachFeatureAtCoordinate=function(t,e,i,n,o){if(this.replayGroup_){const s=e.viewState.resolution,r=e.viewState.rotation,a=this.getLayer(),h={};return this.replayGroup_.forEachFeatureAtCoordinate(t,s,r,i,{},function(t){const e=l(t).toString();if(!(e in h))return h[e]=!0,n.call(o,t,a)},null)}},_c.prototype.handleFontsChanged_=function(t){const e=this.getLayer();e.getVisible()&&this.replayGroup_&&e.changed()},_c.prototype.handleStyleImageChange_=function(t){this.renderIfReadyAndVisible()},_c.prototype.prepareFrame=function(t,e){const i=this.getLayer(),n=i.getSource(),o=t.viewHints[cs.ANIMATING],s=t.viewHints[cs.INTERACTING],r=i.getUpdateWhileAnimating(),a=i.getUpdateWhileInteracting();if(!this.dirty_&&!r&&o||!a&&s)return!0;const h=t.extent,l=t.viewState,c=l.projection,u=l.resolution,p=t.pixelRatio,d=i.getRevision(),f=i.getRenderBuffer();let g=i.getRenderOrder();void 0===g&&(g=pc);const _=H(h,f*u),y=l.projection.getExtent();if(n.getWrapX()&&l.projection.canWrapX()&&!J(y,t.extent)){const t=Ct(y),e=Math.max(Ct(_)/2,t);_[0]=y[0]-e,_[2]=y[2]+e}if(!this.dirty_&&this.renderedResolution_==u&&this.renderedRevision_==d&&this.renderedRenderOrder_==g&&J(this.renderedExtent_,_))return this.replayGroupChanged=!1,!0;this.replayGroup_=null,this.dirty_=!1;const m=new lc(fc(u,p),_,u,p,n.getOverlaps(),this.declutterTree_,i.getRenderBuffer());n.loadFeatures(_,u,c);const v=function(t){let e;const n=t.getStyleFunction()||i.getStyleFunction();if(n&&(e=n(t,u)),e){const i=this.renderFeature(t,u,p,e,m);this.dirty_=this.dirty_||i}}.bind(this);if(g){const t=[];n.forEachFeatureInExtent(_,function(e){t.push(e)},this),t.sort(g);for(let e=0,i=t.length;e<i;++e)v(t[e])}else n.forEachFeatureInExtent(_,v,this);return m.finish(),this.renderedResolution_=u,this.renderedRevision_=d,this.renderedRenderOrder_=g,this.renderedExtent_=_,this.replayGroup_=m,this.replayGroupChanged=!0,!0},_c.prototype.renderFeature=function(t,e,i,n,o){if(!n)return!1;let s=!1;if(Array.isArray(n))for(let r=0,a=n.length;r<a;++r)s=gc(o,t,n[r],dc(e,i),this.handleStyleImageChange_,this)||s;else s=gc(o,t,n,dc(e,i),this.handleStyleImageChange_,this);return s};var yc=_c,mc=\"vector\";const vc={image:[Al.POLYGON,Al.CIRCLE,Al.LINE_STRING,Al.IMAGE,Al.TEXT],hybrid:[Al.POLYGON,Al.LINE_STRING]},xc={image:[Al.DEFAULT],hybrid:[Al.IMAGE,Al.TEXT,Al.DEFAULT],vector:Kl},Cc=function(t){this.context=null,bl.call(this,t),this.declutterTree_=t.getDeclutter()?sh()(9,void 0):null,this.dirty_=!1,this.renderedLayerRevision_,this.tmpTransform_=[1,0,0,1,0,0],this.zDirection=t.getRenderMode()==mc?1:0,C(ni,w.CLEAR,this.handleFontsChanged_,this)};a(Cc,bl),Cc.handles=function(t){return t.getType()===Ka},Cc.create=function(t,e){return new Cc(e)},Cc.prototype.disposeInternal=function(){T(ni,w.CLEAR,this.handleFontsChanged_,this),bl.prototype.disposeInternal.call(this)},Cc.prototype.getTile=function(t,e,i,n,o){const s=bl.prototype.getTile.call(this,t,e,i,n,o);return s.getState()===Jo&&(this.createReplayGroup_(s,n,o),this.context&&this.renderTileImage_(s,n,o)),s},Cc.prototype.prepareFrame=function(t,e){const i=this.getLayer(),n=i.getRevision();if(this.renderedLayerRevision_!=n){this.renderedTiles.length=0;const t=i.getRenderMode();this.context||t==mc||(this.context=ke()),this.context&&t==mc&&(this.context=null)}return this.renderedLayerRevision_=n,bl.prototype.prepareFrame.apply(this,arguments)},Cc.prototype.createReplayGroup_=function(t,e,i){const n=this.getLayer(),o=n.getRevision(),s=n.getRenderOrder()||null,r=t.getReplayState(n);if(!r.dirty&&r.renderedRevision==o&&r.renderedRenderOrder==s)return;const a=n.getSource(),h=a.getTileGrid(),l=a.getTileGridForProjection(i).getResolution(t.tileCoord[0]),c=t.extent,u={};for(let o=0,p=t.tileKeys.length;o<p;++o){const p=t.getTile(t.tileKeys[o]);if(p.getState()!=Jo)continue;const d=p.tileCoord,f=h.getTileCoordExtent(d),g=mt(c,f),_=st(f,g)?null:H(g,n.getRenderBuffer()*l,this.tmpExtent),y=p.getProjection();let m=!1;le(i,y)||(m=!0,p.setProjection(i)),r.dirty=!1;const v=new lc(0,g,l,e,a.getOverlaps(),this.declutterTree_,n.getRenderBuffer()),x=dc(l,e),C=function(t){let e;const i=t.getStyleFunction()||n.getStyleFunction();if(i&&(e=i(t,l)),e){const i=this.renderFeature(t,x,e,v);this.dirty_=this.dirty_||i,r.dirty=r.dirty||i}},E=p.getFeatures();s&&s!==r.renderedRenderOrder&&E.sort(s);for(let t=0,e=E.length;t<e;++t){const e=E[t];m&&(y.getUnits()==Nt.TILE_PIXELS&&(y.setWorldExtent(f),y.setExtent(p.getExtent())),e.getGeometry().transform(y,i)),_&&!Et(_,e.getGeometry().getExtent())||C.call(this,e)}v.finish();for(const t in v.getReplays())u[t]=!0;p.setReplayGroup(n,t.tileCoord.toString(),v)}r.renderedRevision=o,r.renderedRenderOrder=s},Cc.prototype.forEachFeatureAtCoordinate=function(t,e,i,n,o){const s=e.viewState.resolution,r=e.viewState.rotation;i=void 0==i?0:i;const a=this.getLayer(),h={},c=this.renderedTiles;let u,p,d,f,g;for(d=0,f=c.length;d<f;++d){const e=c[d];if(q(u=H(e.extent,i*s,u),t))for(let c=0,u=e.tileKeys.length;c<u;++c){const u=e.getTile(e.tileKeys[c]);u.getState()==Jo&&(g=u.getReplayGroup(a,e.tileCoord.toString()),p=p||g.forEachFeatureAtCoordinate(t,s,r,i,{},function(t){const e=l(t).toString();if(!(e in h))return h[e]=!0,n.call(o,t,a)},null))}}return p},Cc.prototype.getReplayTransform_=function(t,e){const i=this.getLayer().getSource().getTileGrid(),n=t.tileCoord,o=i.getResolution(n[0]),s=e.viewState,r=e.pixelRatio,a=s.resolution/r,h=i.getTileCoordExtent(n,this.tmpExtent),l=s.center,c=vt(h),u=e.size,p=Math.round(r*u[0]/2),d=Math.round(r*u[1]/2);return Te(this.tmpTransform_,p,d,o/a,o/a,s.rotation,(c[0]-l[0])/o,(l[1]-c[1])/o)},Cc.prototype.handleFontsChanged_=function(t){const e=this.getLayer();e.getVisible()&&void 0!==this.renderedLayerRevision_&&e.changed()},Cc.prototype.handleStyleImageChange_=function(t){this.renderIfReadyAndVisible()},Cc.prototype.postCompose=function(t,e,i){const n=this.getLayer(),o=n.getDeclutter()?{}:null,s=n.getSource(),r=n.getRenderMode(),a=xc[r],h=e.pixelRatio,l=e.viewState.rotation,c=e.size;let u,p;l&&ui(t,-l,u=Math.round(h*c[0]/2),p=Math.round(h*c[1]/2)),o&&this.declutterTree_.clear();const d=this.renderedTiles,f=s.getTileGridForProjection(e.viewState.projection),g=[],_=[];for(let s=d.length-1;s>=0;--s){const h=d[s];if(h.getState()==ts)continue;const c=h.tileCoord,u=f.getTileCoordExtent(c,this.tmpExtent)[0]-h.extent[0];let p=void 0;for(let s=0,d=h.tileKeys.length;s<d;++s){const d=h.getTile(h.tileKeys[s]);if(d.getState()!=Jo)continue;const f=d.getReplayGroup(n,c.toString());if(r!=mc&&!f.hasReplays(a))continue;p||(p=this.getTransform(e,u));const y=d.tileCoord[0],m=f.getClipCoords(p);t.save(),t.globalAlpha=i.opacity;for(let e=0,i=g.length;e<i;++e){const i=g[e];y<_[e]&&(t.beginPath(),t.moveTo(m[0],m[1]),t.lineTo(m[2],m[3]),t.lineTo(m[4],m[5]),t.lineTo(m[6],m[7]),t.moveTo(i[6],i[7]),t.lineTo(i[4],i[5]),t.lineTo(i[2],i[3]),t.lineTo(i[0],i[1]),t.clip())}f.replay(t,p,l,{},a,o),t.restore(),g.push(m),_.push(y)}}o&&function(t,e,i){const n=Object.keys(t).map(Number).sort(Wi),o={};for(let s=0,r=n.length;s<r;++s){const r=t[n[s].toString()];for(let t=0,n=r.length;t<n;){const n=r[t++],s=r[t++];n.replay(e,s,i,o)}}}(o,t,l),l&&ui(t,l,u,p),bl.prototype.postCompose.apply(this,arguments)},Cc.prototype.renderFeature=function(t,e,i,n){if(!i)return!1;let o=!1;if(Array.isArray(i))for(let s=0,r=i.length;s<r;++s)o=gc(n,t,i[s],e,this.handleStyleImageChange_,this)||o;else o=gc(n,t,i,e,this.handleStyleImageChange_,this);return o},Cc.prototype.renderTileImage_=function(t,e,i){const n=this.getLayer(),o=t.getReplayState(n),s=n.getRevision(),r=vc[n.getRenderMode()];if(r&&o.renderedTileRevision!==s){o.renderedTileRevision=s;const a=t.wrappedTileCoord,h=a[0],l=n.getSource(),c=l.getTileGridForProjection(i),u=c.getResolution(h),p=t.getContext(n),d=l.getTilePixelSize(h,e,i);p.canvas.width=d[0],p.canvas.height=d[1];const f=c.getTileCoordExtent(a,this.tmpExtent);for(let i=0,o=t.tileKeys.length;i<o;++i){const o=t.getTile(t.tileKeys[i]);if(o.getState()!=Jo)continue;const s=e/u,a=me(this.tmpTransform_,1,0,0,1,0,0);Ce(a,s,-s),Ee(a,-f[0],-f[3]),o.getReplayGroup(n,t.tileCoord.toString()).replay(p,a,0,{},r)}}};var Ec=Cc;const Tc=function(t){(t=d({},t)).controls||(t.controls=function(t){const e=t||{},i=new ro;return(void 0===e.zoom||e.zoom)&&i.push(new hr(e.zoomOptions)),(void 0===e.rotate||e.rotate)&&i.push(new rr(e.rotateOptions)),(void 0===e.attribution||e.attribution)&&i.push(new nr(e.attributionOptions)),i}()),t.interactions||(t.interactions=function(t){const e=t||{},i=new ro,n=new cr(-.005,.05,100);return(void 0===e.altShiftDragRotate||e.altShiftDragRotate)&&i.push(new qr),(void 0===e.doubleClickZoom||e.doubleClickZoom)&&i.push(new Cr({delta:e.zoomDelta,duration:e.zoomDuration})),(void 0===e.dragPan||e.dragPan)&&i.push(new Br({kinetic:n})),(void 0===e.pinchRotate||e.pinchRotate)&&i.push(new Sa),(void 0===e.pinchZoom||e.pinchZoom)&&i.push(new Pa({constrainResolution:e.constrainResolution,duration:e.zoomDuration})),(void 0===e.keyboard||e.keyboard)&&(i.push(new pa),i.push(new ga({delta:e.zoomDelta,duration:e.zoomDuration}))),(void 0===e.mouseWheelZoom||e.mouseWheelZoom)&&i.push(new va({constrainResolution:e.constrainResolution,duration:e.zoomDuration})),(void 0===e.shiftDragZoom||e.shiftDragZoom)&&i.push(new ha({duration:e.zoomDuration})),i}()),js.call(this,t)};a(Tc,js),Tc.prototype.createRenderer=function(){const t=new vl(this);return t.registerLayerRenderers([Il,bl,yc,Ec]),t};var Sc=Tc,wc=\"preload\",Rc=\"useInterimTilesOnError\";const Ic=function(t){const e=t||{},i=d({},e);delete i.preload,delete i.useInterimTilesOnError,tr.call(this,i),this.setPreload(void 0!==e.preload?e.preload:0),this.setUseInterimTilesOnError(void 0===e.useInterimTilesOnError||e.useInterimTilesOnError),this.type=Wa};a(Ic,tr),Ic.prototype.getPreload=function(){return this.get(wc)},Ic.prototype.getSource,Ic.prototype.setPreload=function(t){this.set(wc,t)},Ic.prototype.getUseInterimTilesOnError=function(){return this.get(Rc)},Ic.prototype.setUseInterimTilesOnError=function(t){this.set(Rc,t)};var Fc=Ic;const Pc=function(t,e,i){G.call(this);const n=i||{};this.tileCoord=t,this.state=e,this.interimTile=null,this.key=\"\",this.transition_=void 0===n.transition?250:n.transition,this.transitionStarts_={}};a(Pc,G),Pc.prototype.changed=function(){this.dispatchEvent(w.CHANGE)},Pc.prototype.getKey=function(){return this.key+\"/\"+this.tileCoord},Pc.prototype.getInterimTile=function(){if(!this.interimTile)return this;let t=this.interimTile;do{if(t.getState()==Jo)return t;t=t.interimTile}while(t);return this},Pc.prototype.refreshInterimChain=function(){if(!this.interimTile)return;let t=this.interimTile,e=this;do{if(t.getState()==Jo){t.interimTile=null;break}t.getState()==qo?e=t:t.getState()==Zo?e.interimTile=t.interimTile:e=t,t=e.interimTile}while(t)},Pc.prototype.getTileCoord=function(){return this.tileCoord},Pc.prototype.getState=function(){return this.state},Pc.prototype.setState=function(t){this.state=t,this.changed()},Pc.prototype.load=function(){},Pc.prototype.getAlpha=function(t,e){if(!this.transition_)return 1;let i=this.transitionStarts_[t];if(i){if(-1===i)return 1}else i=e,this.transitionStarts_[t]=i;const n=e-i+1e3/60;return n>=this.transition_?1:Es(n/this.transition_)},Pc.prototype.inTransition=function(t){return!!this.transition_&&-1!==this.transitionStarts_[t]},Pc.prototype.endTransition=function(t){this.transition_&&(this.transitionStarts_[t]=-1)};var Lc=Pc;const Mc=function(t,e,i,n,o,s){Lc.call(this,t,e,s),this.crossOrigin_=n,this.src_=i,this.image_=new Image,null!==n&&(this.image_.crossOrigin=n),this.imageListenerKeys_=null,this.tileLoadFunction_=o};function bc(){const t=ke(1,1);return t.fillStyle=\"rgba(0,0,0,0)\",t.fillRect(0,0,1,1),t.canvas}a(Mc,Lc),Mc.prototype.disposeInternal=function(){this.state==qo&&(this.unlistenImage_(),this.image_=bc()),this.interimTile&&this.interimTile.dispose(),this.state=ts,this.changed(),Lc.prototype.disposeInternal.call(this)},Mc.prototype.getImage=function(){return this.image_},Mc.prototype.getKey=function(){return this.src_},Mc.prototype.handleImageError_=function(){this.state=Qo,this.unlistenImage_(),this.image_=bc(),this.changed()},Mc.prototype.handleImageLoad_=function(){this.image_.naturalWidth&&this.image_.naturalHeight?this.state=Jo:this.state=$o,this.unlistenImage_(),this.changed()},Mc.prototype.load=function(){this.state==Qo&&(this.state=Zo,this.image_=new Image,null!==this.crossOrigin_&&(this.image_.crossOrigin=this.crossOrigin_)),this.state==Zo&&(this.state=qo,this.changed(),this.imageListenerKeys_=[E(this.image_,w.ERROR,this.handleImageError_,this),E(this.image_,w.LOAD,this.handleImageLoad_,this)],this.tileLoadFunction_(this,this.src_))},Mc.prototype.unlistenImage_=function(){this.imageListenerKeys_.forEach(S),this.imageListenerKeys_=null};var Oc=Mc;function kc(t,e,i,n){return void 0!==n?(n[0]=t,n[1]=e,n[2]=i,n):[t,e,i]}function Ac(t,e,i){return t+\"/\"+e+\"/\"+i}function Gc(t){return Ac(t[0],t[1],t[2])}const Dc=function(t){Qe.call(this,t)};a(Dc,Qe),Dc.prototype.expireCache=function(t){for(;this.canExpireCache();){const e=this.peekLast(),i=e.tileCoord[0].toString();if(i in t&&t[i].contains(e.tileCoord))break;this.pop().dispose()}},Dc.prototype.pruneExceptNewestZ=function(){if(0===this.getCount())return;const t=function(t){return t.split(\"/\").map(Number)}(this.peekFirstKey())[0];this.forEach(function(e){e.tileCoord[0]!==t&&(this.remove(Gc(e.tileCoord)),e.dispose())},this)};var Nc=Dc;function Yc(t,e,i,n){const o=i-t,s=n-e,r=Math.sqrt(o*o+s*s);return[Math.round(i+o/r),Math.round(n+s/r)]}function Xc(t,e,i,n,o,s,r,a,h,l,c){const u=ke(Math.round(i*t),Math.round(i*e));if(0===h.length)return u.canvas;u.scale(i,i);const p=[1/0,1/0,-1/0,-1/0];h.forEach(function(t,e,i){rt(p,t.extent)});const d=Ct(p),f=yt(p),g=ke(Math.round(i*d/n),Math.round(i*f/n)),_=i/n;h.forEach(function(t,e,i){const n=t.extent[0]-p[0],o=-(t.extent[3]-p[3]),s=Ct(t.extent),r=yt(t.extent);g.drawImage(t.image,l,l,t.image.width-2*l,t.image.height-2*l,n*_,o*_,s*_,r*_)});const y=vt(r);return a.getTriangles().forEach(function(t,e,o){const r=t.source,a=t.target;let h=r[0][0],l=r[0][1],c=r[1][0],d=r[1][1],f=r[2][0],_=r[2][1];const m=(a[0][0]-y[0])/s,v=-(a[0][1]-y[1])/s,x=(a[1][0]-y[0])/s,C=-(a[1][1]-y[1])/s,E=(a[2][0]-y[0])/s,T=-(a[2][1]-y[1])/s,S=h,w=l;h=0,l=0;const R=function(t){const e=t.length;for(let i=0;i<e;i++){let n=i,o=Math.abs(t[i][i]);for(let s=i+1;s<e;s++){const e=Math.abs(t[s][i]);e>o&&(o=e,n=s)}if(0===o)return null;const s=t[n];t[n]=t[i],t[i]=s;for(let n=i+1;n<e;n++){const o=-t[n][i]/t[i][i];for(let s=i;s<e+1;s++)i==s?t[n][s]=0:t[n][s]+=o*t[i][s]}}const i=new Array(e);for(let n=e-1;n>=0;n--){i[n]=t[n][e]/t[n][n];for(let o=n-1;o>=0;o--)t[o][e]-=t[o][n]*i[n]}return i}([[c-=S,d-=w,0,0,x-m],[f-=S,_-=w,0,0,E-m],[0,0,c,d,C-v],[0,0,f,_,T-v]]);if(!R)return;u.save(),u.beginPath();const I=(m+x+E)/3,F=(v+C+T)/3,P=Yc(I,F,m,v),L=Yc(I,F,x,C),M=Yc(I,F,E,T);u.moveTo(L[0],L[1]),u.lineTo(P[0],P[1]),u.lineTo(M[0],M[1]),u.clip(),u.transform(R[0],R[2],R[1],R[3],m,v),u.translate(p[0]-S,p[3]-w),u.scale(n/i,-n/i),u.drawImage(g.canvas,0,0),u.restore()}),c&&(u.save(),u.strokeStyle=\"black\",u.lineWidth=1,a.getTriangles().forEach(function(t,e,i){const n=t.target,o=(n[0][0]-y[0])/s,r=-(n[0][1]-y[1])/s,a=(n[1][0]-y[0])/s,h=-(n[1][1]-y[1])/s,l=(n[2][0]-y[0])/s,c=-(n[2][1]-y[1])/s;u.beginPath(),u.moveTo(a,h),u.lineTo(o,r),u.lineTo(l,c),u.closePath(),u.stroke()}),u.restore()),u.canvas}const zc=function(t,e,i,n,o){this.sourceProj_=t,this.targetProj_=e;let s={};const r=ue(this.targetProj_,this.sourceProj_);this.transformInv_=function(t){const e=t[0]+\"/\"+t[1];return s[e]||(s[e]=r(t)),s[e]},this.maxSourceExtent_=n,this.errorThresholdSquared_=o*o,this.triangles_=[],this.wrapsXInSource_=!1,this.canWrapXInSource_=this.sourceProj_.canWrapX()&&!!n&&!!this.sourceProj_.getExtent()&&Ct(n)==Ct(this.sourceProj_.getExtent()),this.sourceWorldWidth_=this.sourceProj_.getExtent()?Ct(this.sourceProj_.getExtent()):null,this.targetWorldWidth_=this.targetProj_.getExtent()?Ct(this.targetProj_.getExtent()):null;const a=vt(i),h=xt(i),l=ft(i),c=dt(i),u=this.transformInv_(a),p=this.transformInv_(h),d=this.transformInv_(l),f=this.transformInv_(c);if(this.addQuad_(a,h,l,c,u,p,d,f,10),this.wrapsXInSource_){let t=1/0;this.triangles_.forEach(function(e,i,n){t=Math.min(t,e.source[0][0],e.source[1][0],e.source[2][0])}),this.triangles_.forEach(function(e){if(Math.max(e.source[0][0],e.source[1][0],e.source[2][0])-t>this.sourceWorldWidth_/2){const i=[[e.source[0][0],e.source[0][1]],[e.source[1][0],e.source[1][1]],[e.source[2][0],e.source[2][1]]];i[0][0]-t>this.sourceWorldWidth_/2&&(i[0][0]-=this.sourceWorldWidth_),i[1][0]-t>this.sourceWorldWidth_/2&&(i[1][0]-=this.sourceWorldWidth_),i[2][0]-t>this.sourceWorldWidth_/2&&(i[2][0]-=this.sourceWorldWidth_);const n=Math.min(i[0][0],i[1][0],i[2][0]);Math.max(i[0][0],i[1][0],i[2][0])-n<this.sourceWorldWidth_/2&&(e.source=i)}}.bind(this))}s={}};zc.prototype.addTriangle_=function(t,e,i,n,o,s){this.triangles_.push({source:[n,o,s],target:[t,e,i]})},zc.prototype.addQuad_=function(t,e,i,n,o,s,r,a,h){const l=j([o,s,r,a]),c=this.sourceWorldWidth_?Ct(l)/this.sourceWorldWidth_:null,u=this.sourceWorldWidth_,p=this.sourceProj_.canWrapX()&&c>.5&&c<1;let d=!1;if(h>0){if(this.targetProj_.isGlobal()&&this.targetWorldWidth_){d|=Ct(j([t,e,i,n]))/this.targetWorldWidth_>.25}!p&&this.sourceProj_.isGlobal()&&c&&(d|=c>.25)}if(d||!this.maxSourceExtent_||Et(l,this.maxSourceExtent_)){if(!(d||isFinite(o[0])&&isFinite(o[1])&&isFinite(s[0])&&isFinite(s[1])&&isFinite(r[0])&&isFinite(r[1])&&isFinite(a[0])&&isFinite(a[1]))){if(!(h>0))return;d=!0}if(h>0){if(!d){const e=[(t[0]+i[0])/2,(t[1]+i[1])/2],n=this.transformInv_(e);let s;if(p){s=(Mt(o[0],u)+Mt(r[0],u))/2-Mt(n[0],u)}else s=(o[0]+r[0])/2-n[0];const a=(o[1]+r[1])/2-n[1];d=s*s+a*a>this.errorThresholdSquared_}if(d){if(Math.abs(t[0]-i[0])<=Math.abs(t[1]-i[1])){const l=[(e[0]+i[0])/2,(e[1]+i[1])/2],c=this.transformInv_(l),u=[(n[0]+t[0])/2,(n[1]+t[1])/2],p=this.transformInv_(u);this.addQuad_(t,e,l,u,o,s,c,p,h-1),this.addQuad_(u,l,i,n,p,c,r,a,h-1)}else{const l=[(t[0]+e[0])/2,(t[1]+e[1])/2],c=this.transformInv_(l),u=[(i[0]+n[0])/2,(i[1]+n[1])/2],p=this.transformInv_(u);this.addQuad_(t,l,u,n,o,c,p,a,h-1),this.addQuad_(l,e,i,u,c,s,r,p,h-1)}return}}if(p){if(!this.canWrapXInSource_)return;this.wrapsXInSource_=!0}this.addTriangle_(t,i,n,o,r,a),this.addTriangle_(t,e,i,o,s,r)}},zc.prototype.calculateSourceExtent=function(){const t=[1/0,1/0,-1/0,-1/0];return this.triangles_.forEach(function(e,i,n){const o=e.source;at(t,o[0]),at(t,o[1]),at(t,o[2])}),t},zc.prototype.getTriangles=function(){return this.triangles_};var Wc=zc;const Kc=function(t,e,i,n,o,s,r,a,h,l,c){Lc.call(this,o,Zo),this.renderEdges_=void 0!==c&&c,this.pixelRatio_=r,this.gutter_=a,this.canvas_=null,this.sourceTileGrid_=e,this.targetTileGrid_=n,this.wrappedTileCoord_=s||o,this.sourceTiles_=[],this.sourcesListenerKeys_=null,this.sourceZ_=0;const u=n.getTileCoordExtent(this.wrappedTileCoord_),p=this.targetTileGrid_.getExtent();let d=this.sourceTileGrid_.getExtent();const f=p?mt(u,p):u;if(0===pt(f))return void(this.state=$o);const g=t.getExtent();g&&(d=d?mt(d,g):g);const _=n.getResolution(this.wrappedTileCoord_[0]),y=function(t,e,i,n){const o=pe(i,e,t);let s=re(e,n,i);const r=e.getMetersPerUnit();void 0!==r&&(s*=r);const a=t.getMetersPerUnit();void 0!==a&&(s/=a);const h=t.getExtent();if(!h||q(h,o)){const e=re(t,s,o)/s;isFinite(e)&&e>0&&(s/=e)}return s}(t,i,gt(f),_);if(!isFinite(y)||y<=0)return void(this.state=$o);const m=void 0!==l?l:.5;if(this.triangulation_=new Wc(t,i,f,d,y*m),0===this.triangulation_.getTriangles().length)return void(this.state=$o);this.sourceZ_=e.getZForResolution(y);let v=this.triangulation_.calculateSourceExtent();if(d&&(t.canWrapX()?(v[1]=Rt(v[1],d[1],d[3]),v[3]=Rt(v[3],d[1],d[3])):v=mt(v,d)),pt(v)){const t=e.getTileRangeForExtentAndZ(v,this.sourceZ_);for(let e=t.minX;e<=t.maxX;e++)for(let i=t.minY;i<=t.maxY;i++){const t=h(this.sourceZ_,e,i,r);t&&this.sourceTiles_.push(t)}0===this.sourceTiles_.length&&(this.state=$o)}else this.state=$o};a(Kc,Lc),Kc.prototype.disposeInternal=function(){this.state==qo&&this.unlistenSources_(),Lc.prototype.disposeInternal.call(this)},Kc.prototype.getImage=function(){return this.canvas_},Kc.prototype.reproject_=function(){const t=[];if(this.sourceTiles_.forEach(function(e,i,n){e&&e.getState()==Jo&&t.push({extent:this.sourceTileGrid_.getTileCoordExtent(e.tileCoord),image:e.getImage()})}.bind(this)),this.sourceTiles_.length=0,0===t.length)this.state=Qo;else{const e=this.wrappedTileCoord_[0],i=this.targetTileGrid_.getTileSize(e),n=\"number\"==typeof i?i:i[0],o=\"number\"==typeof i?i:i[1],s=this.targetTileGrid_.getResolution(e),r=this.sourceTileGrid_.getResolution(this.sourceZ_),a=this.targetTileGrid_.getTileCoordExtent(this.wrappedTileCoord_);this.canvas_=Xc(n,o,this.pixelRatio_,r,this.sourceTileGrid_.getExtent(),s,a,this.triangulation_,t,this.gutter_,this.renderEdges_),this.state=Jo}this.changed()},Kc.prototype.load=function(){if(this.state==Zo){this.state=qo,this.changed();let t=0;this.sourcesListenerKeys_=[],this.sourceTiles_.forEach(function(e,i,n){const o=e.getState();if(o==Zo||o==qo){t++;const i=C(e,w.CHANGE,function(n){const o=e.getState();o!=Jo&&o!=Qo&&o!=$o||(S(i),0===--t&&(this.unlistenSources_(),this.reproject_()))},this);this.sourcesListenerKeys_.push(i)}}.bind(this)),this.sourceTiles_.forEach(function(t,e,i){t.getState()==Zo&&t.load()}),0===t&&setTimeout(this.reproject_.bind(this),0)}},Kc.prototype.unlistenSources_=function(){this.sourcesListenerKeys_.forEach(S),this.sourcesListenerKeys_=null};var Uc=Kc;function Bc(t,e){const i=/\\{z\\}/g,n=/\\{x\\}/g,o=/\\{y\\}/g,s=/\\{-y\\}/g;return function(r,a,h){return r?t.replace(i,r[0].toString()).replace(n,r[1].toString()).replace(o,function(){return(-r[2]-1).toString()}).replace(s,function(){const t=r[0],i=e.getFullTileRange(t);return p(i,55),(i.getHeight()+r[2]).toString()}):void 0}}function jc(t,e){const i=t.length,n=new Array(i);for(let o=0;o<i;++o)n[o]=Bc(t[o],e);return function(t){if(1===t.length)return t[0];return function(e,i,n){if(e){const o=function(t){return(t[1]<<t[0])+t[2]}(e),s=Mt(o,t.length);return t[s](e,i,n)}}}(n)}function Hc(t,e,i){}const Vc=function(t){let e;if(this.minZoom=void 0!==t.minZoom?t.minZoom:0,this.resolutions_=t.resolutions,p(function(t,e,i){const n=e||Wi;return t.every(function(e,o){if(0===o)return!0;const s=n(t[o-1],e);return!(s>0||i&&0===s)})}(this.resolutions_,function(t,e){return e-t},!0),17),!t.origins)for(let t=0,i=this.resolutions_.length-1;t<i;++t)if(e){if(this.resolutions_[t]/this.resolutions_[t+1]!==e){e=void 0;break}}else e=this.resolutions_[t]/this.resolutions_[t+1];this.zoomFactor_=e,this.maxZoom=this.resolutions_.length-1,this.origin_=void 0!==t.origin?t.origin:null,this.origins_=null,void 0!==t.origins&&(this.origins_=t.origins,p(this.origins_.length==this.resolutions_.length,20));const i=t.extent;void 0===i||this.origin_||this.origins_||(this.origin_=vt(i)),p(!this.origin_&&this.origins_||this.origin_&&!this.origins_,18),this.tileSizes_=null,void 0!==t.tileSizes&&(this.tileSizes_=t.tileSizes,p(this.tileSizes_.length==this.resolutions_.length,19)),this.tileSize_=void 0!==t.tileSize?t.tileSize:this.tileSizes_?null:rs,p(!this.tileSize_&&this.tileSizes_||this.tileSize_&&!this.tileSizes_,22),this.extent_=void 0!==i?i:null,this.fullTileRanges_=null,this.tmpSize_=[0,0],void 0!==t.sizes?this.fullTileRanges_=t.sizes.map(function(t,e){return new Ll(Math.min(0,t[0]),Math.max(t[0]-1,-1),Math.min(0,t[1]),Math.max(t[1]-1,-1))},this):i&&this.calculateTileRanges_(i)},Zc=[0,0,0];Vc.prototype.forEachTileCoord=function(t,e,i){const n=this.getTileRangeForExtentAndZ(t,e);for(let t=n.minX,o=n.maxX;t<=o;++t)for(let o=n.minY,s=n.maxY;o<=s;++o)i([e,t,o])},Vc.prototype.forEachTileCoordParentTileRange=function(t,e,i,n,o){let s,r,a,h=null,l=t[0]-1;for(2===this.zoomFactor_?(r=t[1],a=t[2]):h=this.getTileCoordExtent(t,o);l>=this.minZoom;){if(s=2===this.zoomFactor_?Pl(r=Math.floor(r/2),r,a=Math.floor(a/2),a,n):this.getTileRangeForExtentAndZ(h,l,n),e.call(i,l,s))return!0;--l}return!1},Vc.prototype.getExtent=function(){return this.extent_},Vc.prototype.getMaxZoom=function(){return this.maxZoom},Vc.prototype.getMinZoom=function(){return this.minZoom},Vc.prototype.getOrigin=function(t){return this.origin_?this.origin_:this.origins_[t]},Vc.prototype.getResolution=function(t){return this.resolutions_[t]},Vc.prototype.getResolutions=function(){return this.resolutions_},Vc.prototype.getTileCoordChildTileRange=function(t,e,i){if(t[0]<this.maxZoom){if(2===this.zoomFactor_){const i=2*t[1],n=2*t[2];return Pl(i,i+1,n,n+1,e)}const n=this.getTileCoordExtent(t,i);return this.getTileRangeForExtentAndZ(n,t[0]+1,e)}return null},Vc.prototype.getTileRangeExtent=function(t,e,i){const n=this.getOrigin(t),o=this.getResolution(t),s=Us(this.getTileSize(t),this.tmpSize_),r=n[0]+e.minX*s[0]*o,a=n[0]+(e.maxX+1)*s[0]*o;return et(r,n[1]+e.minY*s[1]*o,a,n[1]+(e.maxY+1)*s[1]*o,i)},Vc.prototype.getTileRangeForExtentAndZ=function(t,e,i){const n=Zc;this.getTileCoordForXYAndZ_(t[0],t[1],e,!1,n);const o=n[1],s=n[2];return this.getTileCoordForXYAndZ_(t[2],t[3],e,!0,n),Pl(o,n[1],s,n[2],i)},Vc.prototype.getTileCoordCenter=function(t){const e=this.getOrigin(t[0]),i=this.getResolution(t[0]),n=Us(this.getTileSize(t[0]),this.tmpSize_);return[e[0]+(t[1]+.5)*n[0]*i,e[1]+(t[2]+.5)*n[1]*i]},Vc.prototype.getTileCoordExtent=function(t,e){const i=this.getOrigin(t[0]),n=this.getResolution(t[0]),o=Us(this.getTileSize(t[0]),this.tmpSize_),s=i[0]+t[1]*o[0]*n,r=i[1]+t[2]*o[1]*n;return et(s,r,s+o[0]*n,r+o[1]*n,e)},Vc.prototype.getTileCoordForCoordAndResolution=function(t,e,i){return this.getTileCoordForXYAndResolution_(t[0],t[1],e,!1,i)},Vc.prototype.getTileCoordForXYAndResolution_=function(t,e,i,n,o){const s=this.getZForResolution(i),r=i/this.getResolution(s),a=this.getOrigin(s),h=Us(this.getTileSize(s),this.tmpSize_),l=n?.5:0,c=n?0:.5,u=Math.floor((t-a[0])/i+l),p=Math.floor((e-a[1])/i+c);let d=r*u/h[0],f=r*p/h[1];return n?(d=Math.ceil(d)-1,f=Math.ceil(f)-1):(d=Math.floor(d),f=Math.floor(f)),kc(s,d,f,o)},Vc.prototype.getTileCoordForXYAndZ_=function(t,e,i,n,o){const s=this.getOrigin(i),r=this.getResolution(i),a=Us(this.getTileSize(i),this.tmpSize_),h=n?.5:0,l=n?0:.5,c=Math.floor((t-s[0])/r+h),u=Math.floor((e-s[1])/r+l);let p=c/a[0],d=u/a[1];return n?(p=Math.ceil(p)-1,d=Math.ceil(d)-1):(p=Math.floor(p),d=Math.floor(d)),kc(i,p,d,o)},Vc.prototype.getTileCoordForCoordAndZ=function(t,e,i){return this.getTileCoordForXYAndZ_(t[0],t[1],e,!1,i)},Vc.prototype.getTileCoordResolution=function(t){return this.resolutions_[t[0]]},Vc.prototype.getTileSize=function(t){return this.tileSize_?this.tileSize_:this.tileSizes_[t]},Vc.prototype.getFullTileRange=function(t){return this.fullTileRanges_?this.fullTileRanges_[t]:null},Vc.prototype.getZForResolution=function(t,e){return Rt(Ui(this.resolutions_,t,e||0),this.minZoom,this.maxZoom)},Vc.prototype.calculateTileRanges_=function(t){const e=this.resolutions_.length,i=new Array(e);for(let n=this.minZoom;n<e;++n)i[n]=this.getTileRangeForExtentAndZ(t,n);this.fullTileRanges_=i};var qc=Vc;function Jc(t){let e=t.getDefaultTileGrid();return e||(e=function(t,e,i,n){return function(t,e,i,n){const o=void 0!==n?n:U.TOP_LEFT,s=Qc(t,e,i);return new qc({extent:t,origin:function(t,e){let i;return e===U.BOTTOM_LEFT?i=dt(t):e===U.BOTTOM_RIGHT?i=ft(t):e===U.TOP_LEFT?i=vt(t):e===U.TOP_RIGHT?i=xt(t):p(!1,13),i}(t,o),resolutions:s,tileSize:i})}($c(t),e,i,n)}(t),t.setDefaultTileGrid(e)),e}function Qc(t,e,i){const n=void 0!==e?e:ss,o=yt(t),s=Ct(t),r=Us(void 0!==i?i:rs),a=Math.max(s/r[0],o/r[1]),h=n+1,l=new Array(h);for(let t=0;t<h;++t)l[t]=a/Math.pow(2,t);return l}function $c(t){let e=(t=se(t)).getExtent();if(!e){const i=180*Dt[Nt.DEGREES]/t.getMetersPerUnit();e=et(-i,-i,i,i)}return e}const tu=function(t){$a.call(this,{attributions:t.attributions,extent:t.extent,projection:t.projection,state:t.state,wrapX:t.wrapX}),this.opaque_=void 0!==t.opaque&&t.opaque,this.tilePixelRatio_=void 0!==t.tilePixelRatio?t.tilePixelRatio:1,this.tileGrid=void 0!==t.tileGrid?t.tileGrid:null,this.tileCache=new Nc(t.cacheSize),this.tmpSize=[0,0],this.key_=\"\",this.tileOptions={transition:t.transition}};a(tu,$a),tu.prototype.canExpireCache=function(){return this.tileCache.canExpireCache()},tu.prototype.expireCache=function(t,e){const i=this.getTileCacheForProjection(t);i&&i.expireCache(e)},tu.prototype.forEachLoadedTile=function(t,e,i,n){const o=this.getTileCacheForProjection(t);if(!o)return!1;let s,r,a,h=!0;for(let t=i.minX;t<=i.maxX;++t)for(let l=i.minY;l<=i.maxY;++l)r=Ac(e,t,l),a=!1,o.containsKey(r)&&(a=(s=o.get(r)).getState()===Jo)&&(a=!1!==n(s)),a||(h=!1);return h},tu.prototype.getGutter=function(t){return 0},tu.prototype.getKey=function(){return this.key_},tu.prototype.setKey=function(t){this.key_!==t&&(this.key_=t,this.changed())},tu.prototype.getOpaque=function(t){return this.opaque_},tu.prototype.getResolutions=function(){return this.tileGrid.getResolutions()},tu.prototype.getTile=function(t,e,i,n,o){},tu.prototype.getTileGrid=function(){return this.tileGrid},tu.prototype.getTileGridForProjection=function(t){return this.tileGrid?this.tileGrid:Jc(t)},tu.prototype.getTileCacheForProjection=function(t){const e=this.getProjection();return e&&!le(e,t)?null:this.tileCache},tu.prototype.getTilePixelRatio=function(t){return this.tilePixelRatio_},tu.prototype.getTilePixelSize=function(t,e,i){const n=this.getTileGridForProjection(i),o=this.getTilePixelRatio(e),s=Us(n.getTileSize(t),this.tmpSize);return 1==o?s:(r=s,a=o,void 0===(h=this.tmpSize)&&(h=[0,0]),h[0]=r[0]*a+.5|0,h[1]=r[1]*a+.5|0,h);var r,a,h},tu.prototype.getTileCoordForTileUrlFunction=function(t,e){const i=void 0!==e?e:this.getProjection(),n=this.getTileGridForProjection(i);return this.getWrapX()&&i.isGlobal()&&(t=function(t,e,i){const n=e[0],o=t.getTileCoordCenter(e),s=$c(i);if(q(s,o))return e;{const e=Ct(s),i=Math.ceil((s[0]-o[0])/e);return o[0]+=e*i,t.getTileCoordForCoordAndZ(o,n)}}(n,t,i)),function(t,e){const i=t[0],n=t[1],o=t[2];if(e.getMinZoom()>i||i>e.getMaxZoom())return!1;const s=e.getExtent();let r;return!(r=s?e.getTileRangeForExtentAndZ(s,i):e.getFullTileRange(i))||r.containsXY(n,o)}(t,n)?t:null},tu.prototype.refresh=function(){this.tileCache.clear(),this.changed()},tu.prototype.useTile=P;const eu=function(t,e){k.call(this,t),this.tile=e};a(eu,k);var iu=tu,nu=\"tileloadstart\",ou=\"tileloadend\",su=\"tileloaderror\";const ru=function(t){iu.call(this,{attributions:t.attributions,cacheSize:t.cacheSize,extent:t.extent,opaque:t.opaque,projection:t.projection,state:t.state,tileGrid:t.tileGrid,tilePixelRatio:t.tilePixelRatio,wrapX:t.wrapX,transition:t.transition}),this.tileLoadFunction=t.tileLoadFunction,this.tileUrlFunction=this.fixedTileUrlFunction?this.fixedTileUrlFunction.bind(this):Hc,this.urls=null,t.urls?this.setUrls(t.urls):t.url&&this.setUrl(t.url),t.tileUrlFunction&&this.setTileUrlFunction(t.tileUrlFunction),this.tileLoadingKeys_={}};a(ru,iu),ru.prototype.fixedTileUrlFunction,ru.prototype.getTileLoadFunction=function(){return this.tileLoadFunction},ru.prototype.getTileUrlFunction=function(){return this.tileUrlFunction},ru.prototype.getUrls=function(){return this.urls},ru.prototype.handleTileChange=function(t){const e=t.target,i=l(e),n=e.getState();let o;n==qo?(this.tileLoadingKeys_[i]=!0,o=nu):i in this.tileLoadingKeys_&&(delete this.tileLoadingKeys_[i],o=n==Qo?su:n==Jo||n==ts?ou:void 0),void 0!=o&&this.dispatchEvent(new eu(o,e))},ru.prototype.setTileLoadFunction=function(t){this.tileCache.clear(),this.tileLoadFunction=t,this.changed()},ru.prototype.setTileUrlFunction=function(t,e){this.tileUrlFunction=t,this.tileCache.pruneExceptNewestZ(),void 0!==e?this.setKey(e):this.changed()},ru.prototype.setUrl=function(t){const e=this.urls=function(t){const e=[];let i=/\\{([a-z])-([a-z])\\}/.exec(t);if(i){const n=i[1].charCodeAt(0),o=i[2].charCodeAt(0);let s;for(s=n;s<=o;++s)e.push(t.replace(i[0],String.fromCharCode(s)));return e}if(i=i=/\\{(\\d+)-(\\d+)\\}/.exec(t)){const n=parseInt(i[2],10);for(let o=parseInt(i[1],10);o<=n;o++)e.push(t.replace(i[0],o.toString()));return e}return e.push(t),e}(t);this.setTileUrlFunction(this.fixedTileUrlFunction?this.fixedTileUrlFunction.bind(this):jc(e,this.tileGrid),t)},ru.prototype.setUrls=function(t){this.urls=t;const e=t.join(\"\\n\");this.setTileUrlFunction(this.fixedTileUrlFunction?this.fixedTileUrlFunction.bind(this):jc(t,this.tileGrid),e)},ru.prototype.useTile=function(t,e,i){const n=Ac(t,e,i);this.tileCache.containsKey(n)&&this.tileCache.get(n)};var au=ru;const hu=function(t){au.call(this,{attributions:t.attributions,cacheSize:t.cacheSize,extent:t.extent,opaque:t.opaque,projection:t.projection,state:t.state,tileGrid:t.tileGrid,tileLoadFunction:t.tileLoadFunction?t.tileLoadFunction:lu,tilePixelRatio:t.tilePixelRatio,tileUrlFunction:t.tileUrlFunction,url:t.url,urls:t.urls,wrapX:t.wrapX,transition:t.transition}),this.crossOrigin=void 0!==t.crossOrigin?t.crossOrigin:null,this.tileClass=void 0!==t.tileClass?t.tileClass:Oc,this.tileCacheForProjection={},this.tileGridForProjection={},this.reprojectionErrorThreshold_=t.reprojectionErrorThreshold,this.renderReprojectionEdges_=!1};function lu(t,e){t.getImage().src=e}a(hu,au),hu.prototype.canExpireCache=function(){if(this.tileCache.canExpireCache())return!0;for(const t in this.tileCacheForProjection)if(this.tileCacheForProjection[t].canExpireCache())return!0;return!1},hu.prototype.expireCache=function(t,e){const i=this.getTileCacheForProjection(t);this.tileCache.expireCache(this.tileCache==i?e:{});for(const t in this.tileCacheForProjection){const n=this.tileCacheForProjection[t];n.expireCache(n==i?e:{})}},hu.prototype.getGutter=function(t){return this.getProjection()&&t&&!le(this.getProjection(),t)?0:this.getGutterInternal()},hu.prototype.getGutterInternal=function(){return 0},hu.prototype.getOpaque=function(t){return!(this.getProjection()&&t&&!le(this.getProjection(),t))&&au.prototype.getOpaque.call(this,t)},hu.prototype.getTileGridForProjection=function(t){const e=this.getProjection();if(!this.tileGrid||e&&!le(e,t)){const e=l(t).toString();return e in this.tileGridForProjection||(this.tileGridForProjection[e]=Jc(t)),this.tileGridForProjection[e]}return this.tileGrid},hu.prototype.getTileCacheForProjection=function(t){const e=this.getProjection();if(!e||le(e,t))return this.tileCache;{const e=l(t).toString();return e in this.tileCacheForProjection||(this.tileCacheForProjection[e]=new Nc(this.tileCache.highWaterMark)),this.tileCacheForProjection[e]}},hu.prototype.createTile_=function(t,e,i,n,o,s){const r=[t,e,i],a=this.getTileCoordForTileUrlFunction(r,o),h=a?this.tileUrlFunction(a,n,o):void 0,l=new this.tileClass(r,void 0!==h?Zo:$o,void 0!==h?h:\"\",this.crossOrigin,this.tileLoadFunction,this.tileOptions);return l.key=s,C(l,w.CHANGE,this.handleTileChange,this),l},hu.prototype.getTile=function(t,e,i,n,o){const s=this.getProjection();if(s&&o&&!le(s,o)){const r=this.getTileCacheForProjection(o),a=[t,e,i];let h;const l=Gc(a);r.containsKey(l)&&(h=r.get(l));const c=this.getKey();if(h&&h.key==c)return h;{const t=this.getTileGridForProjection(s),e=this.getTileGridForProjection(o),i=this.getTileCoordForTileUrlFunction(a,o),u=new Uc(s,t,o,e,a,i,this.getTilePixelRatio(n),this.getGutterInternal(),function(t,e,i,n){return this.getTileInternal(t,e,i,n,s)}.bind(this),this.reprojectionErrorThreshold_,this.renderReprojectionEdges_);return u.key=c,h?(u.interimTile=h,u.refreshInterimChain(),r.replace(l,u)):r.set(l,u),u}}return this.getTileInternal(t,e,i,n,s||o)},hu.prototype.getTileInternal=function(t,e,i,n,o){let s=null;const r=Ac(t,e,i),a=this.getKey();if(this.tileCache.containsKey(r)){if((s=this.tileCache.get(r)).key!=a){const h=s;s=this.createTile_(t,e,i,n,o,a),h.getState()==Zo?s.interimTile=h.interimTile:s.interimTile=h,s.refreshInterimChain(),this.tileCache.replace(r,s)}}else s=this.createTile_(t,e,i,n,o,a),this.tileCache.set(r,s);return s},hu.prototype.setRenderReprojectionEdges=function(t){if(this.renderReprojectionEdges_!=t){this.renderReprojectionEdges_=t;for(const t in this.tileCacheForProjection)this.tileCacheForProjection[t].clear();this.changed()}},hu.prototype.setTileGridForProjection=function(t,e){{const i=se(t);if(i){const t=l(i).toString();t in this.tileGridForProjection||(this.tileGridForProjection[t]=e)}}};var cu=hu;const uu=function(t){const e=t||{},i=void 0!==e.projection?e.projection:\"EPSG:3857\",n=void 0!==e.tileGrid?e.tileGrid:function(t){const e={};return d(e,void 0!==t?t:{}),void 0===e.extent&&(e.extent=se(\"EPSG:3857\").getExtent()),e.resolutions=Qc(e.extent,e.maxZoom,e.tileSize),delete e.maxZoom,new qc(e)}({extent:$c(i),maxZoom:e.maxZoom,minZoom:e.minZoom,tileSize:e.tileSize});cu.call(this,{attributions:e.attributions,cacheSize:e.cacheSize,crossOrigin:e.crossOrigin,opaque:e.opaque,projection:i,reprojectionErrorThreshold:e.reprojectionErrorThreshold,tileGrid:n,tileLoadFunction:e.tileLoadFunction,tilePixelRatio:e.tilePixelRatio,tileUrlFunction:e.tileUrlFunction,url:e.url,urls:e.urls,wrapX:void 0===e.wrapX||e.wrapX,transition:e.transition})};a(uu,cu);var pu=uu;const du=function(t){const e=t||{};let i;i=void 0!==e.attributions?e.attributions:['&copy; <a href=\"https://www.openstreetmap.org/copyright\">OpenStreetMap</a> contributors.'];const n=void 0!==e.crossOrigin?e.crossOrigin:\"anonymous\",o=void 0!==e.url?e.url:\"https://{a-c}.tile.openstreetmap.org/{z}/{x}/{y}.png\";pu.call(this,{attributions:i,cacheSize:e.cacheSize,crossOrigin:n,opaque:void 0===e.opaque||e.opaque,maxZoom:void 0!==e.maxZoom?e.maxZoom:19,reprojectionErrorThreshold:e.reprojectionErrorThreshold,tileLoadFunction:e.tileLoadFunction,url:o,wrapX:e.wrapX})};a(du,pu);var fu=du;const gu=function(t,e){this.space_=e,this.emptyBlocks_=[{x:0,y:0,width:t,height:t}],this.entries_={},this.context_=ke(t,t),this.canvas_=this.context_.canvas};gu.prototype.get=function(t){return this.entries_[t]||null},gu.prototype.add=function(t,e,i,n,o){for(let s=0,r=this.emptyBlocks_.length;s<r;++s){const r=this.emptyBlocks_[s];if(r.width>=e+this.space_&&r.height>=i+this.space_){const a={offsetX:r.x+this.space_,offsetY:r.y+this.space_,image:this.canvas_};return this.entries_[t]=a,n.call(o,this.context_,r.x+this.space_,r.y+this.space_),this.split_(s,r,e+this.space_,i+this.space_),a}}return null},gu.prototype.split_=function(t,e,i,n){let o,s;e.width-i>e.height-n?(o={x:e.x+i,y:e.y,width:e.width-i,height:e.height},s={x:e.x,y:e.y+n,width:i,height:e.height-n},this.updateBlocks_(t,o,s)):(o={x:e.x+i,y:e.y,width:e.width-i,height:n},s={x:e.x,y:e.y+n,width:e.width,height:e.height-n},this.updateBlocks_(t,o,s))},gu.prototype.updateBlocks_=function(t,e,i){const n=[t,1];e.width>0&&e.height>0&&n.push(e),i.width>0&&i.height>0&&n.push(i),this.emptyBlocks_.splice.apply(this.emptyBlocks_,n)};var _u=gu;const yu=function(t){const e=t||{};this.currentSize_=void 0!==e.initialSize?e.initialSize:256,this.maxSize_=void 0!==e.maxSize?e.maxSize:void 0!==o?o:2048,this.space_=void 0!==e.space?e.space:1,this.atlases_=[new _u(this.currentSize_,this.space_)],this.currentHitSize_=this.currentSize_,this.hitAtlases_=[new _u(this.currentHitSize_,this.space_)]};yu.prototype.getInfo=function(t){const e=this.getInfo_(this.atlases_,t);if(!e)return null;const i=this.getInfo_(this.hitAtlases_,t);return this.mergeInfos_(e,i)},yu.prototype.getInfo_=function(t,e){for(let i=0,n=t.length;i<n;++i){const n=t[i].get(e);if(n)return n}return null},yu.prototype.mergeInfos_=function(t,e){return{offsetX:t.offsetX,offsetY:t.offsetY,image:t.image,hitImage:e.image}},yu.prototype.add=function(t,e,i,n,o,s){if(e+this.space_>this.maxSize_||i+this.space_>this.maxSize_)return null;const r=this.add_(!1,t,e,i,n,s);if(!r)return null;const a=void 0!==o?o:P,h=this.add_(!0,t,e,i,a,s);return this.mergeInfos_(r,h)},yu.prototype.add_=function(t,e,i,n,o,s){const r=t?this.hitAtlases_:this.atlases_;let a,h,l,c;for(l=0,c=r.length;l<c;++l){if(h=(a=r[l]).add(e,i,n,o,s))return h;if(!h&&l===c-1){let e;t?(e=Math.min(2*this.currentHitSize_,this.maxSize_),this.currentHitSize_=e):(e=Math.min(2*this.currentSize_,this.maxSize_),this.currentSize_=e),a=new _u(e,this.space_),r.push(a),++c}}return null};var mu=\"fraction\";const vu=function(t,e,i,n,o,s){G.call(this),this.hitDetectionImage_=null,this.image_=t||new Image,null!==n&&(this.image_.crossOrigin=n),this.canvas_=s?document.createElement(\"CANVAS\"):null,this.color_=s,this.imageListenerKeys_=null,this.imageState_=o,this.size_=i,this.src_=e,this.tainting_=!1,this.imageState_==Ve.LOADED&&this.determineTainting_()};a(vu,G),vu.prototype.determineTainting_=function(){const t=ke(1,1);try{t.drawImage(this.image_,0,0),t.getImageData(0,0,1,1)}catch(t){this.tainting_=!0}},vu.prototype.dispatchChangeEvent_=function(){this.dispatchEvent(w.CHANGE)},vu.prototype.handleImageError_=function(){this.imageState_=Ve.ERROR,this.unlistenImage_(),this.dispatchChangeEvent_()},vu.prototype.handleImageLoad_=function(){this.imageState_=Ve.LOADED,this.size_&&(this.image_.width=this.size_[0],this.image_.height=this.size_[1]),this.size_=[this.image_.width,this.image_.height],this.unlistenImage_(),this.determineTainting_(),this.replaceColor_(),this.dispatchChangeEvent_()},vu.prototype.getImage=function(t){return this.canvas_?this.canvas_:this.image_},vu.prototype.getImageState=function(){return this.imageState_},vu.prototype.getHitDetectionImage=function(t){if(!this.hitDetectionImage_)if(this.tainting_){const t=this.size_[0],e=this.size_[1],i=ke(t,e);i.fillRect(0,0,t,e),this.hitDetectionImage_=i.canvas}else this.hitDetectionImage_=this.image_;return this.hitDetectionImage_},vu.prototype.getSize=function(){return this.size_},vu.prototype.getSrc=function(){return this.src_},vu.prototype.load=function(){if(this.imageState_==Ve.IDLE){this.imageState_=Ve.LOADING,this.imageListenerKeys_=[E(this.image_,w.ERROR,this.handleImageError_,this),E(this.image_,w.LOAD,this.handleImageLoad_,this)];try{this.image_.src=this.src_}catch(t){this.handleImageError_()}}},vu.prototype.replaceColor_=function(){if(this.tainting_||null===this.color_)return;this.canvas_.width=this.image_.width,this.canvas_.height=this.image_.height;const t=this.canvas_.getContext(\"2d\");t.drawImage(this.image_,0,0);const e=t.getImageData(0,0,this.image_.width,this.image_.height),i=e.data,n=this.color_[0]/255,o=this.color_[1]/255,s=this.color_[2]/255;for(let t=0,e=i.length;t<e;t+=4)i[t]*=n,i[t+1]*=o,i[t+2]*=s;t.putImageData(e,0,0)},vu.prototype.unlistenImage_=function(){this.imageListenerKeys_.forEach(S),this.imageListenerKeys_=null};var xu=\"bottom-left\",Cu=\"bottom-right\",Eu=\"top-left\",Tu=\"top-right\";const Su=function(t){const e=t||{};this.anchor_=void 0!==e.anchor?e.anchor:[.5,.5],this.normalizedAnchor_=null,this.anchorOrigin_=void 0!==e.anchorOrigin?e.anchorOrigin:Eu,this.anchorXUnits_=void 0!==e.anchorXUnits?e.anchorXUnits:mu,this.anchorYUnits_=void 0!==e.anchorYUnits?e.anchorYUnits:mu,this.crossOrigin_=void 0!==e.crossOrigin?e.crossOrigin:null;const i=void 0!==e.img?e.img:null,n=void 0!==e.imgSize?e.imgSize:null;let o=e.src;p(!(void 0!==o&&i),4),p(!i||i&&n,5),void 0!==o&&0!==o.length||!i||(o=i.src||l(i).toString()),p(void 0!==o&&o.length>0,6);const s=void 0!==e.src?Ve.IDLE:Ve.LOADED;var r;this.color_=void 0!==e.color?(r=e.color,Array.isArray(r)?r:Le(r)):null,this.iconImage_=function(t,e,i,n,o,s){let r=pl.get(e,n,s);return r||(r=new vu(t,e,i,n,o,s),pl.set(e,n,s,r)),r}(i,o,n,this.crossOrigin_,s,this.color_),this.offset_=void 0!==e.offset?e.offset:[0,0],this.offsetOrigin_=void 0!==e.offsetOrigin?e.offsetOrigin:Eu,this.origin_=null,this.size_=void 0!==e.size?e.size:null;const a=void 0!==e.opacity?e.opacity:1,h=void 0!==e.rotateWithView&&e.rotateWithView,c=void 0!==e.rotation?e.rotation:0,u=void 0!==e.scale?e.scale:1,d=void 0===e.snapToPixel||e.snapToPixel;gi.call(this,{opacity:a,rotation:c,scale:u,snapToPixel:d,rotateWithView:h})};a(Su,gi),Su.prototype.clone=function(){return new Su({anchor:this.anchor_.slice(),anchorOrigin:this.anchorOrigin_,anchorXUnits:this.anchorXUnits_,anchorYUnits:this.anchorYUnits_,crossOrigin:this.crossOrigin_,color:this.color_&&this.color_.slice?this.color_.slice():this.color_||void 0,src:this.getSrc(),offset:this.offset_.slice(),offsetOrigin:this.offsetOrigin_,size:null!==this.size_?this.size_.slice():void 0,opacity:this.getOpacity(),scale:this.getScale(),snapToPixel:this.getSnapToPixel(),rotation:this.getRotation(),rotateWithView:this.getRotateWithView()})},Su.prototype.getAnchor=function(){if(this.normalizedAnchor_)return this.normalizedAnchor_;let t=this.anchor_;const e=this.getSize();if(this.anchorXUnits_==mu||this.anchorYUnits_==mu){if(!e)return null;t=this.anchor_.slice(),this.anchorXUnits_==mu&&(t[0]*=e[0]),this.anchorYUnits_==mu&&(t[1]*=e[1])}if(this.anchorOrigin_!=Eu){if(!e)return null;t===this.anchor_&&(t=this.anchor_.slice()),this.anchorOrigin_!=Tu&&this.anchorOrigin_!=Cu||(t[0]=-t[0]+e[0]),this.anchorOrigin_!=xu&&this.anchorOrigin_!=Cu||(t[1]=-t[1]+e[1])}return this.normalizedAnchor_=t,this.normalizedAnchor_},Su.prototype.getColor=function(){return this.color_},Su.prototype.getImage=function(t){return this.iconImage_.getImage(t)},Su.prototype.getImageSize=function(){return this.iconImage_.getSize()},Su.prototype.getHitDetectionImageSize=function(){return this.getImageSize()},Su.prototype.getImageState=function(){return this.iconImage_.getImageState()},Su.prototype.getHitDetectionImage=function(t){return this.iconImage_.getHitDetectionImage(t)},Su.prototype.getOrigin=function(){if(this.origin_)return this.origin_;let t=this.offset_;if(this.offsetOrigin_!=Eu){const e=this.getSize(),i=this.iconImage_.getSize();if(!e||!i)return null;t=t.slice(),this.offsetOrigin_!=Tu&&this.offsetOrigin_!=Cu||(t[0]=i[0]-e[0]-t[0]),this.offsetOrigin_!=xu&&this.offsetOrigin_!=Cu||(t[1]=i[1]-e[1]-t[1])}return this.origin_=t,this.origin_},Su.prototype.getSrc=function(){return this.iconImage_.getSrc()},Su.prototype.getSize=function(){return this.size_?this.size_:this.iconImage_.getSize()},Su.prototype.listenImageChange=function(t,e){return C(this.iconImage_,w.CHANGE,t,e)},Su.prototype.load=function(){this.iconImage_.load()},Su.prototype.unlistenImageChange=function(t,e){T(this.iconImage_,w.CHANGE,t,e)};const wu=function(t){const e=t||{};this.font_=e.font,this.rotation_=e.rotation,this.rotateWithView_=e.rotateWithView,this.scale_=e.scale,this.text_=e.text,this.textAlign_=e.textAlign,this.textBaseline_=e.textBaseline,this.fill_=void 0!==e.fill?e.fill:new Ci({color:\"#333\"}),this.maxAngle_=void 0!==e.maxAngle?e.maxAngle:Math.PI/4,this.placement_=void 0!==e.placement?e.placement:ic,this.overflow_=!!e.overflow,this.stroke_=void 0!==e.stroke?e.stroke:null,this.offsetX_=void 0!==e.offsetX?e.offsetX:0,this.offsetY_=void 0!==e.offsetY?e.offsetY:0,this.backgroundFill_=e.backgroundFill?e.backgroundFill:null,this.backgroundStroke_=e.backgroundStroke?e.backgroundStroke:null,this.padding_=void 0===e.padding?null:e.padding};wu.prototype.clone=function(){return new wu({font:this.getFont(),placement:this.getPlacement(),maxAngle:this.getMaxAngle(),overflow:this.getOverflow(),rotation:this.getRotation(),rotateWithView:this.getRotateWithView(),scale:this.getScale(),text:this.getText(),textAlign:this.getTextAlign(),textBaseline:this.getTextBaseline(),fill:this.getFill()?this.getFill().clone():void 0,stroke:this.getStroke()?this.getStroke().clone():void 0,offsetX:this.getOffsetX(),offsetY:this.getOffsetY(),backgroundFill:this.getBackgroundFill()?this.getBackgroundFill().clone():void 0,backgroundStroke:this.getBackgroundStroke()?this.getBackgroundStroke().clone():void 0})},wu.prototype.getOverflow=function(){return this.overflow_},wu.prototype.getFont=function(){return this.font_},wu.prototype.getMaxAngle=function(){return this.maxAngle_},wu.prototype.getPlacement=function(){return this.placement_},wu.prototype.getOffsetX=function(){return this.offsetX_},wu.prototype.getOffsetY=function(){return this.offsetY_},wu.prototype.getFill=function(){return this.fill_},wu.prototype.getRotateWithView=function(){return this.rotateWithView_},wu.prototype.getRotation=function(){return this.rotation_},wu.prototype.getScale=function(){return this.scale_},wu.prototype.getStroke=function(){return this.stroke_},wu.prototype.getText=function(){return this.text_},wu.prototype.getTextAlign=function(){return this.textAlign_},wu.prototype.getTextBaseline=function(){return this.textBaseline_},wu.prototype.getBackgroundFill=function(){return this.backgroundFill_},wu.prototype.getBackgroundStroke=function(){return this.backgroundStroke_},wu.prototype.getPadding=function(){return this.padding_},wu.prototype.setOverflow=function(t){this.overflow_=t},wu.prototype.setFont=function(t){this.font_=t},wu.prototype.setMaxAngle=function(t){this.maxAngle_=t},wu.prototype.setOffsetX=function(t){this.offsetX_=t},wu.prototype.setOffsetY=function(t){this.offsetY_=t},wu.prototype.setPlacement=function(t){this.placement_=t},wu.prototype.setFill=function(t){this.fill_=t},wu.prototype.setRotation=function(t){this.rotation_=t},wu.prototype.setScale=function(t){this.scale_=t},wu.prototype.setStroke=function(t){this.stroke_=t},wu.prototype.setText=function(t){this.text_=t},wu.prototype.setTextAlign=function(t){this.textAlign_=t},wu.prototype.setTextBaseline=function(t){this.textBaseline_=t},wu.prototype.setBackgroundFill=function(t){this.backgroundFill_=t},wu.prototype.setBackgroundStroke=function(t){this.backgroundStroke_=t},wu.prototype.setPadding=function(t){this.padding_=t};var Ru=\"bottom-left\",Iu=\"bottom-center\",Fu=\"bottom-right\",Pu=\"center-left\",Lu=\"center-center\",Mu=\"center-right\",bu=\"top-left\",Ou=\"top-center\",ku=\"top-right\";const Au=\"element\",Gu=\"map\",Du=\"offset\",Nu=\"position\",Yu=\"positioning\",Xu=function(t){K.call(this),this.options=t,this.id=t.id,this.insertFirst=void 0===t.insertFirst||t.insertFirst,this.stopEvent=void 0===t.stopEvent||t.stopEvent,this.element=document.createElement(\"DIV\"),this.element.className=void 0!==t.className?t.className:\"ol-overlay-container ol-selectable\",this.element.style.position=\"absolute\",this.autoPan=void 0!==t.autoPan&&t.autoPan,this.autoPanAnimation=t.autoPanAnimation||{},this.autoPanMargin=void 0!==t.autoPanMargin?t.autoPanMargin:20,this.rendered={bottom_:\"\",left_:\"\",right_:\"\",top_:\"\",visible:!0},this.mapPostrenderListenerKey=null,C(this,W(Au),this.handleElementChanged,this),C(this,W(Gu),this.handleMapChanged,this),C(this,W(Du),this.handleOffsetChanged,this),C(this,W(Nu),this.handlePositionChanged,this),C(this,W(Yu),this.handlePositioningChanged,this),void 0!==t.element&&this.setElement(t.element),this.setOffset(void 0!==t.offset?t.offset:[0,0]),this.setPositioning(void 0!==t.positioning?t.positioning:bu),void 0!==t.position&&this.setPosition(t.position)};a(Xu,K),Xu.prototype.getElement=function(){return this.get(Au)},Xu.prototype.getId=function(){return this.id},Xu.prototype.getMap=function(){return this.get(Gu)},Xu.prototype.getOffset=function(){return this.get(Du)},Xu.prototype.getPosition=function(){return this.get(Nu)},Xu.prototype.getPositioning=function(){return this.get(Yu)},Xu.prototype.handleElementChanged=function(){De(this.element);const t=this.getElement();t&&this.element.appendChild(t)},Xu.prototype.handleMapChanged=function(){this.mapPostrenderListenerKey&&(Ge(this.element),S(this.mapPostrenderListenerKey),this.mapPostrenderListenerKey=null);const t=this.getMap();if(t){this.mapPostrenderListenerKey=C(t,Bo,this.render,this),this.updatePixelPosition();const e=this.stopEvent?t.getOverlayContainerStopEvent():t.getOverlayContainer();this.insertFirst?e.insertBefore(this.element,e.childNodes[0]||null):e.appendChild(this.element)}},Xu.prototype.render=function(){this.updatePixelPosition()},Xu.prototype.handleOffsetChanged=function(){this.updatePixelPosition()},Xu.prototype.handlePositionChanged=function(){this.updatePixelPosition(),this.get(Nu)&&this.autoPan&&this.panIntoView()},Xu.prototype.handlePositioningChanged=function(){this.updatePixelPosition()},Xu.prototype.setElement=function(t){this.set(Au,t)},Xu.prototype.setMap=function(t){this.set(Gu,t)},Xu.prototype.setOffset=function(t){this.set(Du,t)},Xu.prototype.setPosition=function(t){this.set(Nu,t)},Xu.prototype.panIntoView=function(){const t=this.getMap();if(!t||!t.getTargetElement())return;const e=this.getRect(t.getTargetElement(),t.getSize()),i=this.getElement(),n=this.getRect(i,[function(t){let e=t.offsetWidth;const i=getComputedStyle(t);return e+=parseInt(i.marginLeft,10)+parseInt(i.marginRight,10)}(i),function(t){let e=t.offsetHeight;const i=getComputedStyle(t);return e+=parseInt(i.marginTop,10)+parseInt(i.marginBottom,10)}(i)]),o=this.autoPanMargin;if(!J(e,n)){const i=n[0]-e[0],s=e[2]-n[2],r=n[1]-e[1],a=e[3]-n[3],h=[0,0];if(i<0?h[0]=i-o:s<0&&(h[0]=Math.abs(s)+o),r<0?h[1]=r-o:a<0&&(h[1]=Math.abs(a)+o),0!==h[0]||0!==h[1]){const e=t.getView().getCenter(),i=t.getPixelFromCoordinate(e),n=[i[0]+h[0],i[1]+h[1]];t.getView().animate({center:t.getCoordinateFromPixel(n),duration:this.autoPanAnimation.duration,easing:this.autoPanAnimation.easing})}}},Xu.prototype.getRect=function(t,e){const i=t.getBoundingClientRect(),n=i.left+window.pageXOffset,o=i.top+window.pageYOffset;return[n,o,n+e[0],o+e[1]]},Xu.prototype.setPositioning=function(t){this.set(Yu,t)},Xu.prototype.setVisible=function(t){this.rendered.visible!==t&&(this.element.style.display=t?\"\":\"none\",this.rendered.visible=t)},Xu.prototype.updatePixelPosition=function(){const t=this.getMap(),e=this.getPosition();if(!t||!t.isRendered()||!e)return void this.setVisible(!1);const i=t.getPixelFromCoordinate(e),n=t.getSize();this.updateRenderedPosition(i,n)},Xu.prototype.updateRenderedPosition=function(t,e){const i=this.element.style,n=this.getOffset(),o=this.getPositioning();this.setVisible(!0);let s=n[0],r=n[1];if(o==Fu||o==Mu||o==ku){\"\"!==this.rendered.left_&&(this.rendered.left_=i.left=\"\");const n=Math.round(e[0]-t[0]-s)+\"px\";this.rendered.right_!=n&&(this.rendered.right_=i.right=n)}else{\"\"!==this.rendered.right_&&(this.rendered.right_=i.right=\"\"),o!=Iu&&o!=Lu&&o!=Ou||(s-=this.element.offsetWidth/2);const e=Math.round(t[0]+s)+\"px\";this.rendered.left_!=e&&(this.rendered.left_=i.left=e)}if(o==Ru||o==Iu||o==Fu){\"\"!==this.rendered.top_&&(this.rendered.top_=i.top=\"\");const n=Math.round(e[1]-t[1]-r)+\"px\";this.rendered.bottom_!=n&&(this.rendered.bottom_=i.bottom=n)}else{\"\"!==this.rendered.bottom_&&(this.rendered.bottom_=i.bottom=\"\"),o!=Pu&&o!=Lu&&o!=Mu||(r-=this.element.offsetHeight/2);const e=Math.round(t[1]+r)+\"px\";this.rendered.top_!=e&&(this.rendered.top_=i.top=e)}},Xu.prototype.getOptions=function(){return this.options};var zu=Xu;i(2);var Wu,Ku=pe([-97.942999,29.888998],\"EPSG:4326\",void 0!==Wu?Wu:\"EPSG:3857\");const Uu=new Za({source:new ch({format:new to,url:\"./data/buildings.geojson\"})}),Bu=new Fc({source:new fu}),ju=new zu({element:document.getElementById(\"popup-container\"),positioning:\"bottom-center\",offset:[0,-10],autoPan:!0}),Hu=new Sc({target:\"map-container\",layers:[Bu,Uu],view:new Ps({center:Ku,zoom:16})});ju.getElement().addEventListener(\"click\",function(){ju.setPosition()}),Hu.addOverlay(ju),Hu.on(\"click\",function(t){let e=\"\";Hu.forEachFeatureAtPixel(t.pixel,function(t){e+=`${e&&\"<hr>\"}<table>`;const i=t.get(\"Bldg_Nam_1\"),n=t.get(\"Status\");e+=`<tr><th>Building Name:</th> <td>${i}</td></tr>`,e+=`<tr><th>Status:</th> <td>${n}</td></tr>`,e+=\"</table>\"},{hitTolerance:1}),e?(document.getElementById(\"popup-content\").innerHTML=e,ju.setPosition(t.coordinate)):ju.setPosition()})},function(t,e){throw new Error('Module parse failed: Unexpected token (2:6)\\nYou may need an appropriate loader to handle this file type.\\n| {\\r\\n| \"type\": \"FeatureCollection\",\\r\\n| \"name\": \"tx_state_buildings\",\\r\\n| \"crs\": { \"type\": \"name\", \"properties\": { \"name\": \"urn:ogc:def:crs:EPSG::3857\" } },\\r')},function(t,e,i){t.exports=function(){\"use strict\";function t(t,e,i){var n=t[e];t[e]=t[i],t[i]=n}function e(t,e){return t<e?-1:t>e?1:0}return function(i,n,o,s,r){!function e(i,n,o,s,r){for(;s>o;){if(s-o>600){var a=s-o+1,h=n-o+1,l=Math.log(a),c=.5*Math.exp(2*l/3),u=.5*Math.sqrt(l*c*(a-c)/a)*(h-a/2<0?-1:1),p=Math.max(o,Math.floor(n-h*c/a+u)),d=Math.min(s,Math.floor(n+(a-h)*c/a+u));e(i,n,p,d,r)}var f=i[n],g=o,_=s;for(t(i,o,n),r(i[s],f)>0&&t(i,o,s);g<_;){for(t(i,g,_),g++,_--;r(i[g],f)<0;)g++;for(;r(i[_],f)>0;)_--}0===r(i[o],f)?t(i,o,_):t(i,++_,s),_<=n&&(o=_+1),n<=_&&(s=_-1)}}(i,n,o||0,s||i.length-1,r||e)}}()},function(t,e){t.exports=function(t){var e=\"undefined\"!=typeof window&&window.location;if(!e)throw new Error(\"fixUrls requires window.location\");if(!t||\"string\"!=typeof t)return t;var i=e.protocol+\"//\"+e.host,n=i+e.pathname.replace(/\\/[^\\/]*$/,\"/\");return t.replace(/url\\s*\\(((?:[^)(]|\\((?:[^)(]+|\\([^)(]*\\))*\\))*)\\)/gi,function(t,e){var o,s=e.trim().replace(/^\"(.*)\"$/,function(t,e){return e}).replace(/^'(.*)'$/,function(t,e){return e});return/^(#|data:|http:\\/\\/|https:\\/\\/|file:\\/\\/\\/|\\s*$)/i.test(s)?t:(o=0===s.indexOf(\"//\")?s:0===s.indexOf(\"/\")?i+s:n+s.replace(/^\\.\\//,\"\"),\"url(\"+JSON.stringify(o)+\")\")})}},function(t,e,i){var n,o,s={},r=(n=function(){return window&&document&&document.all&&!window.atob},function(){return void 0===o&&(o=n.apply(this,arguments)),o}),a=function(t){var e={};return function(t){if(\"function\"==typeof t)return t();if(void 0===e[t]){var i=function(t){return document.querySelector(t)}.call(this,t);if(window.HTMLIFrameElement&&i instanceof window.HTMLIFrameElement)try{i=i.contentDocument.head}catch(t){i=null}e[t]=i}return e[t]}}(),h=null,l=0,c=[],u=i(4);function p(t,e){for(var i=0;i<t.length;i++){var n=t[i],o=s[n.id];if(o){o.refs++;for(var r=0;r<o.parts.length;r++)o.parts[r](n.parts[r]);for(;r<n.parts.length;r++)o.parts.push(m(n.parts[r],e))}else{var a=[];for(r=0;r<n.parts.length;r++)a.push(m(n.parts[r],e));s[n.id]={id:n.id,refs:1,parts:a}}}}function d(t,e){for(var i=[],n={},o=0;o<t.length;o++){var s=t[o],r=e.base?s[0]+e.base:s[0],a={css:s[1],media:s[2],sourceMap:s[3]};n[r]?n[r].parts.push(a):i.push(n[r]={id:r,parts:[a]})}return i}function f(t,e){var i=a(t.insertInto);if(!i)throw new Error(\"Couldn't find a style target. This probably means that the value for the 'insertInto' parameter is invalid.\");var n=c[c.length-1];if(\"top\"===t.insertAt)n?n.nextSibling?i.insertBefore(e,n.nextSibling):i.appendChild(e):i.insertBefore(e,i.firstChild),c.push(e);else if(\"bottom\"===t.insertAt)i.appendChild(e);else{if(\"object\"!=typeof t.insertAt||!t.insertAt.before)throw new Error(\"[Style Loader]\\n\\n Invalid value for parameter 'insertAt' ('options.insertAt') found.\\n Must be 'top', 'bottom', or Object.\\n (https://github.com/webpack-contrib/style-loader#insertat)\\n\");var o=a(t.insertInto+\" \"+t.insertAt.before);i.insertBefore(e,o)}}function g(t){if(null===t.parentNode)return!1;t.parentNode.removeChild(t);var e=c.indexOf(t);e>=0&&c.splice(e,1)}function _(t){var e=document.createElement(\"style\");return void 0===t.attrs.type&&(t.attrs.type=\"text/css\"),y(e,t.attrs),f(t,e),e}function y(t,e){Object.keys(e).forEach(function(i){t.setAttribute(i,e[i])})}function m(t,e){var i,n,o,s;if(e.transform&&t.css){if(!(s=e.transform(t.css)))return function(){};t.css=s}if(e.singleton){var r=l++;i=h||(h=_(e)),n=C.bind(null,i,r,!1),o=C.bind(null,i,r,!0)}else t.sourceMap&&\"function\"==typeof URL&&\"function\"==typeof URL.createObjectURL&&\"function\"==typeof URL.revokeObjectURL&&\"function\"==typeof Blob&&\"function\"==typeof btoa?(i=function(t){var e=document.createElement(\"link\");return void 0===t.attrs.type&&(t.attrs.type=\"text/css\"),t.attrs.rel=\"stylesheet\",y(e,t.attrs),f(t,e),e}(e),n=function(t,e,i){var n=i.css,o=i.sourceMap,s=void 0===e.convertToAbsoluteUrls&&o;(e.convertToAbsoluteUrls||s)&&(n=u(n));o&&(n+=\"\\n/*# sourceMappingURL=data:application/json;base64,\"+btoa(unescape(encodeURIComponent(JSON.stringify(o))))+\" */\");var r=new Blob([n],{type:\"text/css\"}),a=t.href;t.href=URL.createObjectURL(r),a&&URL.revokeObjectURL(a)}.bind(null,i,e),o=function(){g(i),i.href&&URL.revokeObjectURL(i.href)}):(i=_(e),n=function(t,e){var i=e.css,n=e.media;n&&t.setAttribute(\"media\",n);if(t.styleSheet)t.styleSheet.cssText=i;else{for(;t.firstChild;)t.removeChild(t.firstChild);t.appendChild(document.createTextNode(i))}}.bind(null,i),o=function(){g(i)});return n(t),function(e){if(e){if(e.css===t.css&&e.media===t.media&&e.sourceMap===t.sourceMap)return;n(t=e)}else o()}}t.exports=function(t,e){if(\"undefined\"!=typeof DEBUG&&DEBUG&&\"object\"!=typeof document)throw new Error(\"The style-loader cannot be used in a non-browser environment\");(e=e||{}).attrs=\"object\"==typeof e.attrs?e.attrs:{},e.singleton||\"boolean\"==typeof e.singleton||(e.singleton=r()),e.insertInto||(e.insertInto=\"head\"),e.insertAt||(e.insertAt=\"bottom\");var i=d(t,e);return p(i,e),function(t){for(var n=[],o=0;o<i.length;o++){var r=i[o];(a=s[r.id]).refs--,n.push(a)}t&&p(d(t,e),e);for(o=0;o<n.length;o++){var a;if(0===(a=n[o]).refs){for(var h=0;h<a.parts.length;h++)a.parts[h]();delete s[a.id]}}}};var v,x=(v=[],function(t,e){return v[t]=e,v.filter(Boolean).join(\"\\n\")});function C(t,e,i,n){var o=i?\"\":n.css;if(t.styleSheet)t.styleSheet.cssText=x(e,o);else{var s=document.createTextNode(o),r=t.childNodes;r[e]&&t.removeChild(r[e]),r.length?t.insertBefore(s,r[e]):t.appendChild(s)}}},function(t,e){t.exports=function(t){var e=[];return e.toString=function(){return this.map(function(e){var i=function(t,e){var i=t[1]||\"\",n=t[3];if(!n)return i;if(e&&\"function\"==typeof btoa){var o=(r=n,\"/*# sourceMappingURL=data:application/json;charset=utf-8;base64,\"+btoa(unescape(encodeURIComponent(JSON.stringify(r))))+\" */\"),s=n.sources.map(function(t){return\"/*# sourceURL=\"+n.sourceRoot+t+\" */\"});return[i].concat(s).concat([o]).join(\"\\n\")}var r;return[i].join(\"\\n\")}(e,t);return e[2]?\"@media \"+e[2]+\"{\"+i+\"}\":i}).join(\"\")},e.i=function(t,i){\"string\"==typeof t&&(t=[[null,t,\"\"]]);for(var n={},o=0;o<this.length;o++){var s=this[o][0];\"number\"==typeof s&&(n[s]=!0)}for(o=0;o<t.length;o++){var r=t[o];\"number\"==typeof r[0]&&n[r[0]]||(i&&!r[2]?r[2]=i:i&&(r[2]=\"(\"+r[2]+\") and (\"+i+\")\"),e.push(r))}},e}},function(t,e,i){(t.exports=i(6)(!1)).push([t.i,'.ol-box {\\n  box-sizing: border-box;\\n  border-radius: 2px;\\n  border: 2px solid blue;\\n}\\n\\n.ol-mouse-position {\\n  top: 8px;\\n  right: 8px;\\n  position: absolute;\\n}\\n\\n.ol-scale-line {\\n  background: rgba(0,60,136,0.3);\\n  border-radius: 4px;\\n  bottom: 8px;\\n  left: 8px;\\n  padding: 2px;\\n  position: absolute;\\n}\\n.ol-scale-line-inner {\\n  border: 1px solid #eee;\\n  border-top: none;\\n  color: #eee;\\n  font-size: 10px;\\n  text-align: center;\\n  margin: 1px;\\n  will-change: contents, width;\\n}\\n.ol-overlay-container {\\n  will-change: left,right,top,bottom;\\n}\\n\\n.ol-unsupported {\\n  display: none;\\n}\\n.ol-viewport, .ol-unselectable {\\n  -webkit-touch-callout: none;\\n  -webkit-user-select: none;\\n  -moz-user-select: none;\\n  -ms-user-select: none;\\n  user-select: none;\\n  -webkit-tap-highlight-color: rgba(0,0,0,0);\\n}\\n.ol-selectable {\\n  -webkit-touch-callout: default;\\n  -webkit-user-select: text;\\n  -moz-user-select: text;\\n  -ms-user-select: text;\\n  user-select: text;\\n}\\n.ol-grabbing {\\n  cursor: -webkit-grabbing;\\n  cursor: -moz-grabbing;\\n  cursor: grabbing;\\n}\\n.ol-grab {\\n  cursor: move;\\n  cursor: -webkit-grab;\\n  cursor: -moz-grab;\\n  cursor: grab;\\n}\\n.ol-control {\\n  position: absolute;\\n  background-color: rgba(255,255,255,0.4);\\n  border-radius: 4px;\\n  padding: 2px;\\n}\\n.ol-control:hover {\\n  background-color: rgba(255,255,255,0.6);\\n}\\n.ol-zoom {\\n  top: .5em;\\n  left: .5em;\\n}\\n.ol-rotate {\\n  top: .5em;\\n  right: .5em;\\n  transition: opacity .25s linear, visibility 0s linear;\\n}\\n.ol-rotate.ol-hidden {\\n  opacity: 0;\\n  visibility: hidden;\\n  transition: opacity .25s linear, visibility 0s linear .25s;\\n}\\n.ol-zoom-extent {\\n  top: 4.643em;\\n  left: .5em;\\n}\\n.ol-full-screen {\\n  right: .5em;\\n  top: .5em;\\n}\\n@media print {\\n  .ol-control {\\n    display: none;\\n  }\\n}\\n\\n.ol-control button {\\n  display: block;\\n  margin: 1px;\\n  padding: 0;\\n  color: white;\\n  font-size: 1.14em;\\n  font-weight: bold;\\n  text-decoration: none;\\n  text-align: center;\\n  height: 1.375em;\\n  width: 1.375em;\\n  line-height: .4em;\\n  background-color: rgba(0,60,136,0.5);\\n  border: none;\\n  border-radius: 2px;\\n}\\n.ol-control button::-moz-focus-inner {\\n  border: none;\\n  padding: 0;\\n}\\n.ol-zoom-extent button {\\n  line-height: 1.4em;\\n}\\n.ol-compass {\\n  display: block;\\n  font-weight: normal;\\n  font-size: 1.2em;\\n  will-change: transform;\\n}\\n.ol-touch .ol-control button {\\n  font-size: 1.5em;\\n}\\n.ol-touch .ol-zoom-extent {\\n  top: 5.5em;\\n}\\n.ol-control button:hover,\\n.ol-control button:focus {\\n  text-decoration: none;\\n  background-color: rgba(0,60,136,0.7);\\n}\\n.ol-zoom .ol-zoom-in {\\n  border-radius: 2px 2px 0 0;\\n}\\n.ol-zoom .ol-zoom-out {\\n  border-radius: 0 0 2px 2px;\\n}\\n\\n\\n.ol-attribution {\\n  text-align: right;\\n  bottom: .5em;\\n  right: .5em;\\n  max-width: calc(100% - 1.3em);\\n}\\n\\n.ol-attribution ul {\\n  margin: 0;\\n  padding: 0 .5em;\\n  font-size: .7rem;\\n  line-height: 1.375em;\\n  color: #000;\\n  text-shadow: 0 0 2px #fff;\\n}\\n.ol-attribution li {\\n  display: inline;\\n  list-style: none;\\n  line-height: inherit;\\n}\\n.ol-attribution li:not(:last-child):after {\\n  content: \" \";\\n}\\n.ol-attribution img {\\n  max-height: 2em;\\n  max-width: inherit;\\n  vertical-align: middle;\\n}\\n.ol-attribution ul, .ol-attribution button {\\n  display: inline-block;\\n}\\n.ol-attribution.ol-collapsed ul {\\n  display: none;\\n}\\n.ol-attribution:not(.ol-collapsed) {\\n  background: rgba(255,255,255,0.8);\\n}\\n.ol-attribution.ol-uncollapsible {\\n  bottom: 0;\\n  right: 0;\\n  border-radius: 4px 0 0;\\n  height: 1.1em;\\n  line-height: 1em;\\n}\\n.ol-attribution.ol-uncollapsible img {\\n  margin-top: -.2em;\\n  max-height: 1.6em;\\n}\\n.ol-attribution.ol-uncollapsible button {\\n  display: none;\\n}\\n\\n.ol-zoomslider {\\n  top: 4.5em;\\n  left: .5em;\\n  height: 200px;\\n}\\n.ol-zoomslider button {\\n  position: relative;\\n  height: 10px;\\n}\\n\\n.ol-touch .ol-zoomslider {\\n  top: 5.5em;\\n}\\n\\n.ol-overviewmap {\\n  left: 0.5em;\\n  bottom: 0.5em;\\n}\\n.ol-overviewmap.ol-uncollapsible {\\n  bottom: 0;\\n  left: 0;\\n  border-radius: 0 4px 0 0;\\n}\\n.ol-overviewmap .ol-overviewmap-map,\\n.ol-overviewmap button {\\n  display: inline-block;\\n}\\n.ol-overviewmap .ol-overviewmap-map {\\n  border: 1px solid #7b98bc;\\n  height: 150px;\\n  margin: 2px;\\n  width: 150px;\\n}\\n.ol-overviewmap:not(.ol-collapsed) button{\\n  bottom: 1px;\\n  left: 2px;\\n  position: absolute;\\n}\\n.ol-overviewmap.ol-collapsed .ol-overviewmap-map,\\n.ol-overviewmap.ol-uncollapsible button {\\n  display: none;\\n}\\n.ol-overviewmap:not(.ol-collapsed) {\\n  background: rgba(255,255,255,0.8);\\n}\\n.ol-overviewmap-box {\\n  border: 2px dotted rgba(0,60,136,0.7);\\n}\\n\\n.ol-overviewmap .ol-overviewmap-box:hover {\\n  cursor: move;\\n}\\n',\"\"])},function(t,e,i){var n=i(7);\"string\"==typeof n&&(n=[[t.i,n,\"\"]]);var o={hmr:!0,transform:void 0,insertInto:void 0};i(5)(n,o);n.locals&&(t.exports=n.locals)}]);","extractedComments":[]}